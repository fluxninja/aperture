{"version":3,"names":["_types","require","_context","_identifier","_scope","_scopeflags","_parseError","_node","reservedTypes","Set","FlowErrors","ParseErrorEnum","AmbiguousConditionalArrow","AmbiguousDeclareModuleKind","AssignReservedType","reservedType","DeclareClassElement","DeclareClassFieldInitializer","DuplicateDeclareModuleExports","EnumBooleanMemberNotInitialized","memberName","enumName","EnumDuplicateMemberName","EnumInconsistentMemberValues","EnumInvalidExplicitType","invalidEnumType","EnumInvalidExplicitTypeUnknownSupplied","EnumInvalidMemberInitializerPrimaryType","explicitType","EnumInvalidMemberInitializerSymbolType","EnumInvalidMemberInitializerUnknownType","EnumInvalidMemberName","suggestion","EnumNumberMemberNotInitialized","EnumStringMemberInconsistentlyInitailized","GetterMayNotHaveThisParam","ImportReflectionHasImportType","ImportTypeShorthandOnlyInPureImport","InexactInsideExact","InexactInsideNonObject","InexactVariance","InvalidNonTypeImportInDeclareModule","MissingTypeParamDefault","NestedDeclareModule","NestedFlowComment","PatternIsOptional","Object","assign","message","reasonCode","SetterMayNotHaveThisParam","SpreadVariance","ThisParamAnnotationRequired","ThisParamBannedInConstructor","ThisParamMayNotBeOptional","ThisParamMustBeFirst","ThisParamNoDefault","TypeBeforeInitializer","TypeCastInPattern","UnexpectedExplicitInexactInObject","UnexpectedReservedType","UnexpectedReservedUnderscore","UnexpectedSpaceBetweenModuloChecks","UnexpectedSpreadType","UnexpectedSubtractionOperand","UnexpectedTokenAfterTypeParameter","UnexpectedTypeParameterBeforeAsyncArrowFunction","UnsupportedDeclareExportKind","unsupportedExportKind","UnsupportedStatementInDeclareModule","UnterminatedFlowComment","isEsModuleType","bodyElement","type","declaration","hasTypeImportKind","node","importKind","isMaybeDefaultImport","tokenIsKeywordOrIdentifier","exportSuggestions","const","let","interface","partition","list","test","list1","list2","i","length","push","FLOW_PRAGMA_REGEX","_default","superClass","FlowParserMixin","constructor","args","flowPragma","undefined","getScopeHandler","FlowScopeHandler","shouldParseTypes","getPluginOption","shouldParseEnums","finishToken","val","addComment","comment","matches","exec","value","Error","flowParseTypeInitialiser","tok","oldInType","state","inType","expect","flowParseType","flowParsePredicate","startNode","moduloLoc","startLoc","next","expectContextual","lastTokStart","index","raise","at","eat","parseExpression","finishNode","flowParseTypeAndPredicateInitialiser","predicate","match","flowParseDeclareClass","flowParseInterfaceish","flowParseDeclareFunction","id","parseIdentifier","typeNode","typeContainer","typeParameters","flowParseTypeParameterDeclaration","tmp","flowParseFunctionTypeParams","params","rest","this","_this","returnType","typeAnnotation","resetEndLocation","semicolon","scope","declareName","name","BIND_FLOW_DECLARE_FN","loc","start","flowParseDeclare","insideModule","flowParseDeclareVariable","eatContextual","flowParseDeclareModuleExports","lastTokStartLoc","flowParseDeclareModule","isContextual","flowParseDeclareTypeAlias","flowParseDeclareOpaqueType","flowParseDeclareInterface","flowParseDeclareExportDeclaration","unexpected","flowParseTypeAnnotatableIdentifier","BIND_VAR","enter","SCOPE_OTHER","parseExprAtom","bodyNode","body","parseImport","exit","kind","hasModuleExport","forEach","default","isLet","label","parseExport","exportKind","flowParseTypeAnnotation","finished","flowParseTypeAlias","flowParseOpaqueType","isClass","flowParseRestrictedIdentifier","BIND_FUNCTION","BIND_LEXICAL","extends","flowParseInterfaceExtends","implements","mixins","flowParseObjectType","allowStatic","allowExact","allowSpread","allowProto","allowInexact","flowParseQualifiedTypeIdentifier","flowParseTypeParameterInstantiation","flowParseInterface","checkNotUnderscore","word","checkReservedType","has","liberal","right","declare","supertype","impltype","flowParseTypeParameter","requireDefault","nodeStartLoc","variance","flowParseVariance","ident","bound","defaultRequired","typeParameter","oldNoAnonFunctionType","noAnonFunctionType","flowParseTypeParameterInstantiationCallOrNew","flowParseTypeOrImplicitInstantiation","flowParseInterfaceType","flowParseObjectPropertyKey","flowParseObjectTypeIndexer","isStatic","static","lookahead","key","flowParseObjectTypeInternalSlot","method","optional","flowParseObjectTypeMethodish","startNodeAt","flowParseFunctionTypeParam","flowParseObjectTypeCallProperty","valueNode","nodeStart","callProperties","properties","indexers","internalSlots","endDelim","exact","inexact","protoStartLoc","inexactStartLoc","tokenIsLiteralPropertyName","propOrInexact","flowParseObjectTypeProperty","flowObjectTypeSemicolon","out","isInexactToken","argument","proto","flowCheckGetterSetterParams","property","paramCount","Errors","BadGetterArity","BadSetterArity","BadSetterRestParameter","_startLoc","node2","qualification","flowParseGenericType","flowParseTypeofType","flowParsePrimaryType","flowParseTupleType","types","pos","first","lh","isThis","reinterpretTypeAsFunctionTypeParam","flowIdentToTypeAnnotation","isGroupedType","tokenIsIdentifier","token","parseLiteral","parseLiteralAtNode","tokenIsKeyword","tokenLabelName","createIdentifier","flowParsePostfixType","seenOptionalIndexedAccess","canInsertSemicolon","elementType","objectType","indexType","flowParsePrefixType","flowParseAnonFunctionWithoutParens","param","flowParseIntersectionType","flowParseUnionType","allowPrimitiveOverride","typeCastToParameter","expression","end","parseFunctionBody","allowExpressionBody","isMethod","forwardNoArrowParamsConversionAt","parseFunctionBodyAndFinish","parseStatementLike","flags","strict","flowParseEnumDeclaration","stmt","isValidDirective","parseExpressionStatement","expr","decorators","shouldParseExportDeclaration","tokenIsFlowInterfaceOrTypeOrOpaque","containsEsc","isExportDefaultSpecifier","parseExportDefaultExpression","parseConditional","refExpressionErrors","maybeInArrowParameters","nextCh","lookaheadCharCode","setOptionalParametersError","clone","originalNoArrowAt","noArrowAt","consequent","failed","tryParseConditionalConsequent","valid","invalid","getArrowLikeExpressions","alternate","parseMaybeAssign","noArrowParamsConversionAt","parseMaybeAssignAllowIn","pop","disallowInvalid","stack","arrows","finishArrowValidation","every","isAssignable","_node$extra","toAssignableList","extra","trailingCommaLoc","SCOPE_FUNCTION","SCOPE_ARROW","checkParams","parse","result","indexOf","parseParenItem","typeCastNode","assertModuleNodeAllowed","decl","parseExportDeclaration","declarationNode","specifiers","parseExportSpecifiers","parseExportFrom","eatExportStar","maybeParseExportNamespaceSpecifier","hasNamespace","parseClassId","isStatement","optionalId","parseClassMember","classBody","member","parseClassMemberFromModifier","isIterator","readIterator","readWord1","fullWord","InvalidIdentifier","curPosition","identifierName","getTokenFromCode","code","input","charCodeAt","finishOp","isIteratorStart","isBinding","toAssignable","isLHS","left","exprList","toReferencedList","isParenthesizedExpr","_expr$extra","parenthesized","parseArrayLike","close","canBePattern","isTuple","elements","isValidLVal","isParenthesized","binding","parseClassProperty","parseClassPrivateProperty","isClassMethod","isClassProperty","isNonstaticConstructor","pushClassMethod","isGenerator","isAsync","isConstructor","allowsDirectSuper","isThisParam","pushClassPrivateMethod","parseClassSuper","superTypeParameters","implemented","checkGetterSetterParams","getObjectOrClassMethodParams","parsePropertyNamePrefixOperator","parseObjPropValue","prop","isPattern","isAccessor","parseAssignableListItemTypes","parseMaybeDefault","shouldParseDefaultImport","checkImportReflection","module","parseImportSpecifierLocal","specifier","local","finishImportSpecifier","maybeParseDefaultImportSpecifier","parseImportSpecifier","importedIsString","isInTypeOnlyImport","isMaybeTypeOnly","bindingType","firstIdent","imported","specifierTypeKind","isLookaheadContextual","as_ident","cloneIdentifier","ImportBindingIsString","importName","specifierIsTypeImport","checkReservedWord","parseBindingAtom","parseFunctionParams","parseVarId","parseAsyncArrowFromCallExpression","call","shouldParseAsyncArrow","afterLeftParse","_jsx","jsx","hasPlugin","tryParse","error","context","currentContext","tc","j_oTag","j_expr","_jsx2","_jsx3","arrow","abort","_arrowExpression$extr","arrowExpression","resetStartLocationFromNode","maybeUnwrapTypeCastExpression","aborted","async","failState","thrown","parseArrow","shouldParseArrow","setArrowFunctionParameters","allowDuplicates","isArrowFunction","strictModeChanged","parseParenAndDistinguishExpression","canBeArrow","parseSubscripts","base","noCalls","callee","arguments","parseCallExpressionArguments","parseAsyncArrowWithTypeParameters","parseSubscript","subscriptState","isLookaheadToken_lt","optionalChainMember","stop","typeArguments","finishCallExpression","parseNewCallee","targs","parseArrowExpression","readToken_mult_modulo","hasFlowComment","nextToken","readToken_pipe_amp","parseTopLevel","file","program","fileNode","skipBlockComment","skipFlowComment","hasFlowCommentCompletion","commentSkip","shiftToFirstNonWhiteSpace","includes","ch2","ch3","slice","UnterminatedComment","flowEnumErrorBooleanMemberNotInitialized","flowEnumErrorInvalidMemberInitializer","enumContext","flowEnumErrorNumberMemberNotInitialized","flowEnumErrorStringMemberInconsistentlyInitailized","flowEnumMemberInit","endOfInit","literal","parseNumericLiteral","parseStringLiteral","parseBooleanLiteral","flowEnumMemberRaw","init","flowEnumCheckExplicitTypeMismatch","expectedType","flowEnumMembers","seenNames","members","booleanMembers","numberMembers","stringMembers","defaultedMembers","hasUnknownMembers","memberNode","toUpperCase","add","flowEnumStringMembers","initializedMembers","flowEnumParseExplicitType","flowEnumBody","nameLoc","empty","boolsLen","numsLen","strsLen","defaultedLen","nextTokenStart","afterNext","exports"],"sources":["../../../src/plugins/flow/index.ts"],"sourcesContent":["/*:: declare var invariant; */\n\nimport type Parser from \"../../parser\";\nimport {\n  tokenIsIdentifier,\n  tokenIsKeyword,\n  tokenIsKeywordOrIdentifier,\n  tokenIsLiteralPropertyName,\n  tokenLabelName,\n  tt,\n  type TokenType,\n  tokenIsFlowInterfaceOrTypeOrOpaque,\n} from \"../../tokenizer/types\";\nimport type * as N from \"../../types\";\nimport type { Position } from \"../../util/location\";\nimport { types as tc } from \"../../tokenizer/context\";\nimport * as charCodes from \"charcodes\";\nimport { isIteratorStart } from \"../../util/identifier\";\nimport FlowScopeHandler from \"./scope\";\nimport {\n  BIND_LEXICAL,\n  BIND_VAR,\n  BIND_FUNCTION,\n  BIND_FLOW_DECLARE_FN,\n  SCOPE_ARROW,\n  SCOPE_FUNCTION,\n  SCOPE_OTHER,\n  type BindingTypes,\n} from \"../../util/scopeflags\";\nimport type { ExpressionErrors } from \"../../parser/util\";\nimport type { ParseStatementFlag } from \"../../parser/statement\";\nimport { Errors, ParseErrorEnum } from \"../../parse-error\";\nimport { cloneIdentifier, type Undone } from \"../../parser/node\";\n\nconst reservedTypes = new Set([\n  \"_\",\n  \"any\",\n  \"bool\",\n  \"boolean\",\n  \"empty\",\n  \"extends\",\n  \"false\",\n  \"interface\",\n  \"mixed\",\n  \"null\",\n  \"number\",\n  \"static\",\n  \"string\",\n  \"true\",\n  \"typeof\",\n  \"void\",\n]);\n\n/* eslint sort-keys: \"error\" */\n// The Errors key follows https://github.com/facebook/flow/blob/master/src/parser/parse_error.ml unless it does not exist\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow:\n    \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind:\n    \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  // TODO: When we get proper string enums in typescript make this ReservedType.\n  // Not really worth it to do the whole $Values dance with reservedTypes set.\n  AssignReservedType: ({ reservedType }: { reservedType: string }) =>\n    `Cannot overwrite reserved type ${reservedType}.`,\n  DeclareClassElement:\n    \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer:\n    \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports:\n    \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: ({\n    memberName,\n    enumName,\n  }: {\n    memberName: string;\n    enumName: string;\n  }) =>\n    `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`,\n  EnumDuplicateMemberName: ({\n    memberName,\n    enumName,\n  }: {\n    memberName: string;\n    enumName: string;\n  }) =>\n    `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`,\n  EnumInconsistentMemberValues: ({ enumName }: { enumName: string }) =>\n    `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\n  EnumInvalidExplicitType: ({\n    invalidEnumType,\n    enumName,\n  }: {\n    invalidEnumType: string;\n    enumName: string;\n  }) =>\n    `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidExplicitTypeUnknownSupplied: ({\n    enumName,\n  }: {\n    enumName: string;\n  }) =>\n    `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n\n  // TODO: When moving to typescript, we should either have each of the\n  // following errors only accept the specific strings they want:\n  //\n  // ...PrimaryType: explicitType: \"string\" | \"number\" | \"boolean\"\n  // ...SymbolType: explicitType: \"symbol\"\n  // ...UnknownType: explicitType: null\n  //\n  // Or, alternatively, merge these three errors together into one\n  // `EnumInvalidMemberInitializer` error that can accept `EnumExplicitType`\n  // without alteration, and then just have its message change based on the\n  // explicitType.\n  EnumInvalidMemberInitializerPrimaryType: ({\n    enumName,\n    memberName,\n    explicitType,\n  }: {\n    enumName: string;\n    memberName: string;\n    explicitType: EnumExplicitType;\n  }) =>\n    `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`,\n  EnumInvalidMemberInitializerSymbolType: ({\n    enumName,\n    memberName,\n  }: {\n    enumName: string;\n    memberName: string;\n    explicitType: EnumExplicitType;\n  }) =>\n    `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerUnknownType: ({\n    enumName,\n    memberName,\n  }: {\n    enumName: string;\n    memberName: string;\n    explicitType: EnumExplicitType;\n  }) =>\n    `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberName: ({\n    enumName,\n    memberName,\n    suggestion,\n  }: {\n    enumName: string;\n    memberName: string;\n    suggestion: string;\n  }) =>\n    `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`,\n  EnumNumberMemberNotInitialized: ({\n    enumName,\n    memberName,\n  }: {\n    enumName: string;\n    memberName: string;\n  }) =>\n    `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`,\n  EnumStringMemberInconsistentlyInitailized: ({\n    enumName,\n  }: {\n    enumName: string;\n  }) =>\n    `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`,\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportReflectionHasImportType:\n    \"An `import module` declaration can not use `type` or `typeof` keyword.\",\n  ImportTypeShorthandOnlyInPureImport:\n    \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact:\n    \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject:\n    \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule:\n    \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault:\n    \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule:\n    \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: {\n    message:\n      \"A binding pattern parameter cannot be optional in an implementation signature.\",\n    // For consistency in TypeScript and Flow error codes\n    ...(!process.env.BABEL_8_BREAKING\n      ? { reasonCode: \"OptionalBindingPattern\" }\n      : {}),\n  },\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired:\n    \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor:\n    \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst:\n    \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer:\n    \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern:\n    \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject:\n    \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: ({ reservedType }: { reservedType: string }) =>\n    `Unexpected reserved type ${reservedType}.`,\n  UnexpectedReservedUnderscore:\n    \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks:\n    \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType:\n    \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand:\n    'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter:\n    \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction:\n    \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: ({\n    unsupportedExportKind,\n    suggestion,\n  }: {\n    unsupportedExportKind: string;\n    suggestion: string;\n  }) =>\n    `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`,\n  UnsupportedStatementInDeclareModule:\n    \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\",\n});\n/* eslint-disable sort-keys */\n\nfunction isEsModuleType(bodyElement: N.Node): boolean {\n  return (\n    bodyElement.type === \"DeclareExportAllDeclaration\" ||\n    (bodyElement.type === \"DeclareExportDeclaration\" &&\n      (!bodyElement.declaration ||\n        (bodyElement.declaration.type !== \"TypeAlias\" &&\n          bodyElement.declaration.type !== \"InterfaceDeclaration\")))\n  );\n}\n\nfunction hasTypeImportKind(node: N.Node): boolean {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nfunction isMaybeDefaultImport(type: TokenType): boolean {\n  return tokenIsKeywordOrIdentifier(type) && type !== tt._from;\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\",\n};\n\n// Like Array#filter, but returns a tuple [ acceptedElements, discardedElements ]\nfunction partition<T>(\n  list: T[],\n  test: (c: T, b: number, a: T[]) => boolean | undefined | null,\n): [T[], T[]] {\n  const list1: T[] = [];\n  const list2: T[] = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\n\n// Flow enums types\ntype EnumExplicitType = null | \"boolean\" | \"number\" | \"string\" | \"symbol\";\n\ntype EnumContext = {\n  enumName: string;\n  explicitType: EnumExplicitType;\n  memberName: string;\n};\n\ntype EnumMemberInit =\n  | {\n      type: \"number\";\n      loc: Position;\n      value: N.Node;\n    }\n  | {\n      type: \"string\";\n      loc: Position;\n      value: N.Node;\n    }\n  | {\n      type: \"boolean\";\n      loc: Position;\n      value: N.Node;\n    }\n  | {\n      type: \"invalid\";\n      loc: Position;\n    }\n  | {\n      type: \"none\";\n      loc: Position;\n    };\n\nexport default (superClass: typeof Parser) =>\n  class FlowParserMixin extends superClass implements Parser {\n    // The value of the @flow/@noflow pragma. Initially undefined, transitions\n    // to \"@flow\" or \"@noflow\" if we see a pragma. Transitions to null if we are\n    // past the initial comment.\n    flowPragma: void | null | \"flow\" | \"noflow\" = undefined;\n\n    getScopeHandler(): {\n      new (...args: any): FlowScopeHandler;\n    } {\n      return FlowScopeHandler;\n    }\n\n    shouldParseTypes(): boolean {\n      return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n    }\n\n    shouldParseEnums(): boolean {\n      return !!this.getPluginOption(\"flow\", \"enums\");\n    }\n\n    finishToken(type: TokenType, val: any): void {\n      if (\n        type !== tt.string &&\n        type !== tt.semi &&\n        type !== tt.interpreterDirective\n      ) {\n        if (this.flowPragma === undefined) {\n          this.flowPragma = null;\n        }\n      }\n      super.finishToken(type, val);\n    }\n\n    addComment(comment: N.Comment): void {\n      if (this.flowPragma === undefined) {\n        // Try to parse a flow pragma.\n        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n        if (!matches) {\n          // do nothing\n        } else if (matches[1] === \"flow\") {\n          this.flowPragma = \"flow\";\n        } else if (matches[1] === \"noflow\") {\n          this.flowPragma = \"noflow\";\n        } else {\n          throw new Error(\"Unexpected flow pragma\");\n        }\n      }\n      super.addComment(comment);\n    }\n\n    flowParseTypeInitialiser(tok?: TokenType): N.FlowType {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tok || tt.colon);\n\n      const type = this.flowParseType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParsePredicate(): N.FlowPredicate {\n      const node = this.startNode();\n      const moduloLoc = this.state.startLoc;\n      this.next(); // eat `%`\n      this.expectContextual(tt._checks);\n      // Force '%' and 'checks' to be adjacent\n      if (this.state.lastTokStart > moduloLoc.index + 1) {\n        this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {\n          at: moduloLoc,\n        });\n      }\n      if (this.eat(tt.parenL)) {\n        node.value = super.parseExpression();\n        this.expect(tt.parenR);\n        return this.finishNode(node, \"DeclaredPredicate\");\n      } else {\n        return this.finishNode(node, \"InferredPredicate\");\n      }\n    }\n\n    flowParseTypeAndPredicateInitialiser(): [\n      N.FlowType | undefined | null,\n      N.FlowPredicate | undefined | null,\n    ] {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tt.colon);\n      let type = null;\n      let predicate = null;\n      if (this.match(tt.modulo)) {\n        this.state.inType = oldInType;\n        predicate = this.flowParsePredicate();\n      } else {\n        type = this.flowParseType();\n        this.state.inType = oldInType;\n        if (this.match(tt.modulo)) {\n          predicate = this.flowParsePredicate();\n        }\n      }\n      return [type, predicate];\n    }\n\n    flowParseDeclareClass(\n      node: Undone<N.FlowDeclareClass>,\n    ): N.FlowDeclareClass {\n      this.next();\n      this.flowParseInterfaceish(node, /*isClass*/ true);\n      return this.finishNode(node, \"DeclareClass\");\n    }\n\n    flowParseDeclareFunction(\n      node: Undone<N.FlowDeclareFunction>,\n    ): N.FlowDeclareFunction {\n      this.next();\n\n      const id = (node.id = this.parseIdentifier());\n\n      const typeNode = this.startNode();\n      const typeContainer = this.startNode<N.TypeAnnotation>();\n\n      if (this.match(tt.lt)) {\n        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        typeNode.typeParameters = null;\n      }\n\n      this.expect(tt.parenL);\n      const tmp = this.flowParseFunctionTypeParams();\n      typeNode.params = tmp.params;\n      typeNode.rest = tmp.rest;\n      typeNode.this = tmp._this;\n      this.expect(tt.parenR);\n\n      [typeNode.returnType, node.predicate] =\n        this.flowParseTypeAndPredicateInitialiser();\n\n      typeContainer.typeAnnotation = this.finishNode(\n        typeNode,\n        \"FunctionTypeAnnotation\",\n      );\n\n      id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n\n      this.resetEndLocation(id);\n      this.semicolon();\n\n      this.scope.declareName(\n        node.id.name,\n        BIND_FLOW_DECLARE_FN,\n        node.id.loc.start,\n      );\n\n      return this.finishNode(node, \"DeclareFunction\");\n    }\n\n    flowParseDeclare(\n      node: Undone<N.FlowDeclare>,\n      insideModule?: boolean,\n    ): N.FlowDeclare {\n      if (this.match(tt._class)) {\n        return this.flowParseDeclareClass(node);\n      } else if (this.match(tt._function)) {\n        return this.flowParseDeclareFunction(node);\n      } else if (this.match(tt._var)) {\n        return this.flowParseDeclareVariable(node);\n      } else if (this.eatContextual(tt._module)) {\n        if (this.match(tt.dot)) {\n          return this.flowParseDeclareModuleExports(node);\n        } else {\n          if (insideModule) {\n            this.raise(FlowErrors.NestedDeclareModule, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          return this.flowParseDeclareModule(node);\n        }\n      } else if (this.isContextual(tt._type)) {\n        return this.flowParseDeclareTypeAlias(node);\n      } else if (this.isContextual(tt._opaque)) {\n        return this.flowParseDeclareOpaqueType(node);\n      } else if (this.isContextual(tt._interface)) {\n        return this.flowParseDeclareInterface(node);\n      } else if (this.match(tt._export)) {\n        return this.flowParseDeclareExportDeclaration(node, insideModule);\n      } else {\n        this.unexpected();\n      }\n    }\n\n    flowParseDeclareVariable(\n      node: Undone<N.FlowDeclareVariable>,\n    ): N.FlowDeclareVariable {\n      this.next();\n      node.id = this.flowParseTypeAnnotatableIdentifier(\n        /*allowPrimitiveOverride*/ true,\n      );\n      this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);\n      this.semicolon();\n      return this.finishNode(node, \"DeclareVariable\");\n    }\n\n    flowParseDeclareModule(\n      node: Undone<N.FlowDeclareModule>,\n    ): N.FlowDeclareModule {\n      this.scope.enter(SCOPE_OTHER);\n\n      if (this.match(tt.string)) {\n        node.id = super.parseExprAtom();\n      } else {\n        node.id = this.parseIdentifier();\n      }\n\n      const bodyNode = (node.body = this.startNode());\n      // @ts-expect-error refine typings\n      const body = (bodyNode.body = []);\n      this.expect(tt.braceL);\n      while (!this.match(tt.braceR)) {\n        let bodyNode = this.startNode<N.ImportDeclaration>();\n\n        if (this.match(tt._import)) {\n          this.next();\n          if (!this.isContextual(tt._type) && !this.match(tt._typeof)) {\n            this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          super.parseImport(bodyNode);\n        } else {\n          this.expectContextual(\n            tt._declare,\n            FlowErrors.UnsupportedStatementInDeclareModule,\n          );\n          // @ts-expect-error refine typings\n          bodyNode = this.flowParseDeclare(bodyNode, true);\n        }\n\n        body.push(bodyNode);\n      }\n\n      this.scope.exit();\n\n      this.expect(tt.braceR);\n\n      this.finishNode(bodyNode, \"BlockStatement\");\n\n      let kind: \"CommonJS\" | \"ES\" | null = null;\n      let hasModuleExport = false;\n      body.forEach(bodyElement => {\n        if (isEsModuleType(bodyElement)) {\n          if (kind === \"CommonJS\") {\n            this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n              at: bodyElement,\n            });\n          }\n          kind = \"ES\";\n        } else if (bodyElement.type === \"DeclareModuleExports\") {\n          if (hasModuleExport) {\n            this.raise(FlowErrors.DuplicateDeclareModuleExports, {\n              at: bodyElement,\n            });\n          }\n          if (kind === \"ES\") {\n            this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n              at: bodyElement,\n            });\n          }\n          kind = \"CommonJS\";\n          hasModuleExport = true;\n        }\n      });\n\n      node.kind = kind || \"CommonJS\";\n      return this.finishNode(node, \"DeclareModule\");\n    }\n\n    flowParseDeclareExportDeclaration(\n      node: Undone<N.FlowDeclareExportDeclaration>,\n      insideModule?: boolean | null,\n    ): N.FlowDeclareExportDeclaration {\n      this.expect(tt._export);\n\n      if (this.eat(tt._default)) {\n        if (this.match(tt._function) || this.match(tt._class)) {\n          // declare export default class ...\n          // declare export default function ...\n          node.declaration = this.flowParseDeclare(this.startNode());\n        } else {\n          // declare export default [type];\n          node.declaration = this.flowParseType();\n          this.semicolon();\n        }\n        node.default = true;\n\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else {\n        if (\n          this.match(tt._const) ||\n          this.isLet() ||\n          ((this.isContextual(tt._type) || this.isContextual(tt._interface)) &&\n            !insideModule)\n        ) {\n          const label = this.state.value as\n            | \"const\"\n            | \"let\"\n            | \"type\"\n            | \"interface\";\n          throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {\n            at: this.state.startLoc,\n            unsupportedExportKind: label,\n            suggestion: exportSuggestions[label],\n          });\n        }\n\n        if (\n          this.match(tt._var) || // declare export var ...\n          this.match(tt._function) || // declare export function ...\n          this.match(tt._class) || // declare export class ...\n          this.isContextual(tt._opaque) // declare export opaque ..\n        ) {\n          node.declaration = this.flowParseDeclare(this.startNode());\n          node.default = false;\n\n          return this.finishNode(node, \"DeclareExportDeclaration\");\n        } else if (\n          this.match(tt.star) || // declare export * from ''\n          this.match(tt.braceL) || // declare export {} ...\n          this.isContextual(tt._interface) || // declare export interface ...\n          this.isContextual(tt._type) || // declare export type ...\n          this.isContextual(tt._opaque) // declare export opaque type ...\n        ) {\n          node = this.parseExport(\n            node as Undone<N.ExportNamedDeclaration | N.ExportAllDeclaration>,\n            /* decorators */ null,\n          );\n          if (node.type === \"ExportNamedDeclaration\") {\n            node.type = \"ExportDeclaration\";\n            node.default = false;\n            delete node.exportKind;\n          }\n\n          node.type = \"Declare\" + node.type;\n\n          return node as N.Node;\n        }\n      }\n\n      this.unexpected();\n    }\n\n    flowParseDeclareModuleExports(\n      node: Undone<N.FlowDeclareModuleExports>,\n    ): N.FlowDeclareModuleExports {\n      this.next();\n      this.expectContextual(tt._exports);\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n      this.semicolon();\n\n      return this.finishNode(node, \"DeclareModuleExports\");\n    }\n\n    flowParseDeclareTypeAlias(\n      node: Undone<N.FlowDeclareTypeAlias>,\n    ): N.FlowDeclareTypeAlias {\n      this.next();\n      const finished = this.flowParseTypeAlias(node);\n      // Don't do finishNode as we don't want to process comments twice\n      finished.type = \"DeclareTypeAlias\";\n      return finished;\n    }\n\n    flowParseDeclareOpaqueType(\n      node: Undone<N.FlowDeclareOpaqueType>,\n    ): N.FlowDeclareOpaqueType {\n      this.next();\n      const finished = this.flowParseOpaqueType(node, true);\n      // Don't do finishNode as we don't want to process comments twice\n      finished.type = \"DeclareOpaqueType\";\n      return finished;\n    }\n\n    flowParseDeclareInterface(\n      node: Undone<N.FlowDeclareInterface>,\n    ): N.FlowDeclareInterface {\n      this.next();\n      this.flowParseInterfaceish(node, /* isClass */ false);\n      return this.finishNode(node, \"DeclareInterface\");\n    }\n\n    // Interfaces\n\n    flowParseInterfaceish(node: Undone<N.FlowDeclare>, isClass: boolean): void {\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ !isClass,\n        /* declaration */ true,\n      );\n\n      this.scope.declareName(\n        node.id.name,\n        isClass ? BIND_FUNCTION : BIND_LEXICAL,\n        node.id.loc.start,\n      );\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.extends = [];\n\n      if (this.eat(tt._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (!isClass && this.eat(tt.comma));\n      }\n\n      if (isClass) {\n        node.implements = [];\n        node.mixins = [];\n\n        if (this.eatContextual(tt._mixins)) {\n          do {\n            node.mixins.push(this.flowParseInterfaceExtends());\n          } while (this.eat(tt.comma));\n        }\n\n        if (this.eatContextual(tt._implements)) {\n          do {\n            node.implements.push(this.flowParseInterfaceExtends());\n          } while (this.eat(tt.comma));\n        }\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: isClass,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: isClass,\n        allowInexact: false,\n      });\n    }\n\n    flowParseInterfaceExtends(): N.FlowInterfaceExtends {\n      const node = this.startNode();\n\n      node.id = this.flowParseQualifiedTypeIdentifier();\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      } else {\n        node.typeParameters = null;\n      }\n\n      return this.finishNode(node, \"InterfaceExtends\");\n    }\n\n    flowParseInterface(node: Undone<N.FlowInterface>): N.FlowInterface {\n      this.flowParseInterfaceish(node, /* isClass */ false);\n      return this.finishNode(node, \"InterfaceDeclaration\");\n    }\n\n    checkNotUnderscore(word: string) {\n      if (word === \"_\") {\n        this.raise(FlowErrors.UnexpectedReservedUnderscore, {\n          at: this.state.startLoc,\n        });\n      }\n    }\n\n    checkReservedType(word: string, startLoc: Position, declaration?: boolean) {\n      if (!reservedTypes.has(word)) return;\n\n      this.raise(\n        declaration\n          ? FlowErrors.AssignReservedType\n          : FlowErrors.UnexpectedReservedType,\n        {\n          at: startLoc,\n          reservedType: word,\n        },\n      );\n    }\n\n    flowParseRestrictedIdentifier(\n      liberal?: boolean,\n      declaration?: boolean,\n    ): N.Identifier {\n      this.checkReservedType(\n        this.state.value,\n        this.state.startLoc,\n        declaration,\n      );\n      return this.parseIdentifier(liberal);\n    }\n\n    // Type aliases\n\n    flowParseTypeAlias(node: Undone<N.FlowTypeAlias>): N.FlowTypeAlias {\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ false,\n        /* declaration */ true,\n      );\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.right = this.flowParseTypeInitialiser(tt.eq);\n      this.semicolon();\n\n      return this.finishNode(node, \"TypeAlias\");\n    }\n\n    flowParseOpaqueType(\n      node: Undone<N.FlowOpaqueType>,\n      declare: boolean,\n    ): N.FlowOpaqueType {\n      this.expectContextual(tt._type);\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ true,\n        /* declaration */ true,\n      );\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      // Parse the supertype\n      node.supertype = null;\n      if (this.match(tt.colon)) {\n        node.supertype = this.flowParseTypeInitialiser(tt.colon);\n      }\n\n      node.impltype = null;\n      if (!declare) {\n        node.impltype = this.flowParseTypeInitialiser(tt.eq);\n      }\n      this.semicolon();\n\n      return this.finishNode(node, \"OpaqueType\");\n    }\n\n    // Type annotations\n\n    flowParseTypeParameter(requireDefault: boolean = false): N.TypeParameter {\n      const nodeStartLoc = this.state.startLoc;\n\n      const node = this.startNode<N.TypeParameter>();\n\n      const variance = this.flowParseVariance();\n\n      const ident = this.flowParseTypeAnnotatableIdentifier();\n      node.name = ident.name;\n      // @ts-expect-error migrate to Babel types\n      node.variance = variance;\n      // @ts-expect-error migrate to Babel types\n      node.bound = ident.typeAnnotation;\n\n      if (this.match(tt.eq)) {\n        this.eat(tt.eq);\n        // @ts-expect-error migrate to Babel types\n        node.default = this.flowParseType();\n      } else {\n        if (requireDefault) {\n          this.raise(FlowErrors.MissingTypeParamDefault, { at: nodeStartLoc });\n        }\n      }\n\n      return this.finishNode(node, \"TypeParameter\");\n    }\n\n    flowParseTypeParameterDeclaration(): N.TypeParameterDeclaration {\n      const oldInType = this.state.inType;\n      const node = this.startNode<N.TypeParameterDeclaration>();\n      node.params = [];\n\n      this.state.inType = true;\n\n      // istanbul ignore else: this condition is already checked at all call sites\n      if (this.match(tt.lt) || this.match(tt.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      let defaultRequired = false;\n\n      do {\n        const typeParameter = this.flowParseTypeParameter(defaultRequired);\n\n        node.params.push(typeParameter);\n\n        if (typeParameter.default) {\n          defaultRequired = true;\n        }\n\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      } while (!this.match(tt.gt));\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterDeclaration\");\n    }\n\n    flowParseTypeParameterInstantiation(): N.TypeParameterInstantiation {\n      const node = this.startNode<N.TypeParameterInstantiation>();\n      const oldInType = this.state.inType;\n      node.params = [];\n\n      this.state.inType = true;\n\n      this.expect(tt.lt);\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = false;\n      while (!this.match(tt.gt)) {\n        node.params.push(this.flowParseType());\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      }\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseTypeParameterInstantiationCallOrNew(): N.TypeParameterInstantiation {\n      const node = this.startNode<N.TypeParameterInstantiation>();\n      const oldInType = this.state.inType;\n      node.params = [];\n\n      this.state.inType = true;\n\n      this.expect(tt.lt);\n      while (!this.match(tt.gt)) {\n        node.params.push(this.flowParseTypeOrImplicitInstantiation());\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      }\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseInterfaceType(): N.FlowInterfaceType {\n      const node = this.startNode<N.FlowInterfaceType>();\n      this.expectContextual(tt._interface);\n\n      node.extends = [];\n      if (this.eat(tt._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (this.eat(tt.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: false,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: false,\n        allowInexact: false,\n      });\n\n      return this.finishNode(node, \"InterfaceTypeAnnotation\");\n    }\n\n    flowParseObjectPropertyKey(): N.Expression {\n      return this.match(tt.num) || this.match(tt.string)\n        ? super.parseExprAtom()\n        : this.parseIdentifier(true);\n    }\n\n    flowParseObjectTypeIndexer(\n      node: Undone<N.FlowObjectTypeIndexer>,\n      isStatic: boolean,\n      variance?: N.FlowVariance | null,\n    ): N.FlowObjectTypeIndexer {\n      node.static = isStatic;\n\n      // Note: bracketL has already been consumed\n      if (this.lookahead().type === tt.colon) {\n        node.id = this.flowParseObjectPropertyKey();\n        node.key = this.flowParseTypeInitialiser();\n      } else {\n        node.id = null;\n        node.key = this.flowParseType();\n      }\n      this.expect(tt.bracketR);\n      node.value = this.flowParseTypeInitialiser();\n      node.variance = variance;\n\n      return this.finishNode(node, \"ObjectTypeIndexer\");\n    }\n\n    flowParseObjectTypeInternalSlot(\n      node: Undone<N.FlowObjectTypeInternalSlot>,\n      isStatic: boolean,\n    ): N.FlowObjectTypeInternalSlot {\n      node.static = isStatic;\n      // Note: both bracketL have already been consumed\n      node.id = this.flowParseObjectPropertyKey();\n      this.expect(tt.bracketR);\n      this.expect(tt.bracketR);\n      if (this.match(tt.lt) || this.match(tt.parenL)) {\n        node.method = true;\n        node.optional = false;\n        node.value = this.flowParseObjectTypeMethodish(\n          this.startNodeAt(node.loc.start),\n        );\n      } else {\n        node.method = false;\n        if (this.eat(tt.question)) {\n          node.optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n      }\n      return this.finishNode(node, \"ObjectTypeInternalSlot\");\n    }\n\n    flowParseObjectTypeMethodish(\n      node: Undone<N.FlowFunctionTypeAnnotation>,\n    ): N.FlowFunctionTypeAnnotation {\n      node.params = [];\n      node.rest = null;\n      node.typeParameters = null;\n      node.this = null;\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      this.expect(tt.parenL);\n      if (this.match(tt._this)) {\n        node.this = this.flowParseFunctionTypeParam(/* first */ true);\n        // match Flow parser behavior\n        node.this.name = null;\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n        node.params.push(this.flowParseFunctionTypeParam(false));\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n\n      if (this.eat(tt.ellipsis)) {\n        node.rest = this.flowParseFunctionTypeParam(false);\n      }\n      this.expect(tt.parenR);\n      node.returnType = this.flowParseTypeInitialiser();\n\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    flowParseObjectTypeCallProperty(\n      node: Undone<N.FlowObjectTypeCallProperty>,\n      isStatic: boolean,\n    ): N.FlowObjectTypeCallProperty {\n      const valueNode = this.startNode();\n      node.static = isStatic;\n      node.value = this.flowParseObjectTypeMethodish(valueNode);\n      return this.finishNode(node, \"ObjectTypeCallProperty\");\n    }\n\n    flowParseObjectType({\n      allowStatic,\n      allowExact,\n      allowSpread,\n      allowProto,\n      allowInexact,\n    }: {\n      allowStatic: boolean;\n      allowExact: boolean;\n      allowSpread: boolean;\n      allowProto: boolean;\n      allowInexact: boolean;\n    }): N.FlowObjectTypeAnnotation {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n\n      const nodeStart = this.startNode();\n\n      nodeStart.callProperties = [];\n      nodeStart.properties = [];\n      nodeStart.indexers = [];\n      nodeStart.internalSlots = [];\n\n      let endDelim;\n      let exact;\n      let inexact = false;\n      if (allowExact && this.match(tt.braceBarL)) {\n        this.expect(tt.braceBarL);\n        endDelim = tt.braceBarR;\n        exact = true;\n      } else {\n        this.expect(tt.braceL);\n        endDelim = tt.braceR;\n        exact = false;\n      }\n\n      nodeStart.exact = exact;\n\n      while (!this.match(endDelim)) {\n        let isStatic = false;\n        let protoStartLoc: Position | undefined | null = null;\n        let inexactStartLoc: Position | undefined | null = null;\n        const node = this.startNode();\n\n        if (allowProto && this.isContextual(tt._proto)) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\n            this.next();\n            protoStartLoc = this.state.startLoc;\n            allowStatic = false;\n          }\n        }\n\n        if (allowStatic && this.isContextual(tt._static)) {\n          const lookahead = this.lookahead();\n\n          // static is a valid identifier name\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\n            this.next();\n            isStatic = true;\n          }\n        }\n\n        const variance = this.flowParseVariance();\n\n        if (this.eat(tt.bracketL)) {\n          if (protoStartLoc != null) {\n            this.unexpected(protoStartLoc);\n          }\n          if (this.eat(tt.bracketL)) {\n            if (variance) {\n              this.unexpected(variance.loc.start);\n            }\n            nodeStart.internalSlots.push(\n              this.flowParseObjectTypeInternalSlot(node, isStatic),\n            );\n          } else {\n            nodeStart.indexers.push(\n              this.flowParseObjectTypeIndexer(node, isStatic, variance),\n            );\n          }\n        } else if (this.match(tt.parenL) || this.match(tt.lt)) {\n          if (protoStartLoc != null) {\n            this.unexpected(protoStartLoc);\n          }\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n          nodeStart.callProperties.push(\n            this.flowParseObjectTypeCallProperty(node, isStatic),\n          );\n        } else {\n          let kind = \"init\";\n\n          if (this.isContextual(tt._get) || this.isContextual(tt._set)) {\n            const lookahead = this.lookahead();\n            if (tokenIsLiteralPropertyName(lookahead.type)) {\n              kind = this.state.value;\n              this.next();\n            }\n          }\n\n          const propOrInexact = this.flowParseObjectTypeProperty(\n            node,\n            isStatic,\n            protoStartLoc,\n            variance,\n            kind,\n            allowSpread,\n            allowInexact ?? !exact,\n          );\n\n          if (propOrInexact === null) {\n            inexact = true;\n            inexactStartLoc = this.state.lastTokStartLoc;\n          } else {\n            nodeStart.properties.push(propOrInexact);\n          }\n        }\n\n        this.flowObjectTypeSemicolon();\n\n        if (\n          inexactStartLoc &&\n          !this.match(tt.braceR) &&\n          !this.match(tt.braceBarR)\n        ) {\n          this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {\n            at: inexactStartLoc,\n          });\n        }\n      }\n\n      this.expect(endDelim);\n\n      /* The inexact flag should only be added on ObjectTypeAnnotations that\n       * are not the body of an interface, declare interface, or declare class.\n       * Since spreads are only allowed in object types, checking that is\n       * sufficient here.\n       */\n      if (allowSpread) {\n        nodeStart.inexact = inexact;\n      }\n\n      const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n\n      this.state.inType = oldInType;\n\n      return out;\n    }\n\n    flowParseObjectTypeProperty(\n      node: Undone<N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty>,\n      isStatic: boolean,\n      protoStartLoc: Position | undefined | null,\n      variance: N.FlowVariance | undefined | null,\n      kind: string,\n      allowSpread: boolean,\n      allowInexact: boolean,\n    ): N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty | null {\n      if (this.eat(tt.ellipsis)) {\n        const isInexactToken =\n          this.match(tt.comma) ||\n          this.match(tt.semi) ||\n          this.match(tt.braceR) ||\n          this.match(tt.braceBarR);\n\n        if (isInexactToken) {\n          if (!allowSpread) {\n            this.raise(FlowErrors.InexactInsideNonObject, {\n              at: this.state.lastTokStartLoc,\n            });\n          } else if (!allowInexact) {\n            this.raise(FlowErrors.InexactInsideExact, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          if (variance) {\n            this.raise(FlowErrors.InexactVariance, { at: variance });\n          }\n\n          return null;\n        }\n\n        if (!allowSpread) {\n          this.raise(FlowErrors.UnexpectedSpreadType, {\n            at: this.state.lastTokStartLoc,\n          });\n        }\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.raise(FlowErrors.SpreadVariance, { at: variance });\n        }\n\n        node.argument = this.flowParseType();\n        return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n      } else {\n        node.key = this.flowParseObjectPropertyKey();\n        node.static = isStatic;\n        node.proto = protoStartLoc != null;\n        node.kind = kind;\n\n        let optional = false;\n        if (this.match(tt.lt) || this.match(tt.parenL)) {\n          // This is a method property\n          node.method = true;\n\n          if (protoStartLoc != null) {\n            this.unexpected(protoStartLoc);\n          }\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n\n          node.value = this.flowParseObjectTypeMethodish(\n            this.startNodeAt(node.loc.start),\n          );\n          if (kind === \"get\" || kind === \"set\") {\n            this.flowCheckGetterSetterParams(node);\n          }\n          /** Declared classes/interfaces do not allow spread */\n          if (\n            !allowSpread &&\n            node.key.name === \"constructor\" &&\n            node.value.this\n          ) {\n            this.raise(FlowErrors.ThisParamBannedInConstructor, {\n              at: node.value.this,\n            });\n          }\n        } else {\n          if (kind !== \"init\") this.unexpected();\n\n          node.method = false;\n\n          if (this.eat(tt.question)) {\n            optional = true;\n          }\n          node.value = this.flowParseTypeInitialiser();\n          node.variance = variance;\n        }\n\n        node.optional = optional;\n\n        return this.finishNode(node, \"ObjectTypeProperty\");\n      }\n    }\n\n    // This is similar to checkGetterSetterParams, but as\n    // @babel/parser uses non estree properties we cannot reuse it here\n    flowCheckGetterSetterParams(\n      property: Undone<\n        N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty\n      >,\n    ): void {\n      const paramCount = property.kind === \"get\" ? 0 : 1;\n      const length =\n        property.value.params.length + (property.value.rest ? 1 : 0);\n\n      if (property.value.this) {\n        this.raise(\n          property.kind === \"get\"\n            ? FlowErrors.GetterMayNotHaveThisParam\n            : FlowErrors.SetterMayNotHaveThisParam,\n          { at: property.value.this },\n        );\n      }\n\n      if (length !== paramCount) {\n        this.raise(\n          property.kind === \"get\"\n            ? Errors.BadGetterArity\n            : Errors.BadSetterArity,\n          { at: property },\n        );\n      }\n\n      if (property.kind === \"set\" && property.value.rest) {\n        this.raise(Errors.BadSetterRestParameter, { at: property });\n      }\n    }\n\n    flowObjectTypeSemicolon(): void {\n      if (\n        !this.eat(tt.semi) &&\n        !this.eat(tt.comma) &&\n        !this.match(tt.braceR) &&\n        !this.match(tt.braceBarR)\n      ) {\n        this.unexpected();\n      }\n    }\n\n    flowParseQualifiedTypeIdentifier(\n      startLoc?: Position,\n      id?: N.Identifier,\n    ): N.FlowQualifiedTypeIdentifier {\n      startLoc ??= this.state.startLoc;\n      let node: N.Identifier | N.FlowQualifiedTypeIdentifier =\n        id || this.flowParseRestrictedIdentifier(true);\n\n      while (this.eat(tt.dot)) {\n        const node2 = this.startNodeAt<N.FlowQualifiedTypeIdentifier>(startLoc);\n        node2.qualification = node;\n        node2.id = this.flowParseRestrictedIdentifier(true);\n        node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n      }\n\n      return node;\n    }\n\n    flowParseGenericType(\n      startLoc: Position,\n      id: N.Identifier,\n    ): N.FlowGenericTypeAnnotation {\n      const node = this.startNodeAt(startLoc);\n\n      node.typeParameters = null;\n      node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      }\n\n      return this.finishNode(node, \"GenericTypeAnnotation\");\n    }\n\n    flowParseTypeofType(): N.FlowTypeofTypeAnnotation {\n      const node = this.startNode();\n      this.expect(tt._typeof);\n      node.argument = this.flowParsePrimaryType();\n      return this.finishNode(node, \"TypeofTypeAnnotation\");\n    }\n\n    flowParseTupleType(): N.FlowTupleTypeAnnotation {\n      const node = this.startNode();\n      node.types = [];\n      this.expect(tt.bracketL);\n      // We allow trailing commas\n      while (this.state.pos < this.length && !this.match(tt.bracketR)) {\n        node.types.push(this.flowParseType());\n        if (this.match(tt.bracketR)) break;\n        this.expect(tt.comma);\n      }\n      this.expect(tt.bracketR);\n      return this.finishNode(node, \"TupleTypeAnnotation\");\n    }\n\n    flowParseFunctionTypeParam(first: boolean): N.FlowFunctionTypeParam {\n      let name = null;\n      let optional = false;\n      let typeAnnotation = null;\n      const node = this.startNode<N.FlowFunctionTypeParam>();\n      const lh = this.lookahead();\n      const isThis = this.state.type === tt._this;\n\n      if (lh.type === tt.colon || lh.type === tt.question) {\n        if (isThis && !first) {\n          this.raise(FlowErrors.ThisParamMustBeFirst, { at: node });\n        }\n        name = this.parseIdentifier(isThis);\n        if (this.eat(tt.question)) {\n          optional = true;\n          if (isThis) {\n            this.raise(FlowErrors.ThisParamMayNotBeOptional, { at: node });\n          }\n        }\n        typeAnnotation = this.flowParseTypeInitialiser();\n      } else {\n        typeAnnotation = this.flowParseType();\n      }\n      node.name = name;\n      node.optional = optional;\n      node.typeAnnotation = typeAnnotation;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    reinterpretTypeAsFunctionTypeParam(\n      type: N.FlowType,\n    ): N.FlowFunctionTypeParam {\n      const node = this.startNodeAt(type.loc.start);\n      node.name = null;\n      node.optional = false;\n      node.typeAnnotation = type;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    flowParseFunctionTypeParams(params: N.FlowFunctionTypeParam[] = []): {\n      params: N.FlowFunctionTypeParam[];\n      rest: N.FlowFunctionTypeParam | undefined | null;\n      _this: N.FlowFunctionTypeParam | undefined | null;\n    } {\n      let rest: N.FlowFunctionTypeParam | undefined | null = null;\n      let _this: N.FlowFunctionTypeParam | undefined | null = null;\n      if (this.match(tt._this)) {\n        _this = this.flowParseFunctionTypeParam(/* first */ true);\n        // match Flow parser behavior\n        _this.name = null;\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n        params.push(this.flowParseFunctionTypeParam(false));\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      if (this.eat(tt.ellipsis)) {\n        rest = this.flowParseFunctionTypeParam(false);\n      }\n      return { params, rest, _this };\n    }\n\n    flowIdentToTypeAnnotation(\n      startLoc: Position,\n      node: Undone<N.FlowTypeAnnotation>,\n      id: N.Identifier,\n    ): N.FlowTypeAnnotation {\n      switch (id.name) {\n        case \"any\":\n          return this.finishNode(node, \"AnyTypeAnnotation\");\n\n        case \"bool\":\n        case \"boolean\":\n          return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n        case \"mixed\":\n          return this.finishNode(node, \"MixedTypeAnnotation\");\n\n        case \"empty\":\n          return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n        case \"number\":\n          return this.finishNode(node, \"NumberTypeAnnotation\");\n\n        case \"string\":\n          return this.finishNode(node, \"StringTypeAnnotation\");\n\n        case \"symbol\":\n          return this.finishNode(node, \"SymbolTypeAnnotation\");\n\n        default:\n          this.checkNotUnderscore(id.name);\n          return this.flowParseGenericType(startLoc, id);\n      }\n    }\n\n    // The parsing of types roughly parallels the parsing of expressions, and\n    // primary types are kind of like primary expressions...they're the\n    // primitives with which other types are constructed.\n    flowParsePrimaryType(): N.FlowTypeAnnotation {\n      const startLoc = this.state.startLoc;\n      const node = this.startNode();\n      let tmp;\n      let type;\n      let isGroupedType = false;\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n      switch (this.state.type) {\n        case tt.braceL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: false,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: true,\n          });\n\n        case tt.braceBarL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: true,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: false,\n          });\n\n        case tt.bracketL:\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseTupleType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          return type;\n\n        case tt.lt:\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n          this.expect(tt.parenL);\n          tmp = this.flowParseFunctionTypeParams();\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(tt.parenR);\n\n          this.expect(tt.arrow);\n\n          node.returnType = this.flowParseType();\n\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n        case tt.parenL:\n          this.next();\n\n          // Check to see if this is actually a grouped type\n          if (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n            if (tokenIsIdentifier(this.state.type) || this.match(tt._this)) {\n              const token = this.lookahead().type;\n              isGroupedType = token !== tt.question && token !== tt.colon;\n            } else {\n              isGroupedType = true;\n            }\n          }\n\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n            // A `,` or a `) =>` means this is an anonymous function type\n            if (\n              this.state.noAnonFunctionType ||\n              !(\n                this.match(tt.comma) ||\n                (this.match(tt.parenR) && this.lookahead().type === tt.arrow)\n              )\n            ) {\n              this.expect(tt.parenR);\n              return type;\n            } else {\n              // Eat a comma if there is one\n              this.eat(tt.comma);\n            }\n          }\n\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([\n              this.reinterpretTypeAsFunctionTypeParam(type),\n            ]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n\n          this.expect(tt.parenR);\n\n          this.expect(tt.arrow);\n\n          node.returnType = this.flowParseType();\n\n          node.typeParameters = null;\n\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n        case tt.string:\n          return this.parseLiteral<N.StringLiteralTypeAnnotation>(\n            this.state.value,\n            \"StringLiteralTypeAnnotation\",\n          );\n\n        case tt._true:\n        case tt._false:\n          node.value = this.match(tt._true);\n          this.next();\n          return this.finishNode(\n            node as Undone<N.BooleanLiteralTypeAnnotation>,\n            \"BooleanLiteralTypeAnnotation\",\n          );\n\n        case tt.plusMin:\n          if (this.state.value === \"-\") {\n            this.next();\n            if (this.match(tt.num)) {\n              return this.parseLiteralAtNode<N.NumberLiteralTypeAnnotation>(\n                -this.state.value,\n                \"NumberLiteralTypeAnnotation\",\n                node,\n              );\n            }\n\n            if (this.match(tt.bigint)) {\n              return this.parseLiteralAtNode<N.BigIntLiteralTypeAnnotation>(\n                -this.state.value,\n                \"BigIntLiteralTypeAnnotation\",\n                node,\n              );\n            }\n\n            throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {\n              at: this.state.startLoc,\n            });\n          }\n          this.unexpected();\n          return;\n        case tt.num:\n          return this.parseLiteral(\n            this.state.value,\n            \"NumberLiteralTypeAnnotation\",\n          );\n\n        case tt.bigint:\n          return this.parseLiteral(\n            this.state.value,\n            \"BigIntLiteralTypeAnnotation\",\n          );\n\n        case tt._void:\n          this.next();\n          return this.finishNode(node, \"VoidTypeAnnotation\");\n\n        case tt._null:\n          this.next();\n          return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n        case tt._this:\n          this.next();\n          return this.finishNode(node, \"ThisTypeAnnotation\");\n\n        case tt.star:\n          this.next();\n          return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n        case tt._typeof:\n          return this.flowParseTypeofType();\n\n        default:\n          if (tokenIsKeyword(this.state.type)) {\n            const label = tokenLabelName(this.state.type);\n            this.next();\n            return super.createIdentifier(node as Undone<N.Identifier>, label);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            if (this.isContextual(tt._interface)) {\n              return this.flowParseInterfaceType();\n            }\n\n            return this.flowIdentToTypeAnnotation(\n              startLoc,\n              node,\n              this.parseIdentifier(),\n            );\n          }\n      }\n\n      this.unexpected();\n    }\n\n    flowParsePostfixType(): N.FlowTypeAnnotation {\n      const startLoc = this.state.startLoc;\n      let type = this.flowParsePrimaryType();\n      let seenOptionalIndexedAccess = false;\n      while (\n        (this.match(tt.bracketL) || this.match(tt.questionDot)) &&\n        !this.canInsertSemicolon()\n      ) {\n        const node = this.startNodeAt(startLoc);\n        const optional = this.eat(tt.questionDot);\n        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n        this.expect(tt.bracketL);\n        if (!optional && this.match(tt.bracketR)) {\n          node.elementType = type;\n          this.next(); // eat `]`\n          type = this.finishNode(node, \"ArrayTypeAnnotation\");\n        } else {\n          node.objectType = type;\n          node.indexType = this.flowParseType();\n          this.expect(tt.bracketR);\n          if (seenOptionalIndexedAccess) {\n            node.optional = optional;\n            type = this.finishNode<N.FlowOptionalIndexedAccessType>(\n              // @ts-expect-error todo(flow->ts)\n              node,\n              \"OptionalIndexedAccessType\",\n            );\n          } else {\n            type = this.finishNode<N.FlowIndexedAccessType>(\n              // @ts-expect-error todo(flow->ts)\n              node,\n              \"IndexedAccessType\",\n            );\n          }\n        }\n      }\n      return type;\n    }\n\n    flowParsePrefixType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      if (this.eat(tt.question)) {\n        node.typeAnnotation = this.flowParsePrefixType();\n        return this.finishNode(node, \"NullableTypeAnnotation\");\n      } else {\n        return this.flowParsePostfixType();\n      }\n    }\n\n    flowParseAnonFunctionWithoutParens(): N.FlowTypeAnnotation {\n      const param = this.flowParsePrefixType();\n      if (!this.state.noAnonFunctionType && this.eat(tt.arrow)) {\n        // TODO: This should be a type error. Passing in a SourceLocation, and it expects a Position.\n        const node = this.startNodeAt(param.loc.start);\n        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n        node.rest = null;\n        node.this = null;\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      }\n      return param;\n    }\n\n    flowParseIntersectionType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      this.eat(tt.bitwiseAND);\n      const type = this.flowParseAnonFunctionWithoutParens();\n      node.types = [type];\n      while (this.eat(tt.bitwiseAND)) {\n        node.types.push(this.flowParseAnonFunctionWithoutParens());\n      }\n      return node.types.length === 1\n        ? type\n        : this.finishNode(node, \"IntersectionTypeAnnotation\");\n    }\n\n    flowParseUnionType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      this.eat(tt.bitwiseOR);\n      const type = this.flowParseIntersectionType();\n      node.types = [type];\n      while (this.eat(tt.bitwiseOR)) {\n        node.types.push(this.flowParseIntersectionType());\n      }\n      return node.types.length === 1\n        ? type\n        : this.finishNode(node, \"UnionTypeAnnotation\");\n    }\n\n    flowParseType(): N.FlowTypeAnnotation {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      const type = this.flowParseUnionType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParseTypeOrImplicitInstantiation(): N.FlowTypeAnnotation {\n      if (this.state.type === tt.name && this.state.value === \"_\") {\n        const startLoc = this.state.startLoc;\n        const node = this.parseIdentifier();\n        return this.flowParseGenericType(startLoc, node);\n      } else {\n        return this.flowParseType();\n      }\n    }\n\n    flowParseTypeAnnotation(): N.FlowTypeAnnotation {\n      const node = this.startNode<N.FlowTypeAnnotation>();\n      node.typeAnnotation = this.flowParseTypeInitialiser();\n      return this.finishNode(node, \"TypeAnnotation\");\n    }\n\n    flowParseTypeAnnotatableIdentifier(\n      allowPrimitiveOverride?: boolean,\n    ): N.Identifier {\n      const ident = allowPrimitiveOverride\n        ? this.parseIdentifier()\n        : this.flowParseRestrictedIdentifier();\n      if (this.match(tt.colon)) {\n        // @ts-expect-error: refine typings\n        ident.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(ident);\n      }\n      return ident;\n    }\n\n    typeCastToParameter(node: N.Node): N.Node {\n      node.expression.typeAnnotation = node.typeAnnotation;\n\n      this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n\n      return node.expression;\n    }\n\n    flowParseVariance(): N.FlowVariance | undefined | null {\n      let variance = null;\n      if (this.match(tt.plusMin)) {\n        variance = this.startNode<N.FlowVariance>();\n        if (this.state.value === \"+\") {\n          variance.kind = \"plus\";\n        } else {\n          variance.kind = \"minus\";\n        }\n        this.next();\n        return this.finishNode(variance, \"Variance\");\n      }\n      return variance;\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    parseFunctionBody(\n      node: N.Function,\n      allowExpressionBody?: boolean | null,\n      isMethod: boolean = false,\n    ): void {\n      if (allowExpressionBody) {\n        this.forwardNoArrowParamsConversionAt(node, () =>\n          super.parseFunctionBody(node, true, isMethod),\n        );\n        return;\n      }\n\n      super.parseFunctionBody(node, false, isMethod);\n    }\n\n    parseFunctionBodyAndFinish<\n      T extends\n        | N.Function\n        | N.TSDeclareMethod\n        | N.TSDeclareFunction\n        | N.ClassPrivateMethod,\n    >(node: Undone<T>, type: T[\"type\"], isMethod: boolean = false): T {\n      if (this.match(tt.colon)) {\n        const typeNode = this.startNode<N.TypeAnnotation>();\n\n        [\n          typeNode.typeAnnotation,\n          // @ts-expect-error predicate may not exist\n          node.predicate,\n        ] = this.flowParseTypeAndPredicateInitialiser();\n\n        node.returnType = typeNode.typeAnnotation\n          ? this.finishNode(typeNode, \"TypeAnnotation\")\n          : null;\n      }\n\n      return super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    // interfaces and enums\n    parseStatementLike(flags: ParseStatementFlag): N.Statement {\n      // strict mode handling of `interface` since it's a reserved word\n      if (this.state.strict && this.isContextual(tt._interface)) {\n        const lookahead = this.lookahead();\n        if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n          const node = this.startNode<N.FlowInterface>();\n          this.next();\n          return this.flowParseInterface(node);\n        }\n      } else if (this.shouldParseEnums() && this.isContextual(tt._enum)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n      const stmt = super.parseStatementLike(flags);\n      // We will parse a flow pragma in any comment before the first statement.\n      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n        this.flowPragma = null;\n      }\n      return stmt;\n    }\n\n    // declares, interfaces and type aliases\n    parseExpressionStatement(\n      node: N.ExpressionStatement,\n      expr: N.Expression,\n      decorators: N.Decorator[] | null,\n    ): N.ExpressionStatement {\n      if (expr.type === \"Identifier\") {\n        if (expr.name === \"declare\") {\n          if (\n            this.match(tt._class) ||\n            tokenIsIdentifier(this.state.type) ||\n            this.match(tt._function) ||\n            this.match(tt._var) ||\n            this.match(tt._export)\n          ) {\n            // @ts-expect-error: refine typings\n            return this.flowParseDeclare(node);\n          }\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (expr.name === \"interface\") {\n            // @ts-expect-error: refine typings\n            return this.flowParseInterface(node);\n          } else if (expr.name === \"type\") {\n            // @ts-expect-error: refine typings\n            return this.flowParseTypeAlias(node);\n          } else if (expr.name === \"opaque\") {\n            // @ts-expect-error: refine typings\n            return this.flowParseOpaqueType(node, false);\n          }\n        }\n      }\n\n      return super.parseExpressionStatement(node, expr, decorators);\n    }\n\n    // export type\n    shouldParseExportDeclaration(): boolean {\n      const { type } = this.state;\n      if (\n        tokenIsFlowInterfaceOrTypeOrOpaque(type) ||\n        (this.shouldParseEnums() && type === tt._enum)\n      ) {\n        return !this.state.containsEsc;\n      }\n      return super.shouldParseExportDeclaration();\n    }\n\n    isExportDefaultSpecifier(): boolean {\n      const { type } = this.state;\n      if (\n        tokenIsFlowInterfaceOrTypeOrOpaque(type) ||\n        (this.shouldParseEnums() && type === tt._enum)\n      ) {\n        return this.state.containsEsc;\n      }\n\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseExportDefaultExpression(): N.Expression | N.Declaration {\n      if (this.shouldParseEnums() && this.isContextual(tt._enum)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n      return super.parseExportDefaultExpression();\n    }\n\n    parseConditional(\n      expr: N.Expression,\n\n      startLoc: Position,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.Expression {\n      if (!this.match(tt.question)) return expr;\n\n      if (this.state.maybeInArrowParameters) {\n        const nextCh = this.lookaheadCharCode();\n        // These tokens cannot start an expression, so if one of them follows\n        // ? then we are probably in an arrow function parameters list and we\n        // don't parse the conditional expression.\n        if (\n          nextCh === charCodes.comma || // (a?, b) => c\n          nextCh === charCodes.equalsTo || // (a? = b) => c\n          nextCh === charCodes.colon || // (a?: b) => c\n          nextCh === charCodes.rightParenthesis // (a?) => c\n        ) {\n          /*:: invariant(refExpressionErrors != null) */\n          this.setOptionalParametersError(refExpressionErrors);\n          return expr;\n        }\n      }\n\n      this.expect(tt.question);\n      const state = this.state.clone();\n      const originalNoArrowAt = this.state.noArrowAt;\n      const node = this.startNodeAt(startLoc);\n      let { consequent, failed } = this.tryParseConditionalConsequent();\n      let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n      if (failed || invalid.length > 0) {\n        const noArrowAt = [...originalNoArrowAt];\n\n        if (invalid.length > 0) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt;\n\n          for (let i = 0; i < invalid.length; i++) {\n            noArrowAt.push(invalid[i].start);\n          }\n\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\n          [valid, invalid] = this.getArrowLikeExpressions(consequent);\n        }\n\n        if (failed && valid.length > 1) {\n          // if there are two or more possible correct ways of parsing, throw an\n          // error.\n          // e.g.   Source: a ? (b): c => (d): e => f\n          //      Result 1: a ? b : (c => ((d): e => f))\n          //      Result 2: a ? ((b): c => d) : (e => f)\n          this.raise(FlowErrors.AmbiguousConditionalArrow, {\n            at: state.startLoc,\n          });\n        }\n\n        if (failed && valid.length === 1) {\n          this.state = state;\n          noArrowAt.push(valid[0].start);\n          this.state.noArrowAt = noArrowAt;\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\n        }\n      }\n\n      this.getArrowLikeExpressions(consequent, true);\n\n      this.state.noArrowAt = originalNoArrowAt;\n      this.expect(tt.colon);\n\n      node.test = expr;\n      node.consequent = consequent;\n      node.alternate = this.forwardNoArrowParamsConversionAt(node, () =>\n        this.parseMaybeAssign(undefined, undefined),\n      );\n\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    tryParseConditionalConsequent(): {\n      consequent: N.Expression;\n      failed: boolean;\n    } {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n\n      const consequent = this.parseMaybeAssignAllowIn();\n      const failed = !this.match(tt.colon);\n\n      this.state.noArrowParamsConversionAt.pop();\n\n      return { consequent, failed };\n    }\n\n    // Given an expression, walks through out its arrow functions whose body is\n    // an expression and through out conditional expressions. It returns every\n    // function which has been parsed with a return type but could have been\n    // parenthesized expressions.\n    // These functions are separated into two arrays: one containing the ones\n    // whose parameters can be converted to assignable lists, one containing the\n    // others.\n    getArrowLikeExpressions(\n      node: N.Expression,\n      disallowInvalid?: boolean,\n    ): [N.ArrowFunctionExpression[], N.ArrowFunctionExpression[]] {\n      const stack = [node];\n      const arrows: N.ArrowFunctionExpression[] = [];\n\n      while (stack.length !== 0) {\n        const node = stack.pop();\n        if (node.type === \"ArrowFunctionExpression\") {\n          if (node.typeParameters || !node.returnType) {\n            // This is an arrow expression without ambiguity, so check its parameters\n            // @ts-expect-error: refine typings\n            this.finishArrowValidation(node);\n          } else {\n            // @ts-expect-error: refine typings\n            arrows.push(node);\n          }\n          stack.push(node.body);\n        } else if (node.type === \"ConditionalExpression\") {\n          stack.push(node.consequent);\n          stack.push(node.alternate);\n        }\n      }\n\n      if (disallowInvalid) {\n        arrows.forEach(node => this.finishArrowValidation(node));\n        return [arrows, []];\n      }\n\n      return partition(arrows, node =>\n        node.params.every(param => this.isAssignable(param, true)),\n      );\n    }\n\n    finishArrowValidation(node: N.ArrowFunctionExpression) {\n      this.toAssignableList(\n        // node.params is Expression[] instead of $ReadOnlyArray<Pattern> because it\n        // has not been converted yet.\n        node.params as any as N.Expression[],\n        node.extra?.trailingCommaLoc,\n        /* isLHS */ false,\n      );\n      // Enter scope, as checkParams defines bindings\n      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n      // Use super's method to force the parameters to be checked\n      super.checkParams(node, false, true);\n      this.scope.exit();\n    }\n\n    forwardNoArrowParamsConversionAt<T>(\n      node: Undone<N.Node>,\n      parse: () => T,\n    ): T {\n      let result: T;\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        this.state.noArrowParamsConversionAt.push(this.state.start);\n        result = parse();\n        this.state.noArrowParamsConversionAt.pop();\n      } else {\n        result = parse();\n      }\n\n      return result;\n    }\n\n    parseParenItem(\n      node: N.Expression,\n\n      startLoc: Position,\n    ): N.Expression {\n      node = super.parseParenItem(node, startLoc);\n      if (this.eat(tt.question)) {\n        node.optional = true;\n        // Include questionmark in location of node\n        // Don't use this.finishNode() as otherwise we might process comments twice and\n        // include already consumed parens\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(tt.colon)) {\n        const typeCastNode = this.startNodeAt(startLoc);\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n\n        return this.finishNode(typeCastNode, \"TypeCastExpression\");\n      }\n\n      return node;\n    }\n\n    assertModuleNodeAllowed(node: N.Node) {\n      if (\n        (node.type === \"ImportDeclaration\" &&\n          (node.importKind === \"type\" || node.importKind === \"typeof\")) ||\n        (node.type === \"ExportNamedDeclaration\" &&\n          node.exportKind === \"type\") ||\n        (node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\")\n      ) {\n        // Allow Flowtype imports and exports in all conditions because\n        // Flow itself does not care about 'sourceType'.\n        return;\n      }\n\n      super.assertModuleNodeAllowed(node);\n    }\n\n    parseExport(\n      node: Undone<N.ExportNamedDeclaration | N.ExportAllDeclaration>,\n      decorators: N.Decorator[] | null,\n    ): N.AnyExport {\n      const decl = super.parseExport(node, decorators);\n      if (\n        decl.type === \"ExportNamedDeclaration\" ||\n        decl.type === \"ExportAllDeclaration\"\n      ) {\n        decl.exportKind = decl.exportKind || \"value\";\n      }\n      return decl;\n    }\n\n    parseExportDeclaration(\n      node: N.ExportNamedDeclaration,\n    ): N.Declaration | undefined | null {\n      if (this.isContextual(tt._type)) {\n        node.exportKind = \"type\";\n\n        const declarationNode = this.startNode();\n        this.next();\n\n        if (this.match(tt.braceL)) {\n          // export type { foo, bar };\n          node.specifiers = this.parseExportSpecifiers(\n            /* isInTypeExport */ true,\n          );\n          super.parseExportFrom(node);\n          return null;\n        } else {\n          // export type Foo = Bar;\n          // @ts-expect-error: refine typings\n          return this.flowParseTypeAlias(declarationNode);\n        }\n      } else if (this.isContextual(tt._opaque)) {\n        node.exportKind = \"type\";\n\n        const declarationNode = this.startNode();\n        this.next();\n        // export opaque type Foo = Bar;\n        // @ts-expect-error: refine typings\n        return this.flowParseOpaqueType(declarationNode, false);\n      } else if (this.isContextual(tt._interface)) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n        // @ts-expect-error: refine typings\n        return this.flowParseInterface(declarationNode);\n      } else if (this.shouldParseEnums() && this.isContextual(tt._enum)) {\n        node.exportKind = \"value\";\n        const declarationNode = this.startNode();\n        this.next();\n        // @ts-expect-error: refine typings\n        return this.flowParseEnumDeclaration(declarationNode);\n      } else {\n        return super.parseExportDeclaration(node);\n      }\n    }\n\n    eatExportStar(node: N.Node): boolean {\n      if (super.eatExportStar(node)) return true;\n\n      if (this.isContextual(tt._type) && this.lookahead().type === tt.star) {\n        node.exportKind = \"type\";\n        this.next();\n        this.next();\n        return true;\n      }\n\n      return false;\n    }\n\n    maybeParseExportNamespaceSpecifier(node: N.Node): boolean {\n      const { startLoc } = this.state;\n      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n      if (hasNamespace && node.exportKind === \"type\") {\n        this.unexpected(startLoc);\n      }\n      return hasNamespace;\n    }\n\n    parseClassId(\n      node: N.Class,\n      isStatement: boolean,\n      optionalId?: boolean | null,\n    ) {\n      super.parseClassId(node, isStatement, optionalId);\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n    }\n\n    parseClassMember(\n      classBody: N.ClassBody,\n      member: any,\n      state: N.ParseClassMemberState,\n    ): void {\n      const { startLoc } = this.state;\n      if (this.isContextual(tt._declare)) {\n        if (super.parseClassMemberFromModifier(classBody, member)) {\n          // 'declare' is a class element name\n          return;\n        }\n\n        member.declare = true;\n      }\n\n      super.parseClassMember(classBody, member, state);\n\n      if (member.declare) {\n        if (\n          member.type !== \"ClassProperty\" &&\n          member.type !== \"ClassPrivateProperty\" &&\n          member.type !== \"PropertyDefinition\" // Used by estree plugin\n        ) {\n          this.raise(FlowErrors.DeclareClassElement, { at: startLoc });\n        } else if (member.value) {\n          this.raise(FlowErrors.DeclareClassFieldInitializer, {\n            at: member.value,\n          });\n        }\n      }\n    }\n\n    isIterator(word: string): boolean {\n      return word === \"iterator\" || word === \"asyncIterator\";\n    }\n\n    readIterator(): void {\n      const word = super.readWord1();\n      const fullWord = \"@@\" + word;\n\n      // Allow @@iterator and @@asyncIterator as a identifier only inside type\n      if (!this.isIterator(word) || !this.state.inType) {\n        this.raise(Errors.InvalidIdentifier, {\n          at: this.state.curPosition(),\n          identifierName: fullWord,\n        });\n      }\n\n      this.finishToken(tt.name, fullWord);\n    }\n\n    // ensure that inside flow types, we bypass the jsx parser plugin\n    getTokenFromCode(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (code === charCodes.leftCurlyBrace && next === charCodes.verticalBar) {\n        this.finishOp(tt.braceBarL, 2);\n      } else if (\n        this.state.inType &&\n        (code === charCodes.greaterThan || code === charCodes.lessThan)\n      ) {\n        this.finishOp(code === charCodes.greaterThan ? tt.gt : tt.lt, 1);\n      } else if (this.state.inType && code === charCodes.questionMark) {\n        if (next === charCodes.dot) {\n          this.finishOp(tt.questionDot, 2);\n        } else {\n          // allow double nullable types in Flow: ??string\n          this.finishOp(tt.question, 1);\n        }\n      } else if (\n        isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))\n      ) {\n        this.state.pos += 2; // eat \"@@\"\n        this.readIterator();\n      } else {\n        super.getTokenFromCode(code);\n      }\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      if (node.type === \"TypeCastExpression\") {\n        return this.isAssignable(node.expression, isBinding);\n      } else {\n        return super.isAssignable(node, isBinding);\n      }\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): void {\n      if (\n        !isLHS &&\n        node.type === \"AssignmentExpression\" &&\n        node.left.type === \"TypeCastExpression\"\n      ) {\n        node.left = this.typeCastToParameter(node.left);\n      }\n      super.toAssignable(node, isLHS);\n    }\n\n    // turn type casts that we found in function parameter head into type annotated params\n    toAssignableList(\n      exprList: N.Expression[],\n      trailingCommaLoc: Position | undefined | null,\n      isLHS: boolean,\n    ): void {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (expr?.type === \"TypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(expr);\n        }\n      }\n      super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n    }\n\n    // this is a list of nodes, from something like a call expression, we need to filter the\n    // type casts that we've found that are illegal in this context\n    toReferencedList(\n      exprList: ReadonlyArray<N.Expression | undefined | null>,\n      isParenthesizedExpr?: boolean,\n    ): ReadonlyArray<N.Expression | undefined | null> {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (\n          expr &&\n          expr.type === \"TypeCastExpression\" &&\n          !expr.extra?.parenthesized &&\n          (exprList.length > 1 || !isParenthesizedExpr)\n        ) {\n          this.raise(FlowErrors.TypeCastInPattern, {\n            at: expr.typeAnnotation,\n          });\n        }\n      }\n\n      return exprList;\n    }\n\n    parseArrayLike(\n      close: TokenType,\n      canBePattern: boolean,\n      isTuple: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ArrayExpression | N.TupleExpression {\n      const node = super.parseArrayLike(\n        close,\n        canBePattern,\n        isTuple,\n        refExpressionErrors,\n      );\n\n      // This could be an array pattern:\n      //   ([a: string, b: string]) => {}\n      // In this case, we don't have to call toReferencedList. We will\n      // call it, if needed, when we are sure that it is a parenthesized\n      // expression by calling toReferencedListDeep.\n      if (canBePattern && !this.state.maybeInArrowParameters) {\n        this.toReferencedList(node.elements);\n      }\n\n      return node;\n    }\n\n    isValidLVal(type: string, isParenthesized: boolean, binding: BindingTypes) {\n      return (\n        type === \"TypeCastExpression\" ||\n        super.isValidLVal(type, isParenthesized, binding)\n      );\n    }\n\n    // parse class property type annotations\n    parseClassProperty(node: N.ClassProperty): N.ClassProperty {\n      if (this.match(tt.colon)) {\n        // @ts-expect-error refine typings\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(\n      node: N.ClassPrivateProperty,\n    ): N.ClassPrivateProperty {\n      if (this.match(tt.colon)) {\n        // @ts-expect-error refine typings\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return super.parseClassPrivateProperty(node);\n    }\n\n    // determine whether or not we're currently in the position where a class method would appear\n    isClassMethod(): boolean {\n      return this.match(tt.lt) || super.isClassMethod();\n    }\n\n    // determine whether or not we're currently in the position where a class property would appear\n    isClassProperty(): boolean {\n      return this.match(tt.colon) || super.isClassProperty();\n    }\n\n    isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\n      return !this.match(tt.colon) && super.isNonstaticConstructor(method);\n    }\n\n    // parse type parameters for class methods\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      if ((method as any).variance) {\n        this.unexpected((method as any).variance.loc.start);\n      }\n      delete (method as any).variance;\n      if (this.match(tt.lt)) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassMethod(\n        classBody,\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n      );\n\n      if (method.params && isConstructor) {\n        const params = method.params;\n        if (params.length > 0 && this.isThisParam(params[0])) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, { at: method });\n        }\n        // estree support\n      } else if (\n        // @ts-expect-error TS does not know about the face that estree can replace ClassMethod with MethodDefinition\n        method.type === \"MethodDefinition\" &&\n        isConstructor &&\n        // @ts-expect-error estree\n        method.value.params\n      ) {\n        // @ts-expect-error estree\n        const params = method.value.params;\n        if (params.length > 0 && this.isThisParam(params[0])) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, { at: method });\n        }\n      }\n    }\n\n    pushClassPrivateMethod(\n      classBody: N.ClassBody,\n      method: N.ClassPrivateMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n    ): void {\n      if ((method as any).variance) {\n        this.unexpected((method as any).variance.loc.start);\n      }\n      delete (method as any).variance;\n      if (this.match(tt.lt)) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    // parse a the super class type parameters and implements\n    parseClassSuper(node: N.Class): void {\n      super.parseClassSuper(node);\n      if (node.superClass && this.match(tt.lt)) {\n        node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n      }\n      if (this.isContextual(tt._implements)) {\n        this.next();\n        const implemented: N.FlowClassImplements[] = (node.implements = []);\n        do {\n          const node = this.startNode();\n          node.id = this.flowParseRestrictedIdentifier(/*liberal*/ true);\n          if (this.match(tt.lt)) {\n            node.typeParameters = this.flowParseTypeParameterInstantiation();\n          } else {\n            node.typeParameters = null;\n          }\n          implemented.push(this.finishNode(node, \"ClassImplements\"));\n        } while (this.eat(tt.comma));\n      }\n    }\n\n    checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\n      super.checkGetterSetterParams(method);\n      const params = this.getObjectOrClassMethodParams(method);\n      if (params.length > 0) {\n        const param = params[0];\n        if (this.isThisParam(param) && method.kind === \"get\") {\n          this.raise(FlowErrors.GetterMayNotHaveThisParam, { at: param });\n        } else if (this.isThisParam(param)) {\n          this.raise(FlowErrors.SetterMayNotHaveThisParam, { at: param });\n        }\n      }\n    }\n\n    parsePropertyNamePrefixOperator(\n      node: N.ObjectOrClassMember | N.ClassMember,\n    ): void {\n      node.variance = this.flowParseVariance();\n    }\n\n    // parse type parameters for object method shorthand\n    parseObjPropValue(\n      prop: Undone<N.ObjectMethod | N.ObjectProperty>,\n      startLoc: Position | undefined | null,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ObjectMethod | N.ObjectProperty {\n      if ((prop as any).variance) {\n        this.unexpected((prop as any).variance.loc.start);\n      }\n      delete (prop as any).variance;\n\n      let typeParameters;\n\n      // method shorthand\n      if (this.match(tt.lt) && !isAccessor) {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        if (!this.match(tt.parenL)) this.unexpected();\n      }\n\n      const result = super.parseObjPropValue(\n        prop,\n        startLoc,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n        refExpressionErrors,\n      );\n\n      // add typeParameters if we found them\n      if (typeParameters) {\n        (result.value || result).typeParameters = typeParameters;\n      }\n      return result;\n    }\n\n    parseAssignableListItemTypes(param: N.Pattern): N.Pattern {\n      if (this.eat(tt.question)) {\n        if (param.type !== \"Identifier\") {\n          this.raise(FlowErrors.PatternIsOptional, { at: param });\n        }\n        if (this.isThisParam(param)) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, { at: param });\n        }\n\n        (param as any as N.Identifier).optional = true;\n      }\n      if (this.match(tt.colon)) {\n        // @ts-expect-error: refine typings\n        param.typeAnnotation = this.flowParseTypeAnnotation();\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamAnnotationRequired, { at: param });\n      }\n\n      if (this.match(tt.eq) && this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamNoDefault, { at: param });\n      }\n\n      this.resetEndLocation(param);\n      return param;\n    }\n\n    parseMaybeDefault(\n      startLoc?: Position | null,\n      left?: N.Pattern | null,\n    ): N.Pattern {\n      const node = super.parseMaybeDefault(startLoc, left);\n\n      if (\n        node.type === \"AssignmentPattern\" &&\n        node.typeAnnotation &&\n        node.right.start < node.typeAnnotation.start\n      ) {\n        this.raise(FlowErrors.TypeBeforeInitializer, {\n          at: node.typeAnnotation,\n        });\n      }\n\n      return node;\n    }\n\n    shouldParseDefaultImport(node: N.ImportDeclaration): boolean {\n      if (!hasTypeImportKind(node)) {\n        return super.shouldParseDefaultImport(node);\n      }\n\n      return isMaybeDefaultImport(this.state.type);\n    }\n\n    checkImportReflection(node: Undone<N.ImportDeclaration>) {\n      super.checkImportReflection(node);\n      if (node.module && node.importKind !== \"value\") {\n        this.raise(FlowErrors.ImportReflectionHasImportType, {\n          at: node.specifiers[0].loc.start,\n        });\n      }\n    }\n\n    parseImportSpecifierLocal<\n      T extends\n        | N.ImportSpecifier\n        | N.ImportDefaultSpecifier\n        | N.ImportNamespaceSpecifier,\n    >(node: N.ImportDeclaration, specifier: Undone<T>, type: T[\"type\"]): void {\n      specifier.local = hasTypeImportKind(node)\n        ? this.flowParseRestrictedIdentifier(\n            /* liberal */ true,\n            /* declaration */ true,\n          )\n        : this.parseIdentifier();\n\n      node.specifiers.push(this.finishImportSpecifier(specifier, type));\n    }\n\n    // parse typeof and type imports\n    maybeParseDefaultImportSpecifier(node: N.ImportDeclaration): boolean {\n      node.importKind = \"value\";\n\n      let kind = null;\n      if (this.match(tt._typeof)) {\n        kind = \"typeof\" as const;\n      } else if (this.isContextual(tt._type)) {\n        kind = \"type\" as const;\n      }\n      if (kind) {\n        const lh = this.lookahead();\n        const { type } = lh;\n\n        // import type * is not allowed\n        if (kind === \"type\" && type === tt.star) {\n          // FIXME: lh.start?\n          this.unexpected(null, lh.type);\n        }\n\n        if (\n          isMaybeDefaultImport(type) ||\n          type === tt.braceL ||\n          type === tt.star\n        ) {\n          this.next();\n          node.importKind = kind;\n        }\n      }\n\n      return super.maybeParseDefaultImportSpecifier(node);\n    }\n\n    // parse import-type/typeof shorthand\n    parseImportSpecifier(\n      specifier: any,\n      importedIsString: boolean,\n      isInTypeOnlyImport: boolean,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      isMaybeTypeOnly: boolean,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      bindingType: BindingTypes | undefined,\n    ): N.ImportSpecifier {\n      const firstIdent = specifier.imported;\n\n      let specifierTypeKind = null;\n      if (firstIdent.type === \"Identifier\") {\n        if (firstIdent.name === \"type\") {\n          specifierTypeKind = \"type\";\n        } else if (firstIdent.name === \"typeof\") {\n          specifierTypeKind = \"typeof\";\n        }\n      }\n\n      let isBinding = false;\n      if (this.isContextual(tt._as) && !this.isLookaheadContextual(\"as\")) {\n        const as_ident = this.parseIdentifier(true);\n        if (\n          specifierTypeKind !== null &&\n          !tokenIsKeywordOrIdentifier(this.state.type)\n        ) {\n          // `import {type as ,` or `import {type as }`\n          specifier.imported = as_ident;\n          specifier.importKind = specifierTypeKind;\n          specifier.local = cloneIdentifier(as_ident);\n        } else {\n          // `import {type as foo`\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n          specifier.local = this.parseIdentifier();\n        }\n      } else {\n        if (\n          specifierTypeKind !== null &&\n          tokenIsKeywordOrIdentifier(this.state.type)\n        ) {\n          // `import {type foo`\n          specifier.imported = this.parseIdentifier(true);\n          specifier.importKind = specifierTypeKind;\n        } else {\n          if (importedIsString) {\n            /*:: invariant(firstIdent instanceof N.StringLiteral) */\n            throw this.raise(Errors.ImportBindingIsString, {\n              at: specifier,\n              importName: firstIdent.value,\n            });\n          }\n          /*:: invariant(firstIdent instanceof N.Node) */\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n        }\n\n        if (this.eatContextual(tt._as)) {\n          specifier.local = this.parseIdentifier();\n        } else {\n          isBinding = true;\n          specifier.local = cloneIdentifier(specifier.imported);\n        }\n      }\n\n      const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n      if (isInTypeOnlyImport && specifierIsTypeImport) {\n        this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {\n          at: specifier,\n        });\n      }\n\n      if (isInTypeOnlyImport || specifierIsTypeImport) {\n        this.checkReservedType(\n          specifier.local.name,\n          specifier.local.loc.start,\n          /* declaration */ true,\n        );\n      }\n\n      if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n        this.checkReservedWord(\n          specifier.local.name,\n          specifier.loc.start,\n          true,\n          true,\n        );\n      }\n\n      return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n    }\n\n    parseBindingAtom(): N.Pattern {\n      switch (this.state.type) {\n        case tt._this:\n          // \"this\" may be the name of a parameter, so allow it.\n          return this.parseIdentifier(/* liberal */ true);\n        default:\n          return super.parseBindingAtom();\n      }\n    }\n\n    // parse function type parameters - function foo<T>() {}\n    parseFunctionParams(\n      node: Undone<N.Function>,\n      isConstructor: boolean,\n    ): void {\n      // @ts-expect-error kind may not index node\n      const kind = node.kind;\n      if (kind !== \"get\" && kind !== \"set\" && this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n      super.parseFunctionParams(node, isConstructor);\n    }\n\n    // parse flow type annotations on variable declarator heads - let foo: string = bar\n    parseVarId(\n      decl: N.VariableDeclarator,\n      kind: \"var\" | \"let\" | \"const\",\n    ): void {\n      super.parseVarId(decl, kind);\n      if (this.match(tt.colon)) {\n        // @ts-expect-error: refine typings\n        decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(decl.id); // set end position to end of type\n      }\n    }\n\n    // parse the return type of an async arrow function - let foo = (async (): number => {});\n    parseAsyncArrowFromCallExpression(\n      node: N.ArrowFunctionExpression,\n      call: N.CallExpression,\n    ): N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        // @ts-expect-error refine typings\n        node.returnType = this.flowParseTypeAnnotation();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      }\n\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    // todo description\n    shouldParseAsyncArrow(): boolean {\n      return this.match(tt.colon) || super.shouldParseAsyncArrow();\n    }\n\n    // We need to support type parameter declarations for arrow functions. This\n    // is tricky. There are three situations we need to handle\n    //\n    // 1. This is either JSX or an arrow function. We'll try JSX first. If that\n    //    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n    //    error.\n    // 2. This is an arrow function. We'll parse the type parameter declaration,\n    //    parse the rest, make sure the rest is an arrow function, and go from\n    //    there\n    // 3. This is neither. Just call the super method\n    parseMaybeAssign(\n      refExpressionErrors?: ExpressionErrors | null,\n      afterLeftParse?: Function,\n    ): N.Expression {\n      let state = null;\n\n      let jsx;\n\n      if (\n        this.hasPlugin(\"jsx\") &&\n        (this.match(tt.jsxTagStart) || this.match(tt.lt))\n      ) {\n        state = this.state.clone();\n\n        jsx = this.tryParse(\n          () => super.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n          state,\n        );\n\n        /*:: invariant(!jsx.aborted) */\n        /*:: invariant(jsx.node != null) */\n        if (!jsx.error) return jsx.node;\n\n        // Remove `tc.j_expr` and `tc.j_oTag` from context added\n        // by parsing `jsxTagStart` to stop the JSX plugin from\n        // messing with the tokens\n        const { context } = this.state;\n        const currentContext = context[context.length - 1];\n        if (currentContext === tc.j_oTag || currentContext === tc.j_expr) {\n          context.pop();\n        }\n      }\n\n      if (jsx?.error || this.match(tt.lt)) {\n        state = state || this.state.clone();\n\n        let typeParameters: N.TypeParameterDeclaration;\n\n        const arrow = this.tryParse(abort => {\n          typeParameters = this.flowParseTypeParameterDeclaration();\n\n          const arrowExpression = this.forwardNoArrowParamsConversionAt(\n            typeParameters,\n            () => {\n              const result = super.parseMaybeAssign(\n                refExpressionErrors,\n                afterLeftParse,\n              );\n\n              this.resetStartLocationFromNode(result, typeParameters);\n\n              return result;\n            },\n          );\n\n          // <T>(() => {});\n          // <T>(() => {}: any);\n          if (arrowExpression.extra?.parenthesized) abort();\n\n          // The above can return a TypeCastExpression when the arrow\n          // expression is not wrapped in parens. See also `this.parseParenItem`.\n          // (<T>() => {}: any);\n          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n\n          if (expr.type !== \"ArrowFunctionExpression\") abort();\n\n          expr.typeParameters = typeParameters;\n          this.resetStartLocationFromNode(expr, typeParameters);\n\n          return arrowExpression;\n        }, state);\n\n        let arrowExpression:\n          | N.ArrowFunctionExpression\n          | N.TypeCastExpression\n          | undefined\n          | null = null;\n\n        if (\n          arrow.node &&\n          // @ts-expect-error: refine tryParse typings\n          this.maybeUnwrapTypeCastExpression(arrow.node).type ===\n            \"ArrowFunctionExpression\"\n        ) {\n          if (!arrow.error && !arrow.aborted) {\n            // <T> async () => {}\n            // @ts-expect-error: refine tryParse typings\n            if (arrow.node.async) {\n              /*:: invariant(typeParameters) */\n              this.raise(\n                FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction,\n                { at: typeParameters },\n              );\n            }\n            // @ts-expect-error: refine tryParse typings\n            return arrow.node;\n          }\n\n          // @ts-expect-error: refine typings\n          arrowExpression = arrow.node;\n        }\n\n        // If we are here, both JSX and Flow parsing attempts failed.\n        // Give the precedence to the JSX error, except if JSX had an\n        // unrecoverable error while Flow didn't.\n        // If the error is recoverable, we can only re-report it if there is\n        // a node we can return.\n\n        if (jsx?.node) {\n          /*:: invariant(jsx.failState) */\n          this.state = jsx.failState;\n          return jsx.node;\n        }\n\n        if (arrowExpression) {\n          /*:: invariant(arrow.failState) */\n          this.state = arrow.failState;\n          return arrowExpression;\n        }\n\n        if (jsx?.thrown) throw jsx.error;\n        if (arrow.thrown) throw arrow.error;\n\n        /*:: invariant(typeParameters) */\n        throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {\n          at: typeParameters,\n        });\n      }\n\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n\n    // handle return types for arrow functions\n    parseArrow(\n      node: Undone<N.ArrowFunctionExpression>,\n    ): Undone<N.ArrowFunctionExpression> | undefined | null {\n      if (this.match(tt.colon)) {\n        // @ts-expect-error todo(flow->ts)\n        const result = this.tryParse(() => {\n          const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n          this.state.noAnonFunctionType = true;\n\n          const typeNode = this.startNode<N.TypeAnnotation>();\n\n          [\n            typeNode.typeAnnotation,\n            // @ts-expect-error (destructuring not supported yet)\n            node.predicate,\n          ] = this.flowParseTypeAndPredicateInitialiser();\n\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.canInsertSemicolon()) this.unexpected();\n          if (!this.match(tt.arrow)) this.unexpected();\n\n          return typeNode;\n        });\n\n        if (result.thrown) return null;\n        /*:: invariant(result.node) */\n\n        if (result.error) this.state = result.failState;\n\n        // assign after it is clear it is an arrow\n        // @ts-expect-error todo(flow->ts)\n        node.returnType = result.node.typeAnnotation\n          ? this.finishNode(result.node, \"TypeAnnotation\")\n          : null;\n      }\n\n      return super.parseArrow(node);\n    }\n\n    shouldParseArrow(params: Array<N.Node>): boolean {\n      return this.match(tt.colon) || super.shouldParseArrow(params);\n    }\n\n    setArrowFunctionParameters(\n      node: N.ArrowFunctionExpression,\n      params: N.Pattern[],\n    ): void {\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        node.params = params;\n      } else {\n        super.setArrowFunctionParameters(node, params);\n      }\n    }\n\n    checkParams(\n      node: N.Function,\n      allowDuplicates: boolean,\n      isArrowFunction?: boolean | null,\n      strictModeChanged: boolean = true,\n    ): void {\n      if (\n        isArrowFunction &&\n        this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1\n      ) {\n        return;\n      }\n\n      // ensure the `this` param is first, if it exists\n      for (let i = 0; i < node.params.length; i++) {\n        if (this.isThisParam(node.params[i]) && i > 0) {\n          this.raise(FlowErrors.ThisParamMustBeFirst, { at: node.params[i] });\n        }\n      }\n\n      super.checkParams(\n        node,\n        allowDuplicates,\n        isArrowFunction,\n        strictModeChanged,\n      );\n    }\n\n    parseParenAndDistinguishExpression(canBeArrow: boolean): N.Expression {\n      return super.parseParenAndDistinguishExpression(\n        canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1,\n      );\n    }\n\n    parseSubscripts(\n      base: N.Expression,\n\n      startLoc: Position,\n      noCalls?: boolean | null,\n    ): N.Expression {\n      if (\n        base.type === \"Identifier\" &&\n        base.name === \"async\" &&\n        this.state.noArrowAt.indexOf(startLoc.index) !== -1\n      ) {\n        this.next();\n\n        const node = this.startNodeAt(startLoc);\n        node.callee = base;\n        node.arguments = super.parseCallExpressionArguments(tt.parenR, false);\n        base = this.finishNode(node, \"CallExpression\");\n      } else if (\n        base.type === \"Identifier\" &&\n        base.name === \"async\" &&\n        this.match(tt.lt)\n      ) {\n        const state = this.state.clone();\n        const arrow = this.tryParse(\n          abort => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(),\n          state,\n        );\n\n        /*:: invariant(arrow.node != null) */\n        // @ts-expect-error: refine tryParse typings\n        if (!arrow.error && !arrow.aborted) return arrow.node;\n\n        const result = this.tryParse(\n          () => super.parseSubscripts(base, startLoc, noCalls),\n          state,\n        );\n\n        if (result.node && !result.error) return result.node;\n\n        if (arrow.node) {\n          this.state = arrow.failState;\n          // @ts-expect-error: refine tryParse typings\n          return arrow.node;\n        }\n\n        if (result.node) {\n          this.state = result.failState;\n          return result.node;\n        }\n\n        throw arrow.error || result.error;\n      }\n\n      return super.parseSubscripts(base, startLoc, noCalls);\n    }\n\n    parseSubscript(\n      base: N.Expression,\n\n      startLoc: Position,\n      noCalls: boolean | undefined | null,\n      subscriptState: N.ParseSubscriptState,\n    ): N.Expression {\n      if (this.match(tt.questionDot) && this.isLookaheadToken_lt()) {\n        subscriptState.optionalChainMember = true;\n        if (noCalls) {\n          subscriptState.stop = true;\n          return base;\n        }\n        this.next();\n        const node = this.startNodeAt<N.OptionalCallExpression>(startLoc);\n        node.callee = base;\n        node.typeArguments = this.flowParseTypeParameterInstantiation();\n        this.expect(tt.parenL);\n        node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n        node.optional = true;\n        return this.finishCallExpression(node, /* optional */ true);\n      } else if (!noCalls && this.shouldParseTypes() && this.match(tt.lt)) {\n        const node = this.startNodeAt<\n          N.OptionalCallExpression | N.CallExpression\n        >(startLoc);\n        node.callee = base;\n\n        const result = this.tryParse(() => {\n          node.typeArguments =\n            this.flowParseTypeParameterInstantiationCallOrNew();\n          this.expect(tt.parenL);\n          node.arguments = super.parseCallExpressionArguments(tt.parenR, false);\n          if (subscriptState.optionalChainMember) {\n            (node as Undone<N.OptionalCallExpression>).optional = false;\n          }\n          return this.finishCallExpression(\n            node,\n            subscriptState.optionalChainMember,\n          );\n        });\n\n        if (result.node) {\n          if (result.error) this.state = result.failState;\n          return result.node;\n        }\n      }\n\n      return super.parseSubscript(\n        base,\n\n        startLoc,\n        noCalls,\n        subscriptState,\n      );\n    }\n\n    parseNewCallee(node: N.NewExpression): void {\n      super.parseNewCallee(node);\n\n      let targs = null;\n      if (this.shouldParseTypes() && this.match(tt.lt)) {\n        targs = this.tryParse(() =>\n          this.flowParseTypeParameterInstantiationCallOrNew(),\n        ).node;\n      }\n      node.typeArguments = targs;\n    }\n\n    parseAsyncArrowWithTypeParameters(\n      startLoc: Position,\n    ): N.ArrowFunctionExpression | undefined | null {\n      const node = this.startNodeAt<N.ArrowFunctionExpression>(startLoc);\n      this.parseFunctionParams(node, false);\n      if (!this.parseArrow(node)) return;\n      return super.parseArrowExpression(\n        node,\n        /* params */ undefined,\n        /* isAsync */ true,\n      );\n    }\n\n    readToken_mult_modulo(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (\n        code === charCodes.asterisk &&\n        next === charCodes.slash &&\n        this.state.hasFlowComment\n      ) {\n        this.state.hasFlowComment = false;\n        this.state.pos += 2;\n        this.nextToken();\n        return;\n      }\n\n      super.readToken_mult_modulo(code);\n    }\n\n    readToken_pipe_amp(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (\n        code === charCodes.verticalBar &&\n        next === charCodes.rightCurlyBrace\n      ) {\n        // '|}'\n        this.finishOp(tt.braceBarR, 2);\n        return;\n      }\n\n      super.readToken_pipe_amp(code);\n    }\n\n    parseTopLevel(file: N.File, program: N.Program): N.File {\n      const fileNode = super.parseTopLevel(file, program);\n      if (this.state.hasFlowComment) {\n        this.raise(FlowErrors.UnterminatedFlowComment, {\n          at: this.state.curPosition(),\n        });\n      }\n      return fileNode;\n    }\n\n    skipBlockComment(): N.CommentBlock | undefined {\n      if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n        if (this.state.hasFlowComment) {\n          throw this.raise(FlowErrors.NestedFlowComment, {\n            at: this.state.startLoc,\n          });\n        }\n        this.hasFlowCommentCompletion();\n        const commentSkip = this.skipFlowComment();\n        if (commentSkip) {\n          this.state.pos += commentSkip;\n          this.state.hasFlowComment = true;\n        }\n        return;\n      }\n\n      return super.skipBlockComment(this.state.hasFlowComment ? \"*-/\" : \"*/\");\n    }\n\n    skipFlowComment(): number | false {\n      const { pos } = this.state;\n      let shiftToFirstNonWhiteSpace = 2;\n      while (\n        [charCodes.space, charCodes.tab].includes(\n          // @ts-expect-error testing whether a number is included\n          this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace),\n        )\n      ) {\n        shiftToFirstNonWhiteSpace++;\n      }\n\n      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n      if (ch2 === charCodes.colon && ch3 === charCodes.colon) {\n        return shiftToFirstNonWhiteSpace + 2; // check for /*::\n      }\n      if (\n        this.input.slice(\n          shiftToFirstNonWhiteSpace + pos,\n          shiftToFirstNonWhiteSpace + pos + 12,\n        ) === \"flow-include\"\n      ) {\n        return shiftToFirstNonWhiteSpace + 12; // check for /*flow-include\n      }\n      if (ch2 === charCodes.colon && ch3 !== charCodes.colon) {\n        return shiftToFirstNonWhiteSpace; // check for /*:, advance up to :\n      }\n      return false;\n    }\n\n    hasFlowCommentCompletion(): void {\n      const end = this.input.indexOf(\"*/\", this.state.pos);\n      if (end === -1) {\n        throw this.raise(Errors.UnterminatedComment, {\n          at: this.state.curPosition(),\n        });\n      }\n    }\n\n    // Flow enum parsing\n\n    flowEnumErrorBooleanMemberNotInitialized(\n      loc: Position,\n      {\n        enumName,\n        memberName,\n      }: {\n        enumName: string;\n        memberName: string;\n      },\n    ): void {\n      this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {\n        at: loc,\n        memberName,\n        enumName,\n      });\n    }\n\n    flowEnumErrorInvalidMemberInitializer(\n      loc: Position,\n      enumContext: EnumContext,\n    ) {\n      return this.raise(\n        !enumContext.explicitType\n          ? FlowErrors.EnumInvalidMemberInitializerUnknownType\n          : enumContext.explicitType === \"symbol\"\n          ? FlowErrors.EnumInvalidMemberInitializerSymbolType\n          : FlowErrors.EnumInvalidMemberInitializerPrimaryType,\n        {\n          at: loc,\n          ...enumContext,\n        },\n      );\n    }\n\n    flowEnumErrorNumberMemberNotInitialized(\n      loc: Position,\n      {\n        enumName,\n        memberName,\n      }: {\n        enumName: string;\n        memberName: string;\n      },\n    ): void {\n      this.raise(FlowErrors.EnumNumberMemberNotInitialized, {\n        at: loc,\n        enumName,\n        memberName,\n      });\n    }\n\n    flowEnumErrorStringMemberInconsistentlyInitailized(\n      node: N.Node,\n      {\n        enumName,\n      }: {\n        enumName: string;\n      },\n    ): void {\n      this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {\n        at: node,\n        enumName,\n      });\n    }\n\n    flowEnumMemberInit(): EnumMemberInit {\n      const startLoc = this.state.startLoc;\n      const endOfInit = () => this.match(tt.comma) || this.match(tt.braceR);\n      switch (this.state.type) {\n        case tt.num: {\n          const literal = this.parseNumericLiteral(this.state.value);\n          if (endOfInit()) {\n            return { type: \"number\", loc: literal.loc.start, value: literal };\n          }\n          return { type: \"invalid\", loc: startLoc };\n        }\n        case tt.string: {\n          const literal = this.parseStringLiteral(this.state.value);\n          if (endOfInit()) {\n            return { type: \"string\", loc: literal.loc.start, value: literal };\n          }\n          return { type: \"invalid\", loc: startLoc };\n        }\n        case tt._true:\n        case tt._false: {\n          const literal = this.parseBooleanLiteral(this.match(tt._true));\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              loc: literal.loc.start,\n              value: literal,\n            };\n          }\n          return { type: \"invalid\", loc: startLoc };\n        }\n        default:\n          return { type: \"invalid\", loc: startLoc };\n      }\n    }\n\n    flowEnumMemberRaw(): {\n      id: N.Node;\n      init: EnumMemberInit;\n    } {\n      const loc = this.state.startLoc;\n      const id = this.parseIdentifier(true);\n      const init = this.eat(tt.eq)\n        ? this.flowEnumMemberInit()\n        : { type: \"none\" as const, loc };\n      return { id, init };\n    }\n\n    flowEnumCheckExplicitTypeMismatch(\n      loc: Position,\n      context: EnumContext,\n      expectedType: EnumExplicitType,\n    ): void {\n      const { explicitType } = context;\n      if (explicitType === null) {\n        return;\n      }\n      if (explicitType !== expectedType) {\n        this.flowEnumErrorInvalidMemberInitializer(loc, context);\n      }\n    }\n\n    flowEnumMembers({\n      enumName,\n      explicitType,\n    }: {\n      enumName: string;\n      explicitType: EnumExplicitType;\n    }): {\n      members: {\n        booleanMembers: Array<N.Node>;\n        numberMembers: Array<N.Node>;\n        stringMembers: Array<N.Node>;\n        defaultedMembers: Array<N.Node>;\n      };\n      hasUnknownMembers: boolean;\n    } {\n      const seenNames = new Set();\n      const members = {\n        // @ts-expect-error: migrate to Babel types\n        booleanMembers: [],\n        // @ts-expect-error: migrate to Babel types\n        numberMembers: [],\n        // @ts-expect-error: migrate to Babel types\n        stringMembers: [],\n        // @ts-expect-error: migrate to Babel types\n        defaultedMembers: [],\n      };\n      let hasUnknownMembers = false;\n      while (!this.match(tt.braceR)) {\n        if (this.eat(tt.ellipsis)) {\n          hasUnknownMembers = true;\n          break;\n        }\n        const memberNode = this.startNode();\n        const { id, init } = this.flowEnumMemberRaw();\n        const memberName = id.name;\n        if (memberName === \"\") {\n          continue;\n        }\n        if (/^[a-z]/.test(memberName)) {\n          this.raise(FlowErrors.EnumInvalidMemberName, {\n            at: id,\n            memberName,\n            suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n            enumName,\n          });\n        }\n        if (seenNames.has(memberName)) {\n          this.raise(FlowErrors.EnumDuplicateMemberName, {\n            at: id,\n            memberName,\n            enumName,\n          });\n        }\n        seenNames.add(memberName);\n        const context = { enumName, explicitType, memberName };\n        memberNode.id = id;\n        switch (init.type) {\n          case \"boolean\": {\n            this.flowEnumCheckExplicitTypeMismatch(\n              init.loc,\n              context,\n              \"boolean\",\n            );\n            memberNode.init = init.value;\n            members.booleanMembers.push(\n              this.finishNode(memberNode, \"EnumBooleanMember\"),\n            );\n            break;\n          }\n          case \"number\": {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(\n              this.finishNode(memberNode, \"EnumNumberMember\"),\n            );\n            break;\n          }\n          case \"string\": {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(\n              this.finishNode(memberNode, \"EnumStringMember\"),\n            );\n            break;\n          }\n          case \"invalid\": {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n          }\n          case \"none\": {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(\n                  init.loc,\n                  context,\n                );\n                break;\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n                break;\n              default:\n                members.defaultedMembers.push(\n                  this.finishNode(memberNode, \"EnumDefaultedMember\"),\n                );\n            }\n          }\n        }\n\n        if (!this.match(tt.braceR)) {\n          this.expect(tt.comma);\n        }\n      }\n      return { members, hasUnknownMembers };\n    }\n\n    flowEnumStringMembers(\n      initializedMembers: Array<N.Node>,\n      defaultedMembers: Array<N.Node>,\n      {\n        enumName,\n      }: {\n        enumName: string;\n      },\n    ): Array<N.Node> {\n      if (initializedMembers.length === 0) {\n        return defaultedMembers;\n      } else if (defaultedMembers.length === 0) {\n        return initializedMembers;\n      } else if (defaultedMembers.length > initializedMembers.length) {\n        for (const member of initializedMembers) {\n          this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {\n            enumName,\n          });\n        }\n        return defaultedMembers;\n      } else {\n        for (const member of defaultedMembers) {\n          this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {\n            enumName,\n          });\n        }\n        return initializedMembers;\n      }\n    }\n\n    flowEnumParseExplicitType({\n      enumName,\n    }: {\n      enumName: string;\n    }): EnumExplicitType {\n      if (!this.eatContextual(tt._of)) return null;\n\n      if (!tokenIsIdentifier(this.state.type)) {\n        throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {\n          at: this.state.startLoc,\n          enumName,\n        });\n      }\n\n      const { value } = this.state;\n      this.next();\n\n      if (\n        value !== \"boolean\" &&\n        value !== \"number\" &&\n        value !== \"string\" &&\n        value !== \"symbol\"\n      ) {\n        this.raise(FlowErrors.EnumInvalidExplicitType, {\n          at: this.state.startLoc,\n          enumName,\n          invalidEnumType: value,\n        });\n      }\n\n      return value;\n    }\n\n    flowEnumBody(node: Undone<N.Node>, id: N.Node): N.Node {\n      const enumName = id.name;\n      const nameLoc = id.loc.start;\n      const explicitType = this.flowEnumParseExplicitType({ enumName });\n      this.expect(tt.braceL);\n      const { members, hasUnknownMembers } = this.flowEnumMembers({\n        enumName,\n        explicitType,\n      });\n      node.hasUnknownMembers = hasUnknownMembers;\n\n      switch (explicitType) {\n        case \"boolean\":\n          node.explicitType = true;\n          node.members = members.booleanMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumBooleanBody\");\n        case \"number\":\n          node.explicitType = true;\n          node.members = members.numberMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumNumberBody\");\n        case \"string\":\n          node.explicitType = true;\n          node.members = this.flowEnumStringMembers(\n            members.stringMembers,\n            members.defaultedMembers,\n            { enumName },\n          );\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumStringBody\");\n        case \"symbol\":\n          node.members = members.defaultedMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumSymbolBody\");\n        default: {\n          // `explicitType` is `null`\n          const empty = () => {\n            node.members = [];\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n          node.explicitType = false;\n\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(\n              members.stringMembers,\n              members.defaultedMembers,\n              { enumName },\n            );\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name,\n              });\n            }\n            node.members = members.booleanMembers;\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name,\n              });\n            }\n            node.members = members.numberMembers;\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.raise(FlowErrors.EnumInconsistentMemberValues, {\n              at: nameLoc,\n              enumName,\n            });\n            return empty();\n          }\n        }\n      }\n    }\n\n    flowParseEnumDeclaration(node: Undone<N.Node>): N.Node {\n      const id = this.parseIdentifier();\n      node.id = id;\n      node.body = this.flowEnumBody(this.startNode(), id);\n      return this.finishNode(node, \"EnumDeclaration\");\n    }\n\n    // check if the next token is a tt.lt\n    isLookaheadToken_lt(): boolean {\n      const next = this.nextTokenStart();\n      if (this.input.charCodeAt(next) === charCodes.lessThan) {\n        const afterNext = this.input.charCodeAt(next + 1);\n        return (\n          afterNext !== charCodes.lessThan && afterNext !== charCodes.equalsTo\n        );\n      }\n      return false;\n    }\n\n    maybeUnwrapTypeCastExpression(node: N.Node) {\n      return node.type === \"TypeCastExpression\" ? node.expression : node;\n    }\n  };\n"],"mappings":";;;;;;AAGA,IAAAA,MAAA,GAAAC,OAAA;AAYA,IAAAC,QAAA,GAAAD,OAAA;AAEA,IAAAE,WAAA,GAAAF,OAAA;AACA,IAAAG,MAAA,GAAAH,OAAA;AACA,IAAAI,WAAA,GAAAJ,OAAA;AAYA,IAAAK,WAAA,GAAAL,OAAA;AACA,IAAAM,KAAA,GAAAN,OAAA;AAEA,MAAMO,aAAa,GAAG,IAAIC,GAAG,CAAC,CAC5B,GAAG,EACH,KAAK,EACL,MAAM,EACN,SAAS,EACT,OAAO,EACP,SAAS,EACT,OAAO,EACP,WAAW,EACX,OAAO,EACP,MAAM,EACN,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,MAAM,EACN,QAAQ,EACR,MAAM,CACP,CAAC;AAIF,MAAMC,UAAU,GAAG,IAAAC,0BAAc,CAAC,MAAK,CAAC;EACtCC,yBAAyB,EACvB,gFAAgF;EAClFC,0BAA0B,EACxB,wKAAwK;EAG1KC,kBAAkB,EAAEA,CAAC;IAAEC;EAAuC,CAAC,KAC5D,kCAAiCA,YAAa,GAAE;EACnDC,mBAAmB,EACjB,yDAAyD;EAC3DC,4BAA4B,EAC1B,qEAAqE;EACvEC,6BAA6B,EAC3B,+CAA+C;EACjDC,+BAA+B,EAAEA,CAAC;IAChCC,UAAU;IACVC;EAIF,CAAC,KACE,6DAA4DD,UAAW,mBAAkBA,UAAW,yBAAwBC,QAAS,KAAI;EAC5IC,uBAAuB,EAAEA,CAAC;IACxBF,UAAU;IACVC;EAIF,CAAC,KACE,uDAAsDD,UAAW,6CAA4CC,QAAS,KAAI;EAC7HE,4BAA4B,EAAEA,CAAC;IAAEF;EAA+B,CAAC,KAC9D,UAASA,QAAS,uKAAsK;EAC3LG,uBAAuB,EAAEA,CAAC;IACxBC,eAAe;IACfJ;EAIF,CAAC,KACE,eAAcI,eAAgB,4FAA2FJ,QAAS,KAAI;EACzIK,sCAAsC,EAAEA,CAAC;IACvCL;EAGF,CAAC,KACE,4GAA2GA,QAAS,KAAI;EAa3HM,uCAAuC,EAAEA,CAAC;IACxCN,QAAQ;IACRD,UAAU;IACVQ;EAKF,CAAC,KACE,UAASP,QAAS,iBAAgBO,YAAa,+BAA8BR,UAAW,oBAAmBQ,YAAa,WAAU;EACrIC,sCAAsC,EAAEA,CAAC;IACvCR,QAAQ;IACRD;EAKF,CAAC,KACE,oDAAmDA,UAAW,iBAAgBC,QAAS,KAAI;EAC9FS,uCAAuC,EAAEA,CAAC;IACxCT,QAAQ;IACRD;EAKF,CAAC,KACE,qCAAoCA,UAAW,4EAA2EC,QAAS,KAAI;EAC1IU,qBAAqB,EAAEA,CAAC;IACtBV,QAAQ;IACRD,UAAU;IACVY;EAKF,CAAC,KACE,qFAAoFZ,UAAW,wBAAuBY,UAAW,iBAAgBX,QAAS,KAAI;EACjKY,8BAA8B,EAAEA,CAAC;IAC/BZ,QAAQ;IACRD;EAIF,CAAC,KACE,sDAAqDA,UAAW,oBAAmBC,QAAS,KAAI;EACnGa,yCAAyC,EAAEA,CAAC;IAC1Cb;EAGF,CAAC,KACE,2GAA0GA,QAAS,KAAI;EAC1Hc,yBAAyB,EAAE,0CAA0C;EACrEC,6BAA6B,EAC3B,wEAAwE;EAC1EC,mCAAmC,EACjC,wKAAwK;EAC1KC,kBAAkB,EAChB,6EAA6E;EAC/EC,sBAAsB,EACpB,0EAA0E;EAC5EC,eAAe,EAAE,+CAA+C;EAChEC,mCAAmC,EACjC,yFAAyF;EAC3FC,uBAAuB,EACrB,yGAAyG;EAC3GC,mBAAmB,EACjB,kEAAkE;EACpEC,iBAAiB,EAAE,yDAAyD;EAC5EC,iBAAiB,EAAAC,MAAA,CAAAC,MAAA;IACfC,OAAO,EACL;EAAgF,GAG9E;IAAEC,UAAU,EAAE;EAAyB,CAAC,CAE7C;EACDC,yBAAyB,EAAE,0CAA0C;EACrEC,cAAc,EAAE,yCAAyC;EACzDC,2BAA2B,EACzB,yDAAyD;EAC3DC,4BAA4B,EAC1B,mGAAmG;EACrGC,yBAAyB,EAAE,0CAA0C;EACrEC,oBAAoB,EAClB,4DAA4D;EAC9DC,kBAAkB,EAAE,oDAAoD;EACxEC,qBAAqB,EACnB,mHAAmH;EACrHC,iBAAiB,EACf,sEAAsE;EACxEC,iCAAiC,EAC/B,sEAAsE;EACxEC,sBAAsB,EAAEA,CAAC;IAAE7C;EAAuC,CAAC,KAChE,4BAA2BA,YAAa,GAAE;EAC7C8C,4BAA4B,EAC1B,wDAAwD;EAC1DC,kCAAkC,EAChC,uDAAuD;EACzDC,oBAAoB,EAClB,kEAAkE;EACpEC,4BAA4B,EAC1B,kDAAkD;EACpDC,iCAAiC,EAC/B,mEAAmE;EACrEC,+CAA+C,EAC7C,mHAAmH;EACrHC,4BAA4B,EAAEA,CAAC;IAC7BC,qBAAqB;IACrBpC;EAIF,CAAC,KACE,oBAAmBoC,qBAAsB,8BAA6BpC,UAAW,aAAY;EAChGqC,mCAAmC,EACjC,mEAAmE;EACrEC,uBAAuB,EAAE;AAC3B,CAAC,CAAC;AAGF,SAASC,cAAcA,CAACC,WAAmB,EAAW;EACpD,OACEA,WAAW,CAACC,IAAI,KAAK,6BAA6B,IACjDD,WAAW,CAACC,IAAI,KAAK,0BAA0B,KAC7C,CAACD,WAAW,CAACE,WAAW,IACtBF,WAAW,CAACE,WAAW,CAACD,IAAI,KAAK,WAAW,IAC3CD,WAAW,CAACE,WAAW,CAACD,IAAI,KAAK,sBAAuB,CAAE;AAEpE;AAEA,SAASE,iBAAiBA,CAACC,IAAY,EAAW;EAChD,OAAOA,IAAI,CAACC,UAAU,KAAK,MAAM,IAAID,IAAI,CAACC,UAAU,KAAK,QAAQ;AACnE;AAEA,SAASC,oBAAoBA,CAACL,IAAe,EAAW;EACtD,OAAO,IAAAM,iCAA0B,EAACN,IAAI,CAAC,IAAIA,IAAI,OAAa;AAC9D;AAEA,MAAMO,iBAAiB,GAAG;EACxBC,KAAK,EAAE,oBAAoB;EAC3BC,GAAG,EAAE,oBAAoB;EACzBT,IAAI,EAAE,aAAa;EACnBU,SAAS,EAAE;AACb,CAAC;AAGD,SAASC,SAASA,CAChBC,IAAS,EACTC,IAA6D,EACjD;EACZ,MAAMC,KAAU,GAAG,EAAE;EACrB,MAAMC,KAAU,GAAG,EAAE;EACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,IAAI,CAACK,MAAM,EAAED,CAAC,EAAE,EAAE;IACpC,CAACH,IAAI,CAACD,IAAI,CAACI,CAAC,CAAC,EAAEA,CAAC,EAAEJ,IAAI,CAAC,GAAGE,KAAK,GAAGC,KAAK,EAAEG,IAAI,CAACN,IAAI,CAACI,CAAC,CAAC,CAAC;EACxD;EACA,OAAO,CAACF,KAAK,EAAEC,KAAK,CAAC;AACvB;AAEA,MAAMI,iBAAiB,GAAG,wBAAwB;AAAC,IAAAC,QAAA,GAoCnCC,UAAyB,IACvC,MAAMC,eAAe,SAASD,UAAU,CAAmB;EAAAE,YAAA,GAAAC,IAAA;IAAA,SAAAA,IAAA;IAAA,KAIzDC,UAAU,GAAoCC,SAAS;EAAA;EAEvDC,eAAeA,CAAA,EAEb;IACA,OAAOC,cAAgB;EACzB;EAEAC,gBAAgBA,CAAA,EAAY;IAC1B,OAAO,IAAI,CAACC,eAAe,CAAC,MAAM,EAAE,KAAK,CAAC,IAAI,IAAI,CAACL,UAAU,KAAK,MAAM;EAC1E;EAEAM,gBAAgBA,CAAA,EAAY;IAC1B,OAAO,CAAC,CAAC,IAAI,CAACD,eAAe,CAAC,MAAM,EAAE,OAAO,CAAC;EAChD;EAEAE,WAAWA,CAAChC,IAAe,EAAEiC,GAAQ,EAAQ;IAC3C,IACEjC,IAAI,QAAc,IAClBA,IAAI,OAAY,IAChBA,IAAI,OAA4B,EAChC;MACA,IAAI,IAAI,CAACyB,UAAU,KAAKC,SAAS,EAAE;QACjC,IAAI,CAACD,UAAU,GAAG,IAAI;MACxB;IACF;IACA,KAAK,CAACO,WAAW,CAAChC,IAAI,EAAEiC,GAAG,CAAC;EAC9B;EAEAC,UAAUA,CAACC,OAAkB,EAAQ;IACnC,IAAI,IAAI,CAACV,UAAU,KAAKC,SAAS,EAAE;MAEjC,MAAMU,OAAO,GAAGjB,iBAAiB,CAACkB,IAAI,CAACF,OAAO,CAACG,KAAK,CAAC;MACrD,IAAI,CAACF,OAAO,EAAE,CAEd,CAAC,MAAM,IAAIA,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;QAChC,IAAI,CAACX,UAAU,GAAG,MAAM;MAC1B,CAAC,MAAM,IAAIW,OAAO,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;QAClC,IAAI,CAACX,UAAU,GAAG,QAAQ;MAC5B,CAAC,MAAM;QACL,MAAM,IAAIc,KAAK,CAAC,wBAAwB,CAAC;MAC3C;IACF;IACA,KAAK,CAACL,UAAU,CAACC,OAAO,CAAC;EAC3B;EAEAK,wBAAwBA,CAACC,GAAe,EAAc;IACpD,MAAMC,SAAS,GAAG,IAAI,CAACC,KAAK,CAACC,MAAM;IACnC,IAAI,CAACD,KAAK,CAACC,MAAM,GAAG,IAAI;IACxB,IAAI,CAACC,MAAM,CAACJ,GAAG,MAAY,CAAC;IAE5B,MAAMzC,IAAI,GAAG,IAAI,CAAC8C,aAAa,EAAE;IACjC,IAAI,CAACH,KAAK,CAACC,MAAM,GAAGF,SAAS;IAC7B,OAAO1C,IAAI;EACb;EAEA+C,kBAAkBA,CAAA,EAAoB;IACpC,MAAM5C,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAE;IAC7B,MAAMC,SAAS,GAAG,IAAI,CAACN,KAAK,CAACO,QAAQ;IACrC,IAAI,CAACC,IAAI,EAAE;IACX,IAAI,CAACC,gBAAgB,KAAY;IAEjC,IAAI,IAAI,CAACT,KAAK,CAACU,YAAY,GAAGJ,SAAS,CAACK,KAAK,GAAG,CAAC,EAAE;MACjD,IAAI,CAACC,KAAK,CAACtH,UAAU,CAACoD,kCAAkC,EAAE;QACxDmE,EAAE,EAAEP;MACN,CAAC,CAAC;IACJ;IACA,IAAI,IAAI,CAACQ,GAAG,IAAW,EAAE;MACvBtD,IAAI,CAACmC,KAAK,GAAG,KAAK,CAACoB,eAAe,EAAE;MACpC,IAAI,CAACb,MAAM,IAAW;MACtB,OAAO,IAAI,CAACc,UAAU,CAACxD,IAAI,EAAE,mBAAmB,CAAC;IACnD,CAAC,MAAM;MACL,OAAO,IAAI,CAACwD,UAAU,CAACxD,IAAI,EAAE,mBAAmB,CAAC;IACnD;EACF;EAEAyD,oCAAoCA,CAAA,EAGlC;IACA,MAAMlB,SAAS,GAAG,IAAI,CAACC,KAAK,CAACC,MAAM;IACnC,IAAI,CAACD,KAAK,CAACC,MAAM,GAAG,IAAI;IACxB,IAAI,CAACC,MAAM,IAAU;IACrB,IAAI7C,IAAI,GAAG,IAAI;IACf,IAAI6D,SAAS,GAAG,IAAI;IACpB,IAAI,IAAI,CAACC,KAAK,IAAW,EAAE;MACzB,IAAI,CAACnB,KAAK,CAACC,MAAM,GAAGF,SAAS;MAC7BmB,SAAS,GAAG,IAAI,CAACd,kBAAkB,EAAE;IACvC,CAAC,MAAM;MACL/C,IAAI,GAAG,IAAI,CAAC8C,aAAa,EAAE;MAC3B,IAAI,CAACH,KAAK,CAACC,MAAM,GAAGF,SAAS;MAC7B,IAAI,IAAI,CAACoB,KAAK,IAAW,EAAE;QACzBD,SAAS,GAAG,IAAI,CAACd,kBAAkB,EAAE;MACvC;IACF;IACA,OAAO,CAAC/C,IAAI,EAAE6D,SAAS,CAAC;EAC1B;EAEAE,qBAAqBA,CACnB5D,IAAgC,EACZ;IACpB,IAAI,CAACgD,IAAI,EAAE;IACX,IAAI,CAACa,qBAAqB,CAAC7D,IAAI,EAAc,IAAI,CAAC;IAClD,OAAO,IAAI,CAACwD,UAAU,CAACxD,IAAI,EAAE,cAAc,CAAC;EAC9C;EAEA8D,wBAAwBA,CACtB9D,IAAmC,EACZ;IACvB,IAAI,CAACgD,IAAI,EAAE;IAEX,MAAMe,EAAE,GAAI/D,IAAI,CAAC+D,EAAE,GAAG,IAAI,CAACC,eAAe,EAAG;IAE7C,MAAMC,QAAQ,GAAG,IAAI,CAACpB,SAAS,EAAE;IACjC,MAAMqB,aAAa,GAAG,IAAI,CAACrB,SAAS,EAAoB;IAExD,IAAI,IAAI,CAACc,KAAK,IAAO,EAAE;MACrBM,QAAQ,CAACE,cAAc,GAAG,IAAI,CAACC,iCAAiC,EAAE;IACpE,CAAC,MAAM;MACLH,QAAQ,CAACE,cAAc,GAAG,IAAI;IAChC;IAEA,IAAI,CAACzB,MAAM,IAAW;IACtB,MAAM2B,GAAG,GAAG,IAAI,CAACC,2BAA2B,EAAE;IAC9CL,QAAQ,CAACM,MAAM,GAAGF,GAAG,CAACE,MAAM;IAC5BN,QAAQ,CAACO,IAAI,GAAGH,GAAG,CAACG,IAAI;IACxBP,QAAQ,CAACQ,IAAI,GAAGJ,GAAG,CAACK,KAAK;IACzB,IAAI,CAAChC,MAAM,IAAW;IAEtB,CAACuB,QAAQ,CAACU,UAAU,EAAE3E,IAAI,CAAC0D,SAAS,CAAC,GACnC,IAAI,CAACD,oCAAoC,EAAE;IAE7CS,aAAa,CAACU,cAAc,GAAG,IAAI,CAACpB,UAAU,CAC5CS,QAAQ,EACR,wBAAwB,CACzB;IAEDF,EAAE,CAACa,cAAc,GAAG,IAAI,CAACpB,UAAU,CAACU,aAAa,EAAE,gBAAgB,CAAC;IAEpE,IAAI,CAACW,gBAAgB,CAACd,EAAE,CAAC;IACzB,IAAI,CAACe,SAAS,EAAE;IAEhB,IAAI,CAACC,KAAK,CAACC,WAAW,CACpBhF,IAAI,CAAC+D,EAAE,CAACkB,IAAI,EACZC,gCAAoB,EACpBlF,IAAI,CAAC+D,EAAE,CAACoB,GAAG,CAACC,KAAK,CAClB;IAED,OAAO,IAAI,CAAC5B,UAAU,CAACxD,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAEAqF,gBAAgBA,CACdrF,IAA2B,EAC3BsF,YAAsB,EACP;IACf,IAAI,IAAI,CAAC3B,KAAK,IAAW,EAAE;MACzB,OAAO,IAAI,CAACC,qBAAqB,CAAC5D,IAAI,CAAC;IACzC,CAAC,MAAM,IAAI,IAAI,CAAC2D,KAAK,IAAc,EAAE;MACnC,OAAO,IAAI,CAACG,wBAAwB,CAAC9D,IAAI,CAAC;IAC5C,CAAC,MAAM,IAAI,IAAI,CAAC2D,KAAK,IAAS,EAAE;MAC9B,OAAO,IAAI,CAAC4B,wBAAwB,CAACvF,IAAI,CAAC;IAC5C,CAAC,MAAM,IAAI,IAAI,CAACwF,aAAa,KAAY,EAAE;MACzC,IAAI,IAAI,CAAC7B,KAAK,IAAQ,EAAE;QACtB,OAAO,IAAI,CAAC8B,6BAA6B,CAACzF,IAAI,CAAC;MACjD,CAAC,MAAM;QACL,IAAIsF,YAAY,EAAE;UAChB,IAAI,CAAClC,KAAK,CAACtH,UAAU,CAACiC,mBAAmB,EAAE;YACzCsF,EAAE,EAAE,IAAI,CAACb,KAAK,CAACkD;UACjB,CAAC,CAAC;QACJ;QACA,OAAO,IAAI,CAACC,sBAAsB,CAAC3F,IAAI,CAAC;MAC1C;IACF,CAAC,MAAM,IAAI,IAAI,CAAC4F,YAAY,KAAU,EAAE;MACtC,OAAO,IAAI,CAACC,yBAAyB,CAAC7F,IAAI,CAAC;IAC7C,CAAC,MAAM,IAAI,IAAI,CAAC4F,YAAY,KAAY,EAAE;MACxC,OAAO,IAAI,CAACE,0BAA0B,CAAC9F,IAAI,CAAC;IAC9C,CAAC,MAAM,IAAI,IAAI,CAAC4F,YAAY,KAAe,EAAE;MAC3C,OAAO,IAAI,CAACG,yBAAyB,CAAC/F,IAAI,CAAC;IAC7C,CAAC,MAAM,IAAI,IAAI,CAAC2D,KAAK,IAAY,EAAE;MACjC,OAAO,IAAI,CAACqC,iCAAiC,CAAChG,IAAI,EAAEsF,YAAY,CAAC;IACnE,CAAC,MAAM;MACL,IAAI,CAACW,UAAU,EAAE;IACnB;EACF;EAEAV,wBAAwBA,CACtBvF,IAAmC,EACZ;IACvB,IAAI,CAACgD,IAAI,EAAE;IACXhD,IAAI,CAAC+D,EAAE,GAAG,IAAI,CAACmC,kCAAkC,CACpB,IAAI,CAChC;IACD,IAAI,CAACnB,KAAK,CAACC,WAAW,CAAChF,IAAI,CAAC+D,EAAE,CAACkB,IAAI,EAAEkB,oBAAQ,EAAEnG,IAAI,CAAC+D,EAAE,CAACoB,GAAG,CAACC,KAAK,CAAC;IACjE,IAAI,CAACN,SAAS,EAAE;IAChB,OAAO,IAAI,CAACtB,UAAU,CAACxD,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAEA2F,sBAAsBA,CACpB3F,IAAiC,EACZ;IACrB,IAAI,CAAC+E,KAAK,CAACqB,KAAK,CAACC,uBAAW,CAAC;IAE7B,IAAI,IAAI,CAAC1C,KAAK,KAAW,EAAE;MACzB3D,IAAI,CAAC+D,EAAE,GAAG,KAAK,CAACuC,aAAa,EAAE;IACjC,CAAC,MAAM;MACLtG,IAAI,CAAC+D,EAAE,GAAG,IAAI,CAACC,eAAe,EAAE;IAClC;IAEA,MAAMuC,QAAQ,GAAIvG,IAAI,CAACwG,IAAI,GAAG,IAAI,CAAC3D,SAAS,EAAG;IAE/C,MAAM2D,IAAI,GAAID,QAAQ,CAACC,IAAI,GAAG,EAAG;IACjC,IAAI,CAAC9D,MAAM,GAAW;IACtB,OAAO,CAAC,IAAI,CAACiB,KAAK,GAAW,EAAE;MAC7B,IAAI4C,QAAQ,GAAG,IAAI,CAAC1D,SAAS,EAAuB;MAEpD,IAAI,IAAI,CAACc,KAAK,IAAY,EAAE;QAC1B,IAAI,CAACX,IAAI,EAAE;QACX,IAAI,CAAC,IAAI,CAAC4C,YAAY,KAAU,IAAI,CAAC,IAAI,CAACjC,KAAK,IAAY,EAAE;UAC3D,IAAI,CAACP,KAAK,CAACtH,UAAU,CAAC+B,mCAAmC,EAAE;YACzDwF,EAAE,EAAE,IAAI,CAACb,KAAK,CAACkD;UACjB,CAAC,CAAC;QACJ;QACA,KAAK,CAACe,WAAW,CAACF,QAAQ,CAAC;MAC7B,CAAC,MAAM;QACL,IAAI,CAACtD,gBAAgB,MAEnBnH,UAAU,CAAC2D,mCAAmC,CAC/C;QAED8G,QAAQ,GAAG,IAAI,CAAClB,gBAAgB,CAACkB,QAAQ,EAAE,IAAI,CAAC;MAClD;MAEAC,IAAI,CAACzF,IAAI,CAACwF,QAAQ,CAAC;IACrB;IAEA,IAAI,CAACxB,KAAK,CAAC2B,IAAI,EAAE;IAEjB,IAAI,CAAChE,MAAM,GAAW;IAEtB,IAAI,CAACc,UAAU,CAAC+C,QAAQ,EAAE,gBAAgB,CAAC;IAE3C,IAAII,IAA8B,GAAG,IAAI;IACzC,IAAIC,eAAe,GAAG,KAAK;IAC3BJ,IAAI,CAACK,OAAO,CAACjH,WAAW,IAAI;MAC1B,IAAID,cAAc,CAACC,WAAW,CAAC,EAAE;QAC/B,IAAI+G,IAAI,KAAK,UAAU,EAAE;UACvB,IAAI,CAACvD,KAAK,CAACtH,UAAU,CAACG,0BAA0B,EAAE;YAChDoH,EAAE,EAAEzD;UACN,CAAC,CAAC;QACJ;QACA+G,IAAI,GAAG,IAAI;MACb,CAAC,MAAM,IAAI/G,WAAW,CAACC,IAAI,KAAK,sBAAsB,EAAE;QACtD,IAAI+G,eAAe,EAAE;UACnB,IAAI,CAACxD,KAAK,CAACtH,UAAU,CAACQ,6BAA6B,EAAE;YACnD+G,EAAE,EAAEzD;UACN,CAAC,CAAC;QACJ;QACA,IAAI+G,IAAI,KAAK,IAAI,EAAE;UACjB,IAAI,CAACvD,KAAK,CAACtH,UAAU,CAACG,0BAA0B,EAAE;YAChDoH,EAAE,EAAEzD;UACN,CAAC,CAAC;QACJ;QACA+G,IAAI,GAAG,UAAU;QACjBC,eAAe,GAAG,IAAI;MACxB;IACF,CAAC,CAAC;IAEF5G,IAAI,CAAC2G,IAAI,GAAGA,IAAI,IAAI,UAAU;IAC9B,OAAO,IAAI,CAACnD,UAAU,CAACxD,IAAI,EAAE,eAAe,CAAC;EAC/C;EAEAgG,iCAAiCA,CAC/BhG,IAA4C,EAC5CsF,YAA6B,EACG;IAChC,IAAI,CAAC5C,MAAM,IAAY;IAEvB,IAAI,IAAI,CAACY,GAAG,IAAa,EAAE;MACzB,IAAI,IAAI,CAACK,KAAK,IAAc,IAAI,IAAI,CAACA,KAAK,IAAW,EAAE;QAGrD3D,IAAI,CAACF,WAAW,GAAG,IAAI,CAACuF,gBAAgB,CAAC,IAAI,CAACxC,SAAS,EAAE,CAAC;MAC5D,CAAC,MAAM;QAEL7C,IAAI,CAACF,WAAW,GAAG,IAAI,CAAC6C,aAAa,EAAE;QACvC,IAAI,CAACmC,SAAS,EAAE;MAClB;MACA9E,IAAI,CAAC8G,OAAO,GAAG,IAAI;MAEnB,OAAO,IAAI,CAACtD,UAAU,CAACxD,IAAI,EAAE,0BAA0B,CAAC;IAC1D,CAAC,MAAM;MACL,IACE,IAAI,CAAC2D,KAAK,IAAW,IACrB,IAAI,CAACoD,KAAK,EAAE,IACX,CAAC,IAAI,CAACnB,YAAY,KAAU,IAAI,IAAI,CAACA,YAAY,KAAe,KAC/D,CAACN,YAAa,EAChB;QACA,MAAM0B,KAAK,GAAG,IAAI,CAACxE,KAAK,CAACL,KAIV;QACf,MAAM,IAAI,CAACiB,KAAK,CAACtH,UAAU,CAACyD,4BAA4B,EAAE;UACxD8D,EAAE,EAAE,IAAI,CAACb,KAAK,CAACO,QAAQ;UACvBvD,qBAAqB,EAAEwH,KAAK;UAC5B5J,UAAU,EAAEgD,iBAAiB,CAAC4G,KAAK;QACrC,CAAC,CAAC;MACJ;MAEA,IACE,IAAI,CAACrD,KAAK,IAAS,IACnB,IAAI,CAACA,KAAK,IAAc,IACxB,IAAI,CAACA,KAAK,IAAW,IACrB,IAAI,CAACiC,YAAY,KAAY,EAC7B;QACA5F,IAAI,CAACF,WAAW,GAAG,IAAI,CAACuF,gBAAgB,CAAC,IAAI,CAACxC,SAAS,EAAE,CAAC;QAC1D7C,IAAI,CAAC8G,OAAO,GAAG,KAAK;QAEpB,OAAO,IAAI,CAACtD,UAAU,CAACxD,IAAI,EAAE,0BAA0B,CAAC;MAC1D,CAAC,MAAM,IACL,IAAI,CAAC2D,KAAK,IAAS,IACnB,IAAI,CAACA,KAAK,GAAW,IACrB,IAAI,CAACiC,YAAY,KAAe,IAChC,IAAI,CAACA,YAAY,KAAU,IAC3B,IAAI,CAACA,YAAY,KAAY,EAC7B;QACA5F,IAAI,GAAG,IAAI,CAACiH,WAAW,CACrBjH,IAAI,EACa,IAAI,CACtB;QACD,IAAIA,IAAI,CAACH,IAAI,KAAK,wBAAwB,EAAE;UAC1CG,IAAI,CAACH,IAAI,GAAG,mBAAmB;UAC/BG,IAAI,CAAC8G,OAAO,GAAG,KAAK;UACpB,OAAO9G,IAAI,CAACkH,UAAU;QACxB;QAEAlH,IAAI,CAACH,IAAI,GAAG,SAAS,GAAGG,IAAI,CAACH,IAAI;QAEjC,OAAOG,IAAI;MACb;IACF;IAEA,IAAI,CAACiG,UAAU,EAAE;EACnB;EAEAR,6BAA6BA,CAC3BzF,IAAwC,EACZ;IAC5B,IAAI,CAACgD,IAAI,EAAE;IACX,IAAI,CAACC,gBAAgB,KAAa;IAClCjD,IAAI,CAAC4E,cAAc,GAAG,IAAI,CAACuC,uBAAuB,EAAE;IACpD,IAAI,CAACrC,SAAS,EAAE;IAEhB,OAAO,IAAI,CAACtB,UAAU,CAACxD,IAAI,EAAE,sBAAsB,CAAC;EACtD;EAEA6F,yBAAyBA,CACvB7F,IAAoC,EACZ;IACxB,IAAI,CAACgD,IAAI,EAAE;IACX,MAAMoE,QAAQ,GAAG,IAAI,CAACC,kBAAkB,CAACrH,IAAI,CAAC;IAE9CoH,QAAQ,CAACvH,IAAI,GAAG,kBAAkB;IAClC,OAAOuH,QAAQ;EACjB;EAEAtB,0BAA0BA,CACxB9F,IAAqC,EACZ;IACzB,IAAI,CAACgD,IAAI,EAAE;IACX,MAAMoE,QAAQ,GAAG,IAAI,CAACE,mBAAmB,CAACtH,IAAI,EAAE,IAAI,CAAC;IAErDoH,QAAQ,CAACvH,IAAI,GAAG,mBAAmB;IACnC,OAAOuH,QAAQ;EACjB;EAEArB,yBAAyBA,CACvB/F,IAAoC,EACZ;IACxB,IAAI,CAACgD,IAAI,EAAE;IACX,IAAI,CAACa,qBAAqB,CAAC7D,IAAI,EAAgB,KAAK,CAAC;IACrD,OAAO,IAAI,CAACwD,UAAU,CAACxD,IAAI,EAAE,kBAAkB,CAAC;EAClD;EAIA6D,qBAAqBA,CAAC7D,IAA2B,EAAEuH,OAAgB,EAAQ;IACzEvH,IAAI,CAAC+D,EAAE,GAAG,IAAI,CAACyD,6BAA6B,CAC5B,CAACD,OAAO,EACJ,IAAI,CACvB;IAED,IAAI,CAACxC,KAAK,CAACC,WAAW,CACpBhF,IAAI,CAAC+D,EAAE,CAACkB,IAAI,EACZsC,OAAO,GAAGE,yBAAa,GAAGC,wBAAY,EACtC1H,IAAI,CAAC+D,EAAE,CAACoB,GAAG,CAACC,KAAK,CAClB;IAED,IAAI,IAAI,CAACzB,KAAK,IAAO,EAAE;MACrB3D,IAAI,CAACmE,cAAc,GAAG,IAAI,CAACC,iCAAiC,EAAE;IAChE,CAAC,MAAM;MACLpE,IAAI,CAACmE,cAAc,GAAG,IAAI;IAC5B;IAEAnE,IAAI,CAAC2H,OAAO,GAAG,EAAE;IAEjB,IAAI,IAAI,CAACrE,GAAG,IAAa,EAAE;MACzB,GAAG;QACDtD,IAAI,CAAC2H,OAAO,CAAC5G,IAAI,CAAC,IAAI,CAAC6G,yBAAyB,EAAE,CAAC;MACrD,CAAC,QAAQ,CAACL,OAAO,IAAI,IAAI,CAACjE,GAAG,IAAU;IACzC;IAEA,IAAIiE,OAAO,EAAE;MACXvH,IAAI,CAAC6H,UAAU,GAAG,EAAE;MACpB7H,IAAI,CAAC8H,MAAM,GAAG,EAAE;MAEhB,IAAI,IAAI,CAACtC,aAAa,KAAY,EAAE;QAClC,GAAG;UACDxF,IAAI,CAAC8H,MAAM,CAAC/G,IAAI,CAAC,IAAI,CAAC6G,yBAAyB,EAAE,CAAC;QACpD,CAAC,QAAQ,IAAI,CAACtE,GAAG,IAAU;MAC7B;MAEA,IAAI,IAAI,CAACkC,aAAa,KAAgB,EAAE;QACtC,GAAG;UACDxF,IAAI,CAAC6H,UAAU,CAAC9G,IAAI,CAAC,IAAI,CAAC6G,yBAAyB,EAAE,CAAC;QACxD,CAAC,QAAQ,IAAI,CAACtE,GAAG,IAAU;MAC7B;IACF;IAEAtD,IAAI,CAACwG,IAAI,GAAG,IAAI,CAACuB,mBAAmB,CAAC;MACnCC,WAAW,EAAET,OAAO;MACpBU,UAAU,EAAE,KAAK;MACjBC,WAAW,EAAE,KAAK;MAClBC,UAAU,EAAEZ,OAAO;MACnBa,YAAY,EAAE;IAChB,CAAC,CAAC;EACJ;EAEAR,yBAAyBA,CAAA,EAA2B;IAClD,MAAM5H,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAE;IAE7B7C,IAAI,CAAC+D,EAAE,GAAG,IAAI,CAACsE,gCAAgC,EAAE;IACjD,IAAI,IAAI,CAAC1E,KAAK,IAAO,EAAE;MACrB3D,IAAI,CAACmE,cAAc,GAAG,IAAI,CAACmE,mCAAmC,EAAE;IAClE,CAAC,MAAM;MACLtI,IAAI,CAACmE,cAAc,GAAG,IAAI;IAC5B;IAEA,OAAO,IAAI,CAACX,UAAU,CAACxD,IAAI,EAAE,kBAAkB,CAAC;EAClD;EAEAuI,kBAAkBA,CAACvI,IAA6B,EAAmB;IACjE,IAAI,CAAC6D,qBAAqB,CAAC7D,IAAI,EAAgB,KAAK,CAAC;IACrD,OAAO,IAAI,CAACwD,UAAU,CAACxD,IAAI,EAAE,sBAAsB,CAAC;EACtD;EAEAwI,kBAAkBA,CAACC,IAAY,EAAE;IAC/B,IAAIA,IAAI,KAAK,GAAG,EAAE;MAChB,IAAI,CAACrF,KAAK,CAACtH,UAAU,CAACmD,4BAA4B,EAAE;QAClDoE,EAAE,EAAE,IAAI,CAACb,KAAK,CAACO;MACjB,CAAC,CAAC;IACJ;EACF;EAEA2F,iBAAiBA,CAACD,IAAY,EAAE1F,QAAkB,EAAEjD,WAAqB,EAAE;IACzE,IAAI,CAAClE,aAAa,CAAC+M,GAAG,CAACF,IAAI,CAAC,EAAE;IAE9B,IAAI,CAACrF,KAAK,CACRtD,WAAW,GACPhE,UAAU,CAACI,kBAAkB,GAC7BJ,UAAU,CAACkD,sBAAsB,EACrC;MACEqE,EAAE,EAAEN,QAAQ;MACZ5G,YAAY,EAAEsM;IAChB,CAAC,CACF;EACH;EAEAjB,6BAA6BA,CAC3BoB,OAAiB,EACjB9I,WAAqB,EACP;IACd,IAAI,CAAC4I,iBAAiB,CACpB,IAAI,CAAClG,KAAK,CAACL,KAAK,EAChB,IAAI,CAACK,KAAK,CAACO,QAAQ,EACnBjD,WAAW,CACZ;IACD,OAAO,IAAI,CAACkE,eAAe,CAAC4E,OAAO,CAAC;EACtC;EAIAvB,kBAAkBA,CAACrH,IAA6B,EAAmB;IACjEA,IAAI,CAAC+D,EAAE,GAAG,IAAI,CAACyD,6BAA6B,CAC5B,KAAK,EACD,IAAI,CACvB;IACD,IAAI,CAACzC,KAAK,CAACC,WAAW,CAAChF,IAAI,CAAC+D,EAAE,CAACkB,IAAI,EAAEyC,wBAAY,EAAE1H,IAAI,CAAC+D,EAAE,CAACoB,GAAG,CAACC,KAAK,CAAC;IAErE,IAAI,IAAI,CAACzB,KAAK,IAAO,EAAE;MACrB3D,IAAI,CAACmE,cAAc,GAAG,IAAI,CAACC,iCAAiC,EAAE;IAChE,CAAC,MAAM;MACLpE,IAAI,CAACmE,cAAc,GAAG,IAAI;IAC5B;IAEAnE,IAAI,CAAC6I,KAAK,GAAG,IAAI,CAACxG,wBAAwB,IAAO;IACjD,IAAI,CAACyC,SAAS,EAAE;IAEhB,OAAO,IAAI,CAACtB,UAAU,CAACxD,IAAI,EAAE,WAAW,CAAC;EAC3C;EAEAsH,mBAAmBA,CACjBtH,IAA8B,EAC9B8I,OAAgB,EACE;IAClB,IAAI,CAAC7F,gBAAgB,KAAU;IAC/BjD,IAAI,CAAC+D,EAAE,GAAG,IAAI,CAACyD,6BAA6B,CAC5B,IAAI,EACA,IAAI,CACvB;IACD,IAAI,CAACzC,KAAK,CAACC,WAAW,CAAChF,IAAI,CAAC+D,EAAE,CAACkB,IAAI,EAAEyC,wBAAY,EAAE1H,IAAI,CAAC+D,EAAE,CAACoB,GAAG,CAACC,KAAK,CAAC;IAErE,IAAI,IAAI,CAACzB,KAAK,IAAO,EAAE;MACrB3D,IAAI,CAACmE,cAAc,GAAG,IAAI,CAACC,iCAAiC,EAAE;IAChE,CAAC,MAAM;MACLpE,IAAI,CAACmE,cAAc,GAAG,IAAI;IAC5B;IAGAnE,IAAI,CAAC+I,SAAS,GAAG,IAAI;IACrB,IAAI,IAAI,CAACpF,KAAK,IAAU,EAAE;MACxB3D,IAAI,CAAC+I,SAAS,GAAG,IAAI,CAAC1G,wBAAwB,IAAU;IAC1D;IAEArC,IAAI,CAACgJ,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACF,OAAO,EAAE;MACZ9I,IAAI,CAACgJ,QAAQ,GAAG,IAAI,CAAC3G,wBAAwB,IAAO;IACtD;IACA,IAAI,CAACyC,SAAS,EAAE;IAEhB,OAAO,IAAI,CAACtB,UAAU,CAACxD,IAAI,EAAE,YAAY,CAAC;EAC5C;EAIAiJ,sBAAsBA,CAACC,cAAuB,GAAG,KAAK,EAAmB;IACvE,MAAMC,YAAY,GAAG,IAAI,CAAC3G,KAAK,CAACO,QAAQ;IAExC,MAAM/C,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAmB;IAE9C,MAAMuG,QAAQ,GAAG,IAAI,CAACC,iBAAiB,EAAE;IAEzC,MAAMC,KAAK,GAAG,IAAI,CAACpD,kCAAkC,EAAE;IACvDlG,IAAI,CAACiF,IAAI,GAAGqE,KAAK,CAACrE,IAAI;IAEtBjF,IAAI,CAACoJ,QAAQ,GAAGA,QAAQ;IAExBpJ,IAAI,CAACuJ,KAAK,GAAGD,KAAK,CAAC1E,cAAc;IAEjC,IAAI,IAAI,CAACjB,KAAK,IAAO,EAAE;MACrB,IAAI,CAACL,GAAG,IAAO;MAEftD,IAAI,CAAC8G,OAAO,GAAG,IAAI,CAACnE,aAAa,EAAE;IACrC,CAAC,MAAM;MACL,IAAIuG,cAAc,EAAE;QAClB,IAAI,CAAC9F,KAAK,CAACtH,UAAU,CAACgC,uBAAuB,EAAE;UAAEuF,EAAE,EAAE8F;QAAa,CAAC,CAAC;MACtE;IACF;IAEA,OAAO,IAAI,CAAC3F,UAAU,CAACxD,IAAI,EAAE,eAAe,CAAC;EAC/C;EAEAoE,iCAAiCA,CAAA,EAA+B;IAC9D,MAAM7B,SAAS,GAAG,IAAI,CAACC,KAAK,CAACC,MAAM;IACnC,MAAMzC,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAA8B;IACzD7C,IAAI,CAACuE,MAAM,GAAG,EAAE;IAEhB,IAAI,CAAC/B,KAAK,CAACC,MAAM,GAAG,IAAI;IAGxB,IAAI,IAAI,CAACkB,KAAK,IAAO,IAAI,IAAI,CAACA,KAAK,KAAgB,EAAE;MACnD,IAAI,CAACX,IAAI,EAAE;IACb,CAAC,MAAM;MACL,IAAI,CAACiD,UAAU,EAAE;IACnB;IAEA,IAAIuD,eAAe,GAAG,KAAK;IAE3B,GAAG;MACD,MAAMC,aAAa,GAAG,IAAI,CAACR,sBAAsB,CAACO,eAAe,CAAC;MAElExJ,IAAI,CAACuE,MAAM,CAACxD,IAAI,CAAC0I,aAAa,CAAC;MAE/B,IAAIA,aAAa,CAAC3C,OAAO,EAAE;QACzB0C,eAAe,GAAG,IAAI;MACxB;MAEA,IAAI,CAAC,IAAI,CAAC7F,KAAK,IAAO,EAAE;QACtB,IAAI,CAACjB,MAAM,IAAU;MACvB;IACF,CAAC,QAAQ,CAAC,IAAI,CAACiB,KAAK,IAAO;IAC3B,IAAI,CAACjB,MAAM,IAAO;IAElB,IAAI,CAACF,KAAK,CAACC,MAAM,GAAGF,SAAS;IAE7B,OAAO,IAAI,CAACiB,UAAU,CAACxD,IAAI,EAAE,0BAA0B,CAAC;EAC1D;EAEAsI,mCAAmCA,CAAA,EAAiC;IAClE,MAAMtI,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAgC;IAC3D,MAAMN,SAAS,GAAG,IAAI,CAACC,KAAK,CAACC,MAAM;IACnCzC,IAAI,CAACuE,MAAM,GAAG,EAAE;IAEhB,IAAI,CAAC/B,KAAK,CAACC,MAAM,GAAG,IAAI;IAExB,IAAI,CAACC,MAAM,IAAO;IAClB,MAAMgH,qBAAqB,GAAG,IAAI,CAAClH,KAAK,CAACmH,kBAAkB;IAC3D,IAAI,CAACnH,KAAK,CAACmH,kBAAkB,GAAG,KAAK;IACrC,OAAO,CAAC,IAAI,CAAChG,KAAK,IAAO,EAAE;MACzB3D,IAAI,CAACuE,MAAM,CAACxD,IAAI,CAAC,IAAI,CAAC4B,aAAa,EAAE,CAAC;MACtC,IAAI,CAAC,IAAI,CAACgB,KAAK,IAAO,EAAE;QACtB,IAAI,CAACjB,MAAM,IAAU;MACvB;IACF;IACA,IAAI,CAACF,KAAK,CAACmH,kBAAkB,GAAGD,qBAAqB;IACrD,IAAI,CAAChH,MAAM,IAAO;IAElB,IAAI,CAACF,KAAK,CAACC,MAAM,GAAGF,SAAS;IAE7B,OAAO,IAAI,CAACiB,UAAU,CAACxD,IAAI,EAAE,4BAA4B,CAAC;EAC5D;EAEA4J,4CAA4CA,CAAA,EAAiC;IAC3E,MAAM5J,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAgC;IAC3D,MAAMN,SAAS,GAAG,IAAI,CAACC,KAAK,CAACC,MAAM;IACnCzC,IAAI,CAACuE,MAAM,GAAG,EAAE;IAEhB,IAAI,CAAC/B,KAAK,CAACC,MAAM,GAAG,IAAI;IAExB,IAAI,CAACC,MAAM,IAAO;IAClB,OAAO,CAAC,IAAI,CAACiB,KAAK,IAAO,EAAE;MACzB3D,IAAI,CAACuE,MAAM,CAACxD,IAAI,CAAC,IAAI,CAAC8I,oCAAoC,EAAE,CAAC;MAC7D,IAAI,CAAC,IAAI,CAAClG,KAAK,IAAO,EAAE;QACtB,IAAI,CAACjB,MAAM,IAAU;MACvB;IACF;IACA,IAAI,CAACA,MAAM,IAAO;IAElB,IAAI,CAACF,KAAK,CAACC,MAAM,GAAGF,SAAS;IAE7B,OAAO,IAAI,CAACiB,UAAU,CAACxD,IAAI,EAAE,4BAA4B,CAAC;EAC5D;EAEA8J,sBAAsBA,CAAA,EAAwB;IAC5C,MAAM9J,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAuB;IAClD,IAAI,CAACI,gBAAgB,KAAe;IAEpCjD,IAAI,CAAC2H,OAAO,GAAG,EAAE;IACjB,IAAI,IAAI,CAACrE,GAAG,IAAa,EAAE;MACzB,GAAG;QACDtD,IAAI,CAAC2H,OAAO,CAAC5G,IAAI,CAAC,IAAI,CAAC6G,yBAAyB,EAAE,CAAC;MACrD,CAAC,QAAQ,IAAI,CAACtE,GAAG,IAAU;IAC7B;IAEAtD,IAAI,CAACwG,IAAI,GAAG,IAAI,CAACuB,mBAAmB,CAAC;MACnCC,WAAW,EAAE,KAAK;MAClBC,UAAU,EAAE,KAAK;MACjBC,WAAW,EAAE,KAAK;MAClBC,UAAU,EAAE,KAAK;MACjBC,YAAY,EAAE;IAChB,CAAC,CAAC;IAEF,OAAO,IAAI,CAAC5E,UAAU,CAACxD,IAAI,EAAE,yBAAyB,CAAC;EACzD;EAEA+J,0BAA0BA,CAAA,EAAiB;IACzC,OAAO,IAAI,CAACpG,KAAK,KAAQ,IAAI,IAAI,CAACA,KAAK,KAAW,GAC9C,KAAK,CAAC2C,aAAa,EAAE,GACrB,IAAI,CAACtC,eAAe,CAAC,IAAI,CAAC;EAChC;EAEAgG,0BAA0BA,CACxBhK,IAAqC,EACrCiK,QAAiB,EACjBb,QAAgC,EACP;IACzBpJ,IAAI,CAACkK,MAAM,GAAGD,QAAQ;IAGtB,IAAI,IAAI,CAACE,SAAS,EAAE,CAACtK,IAAI,OAAa,EAAE;MACtCG,IAAI,CAAC+D,EAAE,GAAG,IAAI,CAACgG,0BAA0B,EAAE;MAC3C/J,IAAI,CAACoK,GAAG,GAAG,IAAI,CAAC/H,wBAAwB,EAAE;IAC5C,CAAC,MAAM;MACLrC,IAAI,CAAC+D,EAAE,GAAG,IAAI;MACd/D,IAAI,CAACoK,GAAG,GAAG,IAAI,CAACzH,aAAa,EAAE;IACjC;IACA,IAAI,CAACD,MAAM,GAAa;IACxB1C,IAAI,CAACmC,KAAK,GAAG,IAAI,CAACE,wBAAwB,EAAE;IAC5CrC,IAAI,CAACoJ,QAAQ,GAAGA,QAAQ;IAExB,OAAO,IAAI,CAAC5F,UAAU,CAACxD,IAAI,EAAE,mBAAmB,CAAC;EACnD;EAEAqK,+BAA+BA,CAC7BrK,IAA0C,EAC1CiK,QAAiB,EACa;IAC9BjK,IAAI,CAACkK,MAAM,GAAGD,QAAQ;IAEtBjK,IAAI,CAAC+D,EAAE,GAAG,IAAI,CAACgG,0BAA0B,EAAE;IAC3C,IAAI,CAACrH,MAAM,GAAa;IACxB,IAAI,CAACA,MAAM,GAAa;IACxB,IAAI,IAAI,CAACiB,KAAK,IAAO,IAAI,IAAI,CAACA,KAAK,IAAW,EAAE;MAC9C3D,IAAI,CAACsK,MAAM,GAAG,IAAI;MAClBtK,IAAI,CAACuK,QAAQ,GAAG,KAAK;MACrBvK,IAAI,CAACmC,KAAK,GAAG,IAAI,CAACqI,4BAA4B,CAC5C,IAAI,CAACC,WAAW,CAACzK,IAAI,CAACmF,GAAG,CAACC,KAAK,CAAC,CACjC;IACH,CAAC,MAAM;MACLpF,IAAI,CAACsK,MAAM,GAAG,KAAK;MACnB,IAAI,IAAI,CAAChH,GAAG,IAAa,EAAE;QACzBtD,IAAI,CAACuK,QAAQ,GAAG,IAAI;MACtB;MACAvK,IAAI,CAACmC,KAAK,GAAG,IAAI,CAACE,wBAAwB,EAAE;IAC9C;IACA,OAAO,IAAI,CAACmB,UAAU,CAACxD,IAAI,EAAE,wBAAwB,CAAC;EACxD;EAEAwK,4BAA4BA,CAC1BxK,IAA0C,EACZ;IAC9BA,IAAI,CAACuE,MAAM,GAAG,EAAE;IAChBvE,IAAI,CAACwE,IAAI,GAAG,IAAI;IAChBxE,IAAI,CAACmE,cAAc,GAAG,IAAI;IAC1BnE,IAAI,CAACyE,IAAI,GAAG,IAAI;IAEhB,IAAI,IAAI,CAACd,KAAK,IAAO,EAAE;MACrB3D,IAAI,CAACmE,cAAc,GAAG,IAAI,CAACC,iCAAiC,EAAE;IAChE;IAEA,IAAI,CAAC1B,MAAM,IAAW;IACtB,IAAI,IAAI,CAACiB,KAAK,IAAU,EAAE;MACxB3D,IAAI,CAACyE,IAAI,GAAG,IAAI,CAACiG,0BAA0B,CAAa,IAAI,CAAC;MAE7D1K,IAAI,CAACyE,IAAI,CAACQ,IAAI,GAAG,IAAI;MACrB,IAAI,CAAC,IAAI,CAACtB,KAAK,IAAW,EAAE;QAC1B,IAAI,CAACjB,MAAM,IAAU;MACvB;IACF;IACA,OAAO,CAAC,IAAI,CAACiB,KAAK,IAAW,IAAI,CAAC,IAAI,CAACA,KAAK,IAAa,EAAE;MACzD3D,IAAI,CAACuE,MAAM,CAACxD,IAAI,CAAC,IAAI,CAAC2J,0BAA0B,CAAC,KAAK,CAAC,CAAC;MACxD,IAAI,CAAC,IAAI,CAAC/G,KAAK,IAAW,EAAE;QAC1B,IAAI,CAACjB,MAAM,IAAU;MACvB;IACF;IAEA,IAAI,IAAI,CAACY,GAAG,IAAa,EAAE;MACzBtD,IAAI,CAACwE,IAAI,GAAG,IAAI,CAACkG,0BAA0B,CAAC,KAAK,CAAC;IACpD;IACA,IAAI,CAAChI,MAAM,IAAW;IACtB1C,IAAI,CAAC2E,UAAU,GAAG,IAAI,CAACtC,wBAAwB,EAAE;IAEjD,OAAO,IAAI,CAACmB,UAAU,CAACxD,IAAI,EAAE,wBAAwB,CAAC;EACxD;EAEA2K,+BAA+BA,CAC7B3K,IAA0C,EAC1CiK,QAAiB,EACa;IAC9B,MAAMW,SAAS,GAAG,IAAI,CAAC/H,SAAS,EAAE;IAClC7C,IAAI,CAACkK,MAAM,GAAGD,QAAQ;IACtBjK,IAAI,CAACmC,KAAK,GAAG,IAAI,CAACqI,4BAA4B,CAACI,SAAS,CAAC;IACzD,OAAO,IAAI,CAACpH,UAAU,CAACxD,IAAI,EAAE,wBAAwB,CAAC;EACxD;EAEA+H,mBAAmBA,CAAC;IAClBC,WAAW;IACXC,UAAU;IACVC,WAAW;IACXC,UAAU;IACVC;EAOF,CAAC,EAA8B;IAC7B,MAAM7F,SAAS,GAAG,IAAI,CAACC,KAAK,CAACC,MAAM;IACnC,IAAI,CAACD,KAAK,CAACC,MAAM,GAAG,IAAI;IAExB,MAAMoI,SAAS,GAAG,IAAI,CAAChI,SAAS,EAAE;IAElCgI,SAAS,CAACC,cAAc,GAAG,EAAE;IAC7BD,SAAS,CAACE,UAAU,GAAG,EAAE;IACzBF,SAAS,CAACG,QAAQ,GAAG,EAAE;IACvBH,SAAS,CAACI,aAAa,GAAG,EAAE;IAE5B,IAAIC,QAAQ;IACZ,IAAIC,KAAK;IACT,IAAIC,OAAO,GAAG,KAAK;IACnB,IAAInD,UAAU,IAAI,IAAI,CAACtE,KAAK,GAAc,EAAE;MAC1C,IAAI,CAACjB,MAAM,GAAc;MACzBwI,QAAQ,IAAe;MACvBC,KAAK,GAAG,IAAI;IACd,CAAC,MAAM;MACL,IAAI,CAACzI,MAAM,GAAW;MACtBwI,QAAQ,IAAY;MACpBC,KAAK,GAAG,KAAK;IACf;IAEAN,SAAS,CAACM,KAAK,GAAGA,KAAK;IAEvB,OAAO,CAAC,IAAI,CAACxH,KAAK,CAACuH,QAAQ,CAAC,EAAE;MAC5B,IAAIjB,QAAQ,GAAG,KAAK;MACpB,IAAIoB,aAA0C,GAAG,IAAI;MACrD,IAAIC,eAA4C,GAAG,IAAI;MACvD,MAAMtL,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAE;MAE7B,IAAIsF,UAAU,IAAI,IAAI,CAACvC,YAAY,KAAW,EAAE;QAC9C,MAAMuE,SAAS,GAAG,IAAI,CAACA,SAAS,EAAE;QAElC,IAAIA,SAAS,CAACtK,IAAI,OAAa,IAAIsK,SAAS,CAACtK,IAAI,OAAgB,EAAE;UACjE,IAAI,CAACmD,IAAI,EAAE;UACXqI,aAAa,GAAG,IAAI,CAAC7I,KAAK,CAACO,QAAQ;UACnCiF,WAAW,GAAG,KAAK;QACrB;MACF;MAEA,IAAIA,WAAW,IAAI,IAAI,CAACpC,YAAY,KAAY,EAAE;QAChD,MAAMuE,SAAS,GAAG,IAAI,CAACA,SAAS,EAAE;QAGlC,IAAIA,SAAS,CAACtK,IAAI,OAAa,IAAIsK,SAAS,CAACtK,IAAI,OAAgB,EAAE;UACjE,IAAI,CAACmD,IAAI,EAAE;UACXiH,QAAQ,GAAG,IAAI;QACjB;MACF;MAEA,MAAMb,QAAQ,GAAG,IAAI,CAACC,iBAAiB,EAAE;MAEzC,IAAI,IAAI,CAAC/F,GAAG,GAAa,EAAE;QACzB,IAAI+H,aAAa,IAAI,IAAI,EAAE;UACzB,IAAI,CAACpF,UAAU,CAACoF,aAAa,CAAC;QAChC;QACA,IAAI,IAAI,CAAC/H,GAAG,GAAa,EAAE;UACzB,IAAI8F,QAAQ,EAAE;YACZ,IAAI,CAACnD,UAAU,CAACmD,QAAQ,CAACjE,GAAG,CAACC,KAAK,CAAC;UACrC;UACAyF,SAAS,CAACI,aAAa,CAAClK,IAAI,CAC1B,IAAI,CAACsJ,+BAA+B,CAACrK,IAAI,EAAEiK,QAAQ,CAAC,CACrD;QACH,CAAC,MAAM;UACLY,SAAS,CAACG,QAAQ,CAACjK,IAAI,CACrB,IAAI,CAACiJ,0BAA0B,CAAChK,IAAI,EAAEiK,QAAQ,EAAEb,QAAQ,CAAC,CAC1D;QACH;MACF,CAAC,MAAM,IAAI,IAAI,CAACzF,KAAK,IAAW,IAAI,IAAI,CAACA,KAAK,IAAO,EAAE;QACrD,IAAI0H,aAAa,IAAI,IAAI,EAAE;UACzB,IAAI,CAACpF,UAAU,CAACoF,aAAa,CAAC;QAChC;QACA,IAAIjC,QAAQ,EAAE;UACZ,IAAI,CAACnD,UAAU,CAACmD,QAAQ,CAACjE,GAAG,CAACC,KAAK,CAAC;QACrC;QACAyF,SAAS,CAACC,cAAc,CAAC/J,IAAI,CAC3B,IAAI,CAAC4J,+BAA+B,CAAC3K,IAAI,EAAEiK,QAAQ,CAAC,CACrD;MACH,CAAC,MAAM;QACL,IAAItD,IAAI,GAAG,MAAM;QAEjB,IAAI,IAAI,CAACf,YAAY,IAAS,IAAI,IAAI,CAACA,YAAY,KAAS,EAAE;UAC5D,MAAMuE,SAAS,GAAG,IAAI,CAACA,SAAS,EAAE;UAClC,IAAI,IAAAoB,iCAA0B,EAACpB,SAAS,CAACtK,IAAI,CAAC,EAAE;YAC9C8G,IAAI,GAAG,IAAI,CAACnE,KAAK,CAACL,KAAK;YACvB,IAAI,CAACa,IAAI,EAAE;UACb;QACF;QAEA,MAAMwI,aAAa,GAAG,IAAI,CAACC,2BAA2B,CACpDzL,IAAI,EACJiK,QAAQ,EACRoB,aAAa,EACbjC,QAAQ,EACRzC,IAAI,EACJuB,WAAW,EACXE,YAAY,WAAZA,YAAY,GAAI,CAAC+C,KAAK,CACvB;QAED,IAAIK,aAAa,KAAK,IAAI,EAAE;UAC1BJ,OAAO,GAAG,IAAI;UACdE,eAAe,GAAG,IAAI,CAAC9I,KAAK,CAACkD,eAAe;QAC9C,CAAC,MAAM;UACLmF,SAAS,CAACE,UAAU,CAAChK,IAAI,CAACyK,aAAa,CAAC;QAC1C;MACF;MAEA,IAAI,CAACE,uBAAuB,EAAE;MAE9B,IACEJ,eAAe,IACf,CAAC,IAAI,CAAC3H,KAAK,GAAW,IACtB,CAAC,IAAI,CAACA,KAAK,GAAc,EACzB;QACA,IAAI,CAACP,KAAK,CAACtH,UAAU,CAACiD,iCAAiC,EAAE;UACvDsE,EAAE,EAAEiI;QACN,CAAC,CAAC;MACJ;IACF;IAEA,IAAI,CAAC5I,MAAM,CAACwI,QAAQ,CAAC;IAOrB,IAAIhD,WAAW,EAAE;MACf2C,SAAS,CAACO,OAAO,GAAGA,OAAO;IAC7B;IAEA,MAAMO,GAAG,GAAG,IAAI,CAACnI,UAAU,CAACqH,SAAS,EAAE,sBAAsB,CAAC;IAE9D,IAAI,CAACrI,KAAK,CAACC,MAAM,GAAGF,SAAS;IAE7B,OAAOoJ,GAAG;EACZ;EAEAF,2BAA2BA,CACzBzL,IAAuE,EACvEiK,QAAiB,EACjBoB,aAA0C,EAC1CjC,QAA2C,EAC3CzC,IAAY,EACZuB,WAAoB,EACpBE,YAAqB,EAC6C;IAClE,IAAI,IAAI,CAAC9E,GAAG,IAAa,EAAE;MACzB,MAAMsI,cAAc,GAClB,IAAI,CAACjI,KAAK,IAAU,IACpB,IAAI,CAACA,KAAK,IAAS,IACnB,IAAI,CAACA,KAAK,GAAW,IACrB,IAAI,CAACA,KAAK,GAAc;MAE1B,IAAIiI,cAAc,EAAE;QAClB,IAAI,CAAC1D,WAAW,EAAE;UAChB,IAAI,CAAC9E,KAAK,CAACtH,UAAU,CAAC6B,sBAAsB,EAAE;YAC5C0F,EAAE,EAAE,IAAI,CAACb,KAAK,CAACkD;UACjB,CAAC,CAAC;QACJ,CAAC,MAAM,IAAI,CAAC0C,YAAY,EAAE;UACxB,IAAI,CAAChF,KAAK,CAACtH,UAAU,CAAC4B,kBAAkB,EAAE;YACxC2F,EAAE,EAAE,IAAI,CAACb,KAAK,CAACkD;UACjB,CAAC,CAAC;QACJ;QACA,IAAI0D,QAAQ,EAAE;UACZ,IAAI,CAAChG,KAAK,CAACtH,UAAU,CAAC8B,eAAe,EAAE;YAAEyF,EAAE,EAAE+F;UAAS,CAAC,CAAC;QAC1D;QAEA,OAAO,IAAI;MACb;MAEA,IAAI,CAAClB,WAAW,EAAE;QAChB,IAAI,CAAC9E,KAAK,CAACtH,UAAU,CAACqD,oBAAoB,EAAE;UAC1CkE,EAAE,EAAE,IAAI,CAACb,KAAK,CAACkD;QACjB,CAAC,CAAC;MACJ;MACA,IAAI2F,aAAa,IAAI,IAAI,EAAE;QACzB,IAAI,CAACpF,UAAU,CAACoF,aAAa,CAAC;MAChC;MACA,IAAIjC,QAAQ,EAAE;QACZ,IAAI,CAAChG,KAAK,CAACtH,UAAU,CAACyC,cAAc,EAAE;UAAE8E,EAAE,EAAE+F;QAAS,CAAC,CAAC;MACzD;MAEApJ,IAAI,CAAC6L,QAAQ,GAAG,IAAI,CAAClJ,aAAa,EAAE;MACpC,OAAO,IAAI,CAACa,UAAU,CAACxD,IAAI,EAAE,0BAA0B,CAAC;IAC1D,CAAC,MAAM;MACLA,IAAI,CAACoK,GAAG,GAAG,IAAI,CAACL,0BAA0B,EAAE;MAC5C/J,IAAI,CAACkK,MAAM,GAAGD,QAAQ;MACtBjK,IAAI,CAAC8L,KAAK,GAAGT,aAAa,IAAI,IAAI;MAClCrL,IAAI,CAAC2G,IAAI,GAAGA,IAAI;MAEhB,IAAI4D,QAAQ,GAAG,KAAK;MACpB,IAAI,IAAI,CAAC5G,KAAK,IAAO,IAAI,IAAI,CAACA,KAAK,IAAW,EAAE;QAE9C3D,IAAI,CAACsK,MAAM,GAAG,IAAI;QAElB,IAAIe,aAAa,IAAI,IAAI,EAAE;UACzB,IAAI,CAACpF,UAAU,CAACoF,aAAa,CAAC;QAChC;QACA,IAAIjC,QAAQ,EAAE;UACZ,IAAI,CAACnD,UAAU,CAACmD,QAAQ,CAACjE,GAAG,CAACC,KAAK,CAAC;QACrC;QAEApF,IAAI,CAACmC,KAAK,GAAG,IAAI,CAACqI,4BAA4B,CAC5C,IAAI,CAACC,WAAW,CAACzK,IAAI,CAACmF,GAAG,CAACC,KAAK,CAAC,CACjC;QACD,IAAIuB,IAAI,KAAK,KAAK,IAAIA,IAAI,KAAK,KAAK,EAAE;UACpC,IAAI,CAACoF,2BAA2B,CAAC/L,IAAI,CAAC;QACxC;QAEA,IACE,CAACkI,WAAW,IACZlI,IAAI,CAACoK,GAAG,CAACnF,IAAI,KAAK,aAAa,IAC/BjF,IAAI,CAACmC,KAAK,CAACsC,IAAI,EACf;UACA,IAAI,CAACrB,KAAK,CAACtH,UAAU,CAAC2C,4BAA4B,EAAE;YAClD4E,EAAE,EAAErD,IAAI,CAACmC,KAAK,CAACsC;UACjB,CAAC,CAAC;QACJ;MACF,CAAC,MAAM;QACL,IAAIkC,IAAI,KAAK,MAAM,EAAE,IAAI,CAACV,UAAU,EAAE;QAEtCjG,IAAI,CAACsK,MAAM,GAAG,KAAK;QAEnB,IAAI,IAAI,CAAChH,GAAG,IAAa,EAAE;UACzBiH,QAAQ,GAAG,IAAI;QACjB;QACAvK,IAAI,CAACmC,KAAK,GAAG,IAAI,CAACE,wBAAwB,EAAE;QAC5CrC,IAAI,CAACoJ,QAAQ,GAAGA,QAAQ;MAC1B;MAEApJ,IAAI,CAACuK,QAAQ,GAAGA,QAAQ;MAExB,OAAO,IAAI,CAAC/G,UAAU,CAACxD,IAAI,EAAE,oBAAoB,CAAC;IACpD;EACF;EAIA+L,2BAA2BA,CACzBC,QAEC,EACK;IACN,MAAMC,UAAU,GAAGD,QAAQ,CAACrF,IAAI,KAAK,KAAK,GAAG,CAAC,GAAG,CAAC;IAClD,MAAM7F,MAAM,GACVkL,QAAQ,CAAC7J,KAAK,CAACoC,MAAM,CAACzD,MAAM,IAAIkL,QAAQ,CAAC7J,KAAK,CAACqC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;IAE9D,IAAIwH,QAAQ,CAAC7J,KAAK,CAACsC,IAAI,EAAE;MACvB,IAAI,CAACrB,KAAK,CACR4I,QAAQ,CAACrF,IAAI,KAAK,KAAK,GACnB7K,UAAU,CAACyB,yBAAyB,GACpCzB,UAAU,CAACwC,yBAAyB,EACxC;QAAE+E,EAAE,EAAE2I,QAAQ,CAAC7J,KAAK,CAACsC;MAAK,CAAC,CAC5B;IACH;IAEA,IAAI3D,MAAM,KAAKmL,UAAU,EAAE;MACzB,IAAI,CAAC7I,KAAK,CACR4I,QAAQ,CAACrF,IAAI,KAAK,KAAK,GACnBuF,kBAAM,CAACC,cAAc,GACrBD,kBAAM,CAACE,cAAc,EACzB;QAAE/I,EAAE,EAAE2I;MAAS,CAAC,CACjB;IACH;IAEA,IAAIA,QAAQ,CAACrF,IAAI,KAAK,KAAK,IAAIqF,QAAQ,CAAC7J,KAAK,CAACqC,IAAI,EAAE;MAClD,IAAI,CAACpB,KAAK,CAAC8I,kBAAM,CAACG,sBAAsB,EAAE;QAAEhJ,EAAE,EAAE2I;MAAS,CAAC,CAAC;IAC7D;EACF;EAEAN,uBAAuBA,CAAA,EAAS;IAC9B,IACE,CAAC,IAAI,CAACpI,GAAG,IAAS,IAClB,CAAC,IAAI,CAACA,GAAG,IAAU,IACnB,CAAC,IAAI,CAACK,KAAK,GAAW,IACtB,CAAC,IAAI,CAACA,KAAK,GAAc,EACzB;MACA,IAAI,CAACsC,UAAU,EAAE;IACnB;EACF;EAEAoC,gCAAgCA,CAC9BtF,QAAmB,EACnBgB,EAAiB,EACc;IAAA,IAAAuI,SAAA;IAC/B,CAAAA,SAAA,GAAAvJ,QAAQ,YAAAuJ,SAAA,GAARvJ,QAAQ,GAAK,IAAI,CAACP,KAAK,CAACO,QAAQ;IAChC,IAAI/C,IAAkD,GACpD+D,EAAE,IAAI,IAAI,CAACyD,6BAA6B,CAAC,IAAI,CAAC;IAEhD,OAAO,IAAI,CAAClE,GAAG,IAAQ,EAAE;MACvB,MAAMiJ,KAAK,GAAG,IAAI,CAAC9B,WAAW,CAAgC1H,QAAQ,CAAC;MACvEwJ,KAAK,CAACC,aAAa,GAAGxM,IAAI;MAC1BuM,KAAK,CAACxI,EAAE,GAAG,IAAI,CAACyD,6BAA6B,CAAC,IAAI,CAAC;MACnDxH,IAAI,GAAG,IAAI,CAACwD,UAAU,CAAC+I,KAAK,EAAE,yBAAyB,CAAC;IAC1D;IAEA,OAAOvM,IAAI;EACb;EAEAyM,oBAAoBA,CAClB1J,QAAkB,EAClBgB,EAAgB,EACa;IAC7B,MAAM/D,IAAI,GAAG,IAAI,CAACyK,WAAW,CAAC1H,QAAQ,CAAC;IAEvC/C,IAAI,CAACmE,cAAc,GAAG,IAAI;IAC1BnE,IAAI,CAAC+D,EAAE,GAAG,IAAI,CAACsE,gCAAgC,CAACtF,QAAQ,EAAEgB,EAAE,CAAC;IAE7D,IAAI,IAAI,CAACJ,KAAK,IAAO,EAAE;MACrB3D,IAAI,CAACmE,cAAc,GAAG,IAAI,CAACmE,mCAAmC,EAAE;IAClE;IAEA,OAAO,IAAI,CAAC9E,UAAU,CAACxD,IAAI,EAAE,uBAAuB,CAAC;EACvD;EAEA0M,mBAAmBA,CAAA,EAA+B;IAChD,MAAM1M,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAE;IAC7B,IAAI,CAACH,MAAM,IAAY;IACvB1C,IAAI,CAAC6L,QAAQ,GAAG,IAAI,CAACc,oBAAoB,EAAE;IAC3C,OAAO,IAAI,CAACnJ,UAAU,CAACxD,IAAI,EAAE,sBAAsB,CAAC;EACtD;EAEA4M,kBAAkBA,CAAA,EAA8B;IAC9C,MAAM5M,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAE;IAC7B7C,IAAI,CAAC6M,KAAK,GAAG,EAAE;IACf,IAAI,CAACnK,MAAM,GAAa;IAExB,OAAO,IAAI,CAACF,KAAK,CAACsK,GAAG,GAAG,IAAI,CAAChM,MAAM,IAAI,CAAC,IAAI,CAAC6C,KAAK,GAAa,EAAE;MAC/D3D,IAAI,CAAC6M,KAAK,CAAC9L,IAAI,CAAC,IAAI,CAAC4B,aAAa,EAAE,CAAC;MACrC,IAAI,IAAI,CAACgB,KAAK,GAAa,EAAE;MAC7B,IAAI,CAACjB,MAAM,IAAU;IACvB;IACA,IAAI,CAACA,MAAM,GAAa;IACxB,OAAO,IAAI,CAACc,UAAU,CAACxD,IAAI,EAAE,qBAAqB,CAAC;EACrD;EAEA0K,0BAA0BA,CAACqC,KAAc,EAA2B;IAClE,IAAI9H,IAAI,GAAG,IAAI;IACf,IAAIsF,QAAQ,GAAG,KAAK;IACpB,IAAI3F,cAAc,GAAG,IAAI;IACzB,MAAM5E,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAA2B;IACtD,MAAMmK,EAAE,GAAG,IAAI,CAAC7C,SAAS,EAAE;IAC3B,MAAM8C,MAAM,GAAG,IAAI,CAACzK,KAAK,CAAC3C,IAAI,OAAa;IAE3C,IAAImN,EAAE,CAACnN,IAAI,OAAa,IAAImN,EAAE,CAACnN,IAAI,OAAgB,EAAE;MACnD,IAAIoN,MAAM,IAAI,CAACF,KAAK,EAAE;QACpB,IAAI,CAAC3J,KAAK,CAACtH,UAAU,CAAC6C,oBAAoB,EAAE;UAAE0E,EAAE,EAAErD;QAAK,CAAC,CAAC;MAC3D;MACAiF,IAAI,GAAG,IAAI,CAACjB,eAAe,CAACiJ,MAAM,CAAC;MACnC,IAAI,IAAI,CAAC3J,GAAG,IAAa,EAAE;QACzBiH,QAAQ,GAAG,IAAI;QACf,IAAI0C,MAAM,EAAE;UACV,IAAI,CAAC7J,KAAK,CAACtH,UAAU,CAAC4C,yBAAyB,EAAE;YAAE2E,EAAE,EAAErD;UAAK,CAAC,CAAC;QAChE;MACF;MACA4E,cAAc,GAAG,IAAI,CAACvC,wBAAwB,EAAE;IAClD,CAAC,MAAM;MACLuC,cAAc,GAAG,IAAI,CAACjC,aAAa,EAAE;IACvC;IACA3C,IAAI,CAACiF,IAAI,GAAGA,IAAI;IAChBjF,IAAI,CAACuK,QAAQ,GAAGA,QAAQ;IACxBvK,IAAI,CAAC4E,cAAc,GAAGA,cAAc;IACpC,OAAO,IAAI,CAACpB,UAAU,CAACxD,IAAI,EAAE,mBAAmB,CAAC;EACnD;EAEAkN,kCAAkCA,CAChCrN,IAAgB,EACS;IACzB,MAAMG,IAAI,GAAG,IAAI,CAACyK,WAAW,CAAC5K,IAAI,CAACsF,GAAG,CAACC,KAAK,CAAC;IAC7CpF,IAAI,CAACiF,IAAI,GAAG,IAAI;IAChBjF,IAAI,CAACuK,QAAQ,GAAG,KAAK;IACrBvK,IAAI,CAAC4E,cAAc,GAAG/E,IAAI;IAC1B,OAAO,IAAI,CAAC2D,UAAU,CAACxD,IAAI,EAAE,mBAAmB,CAAC;EACnD;EAEAsE,2BAA2BA,CAACC,MAAiC,GAAG,EAAE,EAIhE;IACA,IAAIC,IAAgD,GAAG,IAAI;IAC3D,IAAIE,KAAiD,GAAG,IAAI;IAC5D,IAAI,IAAI,CAACf,KAAK,IAAU,EAAE;MACxBe,KAAK,GAAG,IAAI,CAACgG,0BAA0B,CAAa,IAAI,CAAC;MAEzDhG,KAAK,CAACO,IAAI,GAAG,IAAI;MACjB,IAAI,CAAC,IAAI,CAACtB,KAAK,IAAW,EAAE;QAC1B,IAAI,CAACjB,MAAM,IAAU;MACvB;IACF;IACA,OAAO,CAAC,IAAI,CAACiB,KAAK,IAAW,IAAI,CAAC,IAAI,CAACA,KAAK,IAAa,EAAE;MACzDY,MAAM,CAACxD,IAAI,CAAC,IAAI,CAAC2J,0BAA0B,CAAC,KAAK,CAAC,CAAC;MACnD,IAAI,CAAC,IAAI,CAAC/G,KAAK,IAAW,EAAE;QAC1B,IAAI,CAACjB,MAAM,IAAU;MACvB;IACF;IACA,IAAI,IAAI,CAACY,GAAG,IAAa,EAAE;MACzBkB,IAAI,GAAG,IAAI,CAACkG,0BAA0B,CAAC,KAAK,CAAC;IAC/C;IACA,OAAO;MAAEnG,MAAM;MAAEC,IAAI;MAAEE;IAAM,CAAC;EAChC;EAEAyI,yBAAyBA,CACvBpK,QAAkB,EAClB/C,IAAkC,EAClC+D,EAAgB,EACM;IACtB,QAAQA,EAAE,CAACkB,IAAI;MACb,KAAK,KAAK;QACR,OAAO,IAAI,CAACzB,UAAU,CAACxD,IAAI,EAAE,mBAAmB,CAAC;MAEnD,KAAK,MAAM;MACX,KAAK,SAAS;QACZ,OAAO,IAAI,CAACwD,UAAU,CAACxD,IAAI,EAAE,uBAAuB,CAAC;MAEvD,KAAK,OAAO;QACV,OAAO,IAAI,CAACwD,UAAU,CAACxD,IAAI,EAAE,qBAAqB,CAAC;MAErD,KAAK,OAAO;QACV,OAAO,IAAI,CAACwD,UAAU,CAACxD,IAAI,EAAE,qBAAqB,CAAC;MAErD,KAAK,QAAQ;QACX,OAAO,IAAI,CAACwD,UAAU,CAACxD,IAAI,EAAE,sBAAsB,CAAC;MAEtD,KAAK,QAAQ;QACX,OAAO,IAAI,CAACwD,UAAU,CAACxD,IAAI,EAAE,sBAAsB,CAAC;MAEtD,KAAK,QAAQ;QACX,OAAO,IAAI,CAACwD,UAAU,CAACxD,IAAI,EAAE,sBAAsB,CAAC;MAEtD;QACE,IAAI,CAACwI,kBAAkB,CAACzE,EAAE,CAACkB,IAAI,CAAC;QAChC,OAAO,IAAI,CAACwH,oBAAoB,CAAC1J,QAAQ,EAAEgB,EAAE,CAAC;IAAC;EAErD;EAKA4I,oBAAoBA,CAAA,EAAyB;IAC3C,MAAM5J,QAAQ,GAAG,IAAI,CAACP,KAAK,CAACO,QAAQ;IACpC,MAAM/C,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAE;IAC7B,IAAIwB,GAAG;IACP,IAAIxE,IAAI;IACR,IAAIuN,aAAa,GAAG,KAAK;IACzB,MAAM1D,qBAAqB,GAAG,IAAI,CAAClH,KAAK,CAACmH,kBAAkB;IAE3D,QAAQ,IAAI,CAACnH,KAAK,CAAC3C,IAAI;MACrB;QACE,OAAO,IAAI,CAACkI,mBAAmB,CAAC;UAC9BC,WAAW,EAAE,KAAK;UAClBC,UAAU,EAAE,KAAK;UACjBC,WAAW,EAAE,IAAI;UACjBC,UAAU,EAAE,KAAK;UACjBC,YAAY,EAAE;QAChB,CAAC,CAAC;MAEJ;QACE,OAAO,IAAI,CAACL,mBAAmB,CAAC;UAC9BC,WAAW,EAAE,KAAK;UAClBC,UAAU,EAAE,IAAI;UAChBC,WAAW,EAAE,IAAI;UACjBC,UAAU,EAAE,KAAK;UACjBC,YAAY,EAAE;QAChB,CAAC,CAAC;MAEJ;QACE,IAAI,CAAC5F,KAAK,CAACmH,kBAAkB,GAAG,KAAK;QACrC9J,IAAI,GAAG,IAAI,CAAC+M,kBAAkB,EAAE;QAChC,IAAI,CAACpK,KAAK,CAACmH,kBAAkB,GAAGD,qBAAqB;QACrD,OAAO7J,IAAI;MAEb;QACEG,IAAI,CAACmE,cAAc,GAAG,IAAI,CAACC,iCAAiC,EAAE;QAC9D,IAAI,CAAC1B,MAAM,IAAW;QACtB2B,GAAG,GAAG,IAAI,CAACC,2BAA2B,EAAE;QACxCtE,IAAI,CAACuE,MAAM,GAAGF,GAAG,CAACE,MAAM;QACxBvE,IAAI,CAACwE,IAAI,GAAGH,GAAG,CAACG,IAAI;QACpBxE,IAAI,CAACyE,IAAI,GAAGJ,GAAG,CAACK,KAAK;QACrB,IAAI,CAAChC,MAAM,IAAW;QAEtB,IAAI,CAACA,MAAM,IAAU;QAErB1C,IAAI,CAAC2E,UAAU,GAAG,IAAI,CAAChC,aAAa,EAAE;QAEtC,OAAO,IAAI,CAACa,UAAU,CAACxD,IAAI,EAAE,wBAAwB,CAAC;MAExD;QACE,IAAI,CAACgD,IAAI,EAAE;QAGX,IAAI,CAAC,IAAI,CAACW,KAAK,IAAW,IAAI,CAAC,IAAI,CAACA,KAAK,IAAa,EAAE;UACtD,IAAI,IAAA0J,wBAAiB,EAAC,IAAI,CAAC7K,KAAK,CAAC3C,IAAI,CAAC,IAAI,IAAI,CAAC8D,KAAK,IAAU,EAAE;YAC9D,MAAM2J,KAAK,GAAG,IAAI,CAACnD,SAAS,EAAE,CAACtK,IAAI;YACnCuN,aAAa,GAAGE,KAAK,OAAgB,IAAIA,KAAK,OAAa;UAC7D,CAAC,MAAM;YACLF,aAAa,GAAG,IAAI;UACtB;QACF;QAEA,IAAIA,aAAa,EAAE;UACjB,IAAI,CAAC5K,KAAK,CAACmH,kBAAkB,GAAG,KAAK;UACrC9J,IAAI,GAAG,IAAI,CAAC8C,aAAa,EAAE;UAC3B,IAAI,CAACH,KAAK,CAACmH,kBAAkB,GAAGD,qBAAqB;UAGrD,IACE,IAAI,CAAClH,KAAK,CAACmH,kBAAkB,IAC7B,EACE,IAAI,CAAChG,KAAK,IAAU,IACnB,IAAI,CAACA,KAAK,IAAW,IAAI,IAAI,CAACwG,SAAS,EAAE,CAACtK,IAAI,OAAc,CAC9D,EACD;YACA,IAAI,CAAC6C,MAAM,IAAW;YACtB,OAAO7C,IAAI;UACb,CAAC,MAAM;YAEL,IAAI,CAACyD,GAAG,IAAU;UACpB;QACF;QAEA,IAAIzD,IAAI,EAAE;UACRwE,GAAG,GAAG,IAAI,CAACC,2BAA2B,CAAC,CACrC,IAAI,CAAC4I,kCAAkC,CAACrN,IAAI,CAAC,CAC9C,CAAC;QACJ,CAAC,MAAM;UACLwE,GAAG,GAAG,IAAI,CAACC,2BAA2B,EAAE;QAC1C;QAEAtE,IAAI,CAACuE,MAAM,GAAGF,GAAG,CAACE,MAAM;QACxBvE,IAAI,CAACwE,IAAI,GAAGH,GAAG,CAACG,IAAI;QACpBxE,IAAI,CAACyE,IAAI,GAAGJ,GAAG,CAACK,KAAK;QAErB,IAAI,CAAChC,MAAM,IAAW;QAEtB,IAAI,CAACA,MAAM,IAAU;QAErB1C,IAAI,CAAC2E,UAAU,GAAG,IAAI,CAAChC,aAAa,EAAE;QAEtC3C,IAAI,CAACmE,cAAc,GAAG,IAAI;QAE1B,OAAO,IAAI,CAACX,UAAU,CAACxD,IAAI,EAAE,wBAAwB,CAAC;MAExD;QACE,OAAO,IAAI,CAACuN,YAAY,CACtB,IAAI,CAAC/K,KAAK,CAACL,KAAK,EAChB,6BAA6B,CAC9B;MAEH;MACA;QACEnC,IAAI,CAACmC,KAAK,GAAG,IAAI,CAACwB,KAAK,IAAU;QACjC,IAAI,CAACX,IAAI,EAAE;QACX,OAAO,IAAI,CAACQ,UAAU,CACpBxD,IAAI,EACJ,8BAA8B,CAC/B;MAEH;QACE,IAAI,IAAI,CAACwC,KAAK,CAACL,KAAK,KAAK,GAAG,EAAE;UAC5B,IAAI,CAACa,IAAI,EAAE;UACX,IAAI,IAAI,CAACW,KAAK,KAAQ,EAAE;YACtB,OAAO,IAAI,CAAC6J,kBAAkB,CAC5B,CAAC,IAAI,CAAChL,KAAK,CAACL,KAAK,EACjB,6BAA6B,EAC7BnC,IAAI,CACL;UACH;UAEA,IAAI,IAAI,CAAC2D,KAAK,KAAW,EAAE;YACzB,OAAO,IAAI,CAAC6J,kBAAkB,CAC5B,CAAC,IAAI,CAAChL,KAAK,CAACL,KAAK,EACjB,6BAA6B,EAC7BnC,IAAI,CACL;UACH;UAEA,MAAM,IAAI,CAACoD,KAAK,CAACtH,UAAU,CAACsD,4BAA4B,EAAE;YACxDiE,EAAE,EAAE,IAAI,CAACb,KAAK,CAACO;UACjB,CAAC,CAAC;QACJ;QACA,IAAI,CAACkD,UAAU,EAAE;QACjB;MACF;QACE,OAAO,IAAI,CAACsH,YAAY,CACtB,IAAI,CAAC/K,KAAK,CAACL,KAAK,EAChB,6BAA6B,CAC9B;MAEH;QACE,OAAO,IAAI,CAACoL,YAAY,CACtB,IAAI,CAAC/K,KAAK,CAACL,KAAK,EAChB,6BAA6B,CAC9B;MAEH;QACE,IAAI,CAACa,IAAI,EAAE;QACX,OAAO,IAAI,CAACQ,UAAU,CAACxD,IAAI,EAAE,oBAAoB,CAAC;MAEpD;QACE,IAAI,CAACgD,IAAI,EAAE;QACX,OAAO,IAAI,CAACQ,UAAU,CAACxD,IAAI,EAAE,2BAA2B,CAAC;MAE3D;QACE,IAAI,CAACgD,IAAI,EAAE;QACX,OAAO,IAAI,CAACQ,UAAU,CAACxD,IAAI,EAAE,oBAAoB,CAAC;MAEpD;QACE,IAAI,CAACgD,IAAI,EAAE;QACX,OAAO,IAAI,CAACQ,UAAU,CAACxD,IAAI,EAAE,sBAAsB,CAAC;MAEtD;QACE,OAAO,IAAI,CAAC0M,mBAAmB,EAAE;MAEnC;QACE,IAAI,IAAAe,qBAAc,EAAC,IAAI,CAACjL,KAAK,CAAC3C,IAAI,CAAC,EAAE;UACnC,MAAMmH,KAAK,GAAG,IAAA0G,qBAAc,EAAC,IAAI,CAAClL,KAAK,CAAC3C,IAAI,CAAC;UAC7C,IAAI,CAACmD,IAAI,EAAE;UACX,OAAO,KAAK,CAAC2K,gBAAgB,CAAC3N,IAAI,EAA0BgH,KAAK,CAAC;QACpE,CAAC,MAAM,IAAI,IAAAqG,wBAAiB,EAAC,IAAI,CAAC7K,KAAK,CAAC3C,IAAI,CAAC,EAAE;UAC7C,IAAI,IAAI,CAAC+F,YAAY,KAAe,EAAE;YACpC,OAAO,IAAI,CAACkE,sBAAsB,EAAE;UACtC;UAEA,OAAO,IAAI,CAACqD,yBAAyB,CACnCpK,QAAQ,EACR/C,IAAI,EACJ,IAAI,CAACgE,eAAe,EAAE,CACvB;QACH;IAAC;IAGL,IAAI,CAACiC,UAAU,EAAE;EACnB;EAEA2H,oBAAoBA,CAAA,EAAyB;IAC3C,MAAM7K,QAAQ,GAAG,IAAI,CAACP,KAAK,CAACO,QAAQ;IACpC,IAAIlD,IAAI,GAAG,IAAI,CAAC8M,oBAAoB,EAAE;IACtC,IAAIkB,yBAAyB,GAAG,KAAK;IACrC,OACE,CAAC,IAAI,CAAClK,KAAK,GAAa,IAAI,IAAI,CAACA,KAAK,IAAgB,KACtD,CAAC,IAAI,CAACmK,kBAAkB,EAAE,EAC1B;MACA,MAAM9N,IAAI,GAAG,IAAI,CAACyK,WAAW,CAAC1H,QAAQ,CAAC;MACvC,MAAMwH,QAAQ,GAAG,IAAI,CAACjH,GAAG,IAAgB;MACzCuK,yBAAyB,GAAGA,yBAAyB,IAAItD,QAAQ;MACjE,IAAI,CAAC7H,MAAM,GAAa;MACxB,IAAI,CAAC6H,QAAQ,IAAI,IAAI,CAAC5G,KAAK,GAAa,EAAE;QACxC3D,IAAI,CAAC+N,WAAW,GAAGlO,IAAI;QACvB,IAAI,CAACmD,IAAI,EAAE;QACXnD,IAAI,GAAG,IAAI,CAAC2D,UAAU,CAACxD,IAAI,EAAE,qBAAqB,CAAC;MACrD,CAAC,MAAM;QACLA,IAAI,CAACgO,UAAU,GAAGnO,IAAI;QACtBG,IAAI,CAACiO,SAAS,GAAG,IAAI,CAACtL,aAAa,EAAE;QACrC,IAAI,CAACD,MAAM,GAAa;QACxB,IAAImL,yBAAyB,EAAE;UAC7B7N,IAAI,CAACuK,QAAQ,GAAGA,QAAQ;UACxB1K,IAAI,GAAG,IAAI,CAAC2D,UAAU,CAEpBxD,IAAI,EACJ,2BAA2B,CAC5B;QACH,CAAC,MAAM;UACLH,IAAI,GAAG,IAAI,CAAC2D,UAAU,CAEpBxD,IAAI,EACJ,mBAAmB,CACpB;QACH;MACF;IACF;IACA,OAAOH,IAAI;EACb;EAEAqO,mBAAmBA,CAAA,EAAyB;IAC1C,MAAMlO,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAE;IAC7B,IAAI,IAAI,CAACS,GAAG,IAAa,EAAE;MACzBtD,IAAI,CAAC4E,cAAc,GAAG,IAAI,CAACsJ,mBAAmB,EAAE;MAChD,OAAO,IAAI,CAAC1K,UAAU,CAACxD,IAAI,EAAE,wBAAwB,CAAC;IACxD,CAAC,MAAM;MACL,OAAO,IAAI,CAAC4N,oBAAoB,EAAE;IACpC;EACF;EAEAO,kCAAkCA,CAAA,EAAyB;IACzD,MAAMC,KAAK,GAAG,IAAI,CAACF,mBAAmB,EAAE;IACxC,IAAI,CAAC,IAAI,CAAC1L,KAAK,CAACmH,kBAAkB,IAAI,IAAI,CAACrG,GAAG,IAAU,EAAE;MAExD,MAAMtD,IAAI,GAAG,IAAI,CAACyK,WAAW,CAAC2D,KAAK,CAACjJ,GAAG,CAACC,KAAK,CAAC;MAC9CpF,IAAI,CAACuE,MAAM,GAAG,CAAC,IAAI,CAAC2I,kCAAkC,CAACkB,KAAK,CAAC,CAAC;MAC9DpO,IAAI,CAACwE,IAAI,GAAG,IAAI;MAChBxE,IAAI,CAACyE,IAAI,GAAG,IAAI;MAChBzE,IAAI,CAAC2E,UAAU,GAAG,IAAI,CAAChC,aAAa,EAAE;MACtC3C,IAAI,CAACmE,cAAc,GAAG,IAAI;MAC1B,OAAO,IAAI,CAACX,UAAU,CAACxD,IAAI,EAAE,wBAAwB,CAAC;IACxD;IACA,OAAOoO,KAAK;EACd;EAEAC,yBAAyBA,CAAA,EAAyB;IAChD,MAAMrO,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAE;IAC7B,IAAI,CAACS,GAAG,IAAe;IACvB,MAAMzD,IAAI,GAAG,IAAI,CAACsO,kCAAkC,EAAE;IACtDnO,IAAI,CAAC6M,KAAK,GAAG,CAAChN,IAAI,CAAC;IACnB,OAAO,IAAI,CAACyD,GAAG,IAAe,EAAE;MAC9BtD,IAAI,CAAC6M,KAAK,CAAC9L,IAAI,CAAC,IAAI,CAACoN,kCAAkC,EAAE,CAAC;IAC5D;IACA,OAAOnO,IAAI,CAAC6M,KAAK,CAAC/L,MAAM,KAAK,CAAC,GAC1BjB,IAAI,GACJ,IAAI,CAAC2D,UAAU,CAACxD,IAAI,EAAE,4BAA4B,CAAC;EACzD;EAEAsO,kBAAkBA,CAAA,EAAyB;IACzC,MAAMtO,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAE;IAC7B,IAAI,CAACS,GAAG,IAAc;IACtB,MAAMzD,IAAI,GAAG,IAAI,CAACwO,yBAAyB,EAAE;IAC7CrO,IAAI,CAAC6M,KAAK,GAAG,CAAChN,IAAI,CAAC;IACnB,OAAO,IAAI,CAACyD,GAAG,IAAc,EAAE;MAC7BtD,IAAI,CAAC6M,KAAK,CAAC9L,IAAI,CAAC,IAAI,CAACsN,yBAAyB,EAAE,CAAC;IACnD;IACA,OAAOrO,IAAI,CAAC6M,KAAK,CAAC/L,MAAM,KAAK,CAAC,GAC1BjB,IAAI,GACJ,IAAI,CAAC2D,UAAU,CAACxD,IAAI,EAAE,qBAAqB,CAAC;EAClD;EAEA2C,aAAaA,CAAA,EAAyB;IACpC,MAAMJ,SAAS,GAAG,IAAI,CAACC,KAAK,CAACC,MAAM;IACnC,IAAI,CAACD,KAAK,CAACC,MAAM,GAAG,IAAI;IACxB,MAAM5C,IAAI,GAAG,IAAI,CAACyO,kBAAkB,EAAE;IACtC,IAAI,CAAC9L,KAAK,CAACC,MAAM,GAAGF,SAAS;IAC7B,OAAO1C,IAAI;EACb;EAEAgK,oCAAoCA,CAAA,EAAyB;IAC3D,IAAI,IAAI,CAACrH,KAAK,CAAC3C,IAAI,QAAY,IAAI,IAAI,CAAC2C,KAAK,CAACL,KAAK,KAAK,GAAG,EAAE;MAC3D,MAAMY,QAAQ,GAAG,IAAI,CAACP,KAAK,CAACO,QAAQ;MACpC,MAAM/C,IAAI,GAAG,IAAI,CAACgE,eAAe,EAAE;MACnC,OAAO,IAAI,CAACyI,oBAAoB,CAAC1J,QAAQ,EAAE/C,IAAI,CAAC;IAClD,CAAC,MAAM;MACL,OAAO,IAAI,CAAC2C,aAAa,EAAE;IAC7B;EACF;EAEAwE,uBAAuBA,CAAA,EAAyB;IAC9C,MAAMnH,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAwB;IACnD7C,IAAI,CAAC4E,cAAc,GAAG,IAAI,CAACvC,wBAAwB,EAAE;IACrD,OAAO,IAAI,CAACmB,UAAU,CAACxD,IAAI,EAAE,gBAAgB,CAAC;EAChD;EAEAkG,kCAAkCA,CAChCqI,sBAAgC,EAClB;IACd,MAAMjF,KAAK,GAAGiF,sBAAsB,GAChC,IAAI,CAACvK,eAAe,EAAE,GACtB,IAAI,CAACwD,6BAA6B,EAAE;IACxC,IAAI,IAAI,CAAC7D,KAAK,IAAU,EAAE;MAExB2F,KAAK,CAAC1E,cAAc,GAAG,IAAI,CAACuC,uBAAuB,EAAE;MACrD,IAAI,CAACtC,gBAAgB,CAACyE,KAAK,CAAC;IAC9B;IACA,OAAOA,KAAK;EACd;EAEAkF,mBAAmBA,CAACxO,IAAY,EAAU;IACxCA,IAAI,CAACyO,UAAU,CAAC7J,cAAc,GAAG5E,IAAI,CAAC4E,cAAc;IAEpD,IAAI,CAACC,gBAAgB,CAAC7E,IAAI,CAACyO,UAAU,EAAEzO,IAAI,CAAC4E,cAAc,CAACO,GAAG,CAACuJ,GAAG,CAAC;IAEnE,OAAO1O,IAAI,CAACyO,UAAU;EACxB;EAEApF,iBAAiBA,CAAA,EAAsC;IACrD,IAAID,QAAQ,GAAG,IAAI;IACnB,IAAI,IAAI,CAACzF,KAAK,IAAY,EAAE;MAC1ByF,QAAQ,GAAG,IAAI,CAACvG,SAAS,EAAkB;MAC3C,IAAI,IAAI,CAACL,KAAK,CAACL,KAAK,KAAK,GAAG,EAAE;QAC5BiH,QAAQ,CAACzC,IAAI,GAAG,MAAM;MACxB,CAAC,MAAM;QACLyC,QAAQ,CAACzC,IAAI,GAAG,OAAO;MACzB;MACA,IAAI,CAAC3D,IAAI,EAAE;MACX,OAAO,IAAI,CAACQ,UAAU,CAAC4F,QAAQ,EAAE,UAAU,CAAC;IAC9C;IACA,OAAOA,QAAQ;EACjB;EAMAuF,iBAAiBA,CACf3O,IAAgB,EAChB4O,mBAAoC,EACpCC,QAAiB,GAAG,KAAK,EACnB;IACN,IAAID,mBAAmB,EAAE;MACvB,IAAI,CAACE,gCAAgC,CAAC9O,IAAI,EAAE,MAC1C,KAAK,CAAC2O,iBAAiB,CAAC3O,IAAI,EAAE,IAAI,EAAE6O,QAAQ,CAAC,CAC9C;MACD;IACF;IAEA,KAAK,CAACF,iBAAiB,CAAC3O,IAAI,EAAE,KAAK,EAAE6O,QAAQ,CAAC;EAChD;EAEAE,0BAA0BA,CAMxB/O,IAAe,EAAEH,IAAe,EAAEgP,QAAiB,GAAG,KAAK,EAAK;IAChE,IAAI,IAAI,CAAClL,KAAK,IAAU,EAAE;MACxB,MAAMM,QAAQ,GAAG,IAAI,CAACpB,SAAS,EAAoB;MAEnD,CACEoB,QAAQ,CAACW,cAAc,EAEvB5E,IAAI,CAAC0D,SAAS,CACf,GAAG,IAAI,CAACD,oCAAoC,EAAE;MAE/CzD,IAAI,CAAC2E,UAAU,GAAGV,QAAQ,CAACW,cAAc,GACrC,IAAI,CAACpB,UAAU,CAACS,QAAQ,EAAE,gBAAgB,CAAC,GAC3C,IAAI;IACV;IAEA,OAAO,KAAK,CAAC8K,0BAA0B,CAAC/O,IAAI,EAAEH,IAAI,EAAEgP,QAAQ,CAAC;EAC/D;EAGAG,kBAAkBA,CAACC,KAAyB,EAAe;IAEzD,IAAI,IAAI,CAACzM,KAAK,CAAC0M,MAAM,IAAI,IAAI,CAACtJ,YAAY,KAAe,EAAE;MACzD,MAAMuE,SAAS,GAAG,IAAI,CAACA,SAAS,EAAE;MAClC,IAAI,IAAAhK,iCAA0B,EAACgK,SAAS,CAACtK,IAAI,CAAC,EAAE;QAC9C,MAAMG,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAmB;QAC9C,IAAI,CAACG,IAAI,EAAE;QACX,OAAO,IAAI,CAACuF,kBAAkB,CAACvI,IAAI,CAAC;MACtC;IACF,CAAC,MAAM,IAAI,IAAI,CAAC4B,gBAAgB,EAAE,IAAI,IAAI,CAACgE,YAAY,KAAU,EAAE;MACjE,MAAM5F,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAE;MAC7B,IAAI,CAACG,IAAI,EAAE;MACX,OAAO,IAAI,CAACmM,wBAAwB,CAACnP,IAAI,CAAC;IAC5C;IACA,MAAMoP,IAAI,GAAG,KAAK,CAACJ,kBAAkB,CAACC,KAAK,CAAC;IAE5C,IAAI,IAAI,CAAC3N,UAAU,KAAKC,SAAS,IAAI,CAAC,IAAI,CAAC8N,gBAAgB,CAACD,IAAI,CAAC,EAAE;MACjE,IAAI,CAAC9N,UAAU,GAAG,IAAI;IACxB;IACA,OAAO8N,IAAI;EACb;EAGAE,wBAAwBA,CACtBtP,IAA2B,EAC3BuP,IAAkB,EAClBC,UAAgC,EACT;IACvB,IAAID,IAAI,CAAC1P,IAAI,KAAK,YAAY,EAAE;MAC9B,IAAI0P,IAAI,CAACtK,IAAI,KAAK,SAAS,EAAE;QAC3B,IACE,IAAI,CAACtB,KAAK,IAAW,IACrB,IAAA0J,wBAAiB,EAAC,IAAI,CAAC7K,KAAK,CAAC3C,IAAI,CAAC,IAClC,IAAI,CAAC8D,KAAK,IAAc,IACxB,IAAI,CAACA,KAAK,IAAS,IACnB,IAAI,CAACA,KAAK,IAAY,EACtB;UAEA,OAAO,IAAI,CAAC0B,gBAAgB,CAACrF,IAAI,CAAC;QACpC;MACF,CAAC,MAAM,IAAI,IAAAqN,wBAAiB,EAAC,IAAI,CAAC7K,KAAK,CAAC3C,IAAI,CAAC,EAAE;QAC7C,IAAI0P,IAAI,CAACtK,IAAI,KAAK,WAAW,EAAE;UAE7B,OAAO,IAAI,CAACsD,kBAAkB,CAACvI,IAAI,CAAC;QACtC,CAAC,MAAM,IAAIuP,IAAI,CAACtK,IAAI,KAAK,MAAM,EAAE;UAE/B,OAAO,IAAI,CAACoC,kBAAkB,CAACrH,IAAI,CAAC;QACtC,CAAC,MAAM,IAAIuP,IAAI,CAACtK,IAAI,KAAK,QAAQ,EAAE;UAEjC,OAAO,IAAI,CAACqC,mBAAmB,CAACtH,IAAI,EAAE,KAAK,CAAC;QAC9C;MACF;IACF;IAEA,OAAO,KAAK,CAACsP,wBAAwB,CAACtP,IAAI,EAAEuP,IAAI,EAAEC,UAAU,CAAC;EAC/D;EAGAC,4BAA4BA,CAAA,EAAY;IACtC,MAAM;MAAE5P;IAAK,CAAC,GAAG,IAAI,CAAC2C,KAAK;IAC3B,IACE,IAAAkN,yCAAkC,EAAC7P,IAAI,CAAC,IACvC,IAAI,CAAC+B,gBAAgB,EAAE,IAAI/B,IAAI,QAAc,EAC9C;MACA,OAAO,CAAC,IAAI,CAAC2C,KAAK,CAACmN,WAAW;IAChC;IACA,OAAO,KAAK,CAACF,4BAA4B,EAAE;EAC7C;EAEAG,wBAAwBA,CAAA,EAAY;IAClC,MAAM;MAAE/P;IAAK,CAAC,GAAG,IAAI,CAAC2C,KAAK;IAC3B,IACE,IAAAkN,yCAAkC,EAAC7P,IAAI,CAAC,IACvC,IAAI,CAAC+B,gBAAgB,EAAE,IAAI/B,IAAI,QAAc,EAC9C;MACA,OAAO,IAAI,CAAC2C,KAAK,CAACmN,WAAW;IAC/B;IAEA,OAAO,KAAK,CAACC,wBAAwB,EAAE;EACzC;EAEAC,4BAA4BA,CAAA,EAAiC;IAC3D,IAAI,IAAI,CAACjO,gBAAgB,EAAE,IAAI,IAAI,CAACgE,YAAY,KAAU,EAAE;MAC1D,MAAM5F,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAE;MAC7B,IAAI,CAACG,IAAI,EAAE;MACX,OAAO,IAAI,CAACmM,wBAAwB,CAACnP,IAAI,CAAC;IAC5C;IACA,OAAO,KAAK,CAAC6P,4BAA4B,EAAE;EAC7C;EAEAC,gBAAgBA,CACdP,IAAkB,EAElBxM,QAAkB,EAClBgN,mBAA6C,EAC/B;IACd,IAAI,CAAC,IAAI,CAACpM,KAAK,IAAa,EAAE,OAAO4L,IAAI;IAEzC,IAAI,IAAI,CAAC/M,KAAK,CAACwN,sBAAsB,EAAE;MACrC,MAAMC,MAAM,GAAG,IAAI,CAACC,iBAAiB,EAAE;MAIvC,IACED,MAAM,OAAoB,IAC1BA,MAAM,OAAuB,IAC7BA,MAAM,OAAoB,IAC1BA,MAAM,OAA+B,EACrC;QAEA,IAAI,CAACE,0BAA0B,CAACJ,mBAAmB,CAAC;QACpD,OAAOR,IAAI;MACb;IACF;IAEA,IAAI,CAAC7M,MAAM,IAAa;IACxB,MAAMF,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC4N,KAAK,EAAE;IAChC,MAAMC,iBAAiB,GAAG,IAAI,CAAC7N,KAAK,CAAC8N,SAAS;IAC9C,MAAMtQ,IAAI,GAAG,IAAI,CAACyK,WAAW,CAAC1H,QAAQ,CAAC;IACvC,IAAI;MAAEwN,UAAU;MAAEC;IAAO,CAAC,GAAG,IAAI,CAACC,6BAA6B,EAAE;IACjE,IAAI,CAACC,KAAK,EAAEC,OAAO,CAAC,GAAG,IAAI,CAACC,uBAAuB,CAACL,UAAU,CAAC;IAE/D,IAAIC,MAAM,IAAIG,OAAO,CAAC7P,MAAM,GAAG,CAAC,EAAE;MAChC,MAAMwP,SAAS,GAAG,CAAC,GAAGD,iBAAiB,CAAC;MAExC,IAAIM,OAAO,CAAC7P,MAAM,GAAG,CAAC,EAAE;QACtB,IAAI,CAAC0B,KAAK,GAAGA,KAAK;QAClB,IAAI,CAACA,KAAK,CAAC8N,SAAS,GAAGA,SAAS;QAEhC,KAAK,IAAIzP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8P,OAAO,CAAC7P,MAAM,EAAED,CAAC,EAAE,EAAE;UACvCyP,SAAS,CAACvP,IAAI,CAAC4P,OAAO,CAAC9P,CAAC,CAAC,CAACuE,KAAK,CAAC;QAClC;QAEA,CAAC;UAAEmL,UAAU;UAAEC;QAAO,CAAC,GAAG,IAAI,CAACC,6BAA6B,EAAE;QAC9D,CAACC,KAAK,EAAEC,OAAO,CAAC,GAAG,IAAI,CAACC,uBAAuB,CAACL,UAAU,CAAC;MAC7D;MAEA,IAAIC,MAAM,IAAIE,KAAK,CAAC5P,MAAM,GAAG,CAAC,EAAE;QAM9B,IAAI,CAACsC,KAAK,CAACtH,UAAU,CAACE,yBAAyB,EAAE;UAC/CqH,EAAE,EAAEb,KAAK,CAACO;QACZ,CAAC,CAAC;MACJ;MAEA,IAAIyN,MAAM,IAAIE,KAAK,CAAC5P,MAAM,KAAK,CAAC,EAAE;QAChC,IAAI,CAAC0B,KAAK,GAAGA,KAAK;QAClB8N,SAAS,CAACvP,IAAI,CAAC2P,KAAK,CAAC,CAAC,CAAC,CAACtL,KAAK,CAAC;QAC9B,IAAI,CAAC5C,KAAK,CAAC8N,SAAS,GAAGA,SAAS;QAChC,CAAC;UAAEC,UAAU;UAAEC;QAAO,CAAC,GAAG,IAAI,CAACC,6BAA6B,EAAE;MAChE;IACF;IAEA,IAAI,CAACG,uBAAuB,CAACL,UAAU,EAAE,IAAI,CAAC;IAE9C,IAAI,CAAC/N,KAAK,CAAC8N,SAAS,GAAGD,iBAAiB;IACxC,IAAI,CAAC3N,MAAM,IAAU;IAErB1C,IAAI,CAACU,IAAI,GAAG6O,IAAI;IAChBvP,IAAI,CAACuQ,UAAU,GAAGA,UAAU;IAC5BvQ,IAAI,CAAC6Q,SAAS,GAAG,IAAI,CAAC/B,gCAAgC,CAAC9O,IAAI,EAAE,MAC3D,IAAI,CAAC8Q,gBAAgB,CAACvP,SAAS,EAAEA,SAAS,CAAC,CAC5C;IAED,OAAO,IAAI,CAACiC,UAAU,CAACxD,IAAI,EAAE,uBAAuB,CAAC;EACvD;EAEAyQ,6BAA6BA,CAAA,EAG3B;IACA,IAAI,CAACjO,KAAK,CAACuO,yBAAyB,CAAChQ,IAAI,CAAC,IAAI,CAACyB,KAAK,CAAC4C,KAAK,CAAC;IAE3D,MAAMmL,UAAU,GAAG,IAAI,CAACS,uBAAuB,EAAE;IACjD,MAAMR,MAAM,GAAG,CAAC,IAAI,CAAC7M,KAAK,IAAU;IAEpC,IAAI,CAACnB,KAAK,CAACuO,yBAAyB,CAACE,GAAG,EAAE;IAE1C,OAAO;MAAEV,UAAU;MAAEC;IAAO,CAAC;EAC/B;EASAI,uBAAuBA,CACrB5Q,IAAkB,EAClBkR,eAAyB,EACmC;IAC5D,MAAMC,KAAK,GAAG,CAACnR,IAAI,CAAC;IACpB,MAAMoR,MAAmC,GAAG,EAAE;IAE9C,OAAOD,KAAK,CAACrQ,MAAM,KAAK,CAAC,EAAE;MACzB,MAAMd,IAAI,GAAGmR,KAAK,CAACF,GAAG,EAAE;MACxB,IAAIjR,IAAI,CAACH,IAAI,KAAK,yBAAyB,EAAE;QAC3C,IAAIG,IAAI,CAACmE,cAAc,IAAI,CAACnE,IAAI,CAAC2E,UAAU,EAAE;UAG3C,IAAI,CAAC0M,qBAAqB,CAACrR,IAAI,CAAC;QAClC,CAAC,MAAM;UAELoR,MAAM,CAACrQ,IAAI,CAACf,IAAI,CAAC;QACnB;QACAmR,KAAK,CAACpQ,IAAI,CAACf,IAAI,CAACwG,IAAI,CAAC;MACvB,CAAC,MAAM,IAAIxG,IAAI,CAACH,IAAI,KAAK,uBAAuB,EAAE;QAChDsR,KAAK,CAACpQ,IAAI,CAACf,IAAI,CAACuQ,UAAU,CAAC;QAC3BY,KAAK,CAACpQ,IAAI,CAACf,IAAI,CAAC6Q,SAAS,CAAC;MAC5B;IACF;IAEA,IAAIK,eAAe,EAAE;MACnBE,MAAM,CAACvK,OAAO,CAAC7G,IAAI,IAAI,IAAI,CAACqR,qBAAqB,CAACrR,IAAI,CAAC,CAAC;MACxD,OAAO,CAACoR,MAAM,EAAE,EAAE,CAAC;IACrB;IAEA,OAAO5Q,SAAS,CAAC4Q,MAAM,EAAEpR,IAAI,IAC3BA,IAAI,CAACuE,MAAM,CAAC+M,KAAK,CAAClD,KAAK,IAAI,IAAI,CAACmD,YAAY,CAACnD,KAAK,EAAE,IAAI,CAAC,CAAC,CAC3D;EACH;EAEAiD,qBAAqBA,CAACrR,IAA+B,EAAE;IAAA,IAAAwR,WAAA;IACrD,IAAI,CAACC,gBAAgB,CAGnBzR,IAAI,CAACuE,MAAM,GAAAiN,WAAA,GACXxR,IAAI,CAAC0R,KAAK,qBAAVF,WAAA,CAAYG,gBAAgB,EAChB,KAAK,CAClB;IAED,IAAI,CAAC5M,KAAK,CAACqB,KAAK,CAACwL,0BAAc,GAAGC,uBAAW,CAAC;IAE9C,KAAK,CAACC,WAAW,CAAC9R,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC;IACpC,IAAI,CAAC+E,KAAK,CAAC2B,IAAI,EAAE;EACnB;EAEAoI,gCAAgCA,CAC9B9O,IAAoB,EACpB+R,KAAc,EACX;IACH,IAAIC,MAAS;IACb,IAAI,IAAI,CAACxP,KAAK,CAACuO,yBAAyB,CAACkB,OAAO,CAACjS,IAAI,CAACoF,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;MACnE,IAAI,CAAC5C,KAAK,CAACuO,yBAAyB,CAAChQ,IAAI,CAAC,IAAI,CAACyB,KAAK,CAAC4C,KAAK,CAAC;MAC3D4M,MAAM,GAAGD,KAAK,EAAE;MAChB,IAAI,CAACvP,KAAK,CAACuO,yBAAyB,CAACE,GAAG,EAAE;IAC5C,CAAC,MAAM;MACLe,MAAM,GAAGD,KAAK,EAAE;IAClB;IAEA,OAAOC,MAAM;EACf;EAEAE,cAAcA,CACZlS,IAAkB,EAElB+C,QAAkB,EACJ;IACd/C,IAAI,GAAG,KAAK,CAACkS,cAAc,CAAClS,IAAI,EAAE+C,QAAQ,CAAC;IAC3C,IAAI,IAAI,CAACO,GAAG,IAAa,EAAE;MACzBtD,IAAI,CAACuK,QAAQ,GAAG,IAAI;MAIpB,IAAI,CAAC1F,gBAAgB,CAAC7E,IAAI,CAAC;IAC7B;IAEA,IAAI,IAAI,CAAC2D,KAAK,IAAU,EAAE;MACxB,MAAMwO,YAAY,GAAG,IAAI,CAAC1H,WAAW,CAAC1H,QAAQ,CAAC;MAC/CoP,YAAY,CAAC1D,UAAU,GAAGzO,IAAI;MAC9BmS,YAAY,CAACvN,cAAc,GAAG,IAAI,CAACuC,uBAAuB,EAAE;MAE5D,OAAO,IAAI,CAAC3D,UAAU,CAAC2O,YAAY,EAAE,oBAAoB,CAAC;IAC5D;IAEA,OAAOnS,IAAI;EACb;EAEAoS,uBAAuBA,CAACpS,IAAY,EAAE;IACpC,IACGA,IAAI,CAACH,IAAI,KAAK,mBAAmB,KAC/BG,IAAI,CAACC,UAAU,KAAK,MAAM,IAAID,IAAI,CAACC,UAAU,KAAK,QAAQ,CAAC,IAC7DD,IAAI,CAACH,IAAI,KAAK,wBAAwB,IACrCG,IAAI,CAACkH,UAAU,KAAK,MAAO,IAC5BlH,IAAI,CAACH,IAAI,KAAK,sBAAsB,IAAIG,IAAI,CAACkH,UAAU,KAAK,MAAO,EACpE;MAGA;IACF;IAEA,KAAK,CAACkL,uBAAuB,CAACpS,IAAI,CAAC;EACrC;EAEAiH,WAAWA,CACTjH,IAA+D,EAC/DwP,UAAgC,EACnB;IACb,MAAM6C,IAAI,GAAG,KAAK,CAACpL,WAAW,CAACjH,IAAI,EAAEwP,UAAU,CAAC;IAChD,IACE6C,IAAI,CAACxS,IAAI,KAAK,wBAAwB,IACtCwS,IAAI,CAACxS,IAAI,KAAK,sBAAsB,EACpC;MACAwS,IAAI,CAACnL,UAAU,GAAGmL,IAAI,CAACnL,UAAU,IAAI,OAAO;IAC9C;IACA,OAAOmL,IAAI;EACb;EAEAC,sBAAsBA,CACpBtS,IAA8B,EACI;IAClC,IAAI,IAAI,CAAC4F,YAAY,KAAU,EAAE;MAC/B5F,IAAI,CAACkH,UAAU,GAAG,MAAM;MAExB,MAAMqL,eAAe,GAAG,IAAI,CAAC1P,SAAS,EAAE;MACxC,IAAI,CAACG,IAAI,EAAE;MAEX,IAAI,IAAI,CAACW,KAAK,GAAW,EAAE;QAEzB3D,IAAI,CAACwS,UAAU,GAAG,IAAI,CAACC,qBAAqB,CACrB,IAAI,CAC1B;QACD,KAAK,CAACC,eAAe,CAAC1S,IAAI,CAAC;QAC3B,OAAO,IAAI;MACb,CAAC,MAAM;QAGL,OAAO,IAAI,CAACqH,kBAAkB,CAACkL,eAAe,CAAC;MACjD;IACF,CAAC,MAAM,IAAI,IAAI,CAAC3M,YAAY,KAAY,EAAE;MACxC5F,IAAI,CAACkH,UAAU,GAAG,MAAM;MAExB,MAAMqL,eAAe,GAAG,IAAI,CAAC1P,SAAS,EAAE;MACxC,IAAI,CAACG,IAAI,EAAE;MAGX,OAAO,IAAI,CAACsE,mBAAmB,CAACiL,eAAe,EAAE,KAAK,CAAC;IACzD,CAAC,MAAM,IAAI,IAAI,CAAC3M,YAAY,KAAe,EAAE;MAC3C5F,IAAI,CAACkH,UAAU,GAAG,MAAM;MACxB,MAAMqL,eAAe,GAAG,IAAI,CAAC1P,SAAS,EAAE;MACxC,IAAI,CAACG,IAAI,EAAE;MAEX,OAAO,IAAI,CAACuF,kBAAkB,CAACgK,eAAe,CAAC;IACjD,CAAC,MAAM,IAAI,IAAI,CAAC3Q,gBAAgB,EAAE,IAAI,IAAI,CAACgE,YAAY,KAAU,EAAE;MACjE5F,IAAI,CAACkH,UAAU,GAAG,OAAO;MACzB,MAAMqL,eAAe,GAAG,IAAI,CAAC1P,SAAS,EAAE;MACxC,IAAI,CAACG,IAAI,EAAE;MAEX,OAAO,IAAI,CAACmM,wBAAwB,CAACoD,eAAe,CAAC;IACvD,CAAC,MAAM;MACL,OAAO,KAAK,CAACD,sBAAsB,CAACtS,IAAI,CAAC;IAC3C;EACF;EAEA2S,aAAaA,CAAC3S,IAAY,EAAW;IACnC,IAAI,KAAK,CAAC2S,aAAa,CAAC3S,IAAI,CAAC,EAAE,OAAO,IAAI;IAE1C,IAAI,IAAI,CAAC4F,YAAY,KAAU,IAAI,IAAI,CAACuE,SAAS,EAAE,CAACtK,IAAI,OAAY,EAAE;MACpEG,IAAI,CAACkH,UAAU,GAAG,MAAM;MACxB,IAAI,CAAClE,IAAI,EAAE;MACX,IAAI,CAACA,IAAI,EAAE;MACX,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd;EAEA4P,kCAAkCA,CAAC5S,IAAY,EAAW;IACxD,MAAM;MAAE+C;IAAS,CAAC,GAAG,IAAI,CAACP,KAAK;IAC/B,MAAMqQ,YAAY,GAAG,KAAK,CAACD,kCAAkC,CAAC5S,IAAI,CAAC;IACnE,IAAI6S,YAAY,IAAI7S,IAAI,CAACkH,UAAU,KAAK,MAAM,EAAE;MAC9C,IAAI,CAACjB,UAAU,CAAClD,QAAQ,CAAC;IAC3B;IACA,OAAO8P,YAAY;EACrB;EAEAC,YAAYA,CACV9S,IAAa,EACb+S,WAAoB,EACpBC,UAA2B,EAC3B;IACA,KAAK,CAACF,YAAY,CAAC9S,IAAI,EAAE+S,WAAW,EAAEC,UAAU,CAAC;IACjD,IAAI,IAAI,CAACrP,KAAK,IAAO,EAAE;MACrB3D,IAAI,CAACmE,cAAc,GAAG,IAAI,CAACC,iCAAiC,EAAE;IAChE;EACF;EAEA6O,gBAAgBA,CACdC,SAAsB,EACtBC,MAAW,EACX3Q,KAA8B,EACxB;IACN,MAAM;MAAEO;IAAS,CAAC,GAAG,IAAI,CAACP,KAAK;IAC/B,IAAI,IAAI,CAACoD,YAAY,KAAa,EAAE;MAClC,IAAI,KAAK,CAACwN,4BAA4B,CAACF,SAAS,EAAEC,MAAM,CAAC,EAAE;QAEzD;MACF;MAEAA,MAAM,CAACrK,OAAO,GAAG,IAAI;IACvB;IAEA,KAAK,CAACmK,gBAAgB,CAACC,SAAS,EAAEC,MAAM,EAAE3Q,KAAK,CAAC;IAEhD,IAAI2Q,MAAM,CAACrK,OAAO,EAAE;MAClB,IACEqK,MAAM,CAACtT,IAAI,KAAK,eAAe,IAC/BsT,MAAM,CAACtT,IAAI,KAAK,sBAAsB,IACtCsT,MAAM,CAACtT,IAAI,KAAK,oBAAoB,EACpC;QACA,IAAI,CAACuD,KAAK,CAACtH,UAAU,CAACM,mBAAmB,EAAE;UAAEiH,EAAE,EAAEN;QAAS,CAAC,CAAC;MAC9D,CAAC,MAAM,IAAIoQ,MAAM,CAAChR,KAAK,EAAE;QACvB,IAAI,CAACiB,KAAK,CAACtH,UAAU,CAACO,4BAA4B,EAAE;UAClDgH,EAAE,EAAE8P,MAAM,CAAChR;QACb,CAAC,CAAC;MACJ;IACF;EACF;EAEAkR,UAAUA,CAAC5K,IAAY,EAAW;IAChC,OAAOA,IAAI,KAAK,UAAU,IAAIA,IAAI,KAAK,eAAe;EACxD;EAEA6K,YAAYA,CAAA,EAAS;IACnB,MAAM7K,IAAI,GAAG,KAAK,CAAC8K,SAAS,EAAE;IAC9B,MAAMC,QAAQ,GAAG,IAAI,GAAG/K,IAAI;IAG5B,IAAI,CAAC,IAAI,CAAC4K,UAAU,CAAC5K,IAAI,CAAC,IAAI,CAAC,IAAI,CAACjG,KAAK,CAACC,MAAM,EAAE;MAChD,IAAI,CAACW,KAAK,CAAC8I,kBAAM,CAACuH,iBAAiB,EAAE;QACnCpQ,EAAE,EAAE,IAAI,CAACb,KAAK,CAACkR,WAAW,EAAE;QAC5BC,cAAc,EAAEH;MAClB,CAAC,CAAC;IACJ;IAEA,IAAI,CAAC3R,WAAW,MAAU2R,QAAQ,CAAC;EACrC;EAGAI,gBAAgBA,CAACC,IAAY,EAAQ;IACnC,MAAM7Q,IAAI,GAAG,IAAI,CAAC8Q,KAAK,CAACC,UAAU,CAAC,IAAI,CAACvR,KAAK,CAACsK,GAAG,GAAG,CAAC,CAAC;IACtD,IAAI+G,IAAI,QAA6B,IAAI7Q,IAAI,QAA0B,EAAE;MACvE,IAAI,CAACgR,QAAQ,IAAe,CAAC,CAAC;IAChC,CAAC,MAAM,IACL,IAAI,CAACxR,KAAK,CAACC,MAAM,KAChBoR,IAAI,OAA0B,IAAIA,IAAI,OAAuB,CAAC,EAC/D;MACA,IAAI,CAACG,QAAQ,CAACH,IAAI,OAA0B,UAAgB,EAAE,CAAC,CAAC;IAClE,CAAC,MAAM,IAAI,IAAI,CAACrR,KAAK,CAACC,MAAM,IAAIoR,IAAI,OAA2B,EAAE;MAC/D,IAAI7Q,IAAI,OAAkB,EAAE;QAC1B,IAAI,CAACgR,QAAQ,KAAiB,CAAC,CAAC;MAClC,CAAC,MAAM;QAEL,IAAI,CAACA,QAAQ,KAAc,CAAC,CAAC;MAC/B;IACF,CAAC,MAAM,IACL,IAAAC,2BAAe,EAACJ,IAAI,EAAE7Q,IAAI,EAAE,IAAI,CAAC8Q,KAAK,CAACC,UAAU,CAAC,IAAI,CAACvR,KAAK,CAACsK,GAAG,GAAG,CAAC,CAAC,CAAC,EACtE;MACA,IAAI,CAACtK,KAAK,CAACsK,GAAG,IAAI,CAAC;MACnB,IAAI,CAACwG,YAAY,EAAE;IACrB,CAAC,MAAM;MACL,KAAK,CAACM,gBAAgB,CAACC,IAAI,CAAC;IAC9B;EACF;EAEAtC,YAAYA,CAACvR,IAAY,EAAEkU,SAAmB,EAAW;IACvD,IAAIlU,IAAI,CAACH,IAAI,KAAK,oBAAoB,EAAE;MACtC,OAAO,IAAI,CAAC0R,YAAY,CAACvR,IAAI,CAACyO,UAAU,EAAEyF,SAAS,CAAC;IACtD,CAAC,MAAM;MACL,OAAO,KAAK,CAAC3C,YAAY,CAACvR,IAAI,EAAEkU,SAAS,CAAC;IAC5C;EACF;EAEAC,YAAYA,CAACnU,IAAY,EAAEoU,KAAc,GAAG,KAAK,EAAQ;IACvD,IACE,CAACA,KAAK,IACNpU,IAAI,CAACH,IAAI,KAAK,sBAAsB,IACpCG,IAAI,CAACqU,IAAI,CAACxU,IAAI,KAAK,oBAAoB,EACvC;MACAG,IAAI,CAACqU,IAAI,GAAG,IAAI,CAAC7F,mBAAmB,CAACxO,IAAI,CAACqU,IAAI,CAAC;IACjD;IACA,KAAK,CAACF,YAAY,CAACnU,IAAI,EAAEoU,KAAK,CAAC;EACjC;EAGA3C,gBAAgBA,CACd6C,QAAwB,EACxB3C,gBAA6C,EAC7CyC,KAAc,EACR;IACN,KAAK,IAAIvT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyT,QAAQ,CAACxT,MAAM,EAAED,CAAC,EAAE,EAAE;MACxC,MAAM0O,IAAI,GAAG+E,QAAQ,CAACzT,CAAC,CAAC;MACxB,IAAI,CAAA0O,IAAI,oBAAJA,IAAI,CAAE1P,IAAI,MAAK,oBAAoB,EAAE;QACvCyU,QAAQ,CAACzT,CAAC,CAAC,GAAG,IAAI,CAAC2N,mBAAmB,CAACe,IAAI,CAAC;MAC9C;IACF;IACA,KAAK,CAACkC,gBAAgB,CAAC6C,QAAQ,EAAE3C,gBAAgB,EAAEyC,KAAK,CAAC;EAC3D;EAIAG,gBAAgBA,CACdD,QAAwD,EACxDE,mBAA6B,EACmB;IAChD,KAAK,IAAI3T,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyT,QAAQ,CAACxT,MAAM,EAAED,CAAC,EAAE,EAAE;MAAA,IAAA4T,WAAA;MACxC,MAAMlF,IAAI,GAAG+E,QAAQ,CAACzT,CAAC,CAAC;MACxB,IACE0O,IAAI,IACJA,IAAI,CAAC1P,IAAI,KAAK,oBAAoB,IAClC,GAAA4U,WAAA,GAAClF,IAAI,CAACmC,KAAK,aAAV+C,WAAA,CAAYC,aAAa,MACzBJ,QAAQ,CAACxT,MAAM,GAAG,CAAC,IAAI,CAAC0T,mBAAmB,CAAC,EAC7C;QACA,IAAI,CAACpR,KAAK,CAACtH,UAAU,CAACgD,iBAAiB,EAAE;UACvCuE,EAAE,EAAEkM,IAAI,CAAC3K;QACX,CAAC,CAAC;MACJ;IACF;IAEA,OAAO0P,QAAQ;EACjB;EAEAK,cAAcA,CACZC,KAAgB,EAChBC,YAAqB,EACrBC,OAAgB,EAChB/E,mBAA6C,EACN;IACvC,MAAM/P,IAAI,GAAG,KAAK,CAAC2U,cAAc,CAC/BC,KAAK,EACLC,YAAY,EACZC,OAAO,EACP/E,mBAAmB,CACpB;IAOD,IAAI8E,YAAY,IAAI,CAAC,IAAI,CAACrS,KAAK,CAACwN,sBAAsB,EAAE;MACtD,IAAI,CAACuE,gBAAgB,CAACvU,IAAI,CAAC+U,QAAQ,CAAC;IACtC;IAEA,OAAO/U,IAAI;EACb;EAEAgV,WAAWA,CAACnV,IAAY,EAAEoV,eAAwB,EAAEC,OAAqB,EAAE;IACzE,OACErV,IAAI,KAAK,oBAAoB,IAC7B,KAAK,CAACmV,WAAW,CAACnV,IAAI,EAAEoV,eAAe,EAAEC,OAAO,CAAC;EAErD;EAGAC,kBAAkBA,CAACnV,IAAqB,EAAmB;IACzD,IAAI,IAAI,CAAC2D,KAAK,IAAU,EAAE;MAExB3D,IAAI,CAAC4E,cAAc,GAAG,IAAI,CAACuC,uBAAuB,EAAE;IACtD;IACA,OAAO,KAAK,CAACgO,kBAAkB,CAACnV,IAAI,CAAC;EACvC;EAEAoV,yBAAyBA,CACvBpV,IAA4B,EACJ;IACxB,IAAI,IAAI,CAAC2D,KAAK,IAAU,EAAE;MAExB3D,IAAI,CAAC4E,cAAc,GAAG,IAAI,CAACuC,uBAAuB,EAAE;IACtD;IACA,OAAO,KAAK,CAACiO,yBAAyB,CAACpV,IAAI,CAAC;EAC9C;EAGAqV,aAAaA,CAAA,EAAY;IACvB,OAAO,IAAI,CAAC1R,KAAK,IAAO,IAAI,KAAK,CAAC0R,aAAa,EAAE;EACnD;EAGAC,eAAeA,CAAA,EAAY;IACzB,OAAO,IAAI,CAAC3R,KAAK,IAAU,IAAI,KAAK,CAAC2R,eAAe,EAAE;EACxD;EAEAC,sBAAsBA,CAACjL,MAAuC,EAAW;IACvE,OAAO,CAAC,IAAI,CAAC3G,KAAK,IAAU,IAAI,KAAK,CAAC4R,sBAAsB,CAACjL,MAAM,CAAC;EACtE;EAGAkL,eAAeA,CACbtC,SAAsB,EACtB5I,MAAqB,EACrBmL,WAAoB,EACpBC,OAAgB,EAChBC,aAAsB,EACtBC,iBAA0B,EACpB;IACN,IAAKtL,MAAM,CAASlB,QAAQ,EAAE;MAC5B,IAAI,CAACnD,UAAU,CAAEqE,MAAM,CAASlB,QAAQ,CAACjE,GAAG,CAACC,KAAK,CAAC;IACrD;IACA,OAAQkF,MAAM,CAASlB,QAAQ;IAC/B,IAAI,IAAI,CAACzF,KAAK,IAAO,EAAE;MACrB2G,MAAM,CAACnG,cAAc,GAAG,IAAI,CAACC,iCAAiC,EAAE;IAClE;IAEA,KAAK,CAACoR,eAAe,CACnBtC,SAAS,EACT5I,MAAM,EACNmL,WAAW,EACXC,OAAO,EACPC,aAAa,EACbC,iBAAiB,CAClB;IAED,IAAItL,MAAM,CAAC/F,MAAM,IAAIoR,aAAa,EAAE;MAClC,MAAMpR,MAAM,GAAG+F,MAAM,CAAC/F,MAAM;MAC5B,IAAIA,MAAM,CAACzD,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC+U,WAAW,CAACtR,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;QACpD,IAAI,CAACnB,KAAK,CAACtH,UAAU,CAAC2C,4BAA4B,EAAE;UAAE4E,EAAE,EAAEiH;QAAO,CAAC,CAAC;MACrE;IAEF,CAAC,MAAM,IAELA,MAAM,CAACzK,IAAI,KAAK,kBAAkB,IAClC8V,aAAa,IAEbrL,MAAM,CAACnI,KAAK,CAACoC,MAAM,EACnB;MAEA,MAAMA,MAAM,GAAG+F,MAAM,CAACnI,KAAK,CAACoC,MAAM;MAClC,IAAIA,MAAM,CAACzD,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC+U,WAAW,CAACtR,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;QACpD,IAAI,CAACnB,KAAK,CAACtH,UAAU,CAAC2C,4BAA4B,EAAE;UAAE4E,EAAE,EAAEiH;QAAO,CAAC,CAAC;MACrE;IACF;EACF;EAEAwL,sBAAsBA,CACpB5C,SAAsB,EACtB5I,MAA4B,EAC5BmL,WAAoB,EACpBC,OAAgB,EACV;IACN,IAAKpL,MAAM,CAASlB,QAAQ,EAAE;MAC5B,IAAI,CAACnD,UAAU,CAAEqE,MAAM,CAASlB,QAAQ,CAACjE,GAAG,CAACC,KAAK,CAAC;IACrD;IACA,OAAQkF,MAAM,CAASlB,QAAQ;IAC/B,IAAI,IAAI,CAACzF,KAAK,IAAO,EAAE;MACrB2G,MAAM,CAACnG,cAAc,GAAG,IAAI,CAACC,iCAAiC,EAAE;IAClE;IAEA,KAAK,CAAC0R,sBAAsB,CAAC5C,SAAS,EAAE5I,MAAM,EAAEmL,WAAW,EAAEC,OAAO,CAAC;EACvE;EAGAK,eAAeA,CAAC/V,IAAa,EAAQ;IACnC,KAAK,CAAC+V,eAAe,CAAC/V,IAAI,CAAC;IAC3B,IAAIA,IAAI,CAACkB,UAAU,IAAI,IAAI,CAACyC,KAAK,IAAO,EAAE;MACxC3D,IAAI,CAACgW,mBAAmB,GAAG,IAAI,CAAC1N,mCAAmC,EAAE;IACvE;IACA,IAAI,IAAI,CAAC1C,YAAY,KAAgB,EAAE;MACrC,IAAI,CAAC5C,IAAI,EAAE;MACX,MAAMiT,WAAoC,GAAIjW,IAAI,CAAC6H,UAAU,GAAG,EAAG;MACnE,GAAG;QACD,MAAM7H,IAAI,GAAG,IAAI,CAAC6C,SAAS,EAAE;QAC7B7C,IAAI,CAAC+D,EAAE,GAAG,IAAI,CAACyD,6BAA6B,CAAa,IAAI,CAAC;QAC9D,IAAI,IAAI,CAAC7D,KAAK,IAAO,EAAE;UACrB3D,IAAI,CAACmE,cAAc,GAAG,IAAI,CAACmE,mCAAmC,EAAE;QAClE,CAAC,MAAM;UACLtI,IAAI,CAACmE,cAAc,GAAG,IAAI;QAC5B;QACA8R,WAAW,CAAClV,IAAI,CAAC,IAAI,CAACyC,UAAU,CAACxD,IAAI,EAAE,iBAAiB,CAAC,CAAC;MAC5D,CAAC,QAAQ,IAAI,CAACsD,GAAG,IAAU;IAC7B;EACF;EAEA4S,uBAAuBA,CAAC5L,MAAsC,EAAQ;IACpE,KAAK,CAAC4L,uBAAuB,CAAC5L,MAAM,CAAC;IACrC,MAAM/F,MAAM,GAAG,IAAI,CAAC4R,4BAA4B,CAAC7L,MAAM,CAAC;IACxD,IAAI/F,MAAM,CAACzD,MAAM,GAAG,CAAC,EAAE;MACrB,MAAMsN,KAAK,GAAG7J,MAAM,CAAC,CAAC,CAAC;MACvB,IAAI,IAAI,CAACsR,WAAW,CAACzH,KAAK,CAAC,IAAI9D,MAAM,CAAC3D,IAAI,KAAK,KAAK,EAAE;QACpD,IAAI,CAACvD,KAAK,CAACtH,UAAU,CAACyB,yBAAyB,EAAE;UAAE8F,EAAE,EAAE+K;QAAM,CAAC,CAAC;MACjE,CAAC,MAAM,IAAI,IAAI,CAACyH,WAAW,CAACzH,KAAK,CAAC,EAAE;QAClC,IAAI,CAAChL,KAAK,CAACtH,UAAU,CAACwC,yBAAyB,EAAE;UAAE+E,EAAE,EAAE+K;QAAM,CAAC,CAAC;MACjE;IACF;EACF;EAEAgI,+BAA+BA,CAC7BpW,IAA2C,EACrC;IACNA,IAAI,CAACoJ,QAAQ,GAAG,IAAI,CAACC,iBAAiB,EAAE;EAC1C;EAGAgN,iBAAiBA,CACfC,IAA+C,EAC/CvT,QAAqC,EACrC0S,WAAoB,EACpBC,OAAgB,EAChBa,SAAkB,EAClBC,UAAmB,EACnBzG,mBAA6C,EACV;IACnC,IAAKuG,IAAI,CAASlN,QAAQ,EAAE;MAC1B,IAAI,CAACnD,UAAU,CAAEqQ,IAAI,CAASlN,QAAQ,CAACjE,GAAG,CAACC,KAAK,CAAC;IACnD;IACA,OAAQkR,IAAI,CAASlN,QAAQ;IAE7B,IAAIjF,cAAc;IAGlB,IAAI,IAAI,CAACR,KAAK,IAAO,IAAI,CAAC6S,UAAU,EAAE;MACpCrS,cAAc,GAAG,IAAI,CAACC,iCAAiC,EAAE;MACzD,IAAI,CAAC,IAAI,CAACT,KAAK,IAAW,EAAE,IAAI,CAACsC,UAAU,EAAE;IAC/C;IAEA,MAAM+L,MAAM,GAAG,KAAK,CAACqE,iBAAiB,CACpCC,IAAI,EACJvT,QAAQ,EACR0S,WAAW,EACXC,OAAO,EACPa,SAAS,EACTC,UAAU,EACVzG,mBAAmB,CACpB;IAGD,IAAI5L,cAAc,EAAE;MAClB,CAAC6N,MAAM,CAAC7P,KAAK,IAAI6P,MAAM,EAAE7N,cAAc,GAAGA,cAAc;IAC1D;IACA,OAAO6N,MAAM;EACf;EAEAyE,4BAA4BA,CAACrI,KAAgB,EAAa;IACxD,IAAI,IAAI,CAAC9K,GAAG,IAAa,EAAE;MACzB,IAAI8K,KAAK,CAACvO,IAAI,KAAK,YAAY,EAAE;QAC/B,IAAI,CAACuD,KAAK,CAACtH,UAAU,CAACmC,iBAAiB,EAAE;UAAEoF,EAAE,EAAE+K;QAAM,CAAC,CAAC;MACzD;MACA,IAAI,IAAI,CAACyH,WAAW,CAACzH,KAAK,CAAC,EAAE;QAC3B,IAAI,CAAChL,KAAK,CAACtH,UAAU,CAAC4C,yBAAyB,EAAE;UAAE2E,EAAE,EAAE+K;QAAM,CAAC,CAAC;MACjE;MAECA,KAAK,CAAyB7D,QAAQ,GAAG,IAAI;IAChD;IACA,IAAI,IAAI,CAAC5G,KAAK,IAAU,EAAE;MAExByK,KAAK,CAACxJ,cAAc,GAAG,IAAI,CAACuC,uBAAuB,EAAE;IACvD,CAAC,MAAM,IAAI,IAAI,CAAC0O,WAAW,CAACzH,KAAK,CAAC,EAAE;MAClC,IAAI,CAAChL,KAAK,CAACtH,UAAU,CAAC0C,2BAA2B,EAAE;QAAE6E,EAAE,EAAE+K;MAAM,CAAC,CAAC;IACnE;IAEA,IAAI,IAAI,CAACzK,KAAK,IAAO,IAAI,IAAI,CAACkS,WAAW,CAACzH,KAAK,CAAC,EAAE;MAChD,IAAI,CAAChL,KAAK,CAACtH,UAAU,CAAC8C,kBAAkB,EAAE;QAAEyE,EAAE,EAAE+K;MAAM,CAAC,CAAC;IAC1D;IAEA,IAAI,CAACvJ,gBAAgB,CAACuJ,KAAK,CAAC;IAC5B,OAAOA,KAAK;EACd;EAEAsI,iBAAiBA,CACf3T,QAA0B,EAC1BsR,IAAuB,EACZ;IACX,MAAMrU,IAAI,GAAG,KAAK,CAAC0W,iBAAiB,CAAC3T,QAAQ,EAAEsR,IAAI,CAAC;IAEpD,IACErU,IAAI,CAACH,IAAI,KAAK,mBAAmB,IACjCG,IAAI,CAAC4E,cAAc,IACnB5E,IAAI,CAAC6I,KAAK,CAACzD,KAAK,GAAGpF,IAAI,CAAC4E,cAAc,CAACQ,KAAK,EAC5C;MACA,IAAI,CAAChC,KAAK,CAACtH,UAAU,CAAC+C,qBAAqB,EAAE;QAC3CwE,EAAE,EAAErD,IAAI,CAAC4E;MACX,CAAC,CAAC;IACJ;IAEA,OAAO5E,IAAI;EACb;EAEA2W,wBAAwBA,CAAC3W,IAAyB,EAAW;IAC3D,IAAI,CAACD,iBAAiB,CAACC,IAAI,CAAC,EAAE;MAC5B,OAAO,KAAK,CAAC2W,wBAAwB,CAAC3W,IAAI,CAAC;IAC7C;IAEA,OAAOE,oBAAoB,CAAC,IAAI,CAACsC,KAAK,CAAC3C,IAAI,CAAC;EAC9C;EAEA+W,qBAAqBA,CAAC5W,IAAiC,EAAE;IACvD,KAAK,CAAC4W,qBAAqB,CAAC5W,IAAI,CAAC;IACjC,IAAIA,IAAI,CAAC6W,MAAM,IAAI7W,IAAI,CAACC,UAAU,KAAK,OAAO,EAAE;MAC9C,IAAI,CAACmD,KAAK,CAACtH,UAAU,CAAC0B,6BAA6B,EAAE;QACnD6F,EAAE,EAAErD,IAAI,CAACwS,UAAU,CAAC,CAAC,CAAC,CAACrN,GAAG,CAACC;MAC7B,CAAC,CAAC;IACJ;EACF;EAEA0R,yBAAyBA,CAKvB9W,IAAyB,EAAE+W,SAAoB,EAAElX,IAAe,EAAQ;IACxEkX,SAAS,CAACC,KAAK,GAAGjX,iBAAiB,CAACC,IAAI,CAAC,GACrC,IAAI,CAACwH,6BAA6B,CAClB,IAAI,EACA,IAAI,CACvB,GACD,IAAI,CAACxD,eAAe,EAAE;IAE1BhE,IAAI,CAACwS,UAAU,CAACzR,IAAI,CAAC,IAAI,CAACkW,qBAAqB,CAACF,SAAS,EAAElX,IAAI,CAAC,CAAC;EACnE;EAGAqX,gCAAgCA,CAAClX,IAAyB,EAAW;IACnEA,IAAI,CAACC,UAAU,GAAG,OAAO;IAEzB,IAAI0G,IAAI,GAAG,IAAI;IACf,IAAI,IAAI,CAAChD,KAAK,IAAY,EAAE;MAC1BgD,IAAI,GAAG,QAAiB;IAC1B,CAAC,MAAM,IAAI,IAAI,CAACf,YAAY,KAAU,EAAE;MACtCe,IAAI,GAAG,MAAe;IACxB;IACA,IAAIA,IAAI,EAAE;MACR,MAAMqG,EAAE,GAAG,IAAI,CAAC7C,SAAS,EAAE;MAC3B,MAAM;QAAEtK;MAAK,CAAC,GAAGmN,EAAE;MAGnB,IAAIrG,IAAI,KAAK,MAAM,IAAI9G,IAAI,OAAY,EAAE;QAEvC,IAAI,CAACoG,UAAU,CAAC,IAAI,EAAE+G,EAAE,CAACnN,IAAI,CAAC;MAChC;MAEA,IACEK,oBAAoB,CAACL,IAAI,CAAC,IAC1BA,IAAI,MAAc,IAClBA,IAAI,OAAY,EAChB;QACA,IAAI,CAACmD,IAAI,EAAE;QACXhD,IAAI,CAACC,UAAU,GAAG0G,IAAI;MACxB;IACF;IAEA,OAAO,KAAK,CAACuQ,gCAAgC,CAAClX,IAAI,CAAC;EACrD;EAGAmX,oBAAoBA,CAClBJ,SAAc,EACdK,gBAAyB,EACzBC,kBAA2B,EAE3BC,eAAwB,EAExBC,WAAqC,EAClB;IACnB,MAAMC,UAAU,GAAGT,SAAS,CAACU,QAAQ;IAErC,IAAIC,iBAAiB,GAAG,IAAI;IAC5B,IAAIF,UAAU,CAAC3X,IAAI,KAAK,YAAY,EAAE;MACpC,IAAI2X,UAAU,CAACvS,IAAI,KAAK,MAAM,EAAE;QAC9ByS,iBAAiB,GAAG,MAAM;MAC5B,CAAC,MAAM,IAAIF,UAAU,CAACvS,IAAI,KAAK,QAAQ,EAAE;QACvCyS,iBAAiB,GAAG,QAAQ;MAC9B;IACF;IAEA,IAAIxD,SAAS,GAAG,KAAK;IACrB,IAAI,IAAI,CAACtO,YAAY,IAAQ,IAAI,CAAC,IAAI,CAAC+R,qBAAqB,CAAC,IAAI,CAAC,EAAE;MAClE,MAAMC,QAAQ,GAAG,IAAI,CAAC5T,eAAe,CAAC,IAAI,CAAC;MAC3C,IACE0T,iBAAiB,KAAK,IAAI,IAC1B,CAAC,IAAAvX,iCAA0B,EAAC,IAAI,CAACqC,KAAK,CAAC3C,IAAI,CAAC,EAC5C;QAEAkX,SAAS,CAACU,QAAQ,GAAGG,QAAQ;QAC7Bb,SAAS,CAAC9W,UAAU,GAAGyX,iBAAiB;QACxCX,SAAS,CAACC,KAAK,GAAG,IAAAa,qBAAe,EAACD,QAAQ,CAAC;MAC7C,CAAC,MAAM;QAELb,SAAS,CAACU,QAAQ,GAAGD,UAAU;QAC/BT,SAAS,CAAC9W,UAAU,GAAG,IAAI;QAC3B8W,SAAS,CAACC,KAAK,GAAG,IAAI,CAAChT,eAAe,EAAE;MAC1C;IACF,CAAC,MAAM;MACL,IACE0T,iBAAiB,KAAK,IAAI,IAC1B,IAAAvX,iCAA0B,EAAC,IAAI,CAACqC,KAAK,CAAC3C,IAAI,CAAC,EAC3C;QAEAkX,SAAS,CAACU,QAAQ,GAAG,IAAI,CAACzT,eAAe,CAAC,IAAI,CAAC;QAC/C+S,SAAS,CAAC9W,UAAU,GAAGyX,iBAAiB;MAC1C,CAAC,MAAM;QACL,IAAIN,gBAAgB,EAAE;UAEpB,MAAM,IAAI,CAAChU,KAAK,CAAC8I,kBAAM,CAAC4L,qBAAqB,EAAE;YAC7CzU,EAAE,EAAE0T,SAAS;YACbgB,UAAU,EAAEP,UAAU,CAACrV;UACzB,CAAC,CAAC;QACJ;QAEA4U,SAAS,CAACU,QAAQ,GAAGD,UAAU;QAC/BT,SAAS,CAAC9W,UAAU,GAAG,IAAI;MAC7B;MAEA,IAAI,IAAI,CAACuF,aAAa,IAAQ,EAAE;QAC9BuR,SAAS,CAACC,KAAK,GAAG,IAAI,CAAChT,eAAe,EAAE;MAC1C,CAAC,MAAM;QACLkQ,SAAS,GAAG,IAAI;QAChB6C,SAAS,CAACC,KAAK,GAAG,IAAAa,qBAAe,EAACd,SAAS,CAACU,QAAQ,CAAC;MACvD;IACF;IAEA,MAAMO,qBAAqB,GAAGjY,iBAAiB,CAACgX,SAAS,CAAC;IAE1D,IAAIM,kBAAkB,IAAIW,qBAAqB,EAAE;MAC/C,IAAI,CAAC5U,KAAK,CAACtH,UAAU,CAAC2B,mCAAmC,EAAE;QACzD4F,EAAE,EAAE0T;MACN,CAAC,CAAC;IACJ;IAEA,IAAIM,kBAAkB,IAAIW,qBAAqB,EAAE;MAC/C,IAAI,CAACtP,iBAAiB,CACpBqO,SAAS,CAACC,KAAK,CAAC/R,IAAI,EACpB8R,SAAS,CAACC,KAAK,CAAC7R,GAAG,CAACC,KAAK,EACP,IAAI,CACvB;IACH;IAEA,IAAI8O,SAAS,IAAI,CAACmD,kBAAkB,IAAI,CAACW,qBAAqB,EAAE;MAC9D,IAAI,CAACC,iBAAiB,CACpBlB,SAAS,CAACC,KAAK,CAAC/R,IAAI,EACpB8R,SAAS,CAAC5R,GAAG,CAACC,KAAK,EACnB,IAAI,EACJ,IAAI,CACL;IACH;IAEA,OAAO,IAAI,CAAC6R,qBAAqB,CAACF,SAAS,EAAE,iBAAiB,CAAC;EACjE;EAEAmB,gBAAgBA,CAAA,EAAc;IAC5B,QAAQ,IAAI,CAAC1V,KAAK,CAAC3C,IAAI;MACrB;QAEE,OAAO,IAAI,CAACmE,eAAe,CAAe,IAAI,CAAC;MACjD;QACE,OAAO,KAAK,CAACkU,gBAAgB,EAAE;IAAC;EAEtC;EAGAC,mBAAmBA,CACjBnY,IAAwB,EACxB2V,aAAsB,EAChB;IAEN,MAAMhP,IAAI,GAAG3G,IAAI,CAAC2G,IAAI;IACtB,IAAIA,IAAI,KAAK,KAAK,IAAIA,IAAI,KAAK,KAAK,IAAI,IAAI,CAAChD,KAAK,IAAO,EAAE;MACzD3D,IAAI,CAACmE,cAAc,GAAG,IAAI,CAACC,iCAAiC,EAAE;IAChE;IACA,KAAK,CAAC+T,mBAAmB,CAACnY,IAAI,EAAE2V,aAAa,CAAC;EAChD;EAGAyC,UAAUA,CACR/F,IAA0B,EAC1B1L,IAA6B,EACvB;IACN,KAAK,CAACyR,UAAU,CAAC/F,IAAI,EAAE1L,IAAI,CAAC;IAC5B,IAAI,IAAI,CAAChD,KAAK,IAAU,EAAE;MAExB0O,IAAI,CAACtO,EAAE,CAACa,cAAc,GAAG,IAAI,CAACuC,uBAAuB,EAAE;MACvD,IAAI,CAACtC,gBAAgB,CAACwN,IAAI,CAACtO,EAAE,CAAC;IAChC;EACF;EAGAsU,iCAAiCA,CAC/BrY,IAA+B,EAC/BsY,IAAsB,EACK;IAC3B,IAAI,IAAI,CAAC3U,KAAK,IAAU,EAAE;MACxB,MAAM+F,qBAAqB,GAAG,IAAI,CAAClH,KAAK,CAACmH,kBAAkB;MAC3D,IAAI,CAACnH,KAAK,CAACmH,kBAAkB,GAAG,IAAI;MAEpC3J,IAAI,CAAC2E,UAAU,GAAG,IAAI,CAACwC,uBAAuB,EAAE;MAChD,IAAI,CAAC3E,KAAK,CAACmH,kBAAkB,GAAGD,qBAAqB;IACvD;IAEA,OAAO,KAAK,CAAC2O,iCAAiC,CAACrY,IAAI,EAAEsY,IAAI,CAAC;EAC5D;EAGAC,qBAAqBA,CAAA,EAAY;IAC/B,OAAO,IAAI,CAAC5U,KAAK,IAAU,IAAI,KAAK,CAAC4U,qBAAqB,EAAE;EAC9D;EAYAzH,gBAAgBA,CACdf,mBAA6C,EAC7CyI,cAAyB,EACX;IAAA,IAAAC,IAAA;IACd,IAAIjW,KAAK,GAAG,IAAI;IAEhB,IAAIkW,GAAG;IAEP,IACE,IAAI,CAACC,SAAS,CAAC,KAAK,CAAC,KACpB,IAAI,CAAChV,KAAK,KAAgB,IAAI,IAAI,CAACA,KAAK,IAAO,CAAC,EACjD;MACAnB,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC4N,KAAK,EAAE;MAE1BsI,GAAG,GAAG,IAAI,CAACE,QAAQ,CACjB,MAAM,KAAK,CAAC9H,gBAAgB,CAACf,mBAAmB,EAAEyI,cAAc,CAAC,EACjEhW,KAAK,CACN;MAID,IAAI,CAACkW,GAAG,CAACG,KAAK,EAAE,OAAOH,GAAG,CAAC1Y,IAAI;MAK/B,MAAM;QAAE8Y;MAAQ,CAAC,GAAG,IAAI,CAACtW,KAAK;MAC9B,MAAMuW,cAAc,GAAGD,OAAO,CAACA,OAAO,CAAChY,MAAM,GAAG,CAAC,CAAC;MAClD,IAAIiY,cAAc,KAAKC,cAAE,CAACC,MAAM,IAAIF,cAAc,KAAKC,cAAE,CAACE,MAAM,EAAE;QAChEJ,OAAO,CAAC7H,GAAG,EAAE;MACf;IACF;IAEA,IAAI,CAAAwH,IAAA,GAAAC,GAAG,aAAHD,IAAA,CAAKI,KAAK,IAAI,IAAI,CAAClV,KAAK,IAAO,EAAE;MAAA,IAAAwV,KAAA,EAAAC,KAAA;MACnC5W,KAAK,GAAGA,KAAK,IAAI,IAAI,CAACA,KAAK,CAAC4N,KAAK,EAAE;MAEnC,IAAIjM,cAA0C;MAE9C,MAAMkV,KAAK,GAAG,IAAI,CAACT,QAAQ,CAACU,KAAK,IAAI;QAAA,IAAAC,qBAAA;QACnCpV,cAAc,GAAG,IAAI,CAACC,iCAAiC,EAAE;QAEzD,MAAMoV,eAAe,GAAG,IAAI,CAAC1K,gCAAgC,CAC3D3K,cAAc,EACd,MAAM;UACJ,MAAM6N,MAAM,GAAG,KAAK,CAAClB,gBAAgB,CACnCf,mBAAmB,EACnByI,cAAc,CACf;UAED,IAAI,CAACiB,0BAA0B,CAACzH,MAAM,EAAE7N,cAAc,CAAC;UAEvD,OAAO6N,MAAM;QACf,CAAC,CACF;QAID,KAAAuH,qBAAA,GAAIC,eAAe,CAAC9H,KAAK,aAArB6H,qBAAA,CAAuB7E,aAAa,EAAE4E,KAAK,EAAE;QAKjD,MAAM/J,IAAI,GAAG,IAAI,CAACmK,6BAA6B,CAACF,eAAe,CAAC;QAEhE,IAAIjK,IAAI,CAAC1P,IAAI,KAAK,yBAAyB,EAAEyZ,KAAK,EAAE;QAEpD/J,IAAI,CAACpL,cAAc,GAAGA,cAAc;QACpC,IAAI,CAACsV,0BAA0B,CAAClK,IAAI,EAAEpL,cAAc,CAAC;QAErD,OAAOqV,eAAe;MACxB,CAAC,EAAEhX,KAAK,CAAC;MAET,IAAIgX,eAII,GAAG,IAAI;MAEf,IACEH,KAAK,CAACrZ,IAAI,IAEV,IAAI,CAAC0Z,6BAA6B,CAACL,KAAK,CAACrZ,IAAI,CAAC,CAACH,IAAI,KACjD,yBAAyB,EAC3B;QACA,IAAI,CAACwZ,KAAK,CAACR,KAAK,IAAI,CAACQ,KAAK,CAACM,OAAO,EAAE;UAGlC,IAAIN,KAAK,CAACrZ,IAAI,CAAC4Z,KAAK,EAAE;YAEpB,IAAI,CAACxW,KAAK,CACRtH,UAAU,CAACwD,+CAA+C,EAC1D;cAAE+D,EAAE,EAAEc;YAAe,CAAC,CACvB;UACH;UAEA,OAAOkV,KAAK,CAACrZ,IAAI;QACnB;QAGAwZ,eAAe,GAAGH,KAAK,CAACrZ,IAAI;MAC9B;MAQA,KAAAmZ,KAAA,GAAIT,GAAG,aAAHS,KAAA,CAAKnZ,IAAI,EAAE;QAEb,IAAI,CAACwC,KAAK,GAAGkW,GAAG,CAACmB,SAAS;QAC1B,OAAOnB,GAAG,CAAC1Y,IAAI;MACjB;MAEA,IAAIwZ,eAAe,EAAE;QAEnB,IAAI,CAAChX,KAAK,GAAG6W,KAAK,CAACQ,SAAS;QAC5B,OAAOL,eAAe;MACxB;MAEA,KAAAJ,KAAA,GAAIV,GAAG,aAAHU,KAAA,CAAKU,MAAM,EAAE,MAAMpB,GAAG,CAACG,KAAK;MAChC,IAAIQ,KAAK,CAACS,MAAM,EAAE,MAAMT,KAAK,CAACR,KAAK;MAGnC,MAAM,IAAI,CAACzV,KAAK,CAACtH,UAAU,CAACuD,iCAAiC,EAAE;QAC7DgE,EAAE,EAAEc;MACN,CAAC,CAAC;IACJ;IAEA,OAAO,KAAK,CAAC2M,gBAAgB,CAACf,mBAAmB,EAAEyI,cAAc,CAAC;EACpE;EAGAuB,UAAUA,CACR/Z,IAAuC,EACe;IACtD,IAAI,IAAI,CAAC2D,KAAK,IAAU,EAAE;MAExB,MAAMqO,MAAM,GAAG,IAAI,CAAC4G,QAAQ,CAAC,MAAM;QACjC,MAAMlP,qBAAqB,GAAG,IAAI,CAAClH,KAAK,CAACmH,kBAAkB;QAC3D,IAAI,CAACnH,KAAK,CAACmH,kBAAkB,GAAG,IAAI;QAEpC,MAAM1F,QAAQ,GAAG,IAAI,CAACpB,SAAS,EAAoB;QAEnD,CACEoB,QAAQ,CAACW,cAAc,EAEvB5E,IAAI,CAAC0D,SAAS,CACf,GAAG,IAAI,CAACD,oCAAoC,EAAE;QAE/C,IAAI,CAACjB,KAAK,CAACmH,kBAAkB,GAAGD,qBAAqB;QAErD,IAAI,IAAI,CAACoE,kBAAkB,EAAE,EAAE,IAAI,CAAC7H,UAAU,EAAE;QAChD,IAAI,CAAC,IAAI,CAACtC,KAAK,IAAU,EAAE,IAAI,CAACsC,UAAU,EAAE;QAE5C,OAAOhC,QAAQ;MACjB,CAAC,CAAC;MAEF,IAAI+N,MAAM,CAAC8H,MAAM,EAAE,OAAO,IAAI;MAG9B,IAAI9H,MAAM,CAAC6G,KAAK,EAAE,IAAI,CAACrW,KAAK,GAAGwP,MAAM,CAAC6H,SAAS;MAI/C7Z,IAAI,CAAC2E,UAAU,GAAGqN,MAAM,CAAChS,IAAI,CAAC4E,cAAc,GACxC,IAAI,CAACpB,UAAU,CAACwO,MAAM,CAAChS,IAAI,EAAE,gBAAgB,CAAC,GAC9C,IAAI;IACV;IAEA,OAAO,KAAK,CAAC+Z,UAAU,CAAC/Z,IAAI,CAAC;EAC/B;EAEAga,gBAAgBA,CAACzV,MAAqB,EAAW;IAC/C,OAAO,IAAI,CAACZ,KAAK,IAAU,IAAI,KAAK,CAACqW,gBAAgB,CAACzV,MAAM,CAAC;EAC/D;EAEA0V,0BAA0BA,CACxBja,IAA+B,EAC/BuE,MAAmB,EACb;IACN,IAAI,IAAI,CAAC/B,KAAK,CAACuO,yBAAyB,CAACkB,OAAO,CAACjS,IAAI,CAACoF,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;MACnEpF,IAAI,CAACuE,MAAM,GAAGA,MAAM;IACtB,CAAC,MAAM;MACL,KAAK,CAAC0V,0BAA0B,CAACja,IAAI,EAAEuE,MAAM,CAAC;IAChD;EACF;EAEAuN,WAAWA,CACT9R,IAAgB,EAChBka,eAAwB,EACxBC,eAAgC,EAChCC,iBAA0B,GAAG,IAAI,EAC3B;IACN,IACED,eAAe,IACf,IAAI,CAAC3X,KAAK,CAACuO,yBAAyB,CAACkB,OAAO,CAACjS,IAAI,CAACoF,KAAK,CAAC,KAAK,CAAC,CAAC,EAC/D;MACA;IACF;IAGA,KAAK,IAAIvE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,IAAI,CAACuE,MAAM,CAACzD,MAAM,EAAED,CAAC,EAAE,EAAE;MAC3C,IAAI,IAAI,CAACgV,WAAW,CAAC7V,IAAI,CAACuE,MAAM,CAAC1D,CAAC,CAAC,CAAC,IAAIA,CAAC,GAAG,CAAC,EAAE;QAC7C,IAAI,CAACuC,KAAK,CAACtH,UAAU,CAAC6C,oBAAoB,EAAE;UAAE0E,EAAE,EAAErD,IAAI,CAACuE,MAAM,CAAC1D,CAAC;QAAE,CAAC,CAAC;MACrE;IACF;IAEA,KAAK,CAACiR,WAAW,CACf9R,IAAI,EACJka,eAAe,EACfC,eAAe,EACfC,iBAAiB,CAClB;EACH;EAEAC,kCAAkCA,CAACC,UAAmB,EAAgB;IACpE,OAAO,KAAK,CAACD,kCAAkC,CAC7CC,UAAU,IAAI,IAAI,CAAC9X,KAAK,CAAC8N,SAAS,CAAC2B,OAAO,CAAC,IAAI,CAACzP,KAAK,CAAC4C,KAAK,CAAC,KAAK,CAAC,CAAC,CACpE;EACH;EAEAmV,eAAeA,CACbC,IAAkB,EAElBzX,QAAkB,EAClB0X,OAAwB,EACV;IACd,IACED,IAAI,CAAC3a,IAAI,KAAK,YAAY,IAC1B2a,IAAI,CAACvV,IAAI,KAAK,OAAO,IACrB,IAAI,CAACzC,KAAK,CAAC8N,SAAS,CAAC2B,OAAO,CAAClP,QAAQ,CAACI,KAAK,CAAC,KAAK,CAAC,CAAC,EACnD;MACA,IAAI,CAACH,IAAI,EAAE;MAEX,MAAMhD,IAAI,GAAG,IAAI,CAACyK,WAAW,CAAC1H,QAAQ,CAAC;MACvC/C,IAAI,CAAC0a,MAAM,GAAGF,IAAI;MAClBxa,IAAI,CAAC2a,SAAS,GAAG,KAAK,CAACC,4BAA4B,KAAY,KAAK,CAAC;MACrEJ,IAAI,GAAG,IAAI,CAAChX,UAAU,CAACxD,IAAI,EAAE,gBAAgB,CAAC;IAChD,CAAC,MAAM,IACLwa,IAAI,CAAC3a,IAAI,KAAK,YAAY,IAC1B2a,IAAI,CAACvV,IAAI,KAAK,OAAO,IACrB,IAAI,CAACtB,KAAK,IAAO,EACjB;MACA,MAAMnB,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC4N,KAAK,EAAE;MAChC,MAAMiJ,KAAK,GAAG,IAAI,CAACT,QAAQ,CACzBU,KAAK,IAAI,IAAI,CAACuB,iCAAiC,CAAC9X,QAAQ,CAAC,IAAIuW,KAAK,EAAE,EACpE9W,KAAK,CACN;MAID,IAAI,CAAC6W,KAAK,CAACR,KAAK,IAAI,CAACQ,KAAK,CAACM,OAAO,EAAE,OAAON,KAAK,CAACrZ,IAAI;MAErD,MAAMgS,MAAM,GAAG,IAAI,CAAC4G,QAAQ,CAC1B,MAAM,KAAK,CAAC2B,eAAe,CAACC,IAAI,EAAEzX,QAAQ,EAAE0X,OAAO,CAAC,EACpDjY,KAAK,CACN;MAED,IAAIwP,MAAM,CAAChS,IAAI,IAAI,CAACgS,MAAM,CAAC6G,KAAK,EAAE,OAAO7G,MAAM,CAAChS,IAAI;MAEpD,IAAIqZ,KAAK,CAACrZ,IAAI,EAAE;QACd,IAAI,CAACwC,KAAK,GAAG6W,KAAK,CAACQ,SAAS;QAE5B,OAAOR,KAAK,CAACrZ,IAAI;MACnB;MAEA,IAAIgS,MAAM,CAAChS,IAAI,EAAE;QACf,IAAI,CAACwC,KAAK,GAAGwP,MAAM,CAAC6H,SAAS;QAC7B,OAAO7H,MAAM,CAAChS,IAAI;MACpB;MAEA,MAAMqZ,KAAK,CAACR,KAAK,IAAI7G,MAAM,CAAC6G,KAAK;IACnC;IAEA,OAAO,KAAK,CAAC0B,eAAe,CAACC,IAAI,EAAEzX,QAAQ,EAAE0X,OAAO,CAAC;EACvD;EAEAK,cAAcA,CACZN,IAAkB,EAElBzX,QAAkB,EAClB0X,OAAmC,EACnCM,cAAqC,EACvB;IACd,IAAI,IAAI,CAACpX,KAAK,IAAgB,IAAI,IAAI,CAACqX,mBAAmB,EAAE,EAAE;MAC5DD,cAAc,CAACE,mBAAmB,GAAG,IAAI;MACzC,IAAIR,OAAO,EAAE;QACXM,cAAc,CAACG,IAAI,GAAG,IAAI;QAC1B,OAAOV,IAAI;MACb;MACA,IAAI,CAACxX,IAAI,EAAE;MACX,MAAMhD,IAAI,GAAG,IAAI,CAACyK,WAAW,CAA2B1H,QAAQ,CAAC;MACjE/C,IAAI,CAAC0a,MAAM,GAAGF,IAAI;MAClBxa,IAAI,CAACmb,aAAa,GAAG,IAAI,CAAC7S,mCAAmC,EAAE;MAC/D,IAAI,CAAC5F,MAAM,IAAW;MACtB1C,IAAI,CAAC2a,SAAS,GAAG,IAAI,CAACC,4BAA4B,KAAY,KAAK,CAAC;MACpE5a,IAAI,CAACuK,QAAQ,GAAG,IAAI;MACpB,OAAO,IAAI,CAAC6Q,oBAAoB,CAACpb,IAAI,EAAiB,IAAI,CAAC;IAC7D,CAAC,MAAM,IAAI,CAACya,OAAO,IAAI,IAAI,CAAC/Y,gBAAgB,EAAE,IAAI,IAAI,CAACiC,KAAK,IAAO,EAAE;MACnE,MAAM3D,IAAI,GAAG,IAAI,CAACyK,WAAW,CAE3B1H,QAAQ,CAAC;MACX/C,IAAI,CAAC0a,MAAM,GAAGF,IAAI;MAElB,MAAMxI,MAAM,GAAG,IAAI,CAAC4G,QAAQ,CAAC,MAAM;QACjC5Y,IAAI,CAACmb,aAAa,GAChB,IAAI,CAACvR,4CAA4C,EAAE;QACrD,IAAI,CAAClH,MAAM,IAAW;QACtB1C,IAAI,CAAC2a,SAAS,GAAG,KAAK,CAACC,4BAA4B,KAAY,KAAK,CAAC;QACrE,IAAIG,cAAc,CAACE,mBAAmB,EAAE;UACrCjb,IAAI,CAAsCuK,QAAQ,GAAG,KAAK;QAC7D;QACA,OAAO,IAAI,CAAC6Q,oBAAoB,CAC9Bpb,IAAI,EACJ+a,cAAc,CAACE,mBAAmB,CACnC;MACH,CAAC,CAAC;MAEF,IAAIjJ,MAAM,CAAChS,IAAI,EAAE;QACf,IAAIgS,MAAM,CAAC6G,KAAK,EAAE,IAAI,CAACrW,KAAK,GAAGwP,MAAM,CAAC6H,SAAS;QAC/C,OAAO7H,MAAM,CAAChS,IAAI;MACpB;IACF;IAEA,OAAO,KAAK,CAAC8a,cAAc,CACzBN,IAAI,EAEJzX,QAAQ,EACR0X,OAAO,EACPM,cAAc,CACf;EACH;EAEAM,cAAcA,CAACrb,IAAqB,EAAQ;IAC1C,KAAK,CAACqb,cAAc,CAACrb,IAAI,CAAC;IAE1B,IAAIsb,KAAK,GAAG,IAAI;IAChB,IAAI,IAAI,CAAC5Z,gBAAgB,EAAE,IAAI,IAAI,CAACiC,KAAK,IAAO,EAAE;MAChD2X,KAAK,GAAG,IAAI,CAAC1C,QAAQ,CAAC,MACpB,IAAI,CAAChP,4CAA4C,EAAE,CACpD,CAAC5J,IAAI;IACR;IACAA,IAAI,CAACmb,aAAa,GAAGG,KAAK;EAC5B;EAEAT,iCAAiCA,CAC/B9X,QAAkB,EAC4B;IAC9C,MAAM/C,IAAI,GAAG,IAAI,CAACyK,WAAW,CAA4B1H,QAAQ,CAAC;IAClE,IAAI,CAACoV,mBAAmB,CAACnY,IAAI,EAAE,KAAK,CAAC;IACrC,IAAI,CAAC,IAAI,CAAC+Z,UAAU,CAAC/Z,IAAI,CAAC,EAAE;IAC5B,OAAO,KAAK,CAACub,oBAAoB,CAC/Bvb,IAAI,EACSuB,SAAS,EACR,IAAI,CACnB;EACH;EAEAia,qBAAqBA,CAAC3H,IAAY,EAAQ;IACxC,MAAM7Q,IAAI,GAAG,IAAI,CAAC8Q,KAAK,CAACC,UAAU,CAAC,IAAI,CAACvR,KAAK,CAACsK,GAAG,GAAG,CAAC,CAAC;IACtD,IACE+G,IAAI,OAAuB,IAC3B7Q,IAAI,OAAoB,IACxB,IAAI,CAACR,KAAK,CAACiZ,cAAc,EACzB;MACA,IAAI,CAACjZ,KAAK,CAACiZ,cAAc,GAAG,KAAK;MACjC,IAAI,CAACjZ,KAAK,CAACsK,GAAG,IAAI,CAAC;MACnB,IAAI,CAAC4O,SAAS,EAAE;MAChB;IACF;IAEA,KAAK,CAACF,qBAAqB,CAAC3H,IAAI,CAAC;EACnC;EAEA8H,kBAAkBA,CAAC9H,IAAY,EAAQ;IACrC,MAAM7Q,IAAI,GAAG,IAAI,CAAC8Q,KAAK,CAACC,UAAU,CAAC,IAAI,CAACvR,KAAK,CAACsK,GAAG,GAAG,CAAC,CAAC;IACtD,IACE+G,IAAI,QAA0B,IAC9B7Q,IAAI,QAA8B,EAClC;MAEA,IAAI,CAACgR,QAAQ,IAAe,CAAC,CAAC;MAC9B;IACF;IAEA,KAAK,CAAC2H,kBAAkB,CAAC9H,IAAI,CAAC;EAChC;EAEA+H,aAAaA,CAACC,IAAY,EAAEC,OAAkB,EAAU;IACtD,MAAMC,QAAQ,GAAG,KAAK,CAACH,aAAa,CAACC,IAAI,EAAEC,OAAO,CAAC;IACnD,IAAI,IAAI,CAACtZ,KAAK,CAACiZ,cAAc,EAAE;MAC7B,IAAI,CAACrY,KAAK,CAACtH,UAAU,CAAC4D,uBAAuB,EAAE;QAC7C2D,EAAE,EAAE,IAAI,CAACb,KAAK,CAACkR,WAAW;MAC5B,CAAC,CAAC;IACJ;IACA,OAAOqI,QAAQ;EACjB;EAEAC,gBAAgBA,CAAA,EAA+B;IAC7C,IAAI,IAAI,CAACrD,SAAS,CAAC,cAAc,CAAC,IAAI,IAAI,CAACsD,eAAe,EAAE,EAAE;MAC5D,IAAI,IAAI,CAACzZ,KAAK,CAACiZ,cAAc,EAAE;QAC7B,MAAM,IAAI,CAACrY,KAAK,CAACtH,UAAU,CAACkC,iBAAiB,EAAE;UAC7CqF,EAAE,EAAE,IAAI,CAACb,KAAK,CAACO;QACjB,CAAC,CAAC;MACJ;MACA,IAAI,CAACmZ,wBAAwB,EAAE;MAC/B,MAAMC,WAAW,GAAG,IAAI,CAACF,eAAe,EAAE;MAC1C,IAAIE,WAAW,EAAE;QACf,IAAI,CAAC3Z,KAAK,CAACsK,GAAG,IAAIqP,WAAW;QAC7B,IAAI,CAAC3Z,KAAK,CAACiZ,cAAc,GAAG,IAAI;MAClC;MACA;IACF;IAEA,OAAO,KAAK,CAACO,gBAAgB,CAAC,IAAI,CAACxZ,KAAK,CAACiZ,cAAc,GAAG,KAAK,GAAG,IAAI,CAAC;EACzE;EAEAQ,eAAeA,CAAA,EAAmB;IAChC,MAAM;MAAEnP;IAAI,CAAC,GAAG,IAAI,CAACtK,KAAK;IAC1B,IAAI4Z,yBAAyB,GAAG,CAAC;IACjC,OACE,OAAgC,CAACC,QAAQ,CAEvC,IAAI,CAACvI,KAAK,CAACC,UAAU,CAACjH,GAAG,GAAGsP,yBAAyB,CAAC,CACvD,EACD;MACAA,yBAAyB,EAAE;IAC7B;IAEA,MAAME,GAAG,GAAG,IAAI,CAACxI,KAAK,CAACC,UAAU,CAACqI,yBAAyB,GAAGtP,GAAG,CAAC;IAClE,MAAMyP,GAAG,GAAG,IAAI,CAACzI,KAAK,CAACC,UAAU,CAACqI,yBAAyB,GAAGtP,GAAG,GAAG,CAAC,CAAC;IAEtE,IAAIwP,GAAG,OAAoB,IAAIC,GAAG,OAAoB,EAAE;MACtD,OAAOH,yBAAyB,GAAG,CAAC;IACtC;IACA,IACE,IAAI,CAACtI,KAAK,CAAC0I,KAAK,CACdJ,yBAAyB,GAAGtP,GAAG,EAC/BsP,yBAAyB,GAAGtP,GAAG,GAAG,EAAE,CACrC,KAAK,cAAc,EACpB;MACA,OAAOsP,yBAAyB,GAAG,EAAE;IACvC;IACA,IAAIE,GAAG,OAAoB,IAAIC,GAAG,OAAoB,EAAE;MACtD,OAAOH,yBAAyB;IAClC;IACA,OAAO,KAAK;EACd;EAEAF,wBAAwBA,CAAA,EAAS;IAC/B,MAAMxN,GAAG,GAAG,IAAI,CAACoF,KAAK,CAAC7B,OAAO,CAAC,IAAI,EAAE,IAAI,CAACzP,KAAK,CAACsK,GAAG,CAAC;IACpD,IAAI4B,GAAG,KAAK,CAAC,CAAC,EAAE;MACd,MAAM,IAAI,CAACtL,KAAK,CAAC8I,kBAAM,CAACuQ,mBAAmB,EAAE;QAC3CpZ,EAAE,EAAE,IAAI,CAACb,KAAK,CAACkR,WAAW;MAC5B,CAAC,CAAC;IACJ;EACF;EAIAgJ,wCAAwCA,CACtCvX,GAAa,EACb;IACE1I,QAAQ;IACRD;EAIF,CAAC,EACK;IACN,IAAI,CAAC4G,KAAK,CAACtH,UAAU,CAACS,+BAA+B,EAAE;MACrD8G,EAAE,EAAE8B,GAAG;MACP3I,UAAU;MACVC;IACF,CAAC,CAAC;EACJ;EAEAkgB,qCAAqCA,CACnCxX,GAAa,EACbyX,WAAwB,EACxB;IACA,OAAO,IAAI,CAACxZ,KAAK,CACf,CAACwZ,WAAW,CAAC5f,YAAY,GACrBlB,UAAU,CAACoB,uCAAuC,GAClD0f,WAAW,CAAC5f,YAAY,KAAK,QAAQ,GACrClB,UAAU,CAACmB,sCAAsC,GACjDnB,UAAU,CAACiB,uCAAuC,EAAAmB,MAAA,CAAAC,MAAA;MAEpDkF,EAAE,EAAE8B;IAAG,GACJyX,WAAW,EAEjB;EACH;EAEAC,uCAAuCA,CACrC1X,GAAa,EACb;IACE1I,QAAQ;IACRD;EAIF,CAAC,EACK;IACN,IAAI,CAAC4G,KAAK,CAACtH,UAAU,CAACuB,8BAA8B,EAAE;MACpDgG,EAAE,EAAE8B,GAAG;MACP1I,QAAQ;MACRD;IACF,CAAC,CAAC;EACJ;EAEAsgB,kDAAkDA,CAChD9c,IAAY,EACZ;IACEvD;EAGF,CAAC,EACK;IACN,IAAI,CAAC2G,KAAK,CAACtH,UAAU,CAACwB,yCAAyC,EAAE;MAC/D+F,EAAE,EAAErD,IAAI;MACRvD;IACF,CAAC,CAAC;EACJ;EAEAsgB,kBAAkBA,CAAA,EAAmB;IACnC,MAAMha,QAAQ,GAAG,IAAI,CAACP,KAAK,CAACO,QAAQ;IACpC,MAAMia,SAAS,GAAGA,CAAA,KAAM,IAAI,CAACrZ,KAAK,IAAU,IAAI,IAAI,CAACA,KAAK,GAAW;IACrE,QAAQ,IAAI,CAACnB,KAAK,CAAC3C,IAAI;MACrB;QAAa;UACX,MAAMod,OAAO,GAAG,IAAI,CAACC,mBAAmB,CAAC,IAAI,CAAC1a,KAAK,CAACL,KAAK,CAAC;UAC1D,IAAI6a,SAAS,EAAE,EAAE;YACf,OAAO;cAAEnd,IAAI,EAAE,QAAQ;cAAEsF,GAAG,EAAE8X,OAAO,CAAC9X,GAAG,CAACC,KAAK;cAAEjD,KAAK,EAAE8a;YAAQ,CAAC;UACnE;UACA,OAAO;YAAEpd,IAAI,EAAE,SAAS;YAAEsF,GAAG,EAAEpC;UAAS,CAAC;QAC3C;MACA;QAAgB;UACd,MAAMka,OAAO,GAAG,IAAI,CAACE,kBAAkB,CAAC,IAAI,CAAC3a,KAAK,CAACL,KAAK,CAAC;UACzD,IAAI6a,SAAS,EAAE,EAAE;YACf,OAAO;cAAEnd,IAAI,EAAE,QAAQ;cAAEsF,GAAG,EAAE8X,OAAO,CAAC9X,GAAG,CAACC,KAAK;cAAEjD,KAAK,EAAE8a;YAAQ,CAAC;UACnE;UACA,OAAO;YAAEpd,IAAI,EAAE,SAAS;YAAEsF,GAAG,EAAEpC;UAAS,CAAC;QAC3C;MACA;MACA;QAAgB;UACd,MAAMka,OAAO,GAAG,IAAI,CAACG,mBAAmB,CAAC,IAAI,CAACzZ,KAAK,IAAU,CAAC;UAC9D,IAAIqZ,SAAS,EAAE,EAAE;YACf,OAAO;cACLnd,IAAI,EAAE,SAAS;cACfsF,GAAG,EAAE8X,OAAO,CAAC9X,GAAG,CAACC,KAAK;cACtBjD,KAAK,EAAE8a;YACT,CAAC;UACH;UACA,OAAO;YAAEpd,IAAI,EAAE,SAAS;YAAEsF,GAAG,EAAEpC;UAAS,CAAC;QAC3C;MACA;QACE,OAAO;UAAElD,IAAI,EAAE,SAAS;UAAEsF,GAAG,EAAEpC;QAAS,CAAC;IAAC;EAEhD;EAEAsa,iBAAiBA,CAAA,EAGf;IACA,MAAMlY,GAAG,GAAG,IAAI,CAAC3C,KAAK,CAACO,QAAQ;IAC/B,MAAMgB,EAAE,GAAG,IAAI,CAACC,eAAe,CAAC,IAAI,CAAC;IACrC,MAAMsZ,IAAI,GAAG,IAAI,CAACha,GAAG,IAAO,GACxB,IAAI,CAACyZ,kBAAkB,EAAE,GACzB;MAAEld,IAAI,EAAE,MAAe;MAAEsF;IAAI,CAAC;IAClC,OAAO;MAAEpB,EAAE;MAAEuZ;IAAK,CAAC;EACrB;EAEAC,iCAAiCA,CAC/BpY,GAAa,EACb2T,OAAoB,EACpB0E,YAA8B,EACxB;IACN,MAAM;MAAExgB;IAAa,CAAC,GAAG8b,OAAO;IAChC,IAAI9b,YAAY,KAAK,IAAI,EAAE;MACzB;IACF;IACA,IAAIA,YAAY,KAAKwgB,YAAY,EAAE;MACjC,IAAI,CAACb,qCAAqC,CAACxX,GAAG,EAAE2T,OAAO,CAAC;IAC1D;EACF;EAEA2E,eAAeA,CAAC;IACdhhB,QAAQ;IACRO;EAIF,CAAC,EAQC;IACA,MAAM0gB,SAAS,GAAG,IAAI7hB,GAAG,EAAE;IAC3B,MAAM8hB,OAAO,GAAG;MAEdC,cAAc,EAAE,EAAE;MAElBC,aAAa,EAAE,EAAE;MAEjBC,aAAa,EAAE,EAAE;MAEjBC,gBAAgB,EAAE;IACpB,CAAC;IACD,IAAIC,iBAAiB,GAAG,KAAK;IAC7B,OAAO,CAAC,IAAI,CAACra,KAAK,GAAW,EAAE;MAC7B,IAAI,IAAI,CAACL,GAAG,IAAa,EAAE;QACzB0a,iBAAiB,GAAG,IAAI;QACxB;MACF;MACA,MAAMC,UAAU,GAAG,IAAI,CAACpb,SAAS,EAAE;MACnC,MAAM;QAAEkB,EAAE;QAAEuZ;MAAK,CAAC,GAAG,IAAI,CAACD,iBAAiB,EAAE;MAC7C,MAAM7gB,UAAU,GAAGuH,EAAE,CAACkB,IAAI;MAC1B,IAAIzI,UAAU,KAAK,EAAE,EAAE;QACrB;MACF;MACA,IAAI,QAAQ,CAACkE,IAAI,CAAClE,UAAU,CAAC,EAAE;QAC7B,IAAI,CAAC4G,KAAK,CAACtH,UAAU,CAACqB,qBAAqB,EAAE;UAC3CkG,EAAE,EAAEU,EAAE;UACNvH,UAAU;UACVY,UAAU,EAAEZ,UAAU,CAAC,CAAC,CAAC,CAAC0hB,WAAW,EAAE,GAAG1hB,UAAU,CAACggB,KAAK,CAAC,CAAC,CAAC;UAC7D/f;QACF,CAAC,CAAC;MACJ;MACA,IAAIihB,SAAS,CAAC/U,GAAG,CAACnM,UAAU,CAAC,EAAE;QAC7B,IAAI,CAAC4G,KAAK,CAACtH,UAAU,CAACY,uBAAuB,EAAE;UAC7C2G,EAAE,EAAEU,EAAE;UACNvH,UAAU;UACVC;QACF,CAAC,CAAC;MACJ;MACAihB,SAAS,CAACS,GAAG,CAAC3hB,UAAU,CAAC;MACzB,MAAMsc,OAAO,GAAG;QAAErc,QAAQ;QAAEO,YAAY;QAAER;MAAW,CAAC;MACtDyhB,UAAU,CAACla,EAAE,GAAGA,EAAE;MAClB,QAAQuZ,IAAI,CAACzd,IAAI;QACf,KAAK,SAAS;UAAE;YACd,IAAI,CAAC0d,iCAAiC,CACpCD,IAAI,CAACnY,GAAG,EACR2T,OAAO,EACP,SAAS,CACV;YACDmF,UAAU,CAACX,IAAI,GAAGA,IAAI,CAACnb,KAAK;YAC5Bwb,OAAO,CAACC,cAAc,CAAC7c,IAAI,CACzB,IAAI,CAACyC,UAAU,CAACya,UAAU,EAAE,mBAAmB,CAAC,CACjD;YACD;UACF;QACA,KAAK,QAAQ;UAAE;YACb,IAAI,CAACV,iCAAiC,CAACD,IAAI,CAACnY,GAAG,EAAE2T,OAAO,EAAE,QAAQ,CAAC;YACnEmF,UAAU,CAACX,IAAI,GAAGA,IAAI,CAACnb,KAAK;YAC5Bwb,OAAO,CAACE,aAAa,CAAC9c,IAAI,CACxB,IAAI,CAACyC,UAAU,CAACya,UAAU,EAAE,kBAAkB,CAAC,CAChD;YACD;UACF;QACA,KAAK,QAAQ;UAAE;YACb,IAAI,CAACV,iCAAiC,CAACD,IAAI,CAACnY,GAAG,EAAE2T,OAAO,EAAE,QAAQ,CAAC;YACnEmF,UAAU,CAACX,IAAI,GAAGA,IAAI,CAACnb,KAAK;YAC5Bwb,OAAO,CAACG,aAAa,CAAC/c,IAAI,CACxB,IAAI,CAACyC,UAAU,CAACya,UAAU,EAAE,kBAAkB,CAAC,CAChD;YACD;UACF;QACA,KAAK,SAAS;UAAE;YACd,MAAM,IAAI,CAACtB,qCAAqC,CAACW,IAAI,CAACnY,GAAG,EAAE2T,OAAO,CAAC;UACrE;QACA,KAAK,MAAM;UAAE;YACX,QAAQ9b,YAAY;cAClB,KAAK,SAAS;gBACZ,IAAI,CAAC0f,wCAAwC,CAC3CY,IAAI,CAACnY,GAAG,EACR2T,OAAO,CACR;gBACD;cACF,KAAK,QAAQ;gBACX,IAAI,CAAC+D,uCAAuC,CAACS,IAAI,CAACnY,GAAG,EAAE2T,OAAO,CAAC;gBAC/D;cACF;gBACE6E,OAAO,CAACI,gBAAgB,CAAChd,IAAI,CAC3B,IAAI,CAACyC,UAAU,CAACya,UAAU,EAAE,qBAAqB,CAAC,CACnD;YAAC;UAER;MAAC;MAGH,IAAI,CAAC,IAAI,CAACta,KAAK,GAAW,EAAE;QAC1B,IAAI,CAACjB,MAAM,IAAU;MACvB;IACF;IACA,OAAO;MAAEib,OAAO;MAAEK;IAAkB,CAAC;EACvC;EAEAI,qBAAqBA,CACnBC,kBAAiC,EACjCN,gBAA+B,EAC/B;IACEthB;EAGF,CAAC,EACc;IACf,IAAI4hB,kBAAkB,CAACvd,MAAM,KAAK,CAAC,EAAE;MACnC,OAAOid,gBAAgB;IACzB,CAAC,MAAM,IAAIA,gBAAgB,CAACjd,MAAM,KAAK,CAAC,EAAE;MACxC,OAAOud,kBAAkB;IAC3B,CAAC,MAAM,IAAIN,gBAAgB,CAACjd,MAAM,GAAGud,kBAAkB,CAACvd,MAAM,EAAE;MAC9D,KAAK,MAAMqS,MAAM,IAAIkL,kBAAkB,EAAE;QACvC,IAAI,CAACvB,kDAAkD,CAAC3J,MAAM,EAAE;UAC9D1W;QACF,CAAC,CAAC;MACJ;MACA,OAAOshB,gBAAgB;IACzB,CAAC,MAAM;MACL,KAAK,MAAM5K,MAAM,IAAI4K,gBAAgB,EAAE;QACrC,IAAI,CAACjB,kDAAkD,CAAC3J,MAAM,EAAE;UAC9D1W;QACF,CAAC,CAAC;MACJ;MACA,OAAO4hB,kBAAkB;IAC3B;EACF;EAEAC,yBAAyBA,CAAC;IACxB7hB;EAGF,CAAC,EAAoB;IACnB,IAAI,CAAC,IAAI,CAAC+I,aAAa,KAAQ,EAAE,OAAO,IAAI;IAE5C,IAAI,CAAC,IAAA6H,wBAAiB,EAAC,IAAI,CAAC7K,KAAK,CAAC3C,IAAI,CAAC,EAAE;MACvC,MAAM,IAAI,CAACuD,KAAK,CAACtH,UAAU,CAACgB,sCAAsC,EAAE;QAClEuG,EAAE,EAAE,IAAI,CAACb,KAAK,CAACO,QAAQ;QACvBtG;MACF,CAAC,CAAC;IACJ;IAEA,MAAM;MAAE0F;IAAM,CAAC,GAAG,IAAI,CAACK,KAAK;IAC5B,IAAI,CAACQ,IAAI,EAAE;IAEX,IACEb,KAAK,KAAK,SAAS,IACnBA,KAAK,KAAK,QAAQ,IAClBA,KAAK,KAAK,QAAQ,IAClBA,KAAK,KAAK,QAAQ,EAClB;MACA,IAAI,CAACiB,KAAK,CAACtH,UAAU,CAACc,uBAAuB,EAAE;QAC7CyG,EAAE,EAAE,IAAI,CAACb,KAAK,CAACO,QAAQ;QACvBtG,QAAQ;QACRI,eAAe,EAAEsF;MACnB,CAAC,CAAC;IACJ;IAEA,OAAOA,KAAK;EACd;EAEAoc,YAAYA,CAACve,IAAoB,EAAE+D,EAAU,EAAU;IACrD,MAAMtH,QAAQ,GAAGsH,EAAE,CAACkB,IAAI;IACxB,MAAMuZ,OAAO,GAAGza,EAAE,CAACoB,GAAG,CAACC,KAAK;IAC5B,MAAMpI,YAAY,GAAG,IAAI,CAACshB,yBAAyB,CAAC;MAAE7hB;IAAS,CAAC,CAAC;IACjE,IAAI,CAACiG,MAAM,GAAW;IACtB,MAAM;MAAEib,OAAO;MAAEK;IAAkB,CAAC,GAAG,IAAI,CAACP,eAAe,CAAC;MAC1DhhB,QAAQ;MACRO;IACF,CAAC,CAAC;IACFgD,IAAI,CAACge,iBAAiB,GAAGA,iBAAiB;IAE1C,QAAQhhB,YAAY;MAClB,KAAK,SAAS;QACZgD,IAAI,CAAChD,YAAY,GAAG,IAAI;QACxBgD,IAAI,CAAC2d,OAAO,GAAGA,OAAO,CAACC,cAAc;QACrC,IAAI,CAAClb,MAAM,GAAW;QACtB,OAAO,IAAI,CAACc,UAAU,CAACxD,IAAI,EAAE,iBAAiB,CAAC;MACjD,KAAK,QAAQ;QACXA,IAAI,CAAChD,YAAY,GAAG,IAAI;QACxBgD,IAAI,CAAC2d,OAAO,GAAGA,OAAO,CAACE,aAAa;QACpC,IAAI,CAACnb,MAAM,GAAW;QACtB,OAAO,IAAI,CAACc,UAAU,CAACxD,IAAI,EAAE,gBAAgB,CAAC;MAChD,KAAK,QAAQ;QACXA,IAAI,CAAChD,YAAY,GAAG,IAAI;QACxBgD,IAAI,CAAC2d,OAAO,GAAG,IAAI,CAACS,qBAAqB,CACvCT,OAAO,CAACG,aAAa,EACrBH,OAAO,CAACI,gBAAgB,EACxB;UAAEthB;QAAS,CAAC,CACb;QACD,IAAI,CAACiG,MAAM,GAAW;QACtB,OAAO,IAAI,CAACc,UAAU,CAACxD,IAAI,EAAE,gBAAgB,CAAC;MAChD,KAAK,QAAQ;QACXA,IAAI,CAAC2d,OAAO,GAAGA,OAAO,CAACI,gBAAgB;QACvC,IAAI,CAACrb,MAAM,GAAW;QACtB,OAAO,IAAI,CAACc,UAAU,CAACxD,IAAI,EAAE,gBAAgB,CAAC;MAChD;QAAS;UAEP,MAAMye,KAAK,GAAGA,CAAA,KAAM;YAClBze,IAAI,CAAC2d,OAAO,GAAG,EAAE;YACjB,IAAI,CAACjb,MAAM,GAAW;YACtB,OAAO,IAAI,CAACc,UAAU,CAACxD,IAAI,EAAE,gBAAgB,CAAC;UAChD,CAAC;UACDA,IAAI,CAAChD,YAAY,GAAG,KAAK;UAEzB,MAAM0hB,QAAQ,GAAGf,OAAO,CAACC,cAAc,CAAC9c,MAAM;UAC9C,MAAM6d,OAAO,GAAGhB,OAAO,CAACE,aAAa,CAAC/c,MAAM;UAC5C,MAAM8d,OAAO,GAAGjB,OAAO,CAACG,aAAa,CAAChd,MAAM;UAC5C,MAAM+d,YAAY,GAAGlB,OAAO,CAACI,gBAAgB,CAACjd,MAAM;UAEpD,IAAI,CAAC4d,QAAQ,IAAI,CAACC,OAAO,IAAI,CAACC,OAAO,IAAI,CAACC,YAAY,EAAE;YACtD,OAAOJ,KAAK,EAAE;UAChB,CAAC,MAAM,IAAI,CAACC,QAAQ,IAAI,CAACC,OAAO,EAAE;YAChC3e,IAAI,CAAC2d,OAAO,GAAG,IAAI,CAACS,qBAAqB,CACvCT,OAAO,CAACG,aAAa,EACrBH,OAAO,CAACI,gBAAgB,EACxB;cAAEthB;YAAS,CAAC,CACb;YACD,IAAI,CAACiG,MAAM,GAAW;YACtB,OAAO,IAAI,CAACc,UAAU,CAACxD,IAAI,EAAE,gBAAgB,CAAC;UAChD,CAAC,MAAM,IAAI,CAAC2e,OAAO,IAAI,CAACC,OAAO,IAAIF,QAAQ,IAAIG,YAAY,EAAE;YAC3D,KAAK,MAAM1L,MAAM,IAAIwK,OAAO,CAACI,gBAAgB,EAAE;cAC7C,IAAI,CAACrB,wCAAwC,CAACvJ,MAAM,CAAChO,GAAG,CAACC,KAAK,EAAE;gBAC9D3I,QAAQ;gBACRD,UAAU,EAAE2W,MAAM,CAACpP,EAAE,CAACkB;cACxB,CAAC,CAAC;YACJ;YACAjF,IAAI,CAAC2d,OAAO,GAAGA,OAAO,CAACC,cAAc;YACrC,IAAI,CAAClb,MAAM,GAAW;YACtB,OAAO,IAAI,CAACc,UAAU,CAACxD,IAAI,EAAE,iBAAiB,CAAC;UACjD,CAAC,MAAM,IAAI,CAAC0e,QAAQ,IAAI,CAACE,OAAO,IAAID,OAAO,IAAIE,YAAY,EAAE;YAC3D,KAAK,MAAM1L,MAAM,IAAIwK,OAAO,CAACI,gBAAgB,EAAE;cAC7C,IAAI,CAAClB,uCAAuC,CAAC1J,MAAM,CAAChO,GAAG,CAACC,KAAK,EAAE;gBAC7D3I,QAAQ;gBACRD,UAAU,EAAE2W,MAAM,CAACpP,EAAE,CAACkB;cACxB,CAAC,CAAC;YACJ;YACAjF,IAAI,CAAC2d,OAAO,GAAGA,OAAO,CAACE,aAAa;YACpC,IAAI,CAACnb,MAAM,GAAW;YACtB,OAAO,IAAI,CAACc,UAAU,CAACxD,IAAI,EAAE,gBAAgB,CAAC;UAChD,CAAC,MAAM;YACL,IAAI,CAACoD,KAAK,CAACtH,UAAU,CAACa,4BAA4B,EAAE;cAClD0G,EAAE,EAAEmb,OAAO;cACX/hB;YACF,CAAC,CAAC;YACF,OAAOgiB,KAAK,EAAE;UAChB;QACF;IAAC;EAEL;EAEAtP,wBAAwBA,CAACnP,IAAoB,EAAU;IACrD,MAAM+D,EAAE,GAAG,IAAI,CAACC,eAAe,EAAE;IACjChE,IAAI,CAAC+D,EAAE,GAAGA,EAAE;IACZ/D,IAAI,CAACwG,IAAI,GAAG,IAAI,CAAC+X,YAAY,CAAC,IAAI,CAAC1b,SAAS,EAAE,EAAEkB,EAAE,CAAC;IACnD,OAAO,IAAI,CAACP,UAAU,CAACxD,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAGAgb,mBAAmBA,CAAA,EAAY;IAC7B,MAAMhY,IAAI,GAAG,IAAI,CAAC8b,cAAc,EAAE;IAClC,IAAI,IAAI,CAAChL,KAAK,CAACC,UAAU,CAAC/Q,IAAI,CAAC,OAAuB,EAAE;MACtD,MAAM+b,SAAS,GAAG,IAAI,CAACjL,KAAK,CAACC,UAAU,CAAC/Q,IAAI,GAAG,CAAC,CAAC;MACjD,OACE+b,SAAS,OAAuB,IAAIA,SAAS,OAAuB;IAExE;IACA,OAAO,KAAK;EACd;EAEArF,6BAA6BA,CAAC1Z,IAAY,EAAE;IAC1C,OAAOA,IAAI,CAACH,IAAI,KAAK,oBAAoB,GAAGG,IAAI,CAACyO,UAAU,GAAGzO,IAAI;EACpE;AACF,CAAC;AAAAgf,OAAA,CAAAlY,OAAA,GAAA7F,QAAA"}
