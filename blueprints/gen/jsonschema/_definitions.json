{
  "definitions": {
    "AIMDConcurrencyController": {
      "description": "High level concurrency control component. Baselines a signal using exponential moving average and applies concurrency limits based on deviation of signal from the baseline. Internally implemented as a nested circuit.",
      "properties": {
        "alerter_parameters": {
          "$ref": "#/definitions/AlerterParameters",
          "description": "Configuration for embedded Alerter.",
          "x-order": 0
        },
        "default_config": {
          "$ref": "#/definitions/LoadActuatorDynamicConfig",
          "description": "Default configuration.",
          "x-order": 1
        },
        "dynamic_config_key": {
          "description": "Dynamic configuration key for load actuation.",
          "type": "string",
          "x-order": 2
        },
        "flow_selector": {
          "$ref": "#/definitions/FlowSelector",
          "description": "Flow Selector decides the service and flows at which the concurrency limiter is applied.\nDeprecated 1.8.0: Use `selectors` instead.\n\n",
          "x-go-tag-validate": "required_without=Selectors",
          "x-order": 3
        },
        "gradient_parameters": {
          "$ref": "#/definitions/GradientControllerParameters",
          "description": "Gradient parameters for the controller.",
          "x-order": 4
        },
        "in_ports": {
          "$ref": "#/definitions/AIMDConcurrencyControllerIns",
          "description": "Input ports for the AIMDConcurrencyController component.",
          "x-order": 5
        },
        "load_multiplier_linear_increment": {
          "default": 0.0025,
          "description": "Linear increment to load multiplier in each execution tick when the system is not in overloaded state.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-default": "0.0025",
          "x-order": 6
        },
        "max_load_multiplier": {
          "default": 2,
          "description": "Current accepted concurrency is multiplied with this number to dynamically calculate the upper concurrency limit of a Service during normal (non-overload) state. This protects the Service from sudden spikes.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-default": "2.0",
          "x-order": 7
        },
        "out_ports": {
          "$ref": "#/definitions/AIMDConcurrencyControllerOuts",
          "description": "Output ports for the AIMDConcurrencyController component.",
          "x-order": 8
        },
        "scheduler_parameters": {
          "$ref": "#/definitions/SchedulerParameters",
          "description": "Scheduler parameters.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 9
        },
        "selectors": {
          "description": "Selectors for the component.\n\n",
          "items": {
            "$ref": "#/definitions/Selector",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "required_without=FlowSelector,dive",
          "x-order": 10
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "AIMDConcurrencyControllerIns": {
      "description": "Inputs for the AIMDConcurrencyController component.",
      "properties": {
        "enabled": {
          "$ref": "#/definitions/InPort",
          "description": "The enabled port controls whether the _Adaptive Load Scheduler_ can load shed _Flows_. By default, the _Adaptive Load Scheduler_ is enabled.",
          "x-order": 0
        },
        "setpoint": {
          "$ref": "#/definitions/InPort",
          "description": "The setpoint to the controller.",
          "x-order": 1
        },
        "signal": {
          "$ref": "#/definitions/InPort",
          "description": "The signal to the controller.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "AIMDConcurrencyControllerOuts": {
      "description": "Outputs for the AIMDConcurrencyController component.",
      "properties": {
        "accepted_concurrency": {
          "$ref": "#/definitions/OutPort",
          "description": "Accepted concurrency is the number of concurrent requests that are accepted by the service.",
          "x-order": 0
        },
        "desired_load_multiplier": {
          "$ref": "#/definitions/OutPort",
          "description": "Desired Load multiplier is the ratio of desired concurrency to the incoming concurrency.",
          "x-order": 1
        },
        "incoming_concurrency": {
          "$ref": "#/definitions/OutPort",
          "description": "IncomingConcurrency is the number of concurrent requests that are received by the service.",
          "x-order": 2
        },
        "is_overload": {
          "$ref": "#/definitions/OutPort",
          "title": "Is overload is a Boolean signal that indicates whether the service is overloaded based on the deviation of the signal from the setpoint taking into account some tolerance.\nDeprecated: 1.6.0",
          "x-order": 3
        },
        "observed_load_multiplier": {
          "$ref": "#/definitions/OutPort",
          "description": "Observed Load multiplier is the ratio of accepted concurrency to the incoming concurrency.",
          "x-order": 4
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "AdaptiveLoadScheduler": {
      "description": "The _Adaptive Load Scheduler_ adjusts the accepted token rate based on the deviation of the input signal from the setpoint.",
      "properties": {
        "alerter_parameters": {
          "$ref": "#/definitions/AlerterParameters",
          "description": "Configuration parameters for the embedded Alerter.",
          "x-order": 0
        },
        "default_config": {
          "$ref": "#/definitions/LoadSchedulerActuatorDynamicConfig",
          "description": "Default dynamic configuration for load actuation.",
          "x-order": 1
        },
        "dynamic_config_key": {
          "description": "Dynamic configuration key for load actuation.",
          "type": "string",
          "x-order": 2
        },
        "flow_selector": {
          "$ref": "#/definitions/FlowSelector",
          "description": "_Flow Selector_ is responsible for choosing the _Flows_ to which the _Load Scheduler_ is applied.\nDeprecated 1.8.0: Use `selectors` instead.\n\n",
          "x-go-tag-validate": "required_without=Selectors",
          "x-order": 3
        },
        "gradient_parameters": {
          "$ref": "#/definitions/GradientControllerParameters",
          "description": "Parameters for the _Gradient Controller_.",
          "x-order": 4
        },
        "in_ports": {
          "$ref": "#/definitions/AdaptiveLoadSchedulerIns",
          "description": "Collection of input ports for the _Adaptive Load Scheduler_ component.",
          "x-order": 5
        },
        "load_multiplier_linear_increment": {
          "default": 0.0025,
          "description": "Linear increment to load multiplier in each execution tick when the system is not in overloaded state.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-default": "0.0025",
          "x-order": 6
        },
        "max_load_multiplier": {
          "default": 2,
          "description": "The accepted token rate is multiplied by this value to dynamically calculate the upper concurrency limit of a Service during normal (non-overload) states, helping to protect the Service from sudden spikes in incoming token rate.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-default": "2.0",
          "x-order": 7
        },
        "out_ports": {
          "$ref": "#/definitions/AdaptiveLoadSchedulerOuts",
          "description": "Collection of output ports for the _Adaptive Load Scheduler_ component.",
          "x-order": 8
        },
        "scheduler_parameters": {
          "$ref": "#/definitions/LoadSchedulerSchedulerParameters",
          "description": "Parameters for the _Load Scheduler_.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 9
        },
        "selectors": {
          "description": "Selectors for the component.\n\n",
          "items": {
            "$ref": "#/definitions/Selector",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "required_without=FlowSelector,dive",
          "x-order": 10
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "AdaptiveLoadSchedulerIns": {
      "description": "Input ports for the _Adaptive Load Scheduler_ component.",
      "properties": {
        "overload_confirmation": {
          "$ref": "#/definitions/InPort",
          "description": "Overload confirmation port provides additional criteria to determine overload state which results in flow throttling at the service.",
          "x-order": 0
        },
        "setpoint": {
          "$ref": "#/definitions/InPort",
          "description": "Setpoint input to the controller.",
          "x-order": 1
        },
        "signal": {
          "$ref": "#/definitions/InPort",
          "description": "Input signal to the controller.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "AdaptiveLoadSchedulerOuts": {
      "description": "Output ports for the _Adaptive Load Scheduler_ component.",
      "properties": {
        "accepted_token_rate": {
          "$ref": "#/definitions/OutPort",
          "description": "Accepted token rate is the number of tokens per second accepted by the service.",
          "x-order": 0
        },
        "desired_load_multiplier": {
          "$ref": "#/definitions/OutPort",
          "description": "Desired Load multiplier is the ratio of desired token rate to the incoming token rate.",
          "x-order": 1
        },
        "incoming_token_rate": {
          "$ref": "#/definitions/OutPort",
          "description": "Incoming token rate is the number of tokens per second incoming to the service (including rejected ones).",
          "x-order": 2
        },
        "is_overload": {
          "$ref": "#/definitions/OutPort",
          "description": "A Boolean signal that indicates whether the service is in overload state.",
          "x-order": 3
        },
        "observed_load_multiplier": {
          "$ref": "#/definitions/OutPort",
          "description": "Observed Load multiplier is the ratio of accepted token rate to the incoming token rate.",
          "x-order": 4
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "AddressExtractor": {
      "description": "IP addresses in attribute context are defined as objects with separate IP and port fields.\nThis is a helper to display an address as a single string.\n\n:::caution\n\nThis might introduce high-cardinality flow label values.\n\n:::\n\n[ext-authz-address]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address\n\nExample:\n```yaml\nfrom: \"source.address # or destination.address\"\n```",
      "properties": {
        "from": {
          "description": "Attribute path pointing to some string - for example, `source.address`.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 0
        }
      },
      "required": ["from"],
      "title": "Display an [Address][ext-authz-address] as a single string, for example, `<ip>:<port>`",
      "type": "object",
      "additionalProperties": false
    },
    "Alerter": {
      "description": "Alerter reacts to a signal and generates alert to send to alert manager.",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/AlerterIns",
          "description": "Input ports for the Alerter component.",
          "x-order": 0
        },
        "parameters": {
          "$ref": "#/definitions/AlerterParameters",
          "title": "Alerter configuration",
          "x-go-tag-validate": "required",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "AlerterIns": {
      "description": "Inputs for the Alerter component.",
      "properties": {
        "signal": {
          "$ref": "#/definitions/InPort",
          "description": "Signal which Alerter is monitoring. If the signal greater than 0, Alerter generates an alert.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "AlerterParameters": {
      "description": "Alerter Parameters configure parameters such as alert name, severity, resolve timeout, alert channels and labels.",
      "properties": {
        "alert_channels": {
          "description": "A list of alert channel strings.",
          "items": {
            "type": "string"
          },
          "type": "array",
          "x-order": 0
        },
        "alert_name": {
          "description": "Name of the alert.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 1
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Additional labels to add to alert.",
          "type": "object",
          "x-order": 2
        },
        "resolve_timeout": {
          "default": "5s",
          "description": "Duration of alert resolver.\n\n",
          "type": "string",
          "x-go-tag-default": "5s",
          "x-order": 3
        },
        "severity": {
          "default": "info",
          "description": "Severity of the alert, one of 'info', 'warn' or 'crit'.\n\n",
          "enum": ["info", "warn", "crit"],
          "type": "string",
          "x-go-tag-default": "info",
          "x-go-tag-validate": "oneof=info warn crit",
          "x-oneof": "info | warn | crit",
          "x-order": 4
        }
      },
      "required": ["alert_name"],
      "type": "object",
      "additionalProperties": false
    },
    "And": {
      "description": "Logical AND.\n\nSignals are mapped to Boolean values as follows:\n* Zero is treated as false.\n* Any non-zero is treated as true.\n* Invalid inputs are considered unknown.\n\n  :::note\n\n  Treating invalid inputs as \"unknowns\" has a consequence that the result\n  might end up being valid even when some inputs are invalid. For example, `unknown && false == false`,\n  because the result would end up false no matter if\n  first signal was true or false. Conversely, `unknown && true == unknown`.\n\n  :::",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/AndIns",
          "description": "Input ports for the And component.",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/AndOuts",
          "description": "Output ports for the And component.",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "AndIns": {
      "description": "Inputs for the And component.",
      "properties": {
        "inputs": {
          "description": "Array of input signals.\n\n",
          "items": {
            "$ref": "#/definitions/InPort",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "dive",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "AndOuts": {
      "description": "Output ports for the And component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "Result of logical AND of all the input signals.\n\nWill always be 0 (false), 1 (true) or invalid (unknown).",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "ArithmeticCombinator": {
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/ArithmeticCombinatorIns",
          "description": "Input ports for the Arithmetic Combinator component.",
          "x-order": 0
        },
        "operator": {
          "description": "Operator of the arithmetic operation.\n\nThe arithmetic operation can be addition, subtraction, multiplication, division, XOR, right bit shift or left bit shift.\nIn case of XOR and bit shifts, value of signals is cast to integers before performing the operation.\n\n",
          "enum": ["add", "sub", "mul", "div", "xor", "lshift", "rshift"],
          "type": "string",
          "x-go-tag-validate": "oneof=add sub mul div xor lshift rshift",
          "x-oneof": "add | sub | mul | div | xor | lshift | rshift",
          "x-order": 1
        },
        "out_ports": {
          "$ref": "#/definitions/ArithmeticCombinatorOuts",
          "description": "Output ports for the Arithmetic Combinator component.",
          "x-order": 2
        }
      },
      "title": "Type of Combinator that computes the arithmetic operation on the operand signals",
      "type": "object",
      "additionalProperties": false
    },
    "ArithmeticCombinatorIns": {
      "description": "Inputs for the Arithmetic Combinator component.",
      "properties": {
        "lhs": {
          "$ref": "#/definitions/InPort",
          "description": "Left hand side of the arithmetic operation.",
          "x-order": 0
        },
        "rhs": {
          "$ref": "#/definitions/InPort",
          "description": "Right hand side of the arithmetic operation.",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "ArithmeticCombinatorOuts": {
      "description": "Outputs for the Arithmetic Combinator component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "Result of arithmetic operation.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "AutoScale": {
      "description": "AutoScale components are used to scale a service.",
      "properties": {
        "auto_scaler": {
          "$ref": "#/definitions/AutoScaler",
          "description": "_AutoScaler_ provides auto-scaling functionality for any scalable resource.",
          "x-order": 0
        },
        "pod_auto_scaler": {
          "$ref": "#/definitions/PodAutoScaler",
          "description": "_PodAutoScaler_ provides auto-scaling functionality for scalable Kubernetes resource.",
          "x-order": 1
        },
        "pod_scaler": {
          "$ref": "#/definitions/PodScaler",
          "description": "PodScaler provides pod horizontal scaling functionality for scalable Kubernetes resources.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "AutoScaler": {
      "description": "_AutoScaler_ provides auto-scaling functionality for any scalable resource. Multiple _Controllers_ can be defined on the _AutoScaler_ for performing scale-out or scale-in. The _AutoScaler_ can interface with infrastructure APIs such as Kubernetes to perform auto-scale.",
      "properties": {
        "cooldown_override_percentage": {
          "default": 50,
          "description": "Cooldown override percentage defines a threshold change in scale-out beyond which previous cooldown is overridden.\nFor example, if the cooldown is 5 minutes and the cooldown override percentage is 10%, then if the\nscale-increases by 10% or more, the previous cooldown is cancelled. Defaults to 50%.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-default": "50",
          "x-order": 0
        },
        "max_scale": {
          "default": "9223372036854775807",
          "description": "The maximum scale to which the _AutoScaler_ can scale-out. For example, in case of KubernetesReplicas Scaler, this is the maximum number of replicas.\n\n",
          "format": "int64",
          "minLength": 1,
          "type": "string",
          "x-go-tag-default": "9223372036854775807",
          "x-go-tag-validate": "gt=0",
          "x-order": 1
        },
        "max_scale_in_percentage": {
          "default": 1,
          "description": "The maximum decrease of scale (for example, pods) at one time. Defined as percentage of current scale value. Can never go below one even if percentage computation is less than one. Defaults to 1% of current scale value.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-default": "1",
          "x-order": 2
        },
        "max_scale_out_percentage": {
          "default": 10,
          "description": "The maximum increase of scale (for example, pods) at one time. Defined as percentage of current scale value. Can never go below one even if percentage computation is less than one. Defaults to 10% of current scale value.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-default": "10",
          "x-order": 3
        },
        "min_scale": {
          "default": "0",
          "description": "The minimum scale to which the _AutoScaler_ can scale-in. For example, in case of KubernetesReplicas Scaler, this is the minimum number of replicas.\n\n",
          "format": "int64",
          "minLength": 0,
          "type": "string",
          "x-go-tag-default": "0",
          "x-go-tag-validate": "gte=0",
          "x-order": 4
        },
        "out_ports": {
          "$ref": "#/definitions/AutoScalerOuts",
          "description": "Output ports for the _AutoScaler_.",
          "x-order": 5
        },
        "scale_in_alerter_parameters": {
          "$ref": "#/definitions/AlerterParameters",
          "description": "Configuration for scale-in Alerter.",
          "x-order": 6
        },
        "scale_in_controllers": {
          "description": "List of _Controllers_ for scaling in.",
          "items": {
            "$ref": "#/definitions/ScaleInController",
            "type": "object"
          },
          "type": "array",
          "x-order": 7
        },
        "scale_in_cooldown": {
          "default": "120s",
          "description": "The amount of time to wait after a scale-in operation for another scale-in operation.\n\n",
          "type": "string",
          "x-go-tag-default": "120s",
          "x-order": 8
        },
        "scale_out_alerter_parameters": {
          "$ref": "#/definitions/AlerterParameters",
          "description": "Configuration for scale-out Alerter.",
          "x-order": 9
        },
        "scale_out_controllers": {
          "description": "List of _Controllers_ for scaling out.",
          "items": {
            "$ref": "#/definitions/ScaleOutController",
            "type": "object"
          },
          "type": "array",
          "x-order": 10
        },
        "scale_out_cooldown": {
          "default": "30s",
          "description": "The amount of time to wait after a scale-out operation for another scale-out or scale-in operation.\n\n",
          "type": "string",
          "x-go-tag-default": "30s",
          "x-order": 11
        },
        "scaler": {
          "$ref": "#/definitions/AutoScalerScaler",
          "x-go-tag-validate": "required",
          "x-order": 12
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "AutoScalerOuts": {
      "description": "Outputs for _AutoScaler_.",
      "properties": {
        "actual_scale": {
          "$ref": "#/definitions/OutPort",
          "x-order": 0
        },
        "configured_scale": {
          "$ref": "#/definitions/OutPort",
          "x-order": 1
        },
        "desired_scale": {
          "$ref": "#/definitions/OutPort",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "AutoScalerScaler": {
      "properties": {
        "kubernetes_replicas": {
          "$ref": "#/definitions/KubernetesReplicas",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Circuit": {
      "description": "Circuit is graph of inter-connected signal processing components.\n\n:::info\n\nSee also [Circuit overview](/concepts/policy/circuit.md).\n\n:::\n\nSignals flow between components through ports.\nAs signals traverse the circuit, they get processed, stored within components or get acted upon (for example, load-shed, rate-limit, auto-scale and so on).\nCircuit is evaluated periodically to respond to changes in signal readings.\n\n:::info Signals\n\nSignals are floating point values.\n\nA signal can also have a special **Invalid** value. It's usually used to\ncommunicate that signal does not have a meaningful value at the moment, for example,\n[PromQL](#prom-q-l) emits such a value if it cannot execute a query.\nComponents know when their input signals are invalid and can act\naccordingly. They can either propagate the invalid signal, by making their\noutput itself invalid (for example,\n[ArithmeticCombinator](#arithmetic-combinator)) or use some different\nlogic, for example, [Extrapolator](#extrapolator). Refer to a component's\ndocs on how exactly it handles invalid inputs.\n\n:::",
      "properties": {
        "components": {
          "description": "Defines a signal processing graph as a list of components.\n\n",
          "items": {
            "$ref": "#/definitions/Component",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "dive",
          "x-order": 0
        },
        "evaluation_interval": {
          "default": "0.5s",
          "description": "Evaluation interval (tick) is the time between consecutive runs of the policy circuit.\nThis interval is typically aligned with how often the corrective action (actuation) needs to be taken.\n\n",
          "type": "string",
          "x-go-tag-default": "0.5s",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Classifier": {
      "description": ":::info\n\nSee also [Classifier overview](/concepts/flow-control/resources/classifier.md).\n\n:::\nExample\n```yaml\nflow_selector:\n  service_selector:\n     agent_group: demoapp\n     service: service1-demo-app.demoapp.svc.cluster.local\n  flow_matcher:\n     control_point: ingress\n     label_matcher:\n        match_labels:\n          user_tier: gold\n        match_expressions:\n          - key: user_type\n            operator: In\nrules:\n  user:\n   extractor:\n     from: request.http.headers.user-agent\n  telemetry: false\n```",
      "properties": {
        "flow_selector": {
          "$ref": "#/definitions/FlowSelector",
          "description": "Defines where to apply the flow classification rule.\nDeprecated 1.8.0: Use `selectors` instead.\n\n",
          "x-go-tag-validate": "required_without=Selectors",
          "x-order": 0
        },
        "rego": {
          "$ref": "#/definitions/Rego",
          "description": "Rego is a policy language used to express complex policies in a concise and declarative way.\nIt can be used to define flow classification rules by writing custom queries that extract values from request metadata.\nFor simple cases, such as directly reading a value from header or a field from JSON body, declarative extractors are recommended.",
          "title": "Rego based classification",
          "x-order": 1
        },
        "rules": {
          "additionalProperties": {
            "$ref": "#/definitions/Rule"
          },
          "description": "A map of {key, value} pairs mapping from\n[flow label](/concepts/flow-control/flow-label.md) keys to rules that define\nhow to extract and propagate flow labels with that key.\n\n",
          "type": "object",
          "x-go-tag-validate": "dive,keys,required,endkeys,required",
          "x-order": 2
        },
        "selectors": {
          "description": "Selectors for flows that will be classified by this _Classifier_.\n\n",
          "items": {
            "$ref": "#/definitions/Selector",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "required_without=FlowSelector,dive",
          "x-order": 3
        }
      },
      "title": "Set of classification rules sharing a common selector",
      "type": "object",
      "additionalProperties": false
    },
    "Component": {
      "description": ":::info\n\nSee also [Components overview](/concepts/policy/circuit.md#components).\n\n:::\n\nSignals flow into the components from input ports and results are emitted on output ports.\nComponents are wired to each other based on signal names forming an execution graph of the circuit.\n\n:::note\n\nLoops are broken by the runtime at the earliest component index that is part of the loop.\nThe looped signals are saved in the tick they're generated and served in the subsequent tick.\n\n:::\n\nThere are three categories of components:\n* \"source\" components: they take some sort of input from \"the real world\" and output\n  a signal based on this input. Example: [PromQL](#prom-q-l). In the UI\n  they're represented by green color.\n* signal processor components: processing components that do not interact with the external systems.\n  Examples: [GradientController](#gradient-controller), [Max](#max).\n\n  :::note\n\n  Signal processor components' output can depend on their internal state, in addition to the inputs.\n  Eg. see the [Exponential Moving Average filter](#e-m-a).\n\n  :::\n\n* \"sink\" components:\u00a0they affect the real world.\n  [_Concurrency Limiter_](#concurrency-limiter) and [_Rate Limiter_](#rate-limiter).\n  In the UI, represented by orange color.  Sink components usually come in pairs with a\n  \"sources\" component which emits a feedback signal, like\n  `accepted_concurrency` emitted by _Concurrency Limiter_.\n\nSee also [Policy](#policy) for a higher-level explanation of circuits.",
      "properties": {
        "alerter": {
          "$ref": "#/definitions/Alerter",
          "description": "Alerter reacts to a signal and generates alert to send to alert manager.",
          "x-order": 0
        },
        "and": {
          "$ref": "#/definitions/And",
          "description": "Logical AND.",
          "x-order": 1
        },
        "arithmetic_combinator": {
          "$ref": "#/definitions/ArithmeticCombinator",
          "description": "Applies the given operator on input operands (signals) and emits the result.",
          "x-order": 2
        },
        "auto_scale": {
          "$ref": "#/definitions/AutoScale",
          "description": "AutoScale components are used to scale the service.",
          "x-order": 3
        },
        "decider": {
          "$ref": "#/definitions/Decider",
          "description": "Decider emits the binary result of comparison operator on two operands.",
          "x-order": 4
        },
        "differentiator": {
          "$ref": "#/definitions/Differentiator",
          "description": "Differentiator calculates rate of change per tick.",
          "x-order": 5
        },
        "ema": {
          "$ref": "#/definitions/EMA",
          "description": "Exponential Moving Average filter.",
          "x-order": 6
        },
        "extrapolator": {
          "$ref": "#/definitions/Extrapolator",
          "description": "Takes an input signal and emits the extrapolated value; either mirroring the input value or repeating the last known value up to the maximum extrapolation interval.",
          "x-order": 7
        },
        "first_valid": {
          "$ref": "#/definitions/FirstValid",
          "description": "Picks the first valid input signal and emits it.",
          "x-order": 8
        },
        "flow_control": {
          "$ref": "#/definitions/FlowControl",
          "description": "FlowControl components are used to regulate requests flow.",
          "x-order": 9
        },
        "gradient_controller": {
          "$ref": "#/definitions/GradientController",
          "description": "Gradient controller calculates the ratio between the signal and the setpoint to determine the magnitude of the correction that need to be applied.\nThis controller can be used to build AIMD (Additive Increase, Multiplicative Decrease) or MIMD style response.",
          "x-order": 10
        },
        "holder": {
          "$ref": "#/definitions/Holder",
          "description": "Holds the last valid signal value for the specified duration then waits for next valid value to hold.",
          "x-order": 11
        },
        "integrator": {
          "$ref": "#/definitions/Integrator",
          "description": "Accumulates sum of signal every tick.",
          "x-order": 12
        },
        "inverter": {
          "$ref": "#/definitions/Inverter",
          "description": "Logical NOT.",
          "x-order": 13
        },
        "max": {
          "$ref": "#/definitions/Max",
          "description": "Emits the maximum of the input signals.",
          "x-order": 14
        },
        "min": {
          "$ref": "#/definitions/Min",
          "description": "Emits the minimum of the input signals.",
          "x-order": 15
        },
        "nested_circuit": {
          "$ref": "#/definitions/NestedCircuit",
          "description": "Nested circuit defines a sub-circuit as a high-level component. It consists of a list of components and a map of input and output ports.",
          "x-order": 16
        },
        "nested_signal_egress": {
          "$ref": "#/definitions/NestedSignalEgress",
          "description": "Nested signal egress is a special type of component that allows to extract a signal from a nested circuit.",
          "x-order": 17
        },
        "nested_signal_ingress": {
          "$ref": "#/definitions/NestedSignalIngress",
          "description": "Nested signal ingress is a special type of component that allows to inject a signal into a nested circuit.",
          "x-order": 18
        },
        "or": {
          "$ref": "#/definitions/Or",
          "description": "Logical OR.",
          "x-order": 19
        },
        "pulse_generator": {
          "$ref": "#/definitions/PulseGenerator",
          "description": "Generates 0 and 1 in turns.",
          "x-order": 20
        },
        "query": {
          "$ref": "#/definitions/Query",
          "description": "Query components that are query databases such as Prometheus.",
          "x-order": 21
        },
        "signal_generator": {
          "$ref": "#/definitions/SignalGenerator",
          "description": "Generates the specified signal.",
          "x-order": 22
        },
        "sma": {
          "$ref": "#/definitions/SMA",
          "description": "Simple Moving Average filter.",
          "x-order": 23
        },
        "switcher": {
          "$ref": "#/definitions/Switcher",
          "description": "Switcher acts as a switch that emits one of the two signals based on third signal.",
          "x-order": 24
        },
        "unary_operator": {
          "$ref": "#/definitions/UnaryOperator",
          "description": "Takes an input signal and emits the square root of the input signal.",
          "x-order": 25
        },
        "variable": {
          "$ref": "#/definitions/Variable",
          "description": "Emits a variable signal which can be set to invalid.",
          "x-order": 26
        }
      },
      "title": "Computational block that forms the circuit",
      "type": "object",
      "additionalProperties": false
    },
    "ConcurrencyLimiter": {
      "description": "It's based on the actuation strategy (for example, load actuator) and workload scheduling\nwhich is based on Weighted Fair Queuing principles.\nConcurrency is calculated in terms of total tokens per second, which can translate\nto (avg. latency \\* in-flight requests) (Little's Law) in concurrency limiting use-case.\n\nConcurrencyLimiter configuration is split into two parts: An actuation\nstrategy and a scheduler. At this time, only `load_actuator` strategy is available.",
      "properties": {
        "flow_selector": {
          "$ref": "#/definitions/FlowSelector",
          "description": "Flow Selector decides the service and flows at which the concurrency limiter is applied.\nDeprecated 1.8.0: Use `selectors` instead.\n\n",
          "x-go-tag-validate": "required_without=Selectors",
          "x-order": 0
        },
        "load_actuator": {
          "$ref": "#/definitions/LoadActuator",
          "description": "Actuator based on limiting the accepted concurrency under incoming concurrency * load multiplier.\n\nActuation strategy defines the input signal that will drive the scheduler.",
          "x-order": 1
        },
        "scheduler": {
          "$ref": "#/definitions/Scheduler",
          "description": "Configuration of Weighted Fair Queuing-based workload scheduler.\n\nContains configuration of per-agent scheduler, and also defines some\noutput signals.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 2
        },
        "selectors": {
          "description": "Selectors for the component.\n\n",
          "items": {
            "$ref": "#/definitions/Selector",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "required_without=FlowSelector,dive",
          "x-order": 3
        }
      },
      "title": "_Concurrency Limiter_ is an actuator component that regulates flows to provide active service protection",
      "type": "object",
      "additionalProperties": false
    },
    "ConstantSignal": {
      "description": "Special constant input for ports and Variable component. Can provide either a constant value or special Nan/+-Inf value.",
      "properties": {
        "special_value": {
          "description": "A special value such as NaN, +Inf, -Inf.\n\n",
          "enum": ["NaN", "+Inf", "-Inf"],
          "type": "string",
          "x-go-tag-validate": "oneof=NaN +Inf -Inf",
          "x-oneof": "NaN | +Inf | -Inf",
          "x-order": 0
        },
        "value": {
          "description": "A constant value.",
          "format": "double",
          "type": "number",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Decider": {
      "description": "The comparison operator can be greater-than, less-than, greater-than-or-equal, less-than-or-equal, equal, or not-equal.\n\nThis component also supports time-based response (the output)\ntransitions between 1.0 or 0.0 signal if the decider condition is\ntrue or false for at least `true_for` or `false_for` duration. If\n`true_for` and `false_for` durations are zero then the transitions are\ninstantaneous.",
      "properties": {
        "false_for": {
          "default": "0s",
          "description": "Duration of time to wait before changing to false state.\nIf the duration is zero, the change will happen instantaneously.\n\n",
          "type": "string",
          "x-go-tag-default": "0s",
          "x-order": 0
        },
        "in_ports": {
          "$ref": "#/definitions/DeciderIns",
          "description": "Input ports for the Decider component.",
          "x-order": 1
        },
        "operator": {
          "description": "Comparison operator that computes operation on LHS and RHS input signals.\n\n",
          "enum": ["gt", "lt", "gte", "lte", "eq", "neq"],
          "type": "string",
          "x-go-tag-validate": "oneof=gt lt gte lte eq neq",
          "x-oneof": "gt | lt | gte | lte | eq | neq",
          "x-order": 2
        },
        "out_ports": {
          "$ref": "#/definitions/DeciderOuts",
          "description": "Output ports for the Decider component.",
          "x-order": 3
        },
        "true_for": {
          "default": "0s",
          "title": "Duration of time to wait before changing to true state.\nIf the duration is zero, the change will happen instantaneously.```",
          "type": "string",
          "x-go-tag-default": "0s",
          "x-order": 4
        }
      },
      "title": "Type of Combinator that computes the comparison operation on LHS and RHS signals",
      "type": "object",
      "additionalProperties": false
    },
    "DeciderIns": {
      "description": "Inputs for the Decider component.",
      "properties": {
        "lhs": {
          "$ref": "#/definitions/InPort",
          "description": "Left hand side input signal for the comparison operation.",
          "x-order": 0
        },
        "rhs": {
          "$ref": "#/definitions/InPort",
          "description": "Right hand side input signal for the comparison operation.",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "DeciderOuts": {
      "description": "Outputs for the Decider component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "Selected signal (1.0 or 0.0).",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "DecreasingGradient": {
      "description": "Decreasing Gradient defines a controller for scaling in based on Gradient Controller.",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/DecreasingGradientIns",
          "description": "Input ports for the Gradient.",
          "x-order": 0
        },
        "parameters": {
          "$ref": "#/definitions/DecreasingGradientParameters",
          "title": "Gradient parameters for the controller. Defaults and constraints:\n* `slope` = 1\n* `min_gradient` = -Inf (must be less than 1)\n* `max_gradient` = 1 (cannot be changed)",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "DecreasingGradientIns": {
      "description": "Inputs for Gradient.",
      "properties": {
        "setpoint": {
          "$ref": "#/definitions/InPort",
          "description": "The setpoint to use for scale-in.",
          "x-order": 0
        },
        "signal": {
          "$ref": "#/definitions/InPort",
          "description": "The signal to use for scale-in.",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "DecreasingGradientParameters": {
      "description": "This allows subset of parameters with constrained values compared to a regular gradient controller. For full documentation of these parameters, refer to the [GradientControllerParameters](#gradient-controller-parameters).",
      "properties": {
        "min_gradient": {
          "default": -1.7976931348623157e308,
          "format": "double",
          "type": "number",
          "x-go-tag-default": "-1.79769313486231570814527423731704356798070e+308",
          "x-go-tag-validate": "lte=1.0",
          "x-order": 0
        },
        "slope": {
          "default": 1,
          "format": "double",
          "type": "number",
          "x-go-tag-default": "1.0",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Differentiator": {
      "description": "Differentiator calculates rate of change per tick.",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/DifferentiatorIns",
          "description": "Input ports for the Differentiator component.",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/DifferentiatorOuts",
          "description": "Output ports for the Differentiator component.",
          "x-order": 1
        },
        "window": {
          "default": "5s",
          "description": "The window of time over which differentiator operates.\n\n",
          "type": "string",
          "x-go-tag-default": "5s",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "DifferentiatorIns": {
      "description": "Inputs for the Differentiator component.",
      "properties": {
        "input": {
          "$ref": "#/definitions/InPort",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "DifferentiatorOuts": {
      "description": "Outputs for the Differentiator component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "EMA": {
      "description": "At any time EMA component operates in one of the following states:\n1. Warm up state: The first `warmup_window` samples are used to compute the initial EMA.\n   If an invalid reading is received during the `warmup_window`, the last good average is emitted and the state gets reset back to beginning of warm up state.\n2. Normal state: The EMA is computed using following formula.\n\nThe EMA for a series $Y$ is calculated recursively as:\n<!-- vale off -->\n$$\n\\text{EMA} _t =\n\\begin{cases}\n  Y_0, &\\text{for } t = 0 \\\\\n  \\alpha Y_t + (1 - \\alpha) \\text{EMA}_{t-1}, &\\text{for }t > 0\n\\end{cases}\n$$\n\nThe coefficient $\\alpha$ represents the degree of weighting decrease, a constant smoothing factor between 0 and 1.\nA higher $\\alpha$ discounts older observations faster.\nThe $\\alpha$ is computed using ema\\_window:\n\n$$\n\\alpha = \\frac{2}{N + 1} \\quad\\text{where } N = \\frac{\\text{ema\\_window}}{\\text{evaluation\\_period}}\n$$\n<!-- vale on -->",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/EMAIns",
          "description": "Input ports for the EMA component.",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/EMAOuts",
          "description": "Output ports for the EMA component.",
          "x-order": 1
        },
        "parameters": {
          "$ref": "#/definitions/EMAParameters",
          "description": "Parameters for the EMA component.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 2
        }
      },
      "title": "Exponential Moving Average (EMA) is a type of moving average that applies exponentially more weight to recent signal readings",
      "type": "object",
      "additionalProperties": false
    },
    "EMAIns": {
      "description": "Inputs for the EMA component.",
      "properties": {
        "input": {
          "$ref": "#/definitions/InPort",
          "description": "Input signal to be used for the EMA computation.",
          "x-order": 0
        },
        "max_envelope": {
          "$ref": "#/definitions/InPort",
          "description": "Upper bound of the moving average.\n\nWhen the signal exceeds `max_envelope` it is multiplied by\n`correction_factor_on_max_envelope_violation` **once per tick**.\n\n:::note\n\nIf the signal deviates from `max_envelope` faster than the correction\nfaster, it might end up exceeding the envelope.\n\n:::",
          "x-order": 1
        },
        "min_envelope": {
          "$ref": "#/definitions/InPort",
          "description": "Lower bound of the moving average.\n\nBehavior is similar to `max_envelope`.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "EMAOuts": {
      "description": "Outputs for the EMA component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "Exponential moving average of the series of reading as an output signal.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "EMAParameters": {
      "description": "Parameters for the EMA component.",
      "properties": {
        "correction_factor_on_max_envelope_violation": {
          "default": 1,
          "description": "Correction factor to apply on the output value if its in violation of the max envelope.\n\n",
          "format": "double",
          "minimum": 0,
          "type": "number",
          "x-go-tag-default": "1.0",
          "x-go-tag-validate": "gte=0,lte=1.0",
          "x-order": 0
        },
        "correction_factor_on_min_envelope_violation": {
          "default": 1,
          "description": "Correction factor to apply on the output value if its in violation of the min envelope.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-default": "1.0",
          "x-go-tag-validate": "gte=1.0",
          "x-order": 1
        },
        "ema_window": {
          "description": "Duration of EMA sampling window.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 2
        },
        "valid_during_warmup": {
          "default": false,
          "description": "Whether the output is valid during the warm-up stage.\n\n",
          "type": "boolean",
          "x-go-tag-default": "false",
          "x-order": 3
        },
        "warmup_window": {
          "description": "Duration of EMA warming up window.\n\nThe initial value of the EMA is the average of signal readings received during the warm up window.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 4
        }
      },
      "required": ["ema_window", "warmup_window"],
      "type": "object",
      "additionalProperties": false
    },
    "EqualsMatchExpression": {
      "description": "Label selector expression of the equal form `label == value`.",
      "properties": {
        "label": {
          "description": "Name of the label to equal match the value.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "value": {
          "description": "Exact value that the label should be equal to.",
          "type": "string",
          "x-order": 1
        }
      },
      "required": ["label"],
      "type": "object",
      "additionalProperties": false
    },
    "Extractor": {
      "description": "There are multiple variants of extractor, specify exactly one.",
      "properties": {
        "address": {
          "$ref": "#/definitions/AddressExtractor",
          "description": "Display an address as a single string - `<ip>:<port>`.",
          "x-order": 0
        },
        "from": {
          "description": "Attribute path is a dot-separated path to attribute.\n\nShould be either:\n* one of the fields of [Attribute Context](https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/attribute_context.proto), or\n* a special `request.http.bearer` pseudo-attribute.\nFor example, `request.http.method` or `request.http.header.user-agent`\n\nNote: The same attribute path syntax is shared by other extractor variants,\nwherever attribute path is needed in their \"from\" syntax.\n\nExample:\n```yaml\nfrom: request.http.headers.user-agent\n```",
          "title": "Use an attribute with no conversion",
          "type": "string",
          "x-order": 1
        },
        "json": {
          "$ref": "#/definitions/JSONExtractor",
          "description": "Parse JSON, and extract one of the fields.",
          "x-order": 2
        },
        "jwt": {
          "$ref": "#/definitions/JWTExtractor",
          "description": "Parse the attribute as JWT and read the payload.",
          "x-order": 3
        },
        "path_templates": {
          "$ref": "#/definitions/PathTemplateMatcher",
          "description": "Match HTTP Path to given path templates.",
          "x-order": 4
        }
      },
      "title": "Defines a high-level way to specify how to extract a flow label value given HTTP request metadata, without a need to write Rego code",
      "type": "object",
      "additionalProperties": false
    },
    "Extrapolator": {
      "description": "It does so until `maximum_extrapolation_interval` is reached, beyond which it emits invalid signal unless input signal becomes valid again.",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/ExtrapolatorIns",
          "description": "Input ports for the Extrapolator component.",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/ExtrapolatorOuts",
          "description": "Output ports for the Extrapolator component.",
          "x-order": 1
        },
        "parameters": {
          "$ref": "#/definitions/ExtrapolatorParameters",
          "description": "Parameters for the Extrapolator component.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 2
        }
      },
      "title": "Extrapolates the input signal by repeating the last valid value during the period in which it is invalid",
      "type": "object",
      "additionalProperties": false
    },
    "ExtrapolatorIns": {
      "description": "Inputs for the Extrapolator component.",
      "properties": {
        "input": {
          "$ref": "#/definitions/InPort",
          "description": "Input signal for the Extrapolator component.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "ExtrapolatorOuts": {
      "description": "Outputs for the Extrapolator component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "Extrapolated signal.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "ExtrapolatorParameters": {
      "description": "Parameters for the Extrapolator component.",
      "properties": {
        "max_extrapolation_interval": {
          "description": "Maximum time interval to repeat the last valid value of input signal.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 0
        }
      },
      "required": ["max_extrapolation_interval"],
      "type": "object",
      "additionalProperties": false
    },
    "FirstValid": {
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/FirstValidIns",
          "description": "Input ports for the FirstValid component.",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/FirstValidOuts",
          "description": "Output ports for the FirstValid component.",
          "x-order": 1
        }
      },
      "title": "Picks the first valid input signal from the array of input signals and emits it as an output signal",
      "type": "object",
      "additionalProperties": false
    },
    "FirstValidIns": {
      "description": "Inputs for the FirstValid component.",
      "properties": {
        "inputs": {
          "description": "Array of input signals.\n\n",
          "items": {
            "$ref": "#/definitions/InPort",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "dive",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "FirstValidOuts": {
      "description": "Outputs for the FirstValid component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "First valid input signal as an output signal.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "FlowControl": {
      "description": "_Flow Control_ encompasses components that manage the flow of requests or access to features within a service.",
      "properties": {
        "adaptive_load_scheduler": {
          "$ref": "#/definitions/AdaptiveLoadScheduler",
          "description": "_Adaptive Load Scheduler_ component is based on additive increase and multiplicative decrease of token rate. It takes a signal and setpoint as inputs and reduces token rate proportionally (or any arbitrary power) based on deviation of the signal from setpoint.",
          "x-order": 0
        },
        "aimd_concurrency_controller": {
          "$ref": "#/definitions/AIMDConcurrencyController",
          "title": "AIMD Concurrency control component is based on Additive Increase and Multiplicative Decrease of Concurrency. It takes a signal and setpoint as inputs and reduces concurrency limits proportionally (or any arbitrary power) based on deviation of the signal from setpoint. Internally implemented as a nested circuit.\nDeprecated: 1.6.0",
          "x-order": 1
        },
        "concurrency_limiter": {
          "$ref": "#/definitions/ConcurrencyLimiter",
          "title": "_Concurrency Limiter_ provides service protection by applying prioritized load shedding of flows using a network scheduler (for example, Weighted Fair Queuing).\nDeprecated: 1.6.0",
          "x-order": 2
        },
        "flow_regulator": {
          "$ref": "#/definitions/FlowRegulator",
          "title": "Flow Regulator is a component that regulates the flow of requests to the service by allowing only the specified percentage of requests or sticky sessions.\nDeprecated: 1.6.0",
          "x-order": 3
        },
        "load_ramp": {
          "$ref": "#/definitions/LoadRamp",
          "description": "_Load Ramp_ smoothly regulates the flow of requests over specified steps.",
          "x-order": 4
        },
        "load_ramp_series": {
          "$ref": "#/definitions/LoadRampSeries",
          "description": "_Load Ramp Series_ is a series of _Load Ramp_ components that can shape load one after another at same or different _Control Points_.",
          "x-order": 5
        },
        "load_scheduler": {
          "$ref": "#/definitions/LoadScheduler",
          "description": "_Load Scheduler_ provides service protection by applying prioritized load shedding of flows using a network scheduler (for example, Weighted Fair Queuing).",
          "x-order": 6
        },
        "load_shaper": {
          "$ref": "#/definitions/LoadShaper",
          "title": "_Load Shaper_ is a component that shapes the load at a _Control Point_.\nDeprecated: 1.6.0",
          "x-order": 7
        },
        "load_shaper_series": {
          "$ref": "#/definitions/LoadShaperSeries",
          "title": "_Load Shaper Series_ is a series of _Load Shaper_ components that can shape load one after another at same or different _Control Points_.\nDeprecated: 1.6.0",
          "x-order": 8
        },
        "rate_limiter": {
          "$ref": "#/definitions/RateLimiter",
          "description": "_Rate Limiter_ provides service protection by applying rate limits.",
          "x-order": 9
        },
        "regulator": {
          "$ref": "#/definitions/Regulator",
          "description": "Regulator is a component that regulates the flow of requests to the service by allowing only the specified percentage of requests or sticky sessions.",
          "x-order": 10
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "FlowControlResources": {
      "properties": {
        "classifiers": {
          "description": "Classifiers are installed in the data-plane and are used to label the requests based on payload content.\n\nThe flow labels created by Classifiers can be matched by Flux Meters to create metrics for control purposes.\n\n",
          "items": {
            "$ref": "#/definitions/Classifier",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "dive",
          "x-order": 0
        },
        "flux_meters": {
          "additionalProperties": {
            "$ref": "#/definitions/FluxMeter"
          },
          "description": "Flux Meters are installed in the data-plane and form the observability leg of the feedback loop.\n\nFlux Meter created metrics can be consumed as input to the circuit through the PromQL component.\n\n",
          "type": "object",
          "x-go-tag-validate": "dive",
          "x-order": 1
        }
      },
      "title": "FlowControl Resources",
      "type": "object",
      "additionalProperties": false
    },
    "FlowMatcher": {
      "description": ":::info\n\nSee also [FlowSelector overview](/concepts/flow-control/selector.md).\n\n:::\nExample:\n```yaml\ncontrol_point: ingress\nlabel_matcher:\n  match_labels:\n    user_tier: gold\n  match_expressions:\n    - key: query\n      operator: In\n      values:\n        - insert\n        - delete\n  expression:\n    label_matches:\n        - label: user_agent\n          regex: ^(?!.*Chrome).*Safari\n```\n\nDeprecated 1.8.0: Use `selectors` instead.",
      "properties": {
        "control_point": {
          "description": "[Control Point](/concepts/flow-control/selector.md#control-point)\nidentifies the location of a Flow within a Service. For an SDK based insertion, a Control Point can represent a particular feature or execution\nblock within a Service. In case of Service Mesh or Middleware insertion, a Control Point can identify ingress or egress calls or distinct listeners\nor filter chains.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "label_matcher": {
          "$ref": "#/definitions/LabelMatcher",
          "description": ":::info\n\nSee also [Label Matcher overview](/concepts/flow-control/selector.md#label-matcher).\n\n:::\n\n:::note\n\n[Classifiers](#classifier) _can_ use flow labels created by some other\nclassifier, but only if they were created at some previous control point\n(and propagated in baggage).\n\nThis limitation does not apply to selectors of other entities, like\nFlux Meters or Actuators. It's valid to create a flow label on a control\npoint using classifier, and immediately use it for matching on the same\ncontrol point.\n\n:::",
          "title": "Label matcher allows to add _additional_ condition on\n[flow labels](/concepts/flow-control/flow-label.md)\nmust also be satisfied (in addition to service+control point matching)",
          "x-order": 1
        }
      },
      "required": ["control_point"],
      "title": "Describes which flows a [flow control\ncomponent](/concepts/flow-control/flow-control.md#components) should apply\nto",
      "type": "object",
      "additionalProperties": false
    },
    "FlowRegulator": {
      "description": "_Flow Regulator_ is a component that regulates the flow of requests to the service by allowing only the specified percentage of requests or sticky sessions.",
      "properties": {
        "default_config": {
          "$ref": "#/definitions/FlowRegulatorDynamicConfig",
          "description": "Default configuration.",
          "x-order": 0
        },
        "dynamic_config_key": {
          "description": "Configuration key for DynamicConfig.",
          "type": "string",
          "x-order": 1
        },
        "in_ports": {
          "$ref": "#/definitions/FlowRegulatorIns",
          "description": "Input ports for the _Flow Regulator_.",
          "x-order": 2
        },
        "parameters": {
          "$ref": "#/definitions/FlowRegulatorParameters",
          "description": "Parameters for the _Flow Regulator_.",
          "x-order": 3
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "FlowRegulatorDynamicConfig": {
      "properties": {
        "enable_label_values": {
          "description": "Specify certain label values to be accepted by this flow filter regardless of accept percentage.",
          "items": {
            "type": "string"
          },
          "type": "array",
          "x-order": 0
        }
      },
      "title": "Dynamic Configuration for _Flow Regulator_",
      "type": "object",
      "additionalProperties": false
    },
    "FlowRegulatorIns": {
      "properties": {
        "accept_percentage": {
          "$ref": "#/definitions/InPort",
          "description": "The percentage of requests to accept.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "FlowRegulatorParameters": {
      "properties": {
        "flow_selector": {
          "$ref": "#/definitions/FlowSelector",
          "description": "_Flow Selector_ selects the _Flows_ at which the _Flow Regulator_ is applied.\nDeprecated 1.8.0: Use `selectors` instead.\n\n",
          "x-go-tag-validate": "required_without=Selectors",
          "x-order": 0
        },
        "label_key": {
          "description": "The flow label key for identifying sessions.\n- When label key is specified, _Flow Regulator_ acts as a sticky filter.\n  The series of flows with the same value of label key get the same\n  decision provided that the `accept_percentage` is same or higher.\n- When label key is not specified, _Flow Regulator_ acts as a stateless filter.\n  Percentage of flows are selected randomly for rejection.",
          "type": "string",
          "x-order": 1
        },
        "selectors": {
          "description": "Selectors for the component.\n\n",
          "items": {
            "$ref": "#/definitions/Selector",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "required_without=FlowSelector,dive",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "FlowSelector": {
      "description": "Selects flows based on _Control Point_, flow labels, agent group and service that the [flow control\ncomponent](/concepts/flow-control/flow-control.md#components) operates on.\n\n:::info\n\nSee also [FlowSelector overview](/concepts/flow-control/selector.md).\n\n:::\n\nDeprecated 1.8.0: Use `selectors` instead.",
      "properties": {
        "flow_matcher": {
          "$ref": "#/definitions/FlowMatcher",
          "title": "Match control points and labels",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "service_selector": {
          "$ref": "#/definitions/ServiceSelector",
          "title": "Match agent group and service",
          "x-go-tag-validate": "required",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "FluxMeter": {
      "description": "Flux Meter gathers metrics for the traffic that matches its selector.\nThe histogram created by Flux Meter measures the workload latency by default.\n\n:::info\n\nSee also [Flux Meter overview](/concepts/flow-control/resources/flux-meter.md).\n\n:::\nExample:\n```yaml\nstatic_buckets:\n   buckets: [5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]\nflow_selector:\n  service_selector:\n     agent_group: demoapp\n     service: service1-demo-app.demoapp.svc.cluster.local\n  flow_matcher:\n     control_point: ingress\nattribute_key: response_duration_ms\n```",
      "properties": {
        "attribute_key": {
          "default": "workload_duration_ms",
          "description": "Key of the attribute in access log or span from which the metric for this flux meter is read.\n\n:::info\n\nFor list of available attributes in Envoy access logs, refer\n[Envoy Filter](/get-started/integrations/flow-control/envoy/istio.md#envoy-filter)\n\n:::\n\n",
          "type": "string",
          "x-go-tag-default": "workload_duration_ms",
          "x-order": 0
        },
        "exponential_buckets": {
          "$ref": "#/definitions/FluxMeterExponentialBuckets",
          "x-order": 1
        },
        "exponential_buckets_range": {
          "$ref": "#/definitions/FluxMeterExponentialBucketsRange",
          "x-order": 2
        },
        "flow_selector": {
          "$ref": "#/definitions/FlowSelector",
          "description": "The selection criteria for the traffic that will be measured.\nDeprecated 1.8.0: Use `selectors` instead.\n\n",
          "x-go-tag-validate": "required_without=Selectors",
          "x-order": 3
        },
        "linear_buckets": {
          "$ref": "#/definitions/FluxMeterLinearBuckets",
          "x-order": 4
        },
        "selectors": {
          "description": "Selectors for the component.\n\n",
          "items": {
            "$ref": "#/definitions/Selector",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "required_without=FlowSelector,dive",
          "x-order": 5
        },
        "static_buckets": {
          "$ref": "#/definitions/FluxMeterStaticBuckets",
          "x-order": 6
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "FluxMeterExponentialBuckets": {
      "description": "ExponentialBuckets creates `count` number of buckets where the lowest bucket has an upper bound of `start`\nand each following bucket's upper bound is `factor` times the previous bucket's upper bound. The final +inf\nbucket is not counted.",
      "properties": {
        "count": {
          "description": "Number of buckets.\n\n",
          "exclusiveMinimum": 0,
          "format": "int32",
          "type": "integer",
          "x-go-tag-validate": "gt=0",
          "x-order": 0
        },
        "factor": {
          "description": "Factor to be multiplied to the previous bucket's upper bound to calculate the following bucket's upper bound.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-validate": "gt=1.0",
          "x-order": 1
        },
        "start": {
          "description": "Upper bound of the lowest bucket.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-validate": "gt=0.0",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "FluxMeterExponentialBucketsRange": {
      "description": "ExponentialBucketsRange creates `count` number of buckets where the lowest bucket is `min` and the highest\nbucket is `max`. The final +inf bucket is not counted.",
      "properties": {
        "count": {
          "description": "Number of buckets.\n\n",
          "exclusiveMinimum": 0,
          "format": "int32",
          "type": "integer",
          "x-go-tag-validate": "gt=0",
          "x-order": 0
        },
        "max": {
          "description": "Highest bucket.",
          "format": "double",
          "type": "number",
          "x-order": 1
        },
        "min": {
          "description": "Lowest bucket.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-validate": "gt=0.0",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "FluxMeterLinearBuckets": {
      "description": "LinearBuckets creates `count` number of buckets, each `width` wide, where the lowest bucket has an\nupper bound of `start`. The final +inf bucket is not counted.",
      "properties": {
        "count": {
          "description": "Number of buckets.\n\n",
          "exclusiveMinimum": 0,
          "format": "int32",
          "type": "integer",
          "x-go-tag-validate": "gt=0",
          "x-order": 0
        },
        "start": {
          "description": "Upper bound of the lowest bucket.",
          "format": "double",
          "type": "number",
          "x-order": 1
        },
        "width": {
          "description": "Width of each bucket.",
          "format": "double",
          "type": "number",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "FluxMeterStaticBuckets": {
      "description": "StaticBuckets holds the static value of the buckets where latency histogram will be stored.",
      "properties": {
        "buckets": {
          "default": [5, 10, 25, 50, 100, 250, 500, 1000, 2500, 5000, 10000],
          "description": "The buckets in which latency histogram will be stored.\n\n",
          "items": {
            "format": "double",
            "type": "number"
          },
          "type": "array",
          "x-go-tag-default": "[5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "GradientController": {
      "description": "The `gradient` describes a corrective factor that should be applied to the\ncontrol variable to get the signal closer to the setpoint. It's computed as follows:\n\n$$\n\\text{gradient} = \\left(\\frac{\\text{signal}}{\\text{setpoint}}\\right)^{\\text{slope}}\n$$\n\n`gradient` is then clamped to `[min_gradient, max_gradient]` range.\n\nThe output of gradient controller is computed as follows:\n$$\n\\text{output} = \\text{gradient}_{\\text{clamped}} \\cdot \\text{control\\_variable} + \\text{optimize}.\n$$\n\nNote the additional `optimize` signal, that can be used to \"nudge\" the\ncontroller into desired idle state.\n\nThe output can be _optionally_ clamped to desired range using `max` and\n`min` input.",
      "properties": {
        "default_config": {
          "$ref": "#/definitions/GradientControllerDynamicConfig",
          "description": "Default configuration.",
          "x-order": 0
        },
        "dynamic_config_key": {
          "title": "Configuration key for DynamicConfig",
          "type": "string",
          "x-order": 1
        },
        "in_ports": {
          "$ref": "#/definitions/GradientControllerIns",
          "description": "Input ports of the Gradient Controller.",
          "x-order": 2
        },
        "out_ports": {
          "$ref": "#/definitions/GradientControllerOuts",
          "description": "Output ports of the Gradient Controller.",
          "x-order": 3
        },
        "parameters": {
          "$ref": "#/definitions/GradientControllerParameters",
          "description": "Gradient Parameters.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 4
        }
      },
      "title": "Gradient controller is a type of controller which tries to adjust the\ncontrol variable proportionally to the relative difference between setpoint\nand actual value of the signal",
      "type": "object",
      "additionalProperties": false
    },
    "GradientControllerDynamicConfig": {
      "properties": {
        "manual_mode": {
          "default": false,
          "description": "Decides whether the controller runs in `manual_mode`.\nIn manual mode, the controller does not adjust the control variable It emits the same output as the control variable input.\n\n",
          "type": "boolean",
          "x-go-tag-default": "false",
          "x-order": 0
        }
      },
      "title": "Dynamic Configuration for a Controller",
      "type": "object",
      "additionalProperties": false
    },
    "GradientControllerIns": {
      "description": "Inputs for the Gradient Controller component.",
      "properties": {
        "control_variable": {
          "$ref": "#/definitions/InPort",
          "description": "Actual current value of the control variable.\n\nThis signal is multiplied by the gradient to produce the output.",
          "x-order": 0
        },
        "max": {
          "$ref": "#/definitions/InPort",
          "description": "Maximum value to limit the output signal.",
          "x-order": 1
        },
        "min": {
          "$ref": "#/definitions/InPort",
          "description": "Minimum value to limit the output signal.",
          "x-order": 2
        },
        "optimize": {
          "$ref": "#/definitions/InPort",
          "description": "Optimize signal is added to the output of the gradient calculation.",
          "x-order": 3
        },
        "setpoint": {
          "$ref": "#/definitions/InPort",
          "description": "Setpoint to be used for the gradient computation.",
          "x-order": 4
        },
        "signal": {
          "$ref": "#/definitions/InPort",
          "description": "Signal to be used for the gradient computation.",
          "x-order": 5
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "GradientControllerOuts": {
      "description": "Outputs for the Gradient Controller component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "Computed desired value of the control variable.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "GradientControllerParameters": {
      "description": "Gradient Parameters.",
      "properties": {
        "max_gradient": {
          "default": 1.7976931348623157e308,
          "description": "Maximum gradient which clamps the computed gradient value to the range, `[min_gradient, max_gradient]`.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-default": "1.79769313486231570814527423731704356798070e+308",
          "x-order": 0
        },
        "min_gradient": {
          "default": -1.7976931348623157e308,
          "description": "Minimum gradient which clamps the computed gradient value to the range, `[min_gradient, max_gradient]`.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-default": "-1.79769313486231570814527423731704356798070e+308",
          "x-order": 1
        },
        "slope": {
          "description": "Slope controls the aggressiveness and direction of the Gradient Controller.\n\nSlope is used as exponent on the signal to setpoint ratio in computation\nof the gradient (see the [main description](#gradient-controller) for\nexact equation). This parameter decides how aggressive the controller\nresponds to the deviation of signal from the setpoint.\nfor example:\n* $\\text{slope} = 1$: when signal is too high, increase control variable,\n* $\\text{slope} = -1$: when signal is too high, decrease control variable,\n* $\\text{slope} = -0.5$: when signal is too high, decrease control variable gradually.\n\nThe sign of slope depends on correlation between the signal and control variable:\n* Use $\\text{slope} < 0$ if there is a _positive_ correlation between the signal and\nthe control variable (for example, Per-pod CPU usage and total concurrency).\n* Use $\\text{slope} > 0$ if there is a _negative_ correlation between the signal and\nthe control variable (for example, Per-pod CPU usage and number of pods).\n\n:::note\n\nYou need to set _negative_ slope for a _positive_ correlation, as you're\ndescribing the _action_ which controller should make when the signal\nincreases.\n\n:::\n\nThe magnitude of slope describes how aggressively should the controller\nreact to a deviation of signal.\nWith $|\\text{slope}| = 1$, the controller will aim to bring the signal to\nthe setpoint in one tick (assuming linear correlation with signal and setpoint).\nSmaller magnitudes of slope will make the controller adjust the control\nvariable gradually.\n\nSetting $|\\text{slope}| < 1$ (for example, $\\pm0.8$) is recommended.\nIf you experience overshooting, consider lowering the magnitude even more.\nValues of $|\\text{slope}| > 1$ aren't recommended.\n\n:::note\n\nRemember that the gradient and output signal can be (optionally) clamped,\nso the _slope_ might not fully describe aggressiveness of the controller.\n\n:::\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-validate": "required",
          "x-order": 2
        }
      },
      "required": ["slope"],
      "type": "object",
      "additionalProperties": false
    },
    "Holder": {
      "description": "Holds the last valid signal value for the specified duration then waits for next valid value to hold.\nIf it is holding a value that means it ignores both valid and invalid new signals until the `hold_for` duration is finished.",
      "properties": {
        "hold_for": {
          "default": "5s",
          "description": "Holding the last valid signal value for the `hold_for` duration.\n\n",
          "type": "string",
          "x-go-tag-default": "5s",
          "x-order": 0
        },
        "in_ports": {
          "$ref": "#/definitions/HolderIns",
          "description": "Input ports for the Holder component.",
          "x-order": 1
        },
        "out_ports": {
          "$ref": "#/definitions/HolderOuts",
          "description": "Output ports for the Holder component.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "HolderIns": {
      "description": "Inputs for the Holder component.",
      "properties": {
        "input": {
          "$ref": "#/definitions/InPort",
          "description": "The input signal.",
          "x-order": 0
        },
        "reset": {
          "$ref": "#/definitions/InPort",
          "description": "Resets the holder output to the current input signal when reset signal is valid and non-zero.",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "HolderOuts": {
      "description": "Outputs for the Holder component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "The output signal.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "InPort": {
      "properties": {
        "constant_signal": {
          "$ref": "#/definitions/ConstantSignal",
          "description": "Constant value to be used for this InPort instead of a signal.",
          "x-order": 0
        },
        "signal_name": {
          "description": "Name of the incoming Signal on the InPort.",
          "type": "string",
          "x-order": 1
        }
      },
      "title": "Components receive input from other components through InPorts",
      "type": "object",
      "additionalProperties": false
    },
    "IncreasingGradient": {
      "description": "Increasing Gradient defines a controller for scaling out based on Gradient Controller.",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/IncreasingGradientIns",
          "description": "Input ports for the Gradient.",
          "x-order": 0
        },
        "parameters": {
          "$ref": "#/definitions/IncreasingGradientParameters",
          "title": "Gradient parameters for the controller. Defaults and constraints:\n* `slope` = 1\n* `min_gradient` = 1 (cannot be changed)\n* `max_gradient` = +Inf (must be greater than 1)",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "IncreasingGradientIns": {
      "description": "Inputs for Gradient.",
      "properties": {
        "setpoint": {
          "$ref": "#/definitions/InPort",
          "description": "The setpoint to use for scale-out.",
          "x-order": 0
        },
        "signal": {
          "$ref": "#/definitions/InPort",
          "description": "The signal to use for scale-out.",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "IncreasingGradientParameters": {
      "description": "This allows subset of parameters with constrained values compared to a regular gradient controller. For full documentation of these parameters, refer to the [GradientControllerParameters](#gradient-controller-parameters).",
      "properties": {
        "max_gradient": {
          "default": 1.7976931348623157e308,
          "format": "double",
          "type": "number",
          "x-go-tag-default": "1.79769313486231570814527423731704356798070e+308",
          "x-go-tag-validate": "gte=1.0",
          "x-order": 0
        },
        "slope": {
          "default": 1,
          "format": "double",
          "type": "number",
          "x-go-tag-default": "1.0",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Integrator": {
      "description": "Accumulates sum of signal every tick.",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/IntegratorIns",
          "description": "Input ports for the Integrator component.",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/IntegratorOuts",
          "description": "Output ports for the Integrator component.",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "IntegratorIns": {
      "description": "Inputs for the Integrator component.",
      "properties": {
        "input": {
          "$ref": "#/definitions/InPort",
          "description": "The input signal.",
          "x-order": 0
        },
        "max": {
          "$ref": "#/definitions/InPort",
          "description": "The maximum output.",
          "x-order": 1
        },
        "min": {
          "$ref": "#/definitions/InPort",
          "description": "The minimum output.",
          "x-order": 2
        },
        "reset": {
          "$ref": "#/definitions/InPort",
          "description": "Resets the integrator output to zero when reset signal is valid and non-zero. Reset also resets the max and min constraints.",
          "x-order": 3
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "IntegratorOuts": {
      "description": "Outputs for the Integrator component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Inverter": {
      "description": "Logical NOT.\n\nSee [And component](#and) on how signals are mapped onto Boolean values.",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/InverterIns",
          "description": "Input ports for the Inverter component.",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/InverterOuts",
          "description": "Output ports for the Inverter component.",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "InverterIns": {
      "description": "Inputs for the Inverter component.",
      "properties": {
        "input": {
          "$ref": "#/definitions/InPort",
          "description": "Signal to be negated.\n\n",
          "x-go-tag-validate": "dive",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "InverterOuts": {
      "description": "Output ports for the Inverter component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "Logical negation of the input signal.\n\nWill always be 0 (false), 1 (true) or invalid (unknown).",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "JSONExtractor": {
      "description": "Example:\n```yaml\nfrom: request.http.body\npointer: /user/name\n```",
      "properties": {
        "from": {
          "description": "Attribute path pointing to some strings - for example, `request.http.body`.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "pointer": {
          "description": "JSON pointer represents a parsed JSON pointer which allows to select a specified field from the payload.\n\nNote: Uses [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,\nfor example, `/foo/bar`. If the pointer points into an object, it'd be converted to a string.",
          "type": "string",
          "x-order": 1
        }
      },
      "required": ["from"],
      "title": "Parse JSON, and extract one of the fields",
      "type": "object",
      "additionalProperties": false
    },
    "JWTExtractor": {
      "description": "Specify a field to be extracted from payload using `json_pointer`.\n\nNote: The signature is not verified against the secret (assuming there's some\nother part of the system that handles such verification).\n\nExample:\n```yaml\nfrom: request.http.bearer\njson_pointer: /user/email\n```",
      "properties": {
        "from": {
          "description": "JWT (JSON Web Token) can be extracted from any input attribute, but most likely you'd want to use `request.http.bearer`.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "json_pointer": {
          "description": "JSON pointer allowing to select a specified field from the payload.\n\nNote: Uses [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,\nfor example, `/foo/bar`. If the pointer points into an object, it'd be converted to a string.",
          "type": "string",
          "x-order": 1
        }
      },
      "required": ["from"],
      "title": "Parse the attribute as JWT and read the payload",
      "type": "object",
      "additionalProperties": false
    },
    "K8sLabelMatcherRequirement": {
      "description": "Label selector requirement which is a selector that contains values, a key, and an operator that relates the key and values.",
      "properties": {
        "key": {
          "description": "Label key that the selector applies to.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "operator": {
          "description": "Logical operator which represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.\n\n",
          "enum": ["In", "NotIn", "Exists", "DoesNotExists"],
          "type": "string",
          "x-go-tag-validate": "oneof=In NotIn Exists DoesNotExists",
          "x-oneof": "In | NotIn | Exists | DoesNotExists",
          "x-order": 1
        },
        "values": {
          "description": "An array of string values that relates to the key by an operator.\nIf the operator is In or NotIn, the values array must be non-empty.\nIf the operator is Exists or DoesNotExist, the values array must be empty.",
          "items": {
            "type": "string"
          },
          "type": "array",
          "x-order": 2
        }
      },
      "required": ["key"],
      "type": "object",
      "additionalProperties": false
    },
    "KubernetesObjectSelector": {
      "description": "Describes which pods a control or observability\ncomponent should apply to.",
      "properties": {
        "agent_group": {
          "default": "default",
          "description": "Which [agent-group](/concepts/flow-control/selector.md#agent-group) this\nselector applies to.\n\n",
          "type": "string",
          "x-go-tag-default": "default",
          "x-order": 0
        },
        "api_version": {
          "title": "API version of Kubernetes resource",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 1
        },
        "kind": {
          "description": "Kubernetes resource type.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 2
        },
        "name": {
          "description": "Kubernetes resource name.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 3
        },
        "namespace": {
          "description": "Kubernetes namespace that the resource belongs to.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 4
        }
      },
      "required": ["api_version", "kind", "name", "namespace"],
      "type": "object",
      "additionalProperties": false
    },
    "KubernetesReplicas": {
      "description": "KubernetesReplicas defines a horizontal pod scaler for Kubernetes.",
      "properties": {
        "default_config": {
          "$ref": "#/definitions/PodScalerScaleActuatorDynamicConfig",
          "description": "Default configuration.",
          "x-order": 0
        },
        "dynamic_config_key": {
          "title": "Configuration key for DynamicConfig",
          "type": "string",
          "x-order": 1
        },
        "kubernetes_object_selector": {
          "$ref": "#/definitions/KubernetesObjectSelector",
          "description": "The Kubernetes object on which horizontal scaling is applied.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LabelMatcher": {
      "description": "It provides three ways to define requirements:\n- match labels\n- match expressions\n- arbitrary expression\n\nIf multiple requirements are set, they're all combined using the logical AND operator.\nAn empty label matcher always matches.",
      "properties": {
        "expression": {
          "$ref": "#/definitions/MatchExpression",
          "description": "An arbitrary expression to be evaluated on the labels.",
          "x-order": 0
        },
        "match_expressions": {
          "description": "List of Kubernetes-style label matcher requirements.\n\nNote: The requirements are combined using the logical AND operator.",
          "items": {
            "$ref": "#/definitions/K8sLabelMatcherRequirement",
            "type": "object"
          },
          "type": "array",
          "x-order": 1
        },
        "match_labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "A map of {key,value} pairs representing labels to be matched.\nA single {key,value} in the `match_labels` requires that the label `key` is present and equal to `value`.\n\nNote: The requirements are combined using the logical AND operator.",
          "type": "object",
          "x-order": 2
        }
      },
      "title": "Allows to define rules whether a map of\n[labels](/concepts/flow-control/flow-label.md)\nshould be considered a match or not",
      "type": "object",
      "additionalProperties": false
    },
    "LoadActuator": {
      "properties": {
        "default_config": {
          "$ref": "#/definitions/LoadActuatorDynamicConfig",
          "description": "Default configuration.",
          "x-order": 0
        },
        "dynamic_config_key": {
          "description": "Configuration key for DynamicConfig.",
          "type": "string",
          "x-order": 1
        },
        "in_ports": {
          "$ref": "#/definitions/LoadActuatorIns",
          "description": "Input ports for the Load Actuator component.",
          "x-order": 2
        }
      },
      "title": "Takes the load multiplier input signal and publishes it to the schedulers in the data-plane",
      "type": "object",
      "additionalProperties": false
    },
    "LoadActuatorDynamicConfig": {
      "properties": {
        "dry_run": {
          "description": "Decides whether to run the load actuator in dry-run mode. Dry run mode ensures that no traffic gets dropped by this load actuator.\nUseful for observing the behavior of Load Actuator without disrupting any real traffic.",
          "type": "boolean",
          "x-order": 0
        }
      },
      "title": "Dynamic Configuration for LoadActuator",
      "type": "object",
      "additionalProperties": false
    },
    "LoadActuatorIns": {
      "description": "Input for the Load Actuator component.",
      "properties": {
        "load_multiplier": {
          "$ref": "#/definitions/InPort",
          "description": "Load multiplier is proportion of [incoming\ntoken rate](#scheduler-outs) that needs to be accepted.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadRamp": {
      "description": "The _Load Ramp_ produces a smooth and continuous traffic load\nthat changes progressively over time, based on the specified steps.\n\nEach step is defined by two parameters:\n- The `target_accept_percentage`.\n- The `duration` for the signal to change from the\n  previous step's `target_accept_percentage` to the current step's\n  `target_accept_percentage`.\n\nThe percentage of requests accepted starts at the `target_accept_percentage`\ndefined in the first step and gradually ramps up or down linearly from\nthe previous step's `target_accept_percentage` to the next\n`target_accept_percentage`, over the `duration` specified for each step.",
      "properties": {
        "default_config": {
          "$ref": "#/definitions/RegulatorDynamicConfig",
          "description": "Default configuration.",
          "x-order": 0
        },
        "dynamic_config_key": {
          "description": "Dynamic configuration key for flow regulator.",
          "type": "string",
          "x-order": 1
        },
        "in_ports": {
          "$ref": "#/definitions/LoadRampIns",
          "x-order": 2
        },
        "out_ports": {
          "$ref": "#/definitions/LoadRampOuts",
          "x-order": 3
        },
        "parameters": {
          "$ref": "#/definitions/LoadRampParameters",
          "x-go-tag-validate": "required",
          "x-order": 4
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadRampIns": {
      "description": "Inputs for the _Load Ramp_ component.",
      "properties": {
        "backward": {
          "$ref": "#/definitions/InPort",
          "description": "Whether to progress the _Load Ramp_ towards the previous step.",
          "x-order": 0
        },
        "forward": {
          "$ref": "#/definitions/InPort",
          "description": "Whether to progress the _Load Ramp_ towards the next step.",
          "x-order": 1
        },
        "reset": {
          "$ref": "#/definitions/InPort",
          "description": "Whether to reset the _Load Ramp_ to the first step.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadRampOuts": {
      "description": "Outputs for the _Load Ramp_ component.",
      "properties": {
        "accept_percentage": {
          "$ref": "#/definitions/OutPort",
          "description": "The percentage of flows being accepted by the _Load Ramp_.",
          "x-order": 0
        },
        "at_end": {
          "$ref": "#/definitions/OutPort",
          "description": "A Boolean signal indicating whether the _Load Ramp_ is at the end of signal generation.",
          "x-order": 1
        },
        "at_start": {
          "$ref": "#/definitions/OutPort",
          "description": "A Boolean signal indicating whether the _Load Ramp_ is at the start of signal generation.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadRampParameters": {
      "description": "Parameters for the _Load Ramp_ component.",
      "properties": {
        "regulator_parameters": {
          "$ref": "#/definitions/RegulatorParameters",
          "description": "Parameters for the _Regulator_.",
          "x-order": 0
        },
        "steps": {
          "items": {
            "$ref": "#/definitions/LoadRampParametersStep",
            "type": "object"
          },
          "minItems": 1,
          "type": "array",
          "x-go-tag-validate": "required,gt=0,dive",
          "x-order": 1
        }
      },
      "required": ["steps"],
      "type": "object",
      "additionalProperties": false
    },
    "LoadRampParametersStep": {
      "properties": {
        "duration": {
          "description": "Duration for which the step is active.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "target_accept_percentage": {
          "description": "The value of the step.\n\n",
          "format": "double",
          "maximum": 100,
          "minimum": 0,
          "type": "number",
          "x-go-tag-validate": "gte=0,lte=100",
          "x-order": 1
        }
      },
      "required": ["duration"],
      "type": "object",
      "additionalProperties": false
    },
    "LoadRampSeries": {
      "description": "_LoadRampSeries_ is a component that applies a series of _Load Ramps_ in order.",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/LoadRampSeriesIns",
          "x-order": 0
        },
        "parameters": {
          "$ref": "#/definitions/LoadRampSeriesParameters",
          "x-go-tag-validate": "required",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadRampSeriesIns": {
      "description": "Inputs for the _LoadRampSeries_ component.",
      "properties": {
        "backward": {
          "$ref": "#/definitions/InPort",
          "description": "Whether to progress the load ramp series towards the previous step.",
          "x-order": 0
        },
        "forward": {
          "$ref": "#/definitions/InPort",
          "description": "Whether to progress the load ramp series towards the next step.",
          "x-order": 1
        },
        "reset": {
          "$ref": "#/definitions/InPort",
          "description": "Whether to reset the load ramp series to the first step.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadRampSeriesLoadRampInstance": {
      "properties": {
        "load_ramp": {
          "$ref": "#/definitions/LoadRampParameters",
          "description": "The load ramp.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/LoadRampOuts",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadRampSeriesParameters": {
      "description": "Parameters for the _LoadRampSeries_ component.",
      "properties": {
        "load_ramps": {
          "description": "An ordered list of load ramps that get applied in order.\n\n",
          "items": {
            "$ref": "#/definitions/LoadRampSeriesLoadRampInstance",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "required,dive",
          "x-order": 0
        }
      },
      "required": ["load_ramps"],
      "type": "object",
      "additionalProperties": false
    },
    "LoadScheduler": {
      "description": ":::info\n\nSee also [_Load Scheduler_ overview](/concepts/flow-control/components/load-scheduler.md).\n\n:::\n\nIt's based on the actuation strategy (for example, load actuator) and workload scheduling\nwhich is based on Weighted Fair Queuing principles.\nIt measures and controls the incoming tokens per second, which can translate\nto (avg. latency \\* in-flight requests) (Little's Law) in concurrency limiting use-case.\n\nLoadScheduler configuration is split into two parts: An actuation\nstrategy and a scheduler. At this time, only `load_actuator` strategy is available.",
      "properties": {
        "actuator": {
          "$ref": "#/definitions/LoadSchedulerActuator",
          "description": "Actuator based on limiting the accepted token rate under incoming token rate * load multiplier.",
          "x-order": 0
        },
        "flow_selector": {
          "$ref": "#/definitions/FlowSelector",
          "description": "Flow Selector decides the service and flows at which the _Load Scheduler_ is applied.\nDeprecated 1.8.0: Use `selectors` instead.\n\n",
          "x-go-tag-validate": "required_without=Selectors",
          "x-order": 1
        },
        "scheduler": {
          "$ref": "#/definitions/LoadSchedulerScheduler",
          "description": "Configuration of Weighted Fair Queuing-based workload scheduler.\n\nContains configuration of per-agent scheduler, and also defines some\noutput signals.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 2
        },
        "selectors": {
          "description": "Selectors for the component.\n\n",
          "items": {
            "$ref": "#/definitions/Selector",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "required_without=FlowSelector,dive",
          "x-order": 3
        }
      },
      "title": "_Load Scheduler_ is an actuator component that regulates flows to provide active service protection",
      "type": "object",
      "additionalProperties": false
    },
    "LoadSchedulerActuator": {
      "properties": {
        "default_config": {
          "$ref": "#/definitions/LoadSchedulerActuatorDynamicConfig",
          "description": "Default configuration.",
          "x-order": 0
        },
        "dynamic_config_key": {
          "description": "Configuration key for DynamicConfig.",
          "type": "string",
          "x-order": 1
        },
        "in_ports": {
          "$ref": "#/definitions/LoadSchedulerActuatorIns",
          "description": "Input ports for the Actuator component.",
          "x-order": 2
        }
      },
      "title": "Takes the load multiplier input signal and publishes it to the schedulers in the data-plane",
      "type": "object",
      "additionalProperties": false
    },
    "LoadSchedulerActuatorDynamicConfig": {
      "properties": {
        "dry_run": {
          "description": "Decides whether to run the actuator in dry-run mode. Dry run mode ensures that no traffic gets dropped by this actuator.\nUseful for observing the behavior of actuator without disrupting any real traffic.",
          "type": "boolean",
          "x-order": 0
        }
      },
      "title": "Dynamic Configuration for Actuator",
      "type": "object",
      "additionalProperties": false
    },
    "LoadSchedulerActuatorIns": {
      "description": "Input for the Actuator component.",
      "properties": {
        "load_multiplier": {
          "$ref": "#/definitions/InPort",
          "description": "Load multiplier is proportion of [incoming\ntoken rate](#scheduler-outs) that needs to be accepted.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadSchedulerScheduler": {
      "properties": {
        "out_ports": {
          "$ref": "#/definitions/LoadSchedulerSchedulerOuts",
          "description": "Output ports for the Scheduler component.",
          "x-order": 0
        },
        "parameters": {
          "$ref": "#/definitions/LoadSchedulerSchedulerParameters",
          "description": "Scheduler parameters.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadSchedulerSchedulerOuts": {
      "description": "Output for the Scheduler component.",
      "properties": {
        "accepted_token_rate": {
          "$ref": "#/definitions/OutPort",
          "description": "Accepted token rate is the tokens admitted per second by the scheduler.\nValue of this signal is aggregated from all the relevant schedulers.",
          "x-order": 0
        },
        "incoming_token_rate": {
          "$ref": "#/definitions/OutPort",
          "description": "Incoming token rate is the incoming tokens per second for all the\nflows entering the scheduler including the rejected ones.\n\nThis is computed similar to `accepted_token_rate`,\nby summing up tokens from all the flows entering scheduler.",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadSchedulerSchedulerParameters": {
      "properties": {
        "auto_tokens": {
          "default": false,
          "description": "Automatically estimate the size of a flow in each workload, based on\nhistorical latency. Each workload's `tokens` will be set to average\nlatency of flows in that workload during last few seconds (exact duration\nof this average can change).\nThis setting is useful in concurrency limiting use-case, where the\nconcurrency is calculated as (avg. latency \\* in-flight flows).\n\nThe value of tokens estimated by `auto_tokens` takes lower precedence\nthan the value of `tokens` specified in the workload definition\nand `tokens` explicitly specified in the flow labels.\n\n",
          "type": "boolean",
          "x-go-tag-default": "false",
          "x-order": 0
        },
        "decision_deadline_margin": {
          "default": "0.01s",
          "description": "Decision deadline margin is the amount of time that the scheduler will\nsubtract from the request deadline to determine the deadline for the\ndecision. This is to ensure that the scheduler has enough time to\nmake a decision before the request deadline happens, accounting for\nprocessing delays.\nThe request deadline is based on the\n[gRPC deadline](https://grpc.io/blog/deadlines) or the\n[`grpc-timeout` HTTP header](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests).\n\nFail-open logic is use for flow control APIs, so if the gRPC deadline\nreaches, the flow will end up being unconditionally allowed while\nit is still waiting on the scheduler.\n\n",
          "type": "string",
          "x-go-tag-default": "0.01s",
          "x-order": 1
        },
        "default_workload_parameters": {
          "$ref": "#/definitions/LoadSchedulerSchedulerWorkloadParameters",
          "description": "Parameters to be used if none of workloads specified in `workloads` match.",
          "x-order": 2
        },
        "max_timeout": {
          "default": "0s",
          "description": "Deprecated: 1.5.0. Use `decision_deadline_margin` instead. This value is ignored.\n\n",
          "type": "string",
          "x-go-tag-default": "0s",
          "x-order": 3
        },
        "timeout_factor": {
          "default": 0,
          "description": "Deprecated: 1.5.0. Use `decision_deadline_margin` instead. This value is ignored.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-default": "0",
          "x-go-tag-validate": "gte=0.0",
          "x-order": 4
        },
        "tokens_label_key": {
          "default": "tokens",
          "description": "* Key for a flow label that can be used to override the default number of tokens for this flow.\n* The value associated with this key must be a valid uint64 number.\n* If this parameter is not provided, the number of tokens for the flow will be determined by the matched workload's token count.\n\n",
          "type": "string",
          "x-go-tag-default": "tokens",
          "x-order": 5
        },
        "workloads": {
          "description": "List of workloads to be used in scheduler.\n\nCategorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads\nallows for load-shedding to be \"intelligent\" compared to random rejections.\nThere are two aspects of this \"intelligence\":\n* Scheduler can more precisely calculate concurrency if it understands\n  that flows belonging to different classes have different weights (for example, insert queries compared to select queries).\n* Setting different priorities to different workloads lets the scheduler\n  avoid dropping important traffic during overload.\n\nEach workload in this list specifies also a matcher that is used to\ndetermine which flow will be categorized into which workload.\nIn case of multiple matching workloads, the first matching one will be used.\nIf none of workloads match, `default_workload` will be used.\n\n:::info\n\nSee also [workload definition in the concepts\nsection](/concepts/flow-control/components/load-scheduler.md#workload).\n\n:::\n\n",
          "items": {
            "$ref": "#/definitions/LoadSchedulerSchedulerWorkload",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "dive",
          "x-order": 6
        }
      },
      "title": "Scheduler parameters",
      "type": "object",
      "additionalProperties": false
    },
    "LoadSchedulerSchedulerWorkload": {
      "description": "Workload defines a class of flows that preferably have similar properties such as response latency and desired priority.",
      "properties": {
        "label_matcher": {
          "$ref": "#/definitions/LabelMatcher",
          "description": "Label Matcher to select a Workload based on\n[flow labels](/concepts/flow-control/flow-label.md).\n\n",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "parameters": {
          "$ref": "#/definitions/LoadSchedulerSchedulerWorkloadParameters",
          "description": "Parameters associated with flows matching the label matcher.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadSchedulerSchedulerWorkloadParameters": {
      "description": "Parameters such as priority, tokens and fairness key that\nare applicable to flows within a workload.",
      "properties": {
        "fairness_key": {
          "description": "Fairness key is a label key that can be used to provide fairness within a workload.\nAny [flow label](/concepts/flow-control/flow-label.md) can be used here. For example, if\nyou have a classifier that sets `user` flow label, you might want to set\n`fairness_key = \"user\"`.",
          "type": "string",
          "x-order": 0
        },
        "priority": {
          "default": 0,
          "description": "$$\n\\text{virtual\\_finish\\_time} = \\text{virtual\\_time} + \\left(\\text{tokens} \\cdot \\left(\\text{256} - \\text{priority}\\right)\\right)\n$$\n\n",
          "format": "int64",
          "maximum": 255,
          "minimum": 0,
          "title": "Describes priority level of the flows within the workload.\nPriority level ranges from 0 to 255.\nHigher numbers means higher priority level.\nPriority levels have non-linear effect on the workload scheduling. The following formula is used to determine the position of a flow in the queue based on virtual finish time:",
          "type": "integer",
          "x-go-tag-default": "0",
          "x-go-tag-validate": "gte=0,lte=255",
          "x-order": 1
        },
        "tokens": {
          "description": "Tokens determines the cost of admitting a single flow in the workload,\nwhich is typically defined as milliseconds of flow latency (time to response or duration of a feature) or\nsimply equal to 1 if the resource being accessed is constrained by the\nnumber of flows (3rd party rate limiters).\nThis override is applicable only if tokens for the flow aren't specified\nin the flow labels.",
          "format": "uint64",
          "type": "string",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadShaper": {
      "description": "The _Load Shaper_ produces a smooth and continuous traffic load\nthat changes progressively over time, based on the specified steps.\n\nEach step is defined by two parameters:\n- The `target_accept_percentage`.\n- The `duration` for the signal to change from the\n  previous step's `target_accept_percentage` to the current step's\n  `target_accept_percentage`.\n\nThe percentage of requests accepted starts at the `target_accept_percentage`\ndefined in the first step and gradually ramps up or down linearly from\nthe previous step's `target_accept_percentage` to the next\n`target_accept_percentage`, over the `duration` specified for each step.",
      "properties": {
        "default_config": {
          "$ref": "#/definitions/RegulatorDynamicConfig",
          "description": "Default configuration.",
          "x-order": 0
        },
        "dynamic_config_key": {
          "description": "Dynamic configuration key for flow regulator.",
          "type": "string",
          "x-order": 1
        },
        "in_ports": {
          "$ref": "#/definitions/LoadShaperIns",
          "x-order": 2
        },
        "out_ports": {
          "$ref": "#/definitions/LoadShaperOuts",
          "x-order": 3
        },
        "parameters": {
          "$ref": "#/definitions/LoadShaperParameters",
          "x-go-tag-validate": "required",
          "x-order": 4
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadShaperIns": {
      "description": "Inputs for the _Load Shaper_ component.",
      "properties": {
        "backward": {
          "$ref": "#/definitions/InPort",
          "description": "Whether to progress the _Load Shaper_ towards the previous step.",
          "x-order": 0
        },
        "forward": {
          "$ref": "#/definitions/InPort",
          "description": "Whether to progress the _Load Shaper_ towards the next step.",
          "x-order": 1
        },
        "reset": {
          "$ref": "#/definitions/InPort",
          "description": "Whether to reset the _Load Shaper_ to the first step.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadShaperOuts": {
      "description": "Outputs for the _Load Shaper_ component.",
      "properties": {
        "accept_percentage": {
          "$ref": "#/definitions/OutPort",
          "description": "The percentage of flows being accepted by the _Load Shaper_.",
          "x-order": 0
        },
        "at_end": {
          "$ref": "#/definitions/OutPort",
          "description": "A Boolean signal indicating whether the _Load Shaper_ is at the end of signal generation.",
          "x-order": 1
        },
        "at_start": {
          "$ref": "#/definitions/OutPort",
          "description": "A Boolean signal indicating whether the _Load Shaper_ is at the start of signal generation.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadShaperParameters": {
      "description": "Parameters for the _Load Shaper_ component.",
      "properties": {
        "flow_regulator_parameters": {
          "$ref": "#/definitions/FlowRegulatorParameters",
          "description": "Parameters for the _Flow Regulator_.",
          "x-order": 0
        },
        "steps": {
          "items": {
            "$ref": "#/definitions/LoadShaperParametersStep",
            "type": "object"
          },
          "minItems": 1,
          "type": "array",
          "x-go-tag-validate": "required,gt=0,dive",
          "x-order": 1
        }
      },
      "required": ["steps"],
      "type": "object",
      "additionalProperties": false
    },
    "LoadShaperParametersStep": {
      "properties": {
        "duration": {
          "description": "Duration for which the step is active.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "target_accept_percentage": {
          "description": "The value of the step.\n\n",
          "format": "double",
          "maximum": 100,
          "minimum": 0,
          "type": "number",
          "x-go-tag-validate": "gte=0,lte=100",
          "x-order": 1
        }
      },
      "required": ["duration"],
      "type": "object",
      "additionalProperties": false
    },
    "LoadShaperSeries": {
      "description": "_LoadShaperSeries_ is a component that applies a series of _Load Shapers_ in order.",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/LoadShaperSeriesIns",
          "x-order": 0
        },
        "parameters": {
          "$ref": "#/definitions/LoadShaperSeriesParameters",
          "x-go-tag-validate": "required",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadShaperSeriesIns": {
      "description": "Inputs for the _LoadShaperSeries_ component.",
      "properties": {
        "backward": {
          "$ref": "#/definitions/InPort",
          "description": "Whether to progress the load shaper series towards the previous step.",
          "x-order": 0
        },
        "forward": {
          "$ref": "#/definitions/InPort",
          "description": "Whether to progress the load shaper series towards the next step.",
          "x-order": 1
        },
        "reset": {
          "$ref": "#/definitions/InPort",
          "description": "Whether to reset the load shaper series to the first step.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadShaperSeriesLoadShaperInstance": {
      "properties": {
        "load_shaper": {
          "$ref": "#/definitions/LoadShaperParameters",
          "description": "The load shaper.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/LoadShaperOuts",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "LoadShaperSeriesParameters": {
      "description": "Parameters for the _LoadShaperSeries_ component.",
      "properties": {
        "load_shapers": {
          "description": "An ordered list of load shapers that get applied in order.\n\n",
          "items": {
            "$ref": "#/definitions/LoadShaperSeriesLoadShaperInstance",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "required,dive",
          "x-order": 0
        }
      },
      "required": ["load_shapers"],
      "type": "object",
      "additionalProperties": false
    },
    "MatchExpression": {
      "description": "MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals:\n        label: app\n        value: frobnicator\n```",
      "properties": {
        "all": {
          "$ref": "#/definitions/MatchExpressionList",
          "description": "The expression is true when all sub expressions are true.",
          "x-order": 0
        },
        "any": {
          "$ref": "#/definitions/MatchExpressionList",
          "description": "The expression is true when any sub expression is true.",
          "x-order": 1
        },
        "label_equals": {
          "$ref": "#/definitions/EqualsMatchExpression",
          "description": "The expression is true when label value equals given value.",
          "x-order": 2
        },
        "label_exists": {
          "description": "The expression is true when label with given name exists.",
          "type": "string",
          "x-order": 3
        },
        "label_matches": {
          "$ref": "#/definitions/MatchesMatchExpression",
          "description": "The expression is true when label matches given regular expression.",
          "x-order": 4
        },
        "not": {
          "$ref": "#/definitions/MatchExpression",
          "description": "The expression negates the result of sub expression.",
          "x-order": 5
        }
      },
      "title": "Defines a `[map<string, string> \u2192\u00a0bool]` expression to be evaluated on labels",
      "type": "object",
      "additionalProperties": false
    },
    "MatchExpressionList": {
      "description": "for example, `{any: {of: [expr1, expr2]}}`.",
      "properties": {
        "of": {
          "description": "List of sub expressions of the match expression.",
          "items": {
            "$ref": "#/definitions/MatchExpression",
            "type": "object"
          },
          "type": "array",
          "x-order": 0
        }
      },
      "title": "List of MatchExpressions that is used for all or any matching",
      "type": "object",
      "additionalProperties": false
    },
    "MatchesMatchExpression": {
      "description": "Label selector expression of the form `label matches regex`.",
      "properties": {
        "label": {
          "description": "Name of the label to match the regular expression.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "regex": {
          "description": "Regular expression that should match the label value.\nIt uses [Go's regular expression syntax](https://github.com/google/re2/wiki/Syntax).\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 1
        }
      },
      "required": ["label", "regex"],
      "type": "object",
      "additionalProperties": false
    },
    "Max": {
      "description": "Max: output = max([]inputs).",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/MaxIns",
          "description": "Input ports for the Max component.",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/MaxOuts",
          "description": "Output ports for the Max component.",
          "x-order": 1
        }
      },
      "title": "Takes a list of input signals and emits the signal with the maximum value",
      "type": "object",
      "additionalProperties": false
    },
    "MaxIns": {
      "description": "Inputs for the Max component.",
      "properties": {
        "inputs": {
          "description": "Array of input signals.\n\n",
          "items": {
            "$ref": "#/definitions/InPort",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "dive",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "MaxOuts": {
      "description": "Output for the Max component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "Signal with maximum value as an output signal.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Min": {
      "description": "Takes an array of input signals and emits the signal with the minimum value\nMin: output = min([]inputs).",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/MinIns",
          "description": "Input ports for the Min component.",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/MinOuts",
          "description": "Output ports for the Min component.",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "MinIns": {
      "description": "Inputs for the Min component.",
      "properties": {
        "inputs": {
          "description": "Array of input signals.\n\n",
          "items": {
            "$ref": "#/definitions/InPort",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "dive",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "MinOuts": {
      "description": "Output ports for the Min component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "Signal with minimum value as an output signal.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "NestedCircuit": {
      "description": "Nested circuit defines a sub-circuit as a high-level component. It consists of a list of components and a map of input and output ports.",
      "properties": {
        "components": {
          "description": "List of components in the nested circuit.\n\n",
          "items": {
            "$ref": "#/definitions/Component",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "dive",
          "x-order": 0
        },
        "in_ports_map": {
          "additionalProperties": {
            "$ref": "#/definitions/InPort"
          },
          "description": "Maps input port names to input ports.",
          "type": "object",
          "x-order": 1
        },
        "name": {
          "description": "Name of the nested circuit component. This name is displayed by graph visualization tools.",
          "type": "string",
          "x-order": 2
        },
        "out_ports_map": {
          "additionalProperties": {
            "$ref": "#/definitions/OutPort"
          },
          "description": "Maps output port names to output ports.",
          "type": "object",
          "x-order": 3
        },
        "short_description": {
          "description": "Short description of the nested circuit component. This description is displayed by graph visualization tools.",
          "type": "string",
          "x-order": 4
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "NestedSignalEgress": {
      "description": "Nested signal egress is a special type of component that allows to extract a signal from a nested circuit.",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/NestedSignalEgressIns",
          "description": "Input ports for the NestedSignalEgress component.",
          "x-order": 0
        },
        "port_name": {
          "description": "Name of the port.",
          "type": "string",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "NestedSignalEgressIns": {
      "description": "Inputs for the NestedSignalEgress component.",
      "properties": {
        "signal": {
          "$ref": "#/definitions/InPort",
          "description": "Egress signal.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "NestedSignalIngress": {
      "description": "Nested signal ingress is a special type of component that allows to inject a signal into a nested circuit.",
      "properties": {
        "out_ports": {
          "$ref": "#/definitions/NestedSignalIngressOuts",
          "description": "Output ports for the NestedSignalIngress component.",
          "x-order": 0
        },
        "port_name": {
          "description": "Name of the port.",
          "type": "string",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "NestedSignalIngressOuts": {
      "description": "Outputs for the NestedSignalIngress component.",
      "properties": {
        "signal": {
          "$ref": "#/definitions/OutPort",
          "description": "Ingress signal.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Or": {
      "description": "Logical OR.\n\nSee [And component](#and) on how signals are mapped onto Boolean values.",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/OrIns",
          "description": "Input ports for the Or component.",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/OrOuts",
          "description": "Output ports for the Or component.",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "OrIns": {
      "description": "Inputs for the Or component.",
      "properties": {
        "inputs": {
          "description": "Array of input signals.\n\n",
          "items": {
            "$ref": "#/definitions/InPort",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "dive",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "OrOuts": {
      "description": "Output ports for the Or component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "Result of logical OR of all the input signals.\n\nWill always be 0 (false), 1 (true) or invalid (unknown).",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "OutPort": {
      "properties": {
        "signal_name": {
          "description": "Name of the outgoing Signal on the OutPort.",
          "type": "string",
          "x-order": 0
        }
      },
      "title": "Components produce output for other components through OutPorts",
      "type": "object",
      "additionalProperties": false
    },
    "PathTemplateMatcher": {
      "description": "HTTP path will be matched against given path templates.\nIf a match occurs, the value associated with the path template will be treated as a result.\nIn case of multiple path templates matching, the most specific one will be chosen.",
      "properties": {
        "template_values": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Template value keys are OpenAPI-inspired path templates.\n\n* Static path segment `/foo` matches a path segment exactly\n* `/{param}` matches arbitrary path segment.\n  (The parameter name is ignored and can be omitted (`{}`))\n* The parameter must cover whole segment.\n* Additionally, path template can end with `/*` wildcard to match\n  arbitrary number of trailing segments (0 or more).\n* Multiple consecutive `/` are ignored, as well as trailing `/`.\n* Parametrized path segments must come after static segments.\n* `*`, if present, must come last.\n* Most specific template \"wins\" (`/foo` over `/{}` and `/{}` over `/*`).\n\nSee also <https://swagger.io/specification/#path-templating-matching>\n\nExample:\n```yaml\n/register: register\n\"/user/{userId}\": user\n/static/*: other\n```\n\n",
          "minProperties": 1,
          "type": "object",
          "x-go-tag-validate": "gt=0,dive,keys,required,endkeys,required",
          "x-order": 0
        }
      },
      "title": "Matches HTTP Path to given path templates",
      "type": "object",
      "additionalProperties": false
    },
    "PodAutoScaler": {
      "description": "_PodAutoScaler_ provides auto-scaling functionality for scalable Kubernetes resource. Multiple _Controllers_ can be defined on the _PodAutoScaler_ for performing scale-out or scale-in. The _PodAutoScaler_ interfaces with Kubernetes infrastructure APIs to perform auto-scale.",
      "properties": {
        "cooldown_override_percentage": {
          "default": 50,
          "description": "Cooldown override percentage defines a threshold change in scale-out beyond which previous cooldown is overridden.\nFor example, if the cooldown is 5 minutes and the cooldown override percentage is 10%, then if the\nscale-increases by 10% or more, the previous cooldown is cancelled. Defaults to 50%.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-default": "50",
          "x-order": 0
        },
        "max_replicas": {
          "default": "9223372036854775807",
          "description": "The maximum scale to which the _PodAutoScaler_ can scale-out.\n\n",
          "format": "int64",
          "minLength": 1,
          "type": "string",
          "x-go-tag-default": "9223372036854775807",
          "x-go-tag-validate": "gt=0",
          "x-order": 1
        },
        "max_scale_in_percentage": {
          "default": 1,
          "description": "The maximum decrease of replicas (for example, pods) at one time. Defined as percentage of current scale value. Can never go below one even if percentage computation is less than one. Defaults to 1% of current scale value.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-default": "1",
          "x-order": 2
        },
        "max_scale_out_percentage": {
          "default": 10,
          "description": "The maximum increase of replicas (for example, pods) at one time. Defined as percentage of current scale value. Can never go below one even if percentage computation is less than one. Defaults to 10% of current scale value.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-default": "10",
          "x-order": 3
        },
        "min_replicas": {
          "default": "0",
          "description": "The minimum replicas to which the _PodAutoScaler_ can scale-in.\n\n",
          "format": "int64",
          "minLength": 0,
          "type": "string",
          "x-go-tag-default": "0",
          "x-go-tag-validate": "gte=0",
          "x-order": 4
        },
        "out_ports": {
          "$ref": "#/definitions/PodAutoScalerOuts",
          "description": "Output ports for the _PodAutoScaler_.",
          "x-order": 5
        },
        "pod_scaler": {
          "$ref": "#/definitions/KubernetesReplicas",
          "x-go-tag-validate": "required",
          "x-order": 6
        },
        "scale_in_alerter_parameters": {
          "$ref": "#/definitions/AlerterParameters",
          "description": "Configuration for scale-in Alerter.",
          "x-order": 7
        },
        "scale_in_controllers": {
          "description": "List of _Controllers_ for scaling in.",
          "items": {
            "$ref": "#/definitions/ScaleInController",
            "type": "object"
          },
          "type": "array",
          "x-order": 8
        },
        "scale_in_cooldown": {
          "default": "120s",
          "description": "The amount of time to wait after a scale-in operation for another scale-in operation.\n\n",
          "type": "string",
          "x-go-tag-default": "120s",
          "x-order": 9
        },
        "scale_out_alerter_parameters": {
          "$ref": "#/definitions/AlerterParameters",
          "description": "Configuration for scale-out Alerter.",
          "x-order": 10
        },
        "scale_out_controllers": {
          "description": "List of _Controllers_ for scaling out.",
          "items": {
            "$ref": "#/definitions/ScaleOutController",
            "type": "object"
          },
          "type": "array",
          "x-order": 11
        },
        "scale_out_cooldown": {
          "default": "30s",
          "description": "The amount of time to wait after a scale-out operation for another scale-out or scale-in operation.\n\n",
          "type": "string",
          "x-go-tag-default": "30s",
          "x-order": 12
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "PodAutoScalerOuts": {
      "description": "Outputs for _PodAutoScaler_.",
      "properties": {
        "actual_replicas": {
          "$ref": "#/definitions/OutPort",
          "x-order": 0
        },
        "configured_replicas": {
          "$ref": "#/definitions/OutPort",
          "x-order": 1
        },
        "desired_replicas": {
          "$ref": "#/definitions/OutPort",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "PodScaler": {
      "description": "Component for scaling pods based on a signal.",
      "properties": {
        "kubernetes_object_selector": {
          "$ref": "#/definitions/KubernetesObjectSelector",
          "description": "The Kubernetes object on which horizontal scaling is applied.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "scale_actuator": {
          "$ref": "#/definitions/PodScalerScaleActuator",
          "description": "Actuates scaling of pods based on a signal.",
          "x-order": 1
        },
        "scale_reporter": {
          "$ref": "#/definitions/PodScalerScaleReporter",
          "description": "Reports actual and configured number of replicas.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "PodScalerScaleActuator": {
      "description": "Actuates scaling of pods based on a signal.",
      "properties": {
        "default_config": {
          "$ref": "#/definitions/PodScalerScaleActuatorDynamicConfig",
          "description": "Default configuration.",
          "x-order": 0
        },
        "dynamic_config_key": {
          "title": "Configuration key for DynamicConfig",
          "type": "string",
          "x-order": 1
        },
        "in_ports": {
          "$ref": "#/definitions/PodScalerScaleActuatorIns",
          "description": "Input ports for the PodScaler component.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "PodScalerScaleActuatorDynamicConfig": {
      "properties": {
        "dry_run": {
          "default": false,
          "description": "Decides whether to run the pod scaler in dry-run mode. Dry run mode ensures that no scaling is invoked by this pod scaler.\nUseful for observing the behavior of Scaler without disrupting any real traffic.\n\n",
          "type": "boolean",
          "x-go-tag-default": "false",
          "x-order": 0
        }
      },
      "title": "Dynamic Configuration for ScaleActuator",
      "type": "object",
      "additionalProperties": false
    },
    "PodScalerScaleActuatorIns": {
      "description": "Inputs for the PodScaler component.",
      "properties": {
        "desired_replicas": {
          "$ref": "#/definitions/InPort",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "PodScalerScaleReporter": {
      "description": "Reports actual and configured number of replicas.",
      "properties": {
        "out_ports": {
          "$ref": "#/definitions/PodScalerScaleReporterOuts",
          "description": "Output ports for the PodScaler component.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "PodScalerScaleReporterOuts": {
      "description": "Outputs for the PodScaler component.",
      "properties": {
        "actual_replicas": {
          "$ref": "#/definitions/OutPort",
          "description": "The number of replicas that are currently running.",
          "x-order": 0
        },
        "configured_replicas": {
          "$ref": "#/definitions/OutPort",
          "description": "The number of replicas that are desired.",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Policy": {
      "description": "Policy expresses observability-driven control logic.\n\n:::info\n\nSee also [Policy overview](/concepts/policy/policy.md).\n\n:::\n\nPolicy specification contains a circuit that defines the controller logic and resources that need to be setup.",
      "properties": {
        "circuit": {
          "$ref": "#/definitions/Circuit",
          "description": "Defines the control-loop logic of the policy.",
          "x-order": 0
        },
        "resources": {
          "$ref": "#/definitions/Resources",
          "description": "Resources (such as Flux Meters, Classifiers) to setup.",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "PromQL": {
      "properties": {
        "evaluation_interval": {
          "default": "10s",
          "description": "Describes the interval between successive evaluations of the Prometheus query.\n\n",
          "type": "string",
          "x-go-tag-default": "10s",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/PromQLOuts",
          "description": "Output ports for the PromQL component.",
          "x-order": 1
        },
        "query_string": {
          "description": "Describes the [PromQL](https://prometheus.io/docs/prometheus/latest/querying/basics/) query to be run.\n\n:::note\n\nThe query must return a single value either as a scalar or as a vector with a single element.\n\n:::\n\n:::info Usage with Flux Meter\n\n[Flux Meter](/concepts/flow-control/resources/flux-meter.md) metrics can be queries using PromQL. Flux Meter defines histogram type of metrics in Prometheus.\nTherefore, one can refer to `flux_meter_sum`, `flux_meter_count` and `flux_meter_bucket`.\nThe particular Flux Meter can be identified with the `flux_meter_name` label.\nThere are additional labels available on a Flux Meter such as `valid`, `flow_status`, `http_status_code` and `decision_type`.\n\n:::\n\n:::info Usage with OpenTelemetry Metrics\n\nAperture supports OpenTelemetry metrics. See [reference](/get-started/integrations/metrics/metrics.md) for more details.\n\n:::",
          "type": "string",
          "x-order": 2
        }
      },
      "title": "Component that runs a Prometheus query periodically and returns the result as an output signal",
      "type": "object",
      "additionalProperties": false
    },
    "PromQLOuts": {
      "description": "Output for the PromQL component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "The result of the Prometheus query as an output signal.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "PulseGenerator": {
      "description": "Generates 0 and 1 in turns.",
      "properties": {
        "false_for": {
          "default": "5s",
          "description": "Emitting 0 for the `false_for` duration.\n\n",
          "type": "string",
          "x-go-tag-default": "5s",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/PulseGeneratorOuts",
          "description": "Output ports for the PulseGenerator component.",
          "x-order": 1
        },
        "true_for": {
          "default": "5s",
          "description": "Emitting 1 for the `true_for` duration.\n\n",
          "type": "string",
          "x-go-tag-default": "5s",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "PulseGeneratorOuts": {
      "description": "Outputs for the PulseGenerator component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Query": {
      "description": "Query components that are query databases such as Prometheus.",
      "properties": {
        "promql": {
          "$ref": "#/definitions/PromQL",
          "description": "Periodically runs a Prometheus query in the background and emits the result.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "RateLimiter": {
      "description": ":::info\n\nSee also [_Rate Limiter_ overview](/concepts/flow-control/components/rate-limiter.md).\n\n:::\n\nRateLimiting is done on per-label-value basis. Use `label_key`\nto select which label should be used as key.",
      "properties": {
        "default_config": {
          "$ref": "#/definitions/RateLimiterDynamicConfig",
          "title": "Default configuration",
          "x-order": 0
        },
        "dynamic_config_key": {
          "title": "Configuration key for DynamicConfig",
          "type": "string",
          "x-order": 1
        },
        "flow_selector": {
          "$ref": "#/definitions/FlowSelector",
          "description": "Which control point to apply this rate limiter to.\nDeprecated 1.8.0: Use `selectors` instead.\n\n",
          "x-go-tag-validate": "required_without=Selectors",
          "x-order": 2
        },
        "in_ports": {
          "$ref": "#/definitions/RateLimiterIns",
          "title": "Input ports for the RateLimiter component",
          "x-go-tag-validate": "required",
          "x-order": 3
        },
        "parameters": {
          "$ref": "#/definitions/RateLimiterParameters",
          "title": "Parameters for the RateLimiter component",
          "x-go-tag-validate": "required",
          "x-order": 4
        },
        "selectors": {
          "description": "Selectors for the component.\n\n",
          "items": {
            "$ref": "#/definitions/Selector",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "required_without=FlowSelector,dive",
          "x-order": 5
        }
      },
      "title": "Limits the traffic on a control point to specified rate",
      "type": "object",
      "additionalProperties": false
    },
    "RateLimiterDynamicConfig": {
      "properties": {
        "overrides": {
          "description": "Allows to specify different limits for particular label values.\n\n",
          "items": {
            "$ref": "#/definitions/RateLimiterOverride",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "dive",
          "x-order": 0
        }
      },
      "title": "Dynamic Configuration for the rate limiter",
      "type": "object",
      "additionalProperties": false
    },
    "RateLimiterIns": {
      "properties": {
        "limit": {
          "$ref": "#/definitions/InPort",
          "description": "Number of flows allowed per `limit_reset_interval` per each label.\nNegative values disable the rate limiter.\n\n:::tip\n\nNegative limit can be useful to _conditionally_ enable the rate limiter\nunder certain circumstances. [Decider](#decider) might be helpful.\n\n:::\n\n",
          "x-go-tag-validate": "required",
          "x-order": 0
        }
      },
      "title": "Inputs for the RateLimiter component",
      "type": "object",
      "additionalProperties": false
    },
    "RateLimiterOverride": {
      "properties": {
        "label_value": {
          "description": "Value of the label for which the override should be applied.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "limit_scale_factor": {
          "default": 1,
          "description": "Amount by which the `in_ports.limit` should be multiplied for\nthis label value.\n\n",
          "format": "double",
          "type": "number",
          "x-go-tag-default": "1.0",
          "x-order": 1
        }
      },
      "required": ["label_value"],
      "type": "object",
      "additionalProperties": false
    },
    "RateLimiterParameters": {
      "properties": {
        "label_key": {
          "description": "Specifies which label the rate limiter should be keyed by.\n\nRate limiting is done independently for each value of the\n[label](/concepts/flow-control/flow-label.md) with given key.\nFor example, to give each user a separate limit, assuming you\nhave a _user_ flow\nlabel set up, set `label_key: \"user\"`.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "lazy_sync": {
          "$ref": "#/definitions/RateLimiterParametersLazySync",
          "title": "Configuration of lazy-syncing behavior of rate limiter",
          "x-order": 1
        },
        "limit_reset_interval": {
          "default": "60s",
          "description": "Time after which the limit for a given label value will be reset.\n\n",
          "type": "string",
          "x-go-tag-default": "60s",
          "x-order": 2
        },
        "tokens_label_key": {
          "default": "tokens",
          "description": "Flow label key that will be used to override the number of tokens\nfor this request.\nThis is an optional parameter and takes highest precedence\nwhen assigning tokens to a request.\nThe label value must be a valid uint64 number.\n\n",
          "type": "string",
          "x-go-tag-default": "tokens",
          "x-order": 3
        }
      },
      "required": ["label_key"],
      "type": "object",
      "additionalProperties": false
    },
    "RateLimiterParametersLazySync": {
      "properties": {
        "enabled": {
          "default": false,
          "title": "Enables lazy sync",
          "type": "boolean",
          "x-go-tag-default": "false",
          "x-order": 0
        },
        "num_sync": {
          "default": 5,
          "description": "Number of times to lazy sync within the `limit_reset_interval`.\n\n",
          "exclusiveMinimum": 0,
          "format": "int64",
          "type": "integer",
          "x-go-tag-default": "5",
          "x-go-tag-validate": "gt=0",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Rego": {
      "description": "Rego define a set of labels that are extracted after evaluating a Rego module.\n\n:::info\n\nYou can use the [live-preview](/concepts/flow-control/resources/classifier.md#live-previewing-requests) feature to first preview the input to the classifier before writing the labeling logic.\n\n:::\n\nExample of Rego module which also disables telemetry visibility of label:\n```yaml\nrego:\n  labels:\n    user:\n      telemetry: false\n  module: |\n    package user_from_cookie\n    cookies := split(input.attributes.request.http.headers.cookie, \"; \")\n    user := user {\n        cookie := cookies[_]\n        startswith(cookie, \"session=\")\n        session := substring(cookie, count(\"session=\"), -1)\n        parts := split(session, \".\")\n        object := json.unmarshal(base64url.decode(parts[0]))\n        user := object.user\n    }\n```",
      "properties": {
        "labels": {
          "additionalProperties": {
            "$ref": "#/definitions/RegoLabelProperties"
          },
          "description": "A map of {key, value} pairs mapping from\n[flow label](/concepts/flow-control/flow-label.md) keys to queries that define\nhow to extract and propagate flow labels with that key.\nThe name of the label maps to a variable in the Rego module. It maps to `data.<package>.<label>` variable.\n\n",
          "minProperties": 1,
          "type": "object",
          "x-go-tag-validate": "required,gt=0,dive,keys,required,endkeys,required",
          "x-order": 0
        },
        "module": {
          "description": "Source code of the Rego module.\n\n:::note\n\nMust include a \"package\" declaration.\n\n:::\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 1
        }
      },
      "required": ["labels", "module"],
      "type": "object",
      "additionalProperties": false
    },
    "RegoLabelProperties": {
      "properties": {
        "telemetry": {
          "default": true,
          "description": ":::note\n\nThe flow label is always accessible in Aperture Policies regardless of this setting.\n\n:::\n\n:::caution\n\nWhen using [FluxNinja ARC extension](/arc/extension.md), telemetry enabled\nlabels are sent to FluxNinja ARC for observability. Telemetry should be disabled for\nsensitive labels.\n\n:::\n\n",
          "title": "Decides if the created flow label should be available as an attribute in OLAP telemetry and\npropagated in [baggage](/concepts/flow-control/flow-label.md#baggage)",
          "type": "boolean",
          "x-go-tag-default": "true",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Regulator": {
      "description": "_Regulator_ is a component that regulates the load at a\n[_Control Point_](/concepts/flow-control/selector.md/#control-point) by allowing only a specified percentage of\nflows at random or by sticky sessions.\n\n:::info\n\nSee also [_Load Regulator overview](/concepts/flow-control/components/regulator.md).\n\n:::",
      "properties": {
        "default_config": {
          "$ref": "#/definitions/RegulatorDynamicConfig",
          "description": "Default configuration.",
          "x-order": 0
        },
        "dynamic_config_key": {
          "description": "Configuration key for DynamicConfig.",
          "type": "string",
          "x-order": 1
        },
        "in_ports": {
          "$ref": "#/definitions/RegulatorIns",
          "description": "Input ports for the _Regulator_.",
          "x-order": 2
        },
        "parameters": {
          "$ref": "#/definitions/RegulatorParameters",
          "description": "Parameters for the _Regulator_.",
          "x-order": 3
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "RegulatorDynamicConfig": {
      "properties": {
        "enable_label_values": {
          "description": "Specify certain label values to be accepted by this flow filter regardless of accept percentage.",
          "items": {
            "type": "string"
          },
          "type": "array",
          "x-order": 0
        }
      },
      "title": "Dynamic Configuration for _Regulator_",
      "type": "object",
      "additionalProperties": false
    },
    "RegulatorIns": {
      "properties": {
        "accept_percentage": {
          "$ref": "#/definitions/InPort",
          "description": "The percentage of requests to accept.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "RegulatorParameters": {
      "properties": {
        "flow_selector": {
          "$ref": "#/definitions/FlowSelector",
          "description": "_Flow Selector_ selects the _Flows_ at which the _Regulator_ is applied.\nDeprecated 1.8.0: Use `selectors` instead.\n\n",
          "x-go-tag-validate": "required_without=Selectors",
          "x-order": 0
        },
        "label_key": {
          "description": "The flow label key for identifying sessions.\n- When label key is specified, _Regulator_ acts as a sticky filter.\n  The series of flows with the same value of label key get the same\n  decision provided that the `accept_percentage` is same or higher.\n- When label key is not specified, _Regulator_ acts as a stateless filter.\n  Percentage of flows are selected randomly for rejection.",
          "type": "string",
          "x-order": 1
        },
        "selectors": {
          "description": "Selectors for the component.\n\n",
          "items": {
            "$ref": "#/definitions/Selector",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "required_without=FlowSelector,dive",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Resources": {
      "description": ":::info\n\nSee also [Resources overview](/concepts/policy/resources.md).\n\n:::",
      "properties": {
        "flow_control": {
          "$ref": "#/definitions/FlowControlResources",
          "description": "FlowControlResources are resources that are provided by flow control integration.",
          "x-order": 0
        }
      },
      "title": "Resources that need to be setup for the policy to function",
      "type": "object",
      "additionalProperties": false
    },
    "Rule": {
      "description": "Example of a JSON extractor:\n```yaml\nextractor:\n  json:\n    from: request.http.body\n    pointer: /user/name\n```",
      "properties": {
        "extractor": {
          "$ref": "#/definitions/Extractor",
          "description": "High-level declarative extractor.",
          "x-order": 0
        },
        "telemetry": {
          "default": true,
          "description": ":::note\n\nThe flow label is always accessible in Aperture Policies regardless of this setting.\n\n:::\n\n:::caution\n\nWhen using [FluxNinja ARC extension](/arc/extension.md), telemetry enabled\nlabels are sent to FluxNinja ARC for observability. Telemetry should be disabled for\nsensitive labels.\n\n:::\n\n",
          "title": "Decides if the created flow label should be available as an attribute in OLAP telemetry and\npropagated in [baggage](/concepts/flow-control/flow-label.md#baggage)",
          "type": "boolean",
          "x-go-tag-default": "true",
          "x-order": 1
        }
      },
      "title": "Rule describes a single classification Rule",
      "type": "object",
      "additionalProperties": false
    },
    "SMA": {
      "description": "Simple Moving Average (SMA) is a type of moving average that computes the average of a fixed number of signal readings.",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/SMAIns",
          "description": "Input ports for the SMA component.",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/SMAOuts",
          "description": "Output ports for the SMA component.",
          "x-order": 1
        },
        "parameters": {
          "$ref": "#/definitions/SMAParameters",
          "description": "Parameters for the SMA component.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "SMAIns": {
      "properties": {
        "input": {
          "$ref": "#/definitions/InPort",
          "description": "Signal to be used for the moving average computation.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "SMAOuts": {
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "Computed moving average.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "SMAParameters": {
      "properties": {
        "sma_window": {
          "description": "Window of time over which the moving average is computed.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "valid_during_warmup": {
          "default": false,
          "description": "Whether the output is valid during the warm-up stage.\n\n",
          "type": "boolean",
          "x-go-tag-default": "false",
          "x-order": 1
        }
      },
      "required": ["sma_window"],
      "type": "object",
      "additionalProperties": false
    },
    "ScaleInController": {
      "properties": {
        "alerter_parameters": {
          "$ref": "#/definitions/AlerterParameters",
          "description": "Configuration for embedded Alerter.",
          "x-order": 0
        },
        "controller": {
          "$ref": "#/definitions/ScaleInControllerController",
          "title": "Controller",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "ScaleInControllerController": {
      "properties": {
        "gradient": {
          "$ref": "#/definitions/DecreasingGradient",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "ScaleOutController": {
      "properties": {
        "alerter_parameters": {
          "$ref": "#/definitions/AlerterParameters",
          "description": "Configuration for embedded Alerter.",
          "x-order": 0
        },
        "controller": {
          "$ref": "#/definitions/ScaleOutControllerController",
          "title": "Controller",
          "x-go-tag-validate": "required",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "ScaleOutControllerController": {
      "properties": {
        "gradient": {
          "$ref": "#/definitions/IncreasingGradient",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Scheduler": {
      "description": ":::note\n\nEach Agent instantiates an independent copy of the scheduler, but output\nsignals for accepted and incoming token rate are aggregated across all agents.\n\n:::",
      "properties": {
        "out_ports": {
          "$ref": "#/definitions/SchedulerOuts",
          "description": "Output ports for the Scheduler component.",
          "x-order": 0
        },
        "parameters": {
          "$ref": "#/definitions/SchedulerParameters",
          "description": "Scheduler parameters.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 1
        }
      },
      "title": "Weighted Fair Queuing-based workload scheduler",
      "type": "object",
      "additionalProperties": false
    },
    "SchedulerOuts": {
      "description": "Output for the Scheduler component.",
      "properties": {
        "accepted_concurrency": {
          "$ref": "#/definitions/OutPort",
          "description": "Accepted concurrency is actual concurrency on a control point that this\nscheduler is applied on.\nValue of this signal is aggregated from all the relevant schedulers.",
          "x-order": 0
        },
        "incoming_concurrency": {
          "$ref": "#/definitions/OutPort",
          "description": "Incoming concurrency is concurrency that'd be needed to accept all the\nflows entering the scheduler.\n\nThis is computed in the same way as `accepted_concurrency`,\nby summing up tokens from all the flows entering scheduler,\nincluding rejected ones.",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "SchedulerParameters": {
      "properties": {
        "auto_tokens": {
          "default": false,
          "description": "Automatically estimate the size of a flow in each workload, based on\nhistorical latency. Each workload's `tokens` will be set to average\nlatency of flows in that workload during last few seconds (exact duration\nof this average can change).\nThis setting is useful in concurrency limiting use-case, where the\nconcurrency is calculated as (avg. latency \\* in-flight flows).\n\nThe value of tokens estimated by `auto_tokens` takes lower precedence\nthan the value of `tokens` specified in the workload definition\nand `tokens` explicitly specified in the flow labels.\n\n",
          "type": "boolean",
          "x-go-tag-default": "false",
          "x-order": 0
        },
        "decision_deadline_margin": {
          "default": "0.01s",
          "description": "Decision deadline margin is the amount of time that the scheduler will\nsubtract from the request deadline to determine the deadline for the\ndecision. This is to ensure that the scheduler has enough time to\nmake a decision before the request deadline happens, accounting for\nprocessing delays.\nThe request deadline is based on the\n[gRPC deadline](https://grpc.io/blog/deadlines) or the\n[`grpc-timeout` HTTP header](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests).\n\nFail-open logic is use for flow control APIs, so if the gRPC deadline\nreaches, the flow will end up being unconditionally allowed while\nit is still waiting on the scheduler.\n\n",
          "type": "string",
          "x-go-tag-default": "0.01s",
          "x-order": 1
        },
        "default_workload_parameters": {
          "$ref": "#/definitions/SchedulerWorkloadParameters",
          "description": "Parameters to be used if none of workloads specified in `workloads` match.",
          "x-order": 2
        },
        "tokens_label_key": {
          "default": "tokens",
          "description": "* Key for a flow label that can be used to override the default number of tokens for this flow.\n* The value associated with this key must be a valid uint64 number.\n* If this parameter is not provided, the number of tokens for the flow will be determined by the matched workload's token count.\n\n",
          "type": "string",
          "x-go-tag-default": "tokens",
          "x-order": 3
        },
        "workloads": {
          "description": "List of workloads to be used in scheduler.\n\nCategorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads\nallows for load-shedding to be \"intelligent\" compared to random rejections.\nThere are two aspects of this \"intelligence\":\n* Scheduler can more precisely calculate concurrency if it understands\n  that flows belonging to different classes have different weights (for example, insert queries compared to select queries).\n* Setting different priorities to different workloads lets the scheduler\n  avoid dropping important traffic during overload.\n\nEach workload in this list specifies also a matcher that is used to\ndetermine which flow will be categorized into which workload.\nIn case of multiple matching workloads, the first matching one will be used.\nIf none of workloads match, `default_workload` will be used.\n\n:::info\n\nSee also [workload definition in the concepts\nsection](/concepts/flow-control/components/load-scheduler.md#workload).\n\n:::\n\n",
          "items": {
            "$ref": "#/definitions/SchedulerWorkload",
            "type": "object"
          },
          "type": "array",
          "x-go-tag-validate": "dive",
          "x-order": 4
        }
      },
      "title": "Scheduler parameters",
      "type": "object",
      "additionalProperties": false
    },
    "SchedulerWorkload": {
      "description": "Workload defines a class of flows that preferably have similar properties such as response latency and desired priority.",
      "properties": {
        "label_matcher": {
          "$ref": "#/definitions/LabelMatcher",
          "description": "Label Matcher to select a Workload based on\n[flow labels](/concepts/flow-control/flow-label.md).\n\n",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "parameters": {
          "$ref": "#/definitions/SchedulerWorkloadParameters",
          "description": "Parameters associated with flows matching the label matcher.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 1
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "SchedulerWorkloadParameters": {
      "description": "Parameters such as priority, tokens and fairness key that\nare applicable to flows within a workload.",
      "properties": {
        "fairness_key": {
          "description": "Fairness key is a label key that can be used to provide fairness within a workload.\nAny [flow label](/concepts/flow-control/flow-label.md) can be used here. For example, if\nyou have a classifier that sets `user` flow label, you might want to set\n`fairness_key = \"user\"`.",
          "type": "string",
          "x-order": 0
        },
        "priority": {
          "default": 0,
          "description": "$$\n\\text{virtual\\_finish\\_time} = \\text{virtual\\_time} + \\left(\\text{tokens} \\cdot \\left(\\text{256} - \\text{priority}\\right)\\right)\n$$\n\n",
          "format": "int64",
          "maximum": 255,
          "minimum": 0,
          "title": "Describes priority level of the flows within the workload.\nPriority level ranges from 0 to 255.\nHigher numbers means higher priority level.\nPriority levels have non-linear effect on the workload scheduling. The following formula is used to determine the position of a flow in the queue based on virtual finish time:",
          "type": "integer",
          "x-go-tag-default": "0",
          "x-go-tag-validate": "gte=0,lte=255",
          "x-order": 1
        },
        "tokens": {
          "description": "Tokens determines the cost of admitting a single flow in the workload,\nwhich is typically defined as milliseconds of flow latency (time to response or duration of a feature) or\nsimply equal to 1 if the resource being accessed is constrained by the\nnumber of flows (3rd party rate limiters).\nThis override is applicable only if tokens for the flow aren't specified\nin the flow labels.",
          "format": "uint64",
          "type": "string",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Selector": {
      "description": "Selects flows based on control point, flow labels, agent group and the service\nthat the [flow control component](/concepts/flow-control/flow-control.md#components)\nwill operate on.\n\n:::info\n\nSee also [Selector overview](/concepts/flow-control/selector.md).\n\n:::\n\nExample:\n```yaml\ncontrol_point: ingress\nlabel_matcher:\n  match_labels:\n    user_tier: gold\n  match_expressions:\n    - key: query\n      operator: In\n      values:\n        - insert\n        - delete\n  expression:\n    label_matches:\n        - label: user_agent\n          regex: ^(?!.*Chrome).*Safari\n```",
      "properties": {
        "agent_group": {
          "default": "default",
          "description": "[_Agent Group_](/concepts/flow-control/selector.md#agent-group) this\nselector applies to.\n\n:::info\n\nAgent Groups are used to scope policies to a subset of agents connected to the same controller.\nThe agents within an agent group receive exact same policy configuration and\nform a peer to peer cluster to constantly share state.\n\n:::\n\n",
          "type": "string",
          "x-go-tag-default": "default",
          "x-order": 0
        },
        "control_point": {
          "description": "[Control Point](/concepts/flow-control/selector.md#control-point)\nidentifies location within services where policies can act on flows.\nFor an SDK based insertion,\na _Control Point_ can represent a particular feature or execution\nblock within a service. In case of service mesh or middleware insertion, a\n_Control Point_ can identify ingress or egress calls or distinct listeners\nor filter chains.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 1
        },
        "label_matcher": {
          "$ref": "#/definitions/LabelMatcher",
          "description": "[Label Matcher](/concepts/flow-control/selector.md#label-matcher)\ncan be used to match flows based on flow labels.",
          "x-order": 2
        },
        "service": {
          "default": "any",
          "description": "The Fully Qualified Domain Name of the\n[service](/concepts/flow-control/selector.md) to select.\n\nIn Kubernetes, this is the FQDN of the Service object.\n\n:::info\n\n`any` matches all services.\n\n:::\n\n:::info\n\nAn entity (for example, Kubernetes pod) might belong to multiple services.\n\n:::\n\n",
          "type": "string",
          "x-go-tag-default": "any",
          "x-order": 3
        }
      },
      "required": ["control_point"],
      "type": "object",
      "additionalProperties": false
    },
    "ServiceSelector": {
      "description": ":::info\n\nSee also [FlowSelector overview](/concepts/flow-control/selector.md).\n\n:::\n\nDeprecated 1.8.0: Use `selectors` instead.",
      "properties": {
        "agent_group": {
          "default": "default",
          "description": "Which [agent-group](/concepts/flow-control/selector.md#agent-group) this\nselector applies to.\n\n:::info\n\nAgent Groups are used to scope policies to a subset of agents connected to the same controller.\nThis is especially useful in the Kubernetes sidecar installation because service discovery is switched off in that mode.\nThe agents within an agent group form a peer to peer cluster and constantly share state.\n\n:::\n\n",
          "type": "string",
          "x-go-tag-default": "default",
          "x-order": 0
        },
        "service": {
          "default": "any",
          "description": "The Fully Qualified Domain Name of the\n[service](/concepts/flow-control/selector.md) to select.\n\nIn Kubernetes, this is the FQDN of the Service object.\n\n:::info\n\n`any` matches all services.\n\n:::\n\n:::info\n\nIn the Kubernetes sidecar installation mode, service discovery is switched off by default.\nTo scope policies to services, the `service` should be set to `any` and instead, `agent_group` name should be used.\n\n:::\n\n:::info\n\nAn entity (for example, Kubernetes pod) might belong to multiple services.\n\n:::\n\n",
          "type": "string",
          "x-go-tag-default": "any",
          "x-order": 1
        }
      },
      "title": "Describes which service a [flow control or observability\ncomponent](/concepts/flow-control/flow-control.md#components) should apply\nto",
      "type": "object",
      "additionalProperties": false
    },
    "SignalGenerator": {
      "description": "The _Signal Generator_ component generates a smooth and continuous signal\nby following a sequence of specified steps. Each step has two parameters:\n- `target_output`: The desired output value at the end of the step.\n- `duration`: The time it takes for the signal to change linearly from the\n  previous step's `target_output` to the current step's `target_output`.\n\nThe output signal starts at the `target_output` of the first step and\nchanges linearly between steps based on their `duration`. The _Signal\nGenerator_ can be controlled to move forwards, backwards, or reset to the\nbeginning based on input signals.",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/SignalGeneratorIns",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/SignalGeneratorOuts",
          "x-order": 1
        },
        "parameters": {
          "$ref": "#/definitions/SignalGeneratorParameters",
          "description": "Parameters for the _Signal Generator_ component.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "SignalGeneratorIns": {
      "description": "Inputs for the _Signal Generator_ component.",
      "properties": {
        "backward": {
          "$ref": "#/definitions/InPort",
          "description": "Whether to progress the _Signal Generator_ towards the previous step.",
          "x-order": 0
        },
        "forward": {
          "$ref": "#/definitions/InPort",
          "description": "Whether to progress the _Signal Generator_ towards the next step.",
          "x-order": 1
        },
        "reset": {
          "$ref": "#/definitions/InPort",
          "description": "Whether to reset the _Signal Generator_ to the first step.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "SignalGeneratorOuts": {
      "description": "Outputs for the _Signal Generator_ component.",
      "properties": {
        "at_end": {
          "$ref": "#/definitions/OutPort",
          "description": "A Boolean signal indicating whether the _Signal Generator_ is at the end of signal generation.",
          "x-order": 0
        },
        "at_start": {
          "$ref": "#/definitions/OutPort",
          "description": "A Boolean signal indicating whether the _Signal Generator_ is at the start of signal generation.",
          "x-order": 1
        },
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "The generated signal.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "SignalGeneratorParameters": {
      "description": "Parameters for the _Signal Generator_ component.",
      "properties": {
        "steps": {
          "items": {
            "$ref": "#/definitions/SignalGeneratorParametersStep",
            "type": "object"
          },
          "minItems": 1,
          "type": "array",
          "x-go-tag-validate": "required,gt=0,dive",
          "x-order": 0
        }
      },
      "required": ["steps"],
      "type": "object",
      "additionalProperties": false
    },
    "SignalGeneratorParametersStep": {
      "properties": {
        "duration": {
          "description": "Duration for which the step is active.\n\n",
          "type": "string",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "target_output": {
          "$ref": "#/definitions/ConstantSignal",
          "description": "The value of the step.",
          "x-order": 1
        }
      },
      "required": ["duration"],
      "type": "object",
      "additionalProperties": false
    },
    "Switcher": {
      "description": "`on_signal` will be returned if switch input is valid and not equal to 0.0 ,\n otherwise `off_signal` will be returned.",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/SwitcherIns",
          "description": "Input ports for the Switcher component.",
          "x-order": 0
        },
        "out_ports": {
          "$ref": "#/definitions/SwitcherOuts",
          "description": "Output ports for the Switcher component.",
          "x-order": 1
        }
      },
      "title": "Type of Combinator that switches between `on_signal` and `off_signal` signals based on switch input",
      "type": "object",
      "additionalProperties": false
    },
    "SwitcherIns": {
      "description": "Inputs for the Switcher component.",
      "properties": {
        "off_signal": {
          "$ref": "#/definitions/InPort",
          "description": "Output signal when switch is invalid or 0.0.",
          "x-order": 0
        },
        "on_signal": {
          "$ref": "#/definitions/InPort",
          "description": "Output signal when switch is valid and not 0.0.",
          "x-order": 1
        },
        "switch": {
          "$ref": "#/definitions/InPort",
          "description": "Decides whether to return `on_signal` or `off_signal`.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "SwitcherOuts": {
      "description": "Outputs for the Switcher component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "Selected signal (`on_signal` or `off_signal`).",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "UnaryOperator": {
      "description": "$$\n\\text{output} = \\unary_operator{\\text{input}}\n$$",
      "properties": {
        "in_ports": {
          "$ref": "#/definitions/UnaryOperatorIns",
          "description": "Input ports for the UnaryOperator component.",
          "x-order": 0
        },
        "operator": {
          "description": "Unary Operator to apply.\n\nThe unary operator can be one of the following:\n* `abs`: Absolute value with the sign removed.\n* `acos`: `arccosine`, in radians.\n* `acosh`: Inverse hyperbolic cosine.\n* `asin`: `arcsine`, in radians.\n* `asinh`: Inverse hyperbolic sine.\n* `atan`: `arctangent`, in radians.\n* `atanh`: Inverse hyperbolic tangent.\n* `cbrt`: Cube root.\n* `ceil`: Least integer value greater than or equal to input signal.\n* `cos`: `cosine`, in radians.\n* `cosh`: Hyperbolic cosine.\n* `erf`: Error function.\n* `erfc`: Complementary error function.\n* `erfcinv`: Inverse complementary error function.\n* `erfinv`: Inverse error function.\n* `exp`: The base-e exponential of input signal.\n* `exp2`: The base-2 exponential of input signal.\n* `expm1`: The base-e exponential of input signal minus 1.\n* `floor`: Greatest integer value less than or equal to input signal.\n* `gamma`: Gamma function.\n* `j0`: Bessel function of the first kind of order 0.\n* `j1`: Bessel function of the first kind of order 1.\n* `lgamma`: Natural logarithm of the absolute value of the gamma function.\n* `log`: Natural logarithm of input signal.\n* `log10`: Base-10 logarithm of input signal.\n* `log1p`: Natural logarithm of input signal plus 1.\n* `log2`: Base-2 logarithm of input signal.\n* `round`: Round to nearest integer.\n* `roundtoeven`: Round to nearest integer, with ties going to the nearest even integer.\n* `sin`: `sine`, in radians.\n* `sinh`: Hyperbolic sine.\n* `sqrt`: Square root.\n* `tan`: `tangent`, in radians.\n* `tanh`: Hyperbolic tangent.\n* `trunc`: Truncate to integer.\n* `y0`: Bessel function of the second kind of order 0.\n* `y1`: Bessel function of the second kind of order 1.\n\n",
          "enum": [
            "abs",
            "acos",
            "acosh",
            "asin",
            "asinh",
            "atan",
            "atanh",
            "cbrt",
            "ceil",
            "cos",
            "cosh",
            "erf",
            "erfc",
            "erfcinv",
            "erfinv",
            "exp",
            "exp2",
            "expm1",
            "floor",
            "gamma",
            "j0",
            "j1",
            "lgamma",
            "log",
            "log10",
            "log1p",
            "log2",
            "round",
            "roundtoeven",
            "sin",
            "sinh",
            "sqrt",
            "tan",
            "tanh",
            "trunc",
            "y0",
            "y1"
          ],
          "type": "string",
          "x-go-tag-validate": "oneof=abs acos acosh asin asinh atan atanh cbrt ceil cos cosh erf erfc erfcinv erfinv exp exp2 expm1 floor gamma j0 j1 lgamma log log10 log1p log2 round roundtoeven sin sinh sqrt tan tanh trunc y0 y1",
          "x-oneof": "abs | acos | acosh | asin | asinh | atan | atanh | cbrt | ceil | cos | cosh | erf | erfc | erfcinv | erfinv | exp | exp2 | expm1 | floor | gamma | j0 | j1 | lgamma | log | log10 | log1p | log2 | round | roundtoeven | sin | sinh | sqrt | tan | tanh | trunc | y0 | y1",
          "x-order": 1
        },
        "out_ports": {
          "$ref": "#/definitions/UnaryOperatorOuts",
          "description": "Output ports for the UnaryOperator component.",
          "x-order": 2
        }
      },
      "title": "Takes an input signal and emits the output after applying the specified unary operator",
      "type": "object",
      "additionalProperties": false
    },
    "UnaryOperatorIns": {
      "description": "Inputs for the UnaryOperator component.",
      "properties": {
        "input": {
          "$ref": "#/definitions/InPort",
          "description": "Input signal.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "UnaryOperatorOuts": {
      "description": "Outputs for the UnaryOperator component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "Output signal.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "Variable": {
      "description": "Component that emits a variable value as an output signal, can be defined in dynamic configuration.",
      "properties": {
        "default_config": {
          "$ref": "#/definitions/VariableDynamicConfig",
          "description": "Default configuration.\n\n",
          "x-go-tag-validate": "required",
          "x-order": 0
        },
        "dynamic_config_key": {
          "description": "Configuration key for DynamicConfig.",
          "type": "string",
          "x-order": 1
        },
        "out_ports": {
          "$ref": "#/definitions/VariableOuts",
          "description": "Output ports for the Variable component.",
          "x-order": 2
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "VariableDynamicConfig": {
      "properties": {
        "constant_signal": {
          "$ref": "#/definitions/ConstantSignal",
          "x-go-tag-validate": "required",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "VariableOuts": {
      "description": "Outputs for the Variable component.",
      "properties": {
        "output": {
          "$ref": "#/definitions/OutPort",
          "description": "The value is emitted to the output port.",
          "x-order": 0
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "PolicyCustomResource": {
      "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>.",
      "type": "object",
      "title": "Policy CustomResourceDefinition",
      "additionalProperties": false,
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "x-order": 0,
          "type": ["string", "null"],
          "enum": ["fluxninja.com/v1alpha1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "x-order": 1,
          "type": ["string", "null"],
          "enum": ["Policy"]
        },
        "metadata": {
          "x-order": 2,
          "$ref": "https://kubernetesjsonschema.dev/v1.18.1/_definitions.json#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Aperture Policy Object",
          "x-order": 3,
          "$ref": "#/definitions/Policy"
        },
        "dynamicConfig": {
          "description": "DynamicConfig provides dynamic configuration for the policy.",
          "x-order": 4,
          "type": ["object", "null"]
        },
        "status": {
          "description": "Status indicates the actual state of the CustomResourceDefinition",
          "x-order": 5,
          "$ref": "https://kubernetesjsonschema.dev/v1.18.1/_definitions.json#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionStatus"
        }
      }
    }
  }
}
