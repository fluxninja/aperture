// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.30.0
// 	protoc        (unknown)
// source: aperture/policy/language/v1/flowcontrol.proto

package languagev1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Describes which flow in which service a [flow control
// component](/concepts/integrations/flow-control/flow-control.md#components) should apply
// to
//
// :::info
//
// See also [FlowSelector overview](/concepts/integrations/flow-control/flow-selector.md).
//
// :::
type FlowSelector struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Match agent group and service
	ServiceSelector *ServiceSelector `protobuf:"bytes,1,opt,name=service_selector,json=serviceSelector,proto3" json:"service_selector,omitempty" validate:"required"` // @gotags: validate:"required"
	// Match control points and labels
	FlowMatcher *FlowMatcher `protobuf:"bytes,2,opt,name=flow_matcher,json=flowMatcher,proto3" json:"flow_matcher,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *FlowSelector) Reset() {
	*x = FlowSelector{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FlowSelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowSelector) ProtoMessage() {}

func (x *FlowSelector) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowSelector.ProtoReflect.Descriptor instead.
func (*FlowSelector) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{0}
}

func (x *FlowSelector) GetServiceSelector() *ServiceSelector {
	if x != nil {
		return x.ServiceSelector
	}
	return nil
}

func (x *FlowSelector) GetFlowMatcher() *FlowMatcher {
	if x != nil {
		return x.FlowMatcher
	}
	return nil
}

// Describes which service a [flow control or observability
// component](/concepts/integrations/flow-control/flow-control.md#components) should apply
// to
//
// :::info
//
// See also [FlowSelector overview](/concepts/integrations/flow-control/flow-selector.md).
//
// :::
type ServiceSelector struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Which [agent-group](/concepts/integrations/flow-control/flow-selector.md#agent-group) this
	// selector applies to.
	//
	// :::info
	//
	// Agent Groups are used to scope policies to a subset of agents connected to the same controller. This is especially useful in the Kubernetes sidecar installation because service discovery is switched off in that mode. The agents within an agent group form a peer to peer cluster and constantly share state.
	//
	// :::
	AgentGroup string `protobuf:"bytes,1,opt,name=agent_group,json=agentGroup,proto3" json:"agent_group,omitempty" default:"default"` // @gotags: default:"default"
	// The Fully Qualified Domain Name of the
	// [service](/concepts/integrations/flow-control/flow-selector.md) to select.
	//
	// In Kubernetes, this is the FQDN of the Service object.
	//
	// "all" means all services within an agent group (catch-all).
	//
	// :::info
	//
	// In the Kubernetes sidecar installation mode, service discovery is switched off by default. In order to scope policies to services, the `service` should be set to `all` and instead, `agent_group` name should be used.
	//
	// :::
	//
	// :::info
	//
	// An entity (e.g. Kubernetes pod) may belong to multiple services.
	//
	// :::
	Service string `protobuf:"bytes,2,opt,name=service,proto3" json:"service,omitempty" validate:"required"` // @gotags: validate:"required"];
}

func (x *ServiceSelector) Reset() {
	*x = ServiceSelector{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ServiceSelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServiceSelector) ProtoMessage() {}

func (x *ServiceSelector) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServiceSelector.ProtoReflect.Descriptor instead.
func (*ServiceSelector) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{1}
}

func (x *ServiceSelector) GetAgentGroup() string {
	if x != nil {
		return x.AgentGroup
	}
	return ""
}

func (x *ServiceSelector) GetService() string {
	if x != nil {
		return x.Service
	}
	return ""
}

// Describes which flows a [flow control
// component](/concepts/integrations/flow-control/flow-control.md#components) should apply
// to
//
// :::info
//
// See also [FlowSelector overview](/concepts/integrations/flow-control/flow-selector.md).
//
// :::
// Example:
// ```yaml
// control_point: ingress
// label_matcher:
//
//	match_labels:
//	  user_tier: gold
//	match_expressions:
//	  - key: query
//	    operator: In
//	    values:
//	      - insert
//	      - delete
//	expression:
//	  label_matches:
//	      - label: user_agent
//	        regex: ^(?!.*Chrome).*Safari
//
// ```
type FlowMatcher struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// [Control Point](/concepts/integrations/flow-control/flow-selector.md#control-point)
	// identifies the location of a Flow within a Service. For an SDK based insertion, a Control Point can represent a particular feature or execution
	// block within a Service. In case of Service Mesh or Middleware insertion, a Control Point can identify ingress vs egress calls or distinct listeners
	// or filter chains.
	ControlPoint string `protobuf:"bytes,1,opt,name=control_point,json=controlPoint,proto3" json:"control_point,omitempty" validate:"required"` // @gotags: validate:"required"
	// Label matcher allows to add _additional_ condition on
	// [flow labels](/concepts/integrations/flow-control/flow-label.md)
	// must also be satisfied (in addition to service+control point matching)
	//
	// :::info
	//
	// See also [Label Matcher overview](/concepts/integrations/flow-control/flow-selector.md#label-matcher).
	//
	// :::
	//
	// :::note
	//
	// [Classifiers](#classifier) _can_ use flow labels created by some other
	// classifier, but only if they were created at some previous control point
	// (and propagated in baggage).
	//
	// This limitation doesn't apply to selectors of other entities, like
	// Flux Meters or Actuators. It's valid to create a flow label on a control
	// point using classifier, and immediately use it for matching on the same
	// control point.
	//
	// :::
	LabelMatcher *LabelMatcher `protobuf:"bytes,2,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty"`
}

func (x *FlowMatcher) Reset() {
	*x = FlowMatcher{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FlowMatcher) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowMatcher) ProtoMessage() {}

func (x *FlowMatcher) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowMatcher.ProtoReflect.Descriptor instead.
func (*FlowMatcher) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{2}
}

func (x *FlowMatcher) GetControlPoint() string {
	if x != nil {
		return x.ControlPoint
	}
	return ""
}

func (x *FlowMatcher) GetLabelMatcher() *LabelMatcher {
	if x != nil {
		return x.LabelMatcher
	}
	return nil
}

// Flux Meter gathers metrics for the traffic that matches its selector.
// The histogram created by Flux Meter measures the workload latency by default.
//
// :::info
//
// See also [Flux Meter overview](/concepts/integrations/flow-control/resources/flux-meter.md).
//
// :::
// Example:
// ```yaml
// static_buckets:
//
//	buckets: [5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]
//
// flow_selector:
//
//	service_selector:
//	   agent_group: demoapp
//	   service: service1-demo-app.demoapp.svc.cluster.local
//	flow_matcher:
//	   control_point: ingress
//
// attribute_key: response_duration_ms
// ```
type FluxMeter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The selection criteria for the traffic that will be measured.
	FlowSelector *FlowSelector `protobuf:"bytes,1,opt,name=flow_selector,json=flowSelector,proto3" json:"flow_selector,omitempty"`
	// Latency histogram buckets (in ms) for this Flux Meter.
	//
	// Types that are assignable to HistogramBuckets:
	//
	//	*FluxMeter_StaticBuckets_
	//	*FluxMeter_LinearBuckets_
	//	*FluxMeter_ExponentialBuckets_
	//	*FluxMeter_ExponentialBucketsRange_
	HistogramBuckets isFluxMeter_HistogramBuckets `protobuf_oneof:"histogram_buckets"`
	// Key of the attribute in access log or span from which the metric for this flux meter is read.
	//
	// :::info
	//
	// For list of available attributes in Envoy access logs, refer
	// [Envoy Filter](/get-started/integrations/flow-control/envoy/istio.md#envoy-filter)
	//
	// :::
	AttributeKey string `protobuf:"bytes,6,opt,name=attribute_key,json=attributeKey,proto3" json:"attribute_key,omitempty" default:"workload_duration_ms"` // @gotags: default:"workload_duration_ms"
}

func (x *FluxMeter) Reset() {
	*x = FluxMeter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter) ProtoMessage() {}

func (x *FluxMeter) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter.ProtoReflect.Descriptor instead.
func (*FluxMeter) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{3}
}

func (x *FluxMeter) GetFlowSelector() *FlowSelector {
	if x != nil {
		return x.FlowSelector
	}
	return nil
}

func (m *FluxMeter) GetHistogramBuckets() isFluxMeter_HistogramBuckets {
	if m != nil {
		return m.HistogramBuckets
	}
	return nil
}

func (x *FluxMeter) GetStaticBuckets() *FluxMeter_StaticBuckets {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_StaticBuckets_); ok {
		return x.StaticBuckets
	}
	return nil
}

func (x *FluxMeter) GetLinearBuckets() *FluxMeter_LinearBuckets {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_LinearBuckets_); ok {
		return x.LinearBuckets
	}
	return nil
}

func (x *FluxMeter) GetExponentialBuckets() *FluxMeter_ExponentialBuckets {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_ExponentialBuckets_); ok {
		return x.ExponentialBuckets
	}
	return nil
}

func (x *FluxMeter) GetExponentialBucketsRange() *FluxMeter_ExponentialBucketsRange {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_ExponentialBucketsRange_); ok {
		return x.ExponentialBucketsRange
	}
	return nil
}

func (x *FluxMeter) GetAttributeKey() string {
	if x != nil {
		return x.AttributeKey
	}
	return ""
}

type isFluxMeter_HistogramBuckets interface {
	isFluxMeter_HistogramBuckets()
}

type FluxMeter_StaticBuckets_ struct {
	StaticBuckets *FluxMeter_StaticBuckets `protobuf:"bytes,2,opt,name=static_buckets,json=staticBuckets,proto3,oneof"`
}

type FluxMeter_LinearBuckets_ struct {
	LinearBuckets *FluxMeter_LinearBuckets `protobuf:"bytes,3,opt,name=linear_buckets,json=linearBuckets,proto3,oneof"`
}

type FluxMeter_ExponentialBuckets_ struct {
	ExponentialBuckets *FluxMeter_ExponentialBuckets `protobuf:"bytes,4,opt,name=exponential_buckets,json=exponentialBuckets,proto3,oneof"`
}

type FluxMeter_ExponentialBucketsRange_ struct {
	ExponentialBucketsRange *FluxMeter_ExponentialBucketsRange `protobuf:"bytes,5,opt,name=exponential_buckets_range,json=exponentialBucketsRange,proto3,oneof"`
}

func (*FluxMeter_StaticBuckets_) isFluxMeter_HistogramBuckets() {}

func (*FluxMeter_LinearBuckets_) isFluxMeter_HistogramBuckets() {}

func (*FluxMeter_ExponentialBuckets_) isFluxMeter_HistogramBuckets() {}

func (*FluxMeter_ExponentialBucketsRange_) isFluxMeter_HistogramBuckets() {}

// Set of classification rules sharing a common selector
//
// :::info
//
// See also [Classifier overview](/concepts/integrations/flow-control/resources/classifier.md).
//
// :::
// Example
// ```yaml
// flow_selector:
//
//	service_selector:
//	   agent_group: demoapp
//	   service: service1-demo-app.demoapp.svc.cluster.local
//	flow_matcher:
//	   control_point: ingress
//	   label_matcher:
//	      match_labels:
//	        user_tier: gold
//	      match_expressions:
//	        - key: user_type
//	          operator: In
//
// rules:
//
//	user:
//	 extractor:
//	   from: request.http.headers.user-agent
//	telemetry: false
//
// ```
type Classifier struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Defines where to apply the flow classification rule.
	FlowSelector *FlowSelector `protobuf:"bytes,1,opt,name=flow_selector,json=flowSelector,proto3" json:"flow_selector,omitempty" validate:"required"` // @gotags: validate:"required"
	// A map of {key, value} pairs mapping from
	// [flow label](/concepts/integrations/flow-control/flow-label.md) keys to rules that define
	// how to extract and propagate flow labels with that key.
	Rules map[string]*Rule `protobuf:"bytes,2,rep,name=rules,proto3" json:"rules,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" validate:"required,gt=0,dive,keys,required,endkeys,required"` // @gotags: validate:"required,gt=0,dive,keys,required,endkeys,required"
}

func (x *Classifier) Reset() {
	*x = Classifier{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Classifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Classifier) ProtoMessage() {}

func (x *Classifier) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Classifier.ProtoReflect.Descriptor instead.
func (*Classifier) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{4}
}

func (x *Classifier) GetFlowSelector() *FlowSelector {
	if x != nil {
		return x.FlowSelector
	}
	return nil
}

func (x *Classifier) GetRules() map[string]*Rule {
	if x != nil {
		return x.Rules
	}
	return nil
}

// Rule describes a single classification Rule
//
// Classification rule extracts a value from request metadata.
// More specifically, from `input`, which has the same spec as [Envoy's External Authorization Attribute Context][attribute-context].
// See https://play.openpolicyagent.org/p/gU7vcLkc70 for an example input.
// There are two ways to define a flow classification rule:
// * Using a declarative extractor – suitable from simple cases, such as directly reading a value from header or a field from json body.
// * Rego expression.
//
// Performance note: It's recommended to use declarative extractors where possible, as they may be slightly performant than Rego expressions.
//
// Example of Declarative JSON extractor:
// ```yaml
// extractor:
//
//	json:
//	  from: request.http.body
//	  pointer: /user/name
//
// ```
//
// Example of Rego module which also disables telemetry visibility of label:
// ```yaml
// rego:
//
//	query: data.user_from_cookie.user
//	source: |
//	  package user_from_cookie
//	  cookies := split(input.attributes.request.http.headers.cookie, "; ")
//	  user := user {
//	      cookie := cookies[_]
//	      startswith(cookie, "session=")
//	      session := substring(cookie, count("session="), -1)
//	      parts := split(session, ".")
//	      object := json.unmarshal(base64url.decode(parts[0]))
//	      user := object.user
//	  }
//
// telemetry: false
// ```
// [attribute-context]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/attribute_context.proto
type Rule struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Source:
	//
	//	*Rule_Extractor
	//	*Rule_Rego_
	Source isRule_Source `protobuf_oneof:"source"`
	// Decides if the created flow label should be available as an attribute in OLAP telemetry and
	// propagated in [baggage](/concepts/integrations/flow-control/flow-label.md#baggage)
	//
	// :::note
	//
	// The flow label is always accessible in Aperture Policies regardless of this setting.
	//
	// :::
	//
	// :::caution
	//
	// When using [FluxNinja ARC extension](arc/extension.md), telemetry enabled
	// labels are sent to FluxNinja ARC for observability. Telemetry should be disabled for
	// sensitive labels.
	//
	// :::
	Telemetry bool `protobuf:"varint,3,opt,name=telemetry,proto3" json:"telemetry,omitempty" default:"true"` // @gotags: default:"true"
}

func (x *Rule) Reset() {
	*x = Rule{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Rule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rule) ProtoMessage() {}

func (x *Rule) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rule.ProtoReflect.Descriptor instead.
func (*Rule) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{5}
}

func (m *Rule) GetSource() isRule_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (x *Rule) GetExtractor() *Extractor {
	if x, ok := x.GetSource().(*Rule_Extractor); ok {
		return x.Extractor
	}
	return nil
}

func (x *Rule) GetRego() *Rule_Rego {
	if x, ok := x.GetSource().(*Rule_Rego_); ok {
		return x.Rego
	}
	return nil
}

func (x *Rule) GetTelemetry() bool {
	if x != nil {
		return x.Telemetry
	}
	return false
}

type isRule_Source interface {
	isRule_Source()
}

type Rule_Extractor struct {
	// High-level declarative extractor.
	Extractor *Extractor `protobuf:"bytes,1,opt,name=extractor,proto3,oneof"`
}

type Rule_Rego_ struct {
	// Rego module to extract a value from.
	Rego *Rule_Rego `protobuf:"bytes,2,opt,name=rego,proto3,oneof"`
}

func (*Rule_Extractor) isRule_Source() {}

func (*Rule_Rego_) isRule_Source() {}

// Defines a high-level way to specify how to extract a flow label value given http request metadata, without a need to write rego code
//
// There are multiple variants of extractor, specify exactly one.
type Extractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Variant:
	//
	//	*Extractor_From
	//	*Extractor_Json
	//	*Extractor_Address
	//	*Extractor_Jwt
	//	*Extractor_PathTemplates
	Variant isExtractor_Variant `protobuf_oneof:"variant"`
}

func (x *Extractor) Reset() {
	*x = Extractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Extractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Extractor) ProtoMessage() {}

func (x *Extractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Extractor.ProtoReflect.Descriptor instead.
func (*Extractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{6}
}

func (m *Extractor) GetVariant() isExtractor_Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

func (x *Extractor) GetFrom() string {
	if x, ok := x.GetVariant().(*Extractor_From); ok {
		return x.From
	}
	return ""
}

func (x *Extractor) GetJson() *JSONExtractor {
	if x, ok := x.GetVariant().(*Extractor_Json); ok {
		return x.Json
	}
	return nil
}

func (x *Extractor) GetAddress() *AddressExtractor {
	if x, ok := x.GetVariant().(*Extractor_Address); ok {
		return x.Address
	}
	return nil
}

func (x *Extractor) GetJwt() *JWTExtractor {
	if x, ok := x.GetVariant().(*Extractor_Jwt); ok {
		return x.Jwt
	}
	return nil
}

func (x *Extractor) GetPathTemplates() *PathTemplateMatcher {
	if x, ok := x.GetVariant().(*Extractor_PathTemplates); ok {
		return x.PathTemplates
	}
	return nil
}

type isExtractor_Variant interface {
	isExtractor_Variant()
}

type Extractor_From struct {
	// Use an attribute with no conversion
	//
	// Attribute path is a dot-separated path to attribute.
	//
	// Should be either:
	// * one of the fields of [Attribute Context][attribute-context], or
	// * a special "request.http.bearer" pseudo-attribute.
	// Eg. "request.http.method" or "request.http.header.user-agent"
	//
	// Note: The same attribute path syntax is shared by other extractor variants,
	// wherever attribute path is needed in their "from" syntax.
	//
	// Example:
	// ```yaml
	// from: request.http.headers.user-agent
	// ```
	// [attribute-context]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/attribute_context.proto
	From string `protobuf:"bytes,1,opt,name=from,proto3,oneof"`
}

type Extractor_Json struct {
	// Deserialize a json, and extract one of the fields.
	Json *JSONExtractor `protobuf:"bytes,2,opt,name=json,proto3,oneof"`
}

type Extractor_Address struct {
	// Display an address as a single string - `<ip>:<port>`.
	Address *AddressExtractor `protobuf:"bytes,3,opt,name=address,proto3,oneof"`
}

type Extractor_Jwt struct {
	// Parse the attribute as JWT and read the payload.
	Jwt *JWTExtractor `protobuf:"bytes,4,opt,name=jwt,proto3,oneof"`
}

type Extractor_PathTemplates struct {
	// Match HTTP Path to given path templates.
	PathTemplates *PathTemplateMatcher `protobuf:"bytes,5,opt,name=path_templates,json=pathTemplates,proto3,oneof"`
}

func (*Extractor_From) isExtractor_Variant() {}

func (*Extractor_Json) isExtractor_Variant() {}

func (*Extractor_Address) isExtractor_Variant() {}

func (*Extractor_Jwt) isExtractor_Variant() {}

func (*Extractor_PathTemplates) isExtractor_Variant() {}

// Deserialize a json, and extract one of the fields
//
// Example:
// ```yaml
// from: request.http.body
// pointer: /user/name
// ```
type JSONExtractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Attribute path pointing to some strings - eg. "request.http.body".
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" validate:"required"` //@gotags: validate:"required"
	// Json pointer represents a parsed json pointer which allows to select a specified field from the json payload.
	//
	// Note: Uses [json pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,
	// eg. `/foo/bar`. If the pointer points into an object, it'd be stringified.
	Pointer string `protobuf:"bytes,2,opt,name=pointer,proto3" json:"pointer,omitempty"`
}

func (x *JSONExtractor) Reset() {
	*x = JSONExtractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *JSONExtractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JSONExtractor) ProtoMessage() {}

func (x *JSONExtractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JSONExtractor.ProtoReflect.Descriptor instead.
func (*JSONExtractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{7}
}

func (x *JSONExtractor) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *JSONExtractor) GetPointer() string {
	if x != nil {
		return x.Pointer
	}
	return ""
}

// Display an [Address][ext-authz-address] as a single string, eg. `<ip>:<port>`
//
// IP addresses in attribute context are defined as objects with separate ip and port fields.
// This is a helper to display an address as a single string.
//
// Note: Use with care, as it might accidentally introduce a high-cardinality flow label values.
//
// Example:
// ```yaml
// from: "source.address # or destination.address"
// ```
//
// [ext-authz-address]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address
type AddressExtractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Attribute path pointing to some string - eg. "source.address".
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" validate:"required"` //@gotags: validate:"required"
}

func (x *AddressExtractor) Reset() {
	*x = AddressExtractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddressExtractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddressExtractor) ProtoMessage() {}

func (x *AddressExtractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddressExtractor.ProtoReflect.Descriptor instead.
func (*AddressExtractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{8}
}

func (x *AddressExtractor) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

// Parse the attribute as JWT and read the payload
//
// Specify a field to be extracted from payload using "json_pointer".
//
// Note: The signature is not verified against the secret (we're assuming there's some
// other parts of the system that handles such verification).
//
// Example:
// ```yaml
// from: request.http.bearer
// json_pointer: /user/email
// ```
type JWTExtractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Jwt token can be pulled from any input attribute, but most likely you'd want to use "request.http.bearer".
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" validate:"required"` //@gotags: validate:"required"
	// Json pointer allowing to select a specified field from the json payload.
	//
	// Note: Uses [json pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,
	// eg. `/foo/bar`. If the pointer points into an object, it'd be stringified.
	JsonPointer string `protobuf:"bytes,2,opt,name=json_pointer,json=jsonPointer,proto3" json:"json_pointer,omitempty"`
}

func (x *JWTExtractor) Reset() {
	*x = JWTExtractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *JWTExtractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JWTExtractor) ProtoMessage() {}

func (x *JWTExtractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JWTExtractor.ProtoReflect.Descriptor instead.
func (*JWTExtractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{9}
}

func (x *JWTExtractor) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *JWTExtractor) GetJsonPointer() string {
	if x != nil {
		return x.JsonPointer
	}
	return ""
}

// Matches HTTP Path to given path templates
//
// HTTP path will be matched against given path templates.
// If a match occurs, the value associated with the path template will be treated as a result.
// In case of multiple path templates matching, the most specific one will be chosen.
type PathTemplateMatcher struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Template value keys are OpenAPI-inspired path templates.
	//
	//   - Static path segment `/foo` matches a path segment exactly
	//   - `/{param}` matches arbitrary path segment.
	//     (The param name is ignored and can be omitted (`{}`))
	//   - The parameter must cover whole segment.
	//   - Additionally, path template can end with `/*` wildcard to match
	//     arbitrary number of trailing segments (0 or more).
	//   - Multiple consecutive `/` are ignored, as well as trailing `/`.
	//   - Parametrized path segments must come after static segments.
	//   - `*`, if present, must come last.
	//   - Most specific template "wins" (`/foo` over `/{}` and `/{}` over `/*`).
	//
	// See also <https://swagger.io/specification/#path-templating-matching>
	//
	// Example:
	// ```yaml
	// /register: register
	// "/user/{userId}": user
	// /static/*: other
	// ```
	TemplateValues map[string]string `protobuf:"bytes,1,rep,name=template_values,json=templateValues,proto3" json:"template_values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" validate:"gt=0,dive,keys,required,endkeys,required"` // @gotags: validate:"gt=0,dive,keys,required,endkeys,required"
}

func (x *PathTemplateMatcher) Reset() {
	*x = PathTemplateMatcher{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PathTemplateMatcher) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PathTemplateMatcher) ProtoMessage() {}

func (x *PathTemplateMatcher) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PathTemplateMatcher.ProtoReflect.Descriptor instead.
func (*PathTemplateMatcher) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{10}
}

func (x *PathTemplateMatcher) GetTemplateValues() map[string]string {
	if x != nil {
		return x.TemplateValues
	}
	return nil
}

// FlowControl components are used to regulate requests flow.
type FlowControl struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Component:
	//
	//	*FlowControl_RateLimiter
	//	*FlowControl_ConcurrencyLimiter
	//	*FlowControl_AimdConcurrencyController
	Component isFlowControl_Component `protobuf_oneof:"component"`
}

func (x *FlowControl) Reset() {
	*x = FlowControl{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FlowControl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowControl) ProtoMessage() {}

func (x *FlowControl) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowControl.ProtoReflect.Descriptor instead.
func (*FlowControl) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{11}
}

func (m *FlowControl) GetComponent() isFlowControl_Component {
	if m != nil {
		return m.Component
	}
	return nil
}

func (x *FlowControl) GetRateLimiter() *RateLimiter {
	if x, ok := x.GetComponent().(*FlowControl_RateLimiter); ok {
		return x.RateLimiter
	}
	return nil
}

func (x *FlowControl) GetConcurrencyLimiter() *ConcurrencyLimiter {
	if x, ok := x.GetComponent().(*FlowControl_ConcurrencyLimiter); ok {
		return x.ConcurrencyLimiter
	}
	return nil
}

func (x *FlowControl) GetAimdConcurrencyController() *AIMDConcurrencyController {
	if x, ok := x.GetComponent().(*FlowControl_AimdConcurrencyController); ok {
		return x.AimdConcurrencyController
	}
	return nil
}

type isFlowControl_Component interface {
	isFlowControl_Component()
}

type FlowControl_RateLimiter struct {
	// Rate Limiter provides service protection by applying rate limiter.
	RateLimiter *RateLimiter `protobuf:"bytes,1,opt,name=rate_limiter,json=rateLimiter,proto3,oneof"`
}

type FlowControl_ConcurrencyLimiter struct {
	// Concurrency Limiter provides service protection by applying prioritized load shedding of flows using a network scheduler (e.g. Weighted Fair Queuing).
	ConcurrencyLimiter *ConcurrencyLimiter `protobuf:"bytes,2,opt,name=concurrency_limiter,json=concurrencyLimiter,proto3,oneof"`
}

type FlowControl_AimdConcurrencyController struct {
	// AIMD Concurrency control component is based on Additive Increase and Multiplicative Decrease of Concurrency. It takes a signal and setpoint as inputs and reduces concurrency limits proportionally (or any arbitrary power) based on deviation of the signal from setpoint. Internally implemented as a nested circuit.
	AimdConcurrencyController *AIMDConcurrencyController `protobuf:"bytes,3,opt,name=aimd_concurrency_controller,json=aimdConcurrencyController,proto3,oneof"`
}

func (*FlowControl_RateLimiter) isFlowControl_Component() {}

func (*FlowControl_ConcurrencyLimiter) isFlowControl_Component() {}

func (*FlowControl_AimdConcurrencyController) isFlowControl_Component() {}

// Limits the traffic on a control point to specified rate
//
// :::info
//
// See also [Rate Limiter overview](/concepts/integrations/flow-control/components/rate-limiter.md).
//
// :::
//
// Ratelimiting is done separately on per-label-value basis. Use _label\_key_
// to select which label should be used as key.
type RateLimiter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the RateLimiter component
	InPorts *RateLimiter_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty" validate:"required"` // @gotags: validate:"required"
	// Which control point to apply this ratelimiter to.
	FlowSelector *FlowSelector `protobuf:"bytes,2,opt,name=flow_selector,json=flowSelector,proto3" json:"flow_selector,omitempty" validate:"required"` // @gotags: validate:"required"
	// Parameters for the RateLimiter component
	Parameters *RateLimiter_Parameters `protobuf:"bytes,3,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Configuration key for DynamicConfig
	DynamicConfigKey string `protobuf:"bytes,4,opt,name=dynamic_config_key,json=dynamicConfigKey,proto3" json:"dynamic_config_key,omitempty"`
	// Default configuration
	DefaultConfig *RateLimiter_DynamicConfig `protobuf:"bytes,5,opt,name=default_config,json=defaultConfig,proto3" json:"default_config,omitempty"`
}

func (x *RateLimiter) Reset() {
	*x = RateLimiter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter) ProtoMessage() {}

func (x *RateLimiter) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter.ProtoReflect.Descriptor instead.
func (*RateLimiter) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{12}
}

func (x *RateLimiter) GetInPorts() *RateLimiter_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *RateLimiter) GetFlowSelector() *FlowSelector {
	if x != nil {
		return x.FlowSelector
	}
	return nil
}

func (x *RateLimiter) GetParameters() *RateLimiter_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *RateLimiter) GetDynamicConfigKey() string {
	if x != nil {
		return x.DynamicConfigKey
	}
	return ""
}

func (x *RateLimiter) GetDefaultConfig() *RateLimiter_DynamicConfig {
	if x != nil {
		return x.DefaultConfig
	}
	return nil
}

// Concurrency Limiter is an actuator component that regulates flows in order to provide active service protection
//
// :::info
//
// See also [Concurrency Limiter overview](/concepts/integrations/flow-control/components/concurrency-limiter.md).
//
// :::
//
// It is based on the actuation strategy (e.g. load actuator) and workload scheduling which is based on Weighted Fair Queuing principles.
// Concurrency is calculated in terms of total tokens which translate to (avg. latency \* in-flight requests), i.e. Little's Law.
//
// ConcurrencyLimiter configuration is split into two parts: An actuation
// strategy and a scheduler. Right now, only `load_actuator` strategy is available.
type ConcurrencyLimiter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Flow Selector decides the service and flows at which the concurrency limiter is applied.
	FlowSelector *FlowSelector `protobuf:"bytes,1,opt,name=flow_selector,json=flowSelector,proto3" json:"flow_selector,omitempty" validate:"required"` // @gotags: validate:"required"
	// Configuration of Weighted Fair Queuing-based workload scheduler.
	//
	// Contains configuration of per-agent scheduler, and also defines some
	// output signals.
	Scheduler *Scheduler `protobuf:"bytes,2,opt,name=scheduler,proto3" json:"scheduler,omitempty" validate:"required"` // @gotags: validate:"required"
	// Types that are assignable to ActuationStrategy:
	//
	//	*ConcurrencyLimiter_LoadActuator
	ActuationStrategy isConcurrencyLimiter_ActuationStrategy `protobuf_oneof:"actuation_strategy"`
}

func (x *ConcurrencyLimiter) Reset() {
	*x = ConcurrencyLimiter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ConcurrencyLimiter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConcurrencyLimiter) ProtoMessage() {}

func (x *ConcurrencyLimiter) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConcurrencyLimiter.ProtoReflect.Descriptor instead.
func (*ConcurrencyLimiter) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{13}
}

func (x *ConcurrencyLimiter) GetFlowSelector() *FlowSelector {
	if x != nil {
		return x.FlowSelector
	}
	return nil
}

func (x *ConcurrencyLimiter) GetScheduler() *Scheduler {
	if x != nil {
		return x.Scheduler
	}
	return nil
}

func (m *ConcurrencyLimiter) GetActuationStrategy() isConcurrencyLimiter_ActuationStrategy {
	if m != nil {
		return m.ActuationStrategy
	}
	return nil
}

func (x *ConcurrencyLimiter) GetLoadActuator() *LoadActuator {
	if x, ok := x.GetActuationStrategy().(*ConcurrencyLimiter_LoadActuator); ok {
		return x.LoadActuator
	}
	return nil
}

type isConcurrencyLimiter_ActuationStrategy interface {
	isConcurrencyLimiter_ActuationStrategy()
}

type ConcurrencyLimiter_LoadActuator struct {
	// Actuator based on limiting the accepted concurrency under incoming concurrency * load multiplier.
	//
	// Actuation strategy defines the input signal that will drive the scheduler.
	LoadActuator *LoadActuator `protobuf:"bytes,3,opt,name=load_actuator,json=loadActuator,proto3,oneof"`
}

func (*ConcurrencyLimiter_LoadActuator) isConcurrencyLimiter_ActuationStrategy() {}

// Weighted Fair Queuing-based workload scheduler
//
// :::note
//
// Each Agent instantiates an independent copy of the scheduler, but output
// signals for accepted and incoming concurrency are aggregated across all agents.
//
// :::
//
// See [ConcurrencyLimiter](#concurrency-limiter) for more context.
type Scheduler struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Output ports for the Scheduler component.
	OutPorts *Scheduler_Outs `protobuf:"bytes,1,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
	// Scheduler parameters.
	Parameters *Scheduler_Parameters `protobuf:"bytes,2,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *Scheduler) Reset() {
	*x = Scheduler{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler) ProtoMessage() {}

func (x *Scheduler) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler.ProtoReflect.Descriptor instead.
func (*Scheduler) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{14}
}

func (x *Scheduler) GetOutPorts() *Scheduler_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

func (x *Scheduler) GetParameters() *Scheduler_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

// Takes the load multiplier input signal and publishes it to the schedulers in the data-plane
type LoadActuator struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the Load Actuator component.
	InPorts *LoadActuator_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty"`
	// Configuration key for DynamicConfig.
	DynamicConfigKey string `protobuf:"bytes,2,opt,name=dynamic_config_key,json=dynamicConfigKey,proto3" json:"dynamic_config_key,omitempty"`
	// Default configuration.
	DefaultConfig *LoadActuator_DynamicConfig `protobuf:"bytes,3,opt,name=default_config,json=defaultConfig,proto3" json:"default_config,omitempty"`
}

func (x *LoadActuator) Reset() {
	*x = LoadActuator{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadActuator) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadActuator) ProtoMessage() {}

func (x *LoadActuator) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadActuator.ProtoReflect.Descriptor instead.
func (*LoadActuator) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{15}
}

func (x *LoadActuator) GetInPorts() *LoadActuator_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *LoadActuator) GetDynamicConfigKey() string {
	if x != nil {
		return x.DynamicConfigKey
	}
	return ""
}

func (x *LoadActuator) GetDefaultConfig() *LoadActuator_DynamicConfig {
	if x != nil {
		return x.DefaultConfig
	}
	return nil
}

// High level concurrency control component. Baselines a signal via exponential moving average and applies concurrency limits based on deviation of signal from the baseline. Internally implemented as a nested circuit.
type AIMDConcurrencyController struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the AIMDConcurrencyController component.
	InPorts *AIMDConcurrencyController_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty"`
	// Output ports for the AIMDConcurrencyController component.
	OutPorts *AIMDConcurrencyController_Outs `protobuf:"bytes,2,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
	// Flow Selector decides the service and flows at which the concurrency limiter is applied.
	FlowSelector *FlowSelector `protobuf:"bytes,3,opt,name=flow_selector,json=flowSelector,proto3" json:"flow_selector,omitempty" validate:"required"` // @gotags: validate:"required"
	// Scheduler parameters.
	SchedulerParameters *Scheduler_Parameters `protobuf:"bytes,4,opt,name=scheduler_parameters,json=schedulerParameters,proto3" json:"scheduler_parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Gradient parameters for the controller.
	GradientParameters *GradientController_Parameters `protobuf:"bytes,5,opt,name=gradient_parameters,json=gradientParameters,proto3" json:"gradient_parameters,omitempty"`
	// Current accepted concurrency is multiplied with this number to dynamically calculate the upper concurrency limit of a Service during normal (non-overload) state. This protects the Service from sudden spikes.
	MaxLoadMultiplier float64 `protobuf:"fixed64,6,opt,name=max_load_multiplier,json=maxLoadMultiplier,proto3" json:"max_load_multiplier,omitempty" default:"2.0"` // @gotags: default:"2.0"
	// Linear increment to load multiplier in each execution tick when the system is not in overloaded state.
	LoadMultiplierLinearIncrement float64 `protobuf:"fixed64,7,opt,name=load_multiplier_linear_increment,json=loadMultiplierLinearIncrement,proto3" json:"load_multiplier_linear_increment,omitempty" default:"0.0025"` // @gotags: default:"0.0025"
	// Configuration for embedded alerter.
	AlerterParameters *Alerter_Parameters `protobuf:"bytes,8,opt,name=alerter_parameters,json=alerterParameters,proto3" json:"alerter_parameters,omitempty"`
	// Configuration key for load actuation.
	DynamicConfigKey string `protobuf:"bytes,9,opt,name=dynamic_config_key,json=dynamicConfigKey,proto3" json:"dynamic_config_key,omitempty"`
	// Default configuration.
	DefaultConfig *LoadActuator_DynamicConfig `protobuf:"bytes,10,opt,name=default_config,json=defaultConfig,proto3" json:"default_config,omitempty"`
}

func (x *AIMDConcurrencyController) Reset() {
	*x = AIMDConcurrencyController{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AIMDConcurrencyController) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AIMDConcurrencyController) ProtoMessage() {}

func (x *AIMDConcurrencyController) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AIMDConcurrencyController.ProtoReflect.Descriptor instead.
func (*AIMDConcurrencyController) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{16}
}

func (x *AIMDConcurrencyController) GetInPorts() *AIMDConcurrencyController_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *AIMDConcurrencyController) GetOutPorts() *AIMDConcurrencyController_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

func (x *AIMDConcurrencyController) GetFlowSelector() *FlowSelector {
	if x != nil {
		return x.FlowSelector
	}
	return nil
}

func (x *AIMDConcurrencyController) GetSchedulerParameters() *Scheduler_Parameters {
	if x != nil {
		return x.SchedulerParameters
	}
	return nil
}

func (x *AIMDConcurrencyController) GetGradientParameters() *GradientController_Parameters {
	if x != nil {
		return x.GradientParameters
	}
	return nil
}

func (x *AIMDConcurrencyController) GetMaxLoadMultiplier() float64 {
	if x != nil {
		return x.MaxLoadMultiplier
	}
	return 0
}

func (x *AIMDConcurrencyController) GetLoadMultiplierLinearIncrement() float64 {
	if x != nil {
		return x.LoadMultiplierLinearIncrement
	}
	return 0
}

func (x *AIMDConcurrencyController) GetAlerterParameters() *Alerter_Parameters {
	if x != nil {
		return x.AlerterParameters
	}
	return nil
}

func (x *AIMDConcurrencyController) GetDynamicConfigKey() string {
	if x != nil {
		return x.DynamicConfigKey
	}
	return ""
}

func (x *AIMDConcurrencyController) GetDefaultConfig() *LoadActuator_DynamicConfig {
	if x != nil {
		return x.DefaultConfig
	}
	return nil
}

// StaticBuckets holds the static value of the buckets where latency histogram will be stored.
type FluxMeter_StaticBuckets struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The buckets in which latency histogram will be stored.
	Buckets []float64 `protobuf:"fixed64,1,rep,packed,name=buckets,proto3" json:"buckets,omitempty" default:"[5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]"` // @gotags: default:"[5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]"
}

func (x *FluxMeter_StaticBuckets) Reset() {
	*x = FluxMeter_StaticBuckets{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_StaticBuckets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_StaticBuckets) ProtoMessage() {}

func (x *FluxMeter_StaticBuckets) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_StaticBuckets.ProtoReflect.Descriptor instead.
func (*FluxMeter_StaticBuckets) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{3, 0}
}

func (x *FluxMeter_StaticBuckets) GetBuckets() []float64 {
	if x != nil {
		return x.Buckets
	}
	return nil
}

// LinearBuckets creates `count` number of buckets, each `width` wide, where the lowest bucket has an
// upper bound of `start`. The final +inf bucket is not counted.
type FluxMeter_LinearBuckets struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Upper bound of the lowest bucket.
	Start float64 `protobuf:"fixed64,1,opt,name=start,proto3" json:"start,omitempty"`
	// Width of each bucket.
	Width float64 `protobuf:"fixed64,2,opt,name=width,proto3" json:"width,omitempty"`
	// Number of buckets.
	Count int32 `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty" validate:"gt=0"` // @gotags: validate:"gt=0"
}

func (x *FluxMeter_LinearBuckets) Reset() {
	*x = FluxMeter_LinearBuckets{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_LinearBuckets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_LinearBuckets) ProtoMessage() {}

func (x *FluxMeter_LinearBuckets) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_LinearBuckets.ProtoReflect.Descriptor instead.
func (*FluxMeter_LinearBuckets) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{3, 1}
}

func (x *FluxMeter_LinearBuckets) GetStart() float64 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *FluxMeter_LinearBuckets) GetWidth() float64 {
	if x != nil {
		return x.Width
	}
	return 0
}

func (x *FluxMeter_LinearBuckets) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

// ExponentialBuckets creates `count` number of buckets where the lowest bucket has an upper bound of `start`
// and each following bucket's upper bound is `factor` times the previous bucket's upper bound. The final +inf
// bucket is not counted.
type FluxMeter_ExponentialBuckets struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Upper bound of the lowest bucket.
	Start float64 `protobuf:"fixed64,1,opt,name=start,proto3" json:"start,omitempty" validate:"gt=0.0"` // @gotags: validate:"gt=0.0"
	// Factor to be multiplied to the previous bucket's upper bound to calculate the following bucket's upper bound.
	Factor float64 `protobuf:"fixed64,2,opt,name=factor,proto3" json:"factor,omitempty" validate:"gt=1.0"` // @gotags: validate:"gt=1.0"
	// Number of buckets.
	Count int32 `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty" validate:"gt=0"` // @gotags: validate:"gt=0"
}

func (x *FluxMeter_ExponentialBuckets) Reset() {
	*x = FluxMeter_ExponentialBuckets{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_ExponentialBuckets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_ExponentialBuckets) ProtoMessage() {}

func (x *FluxMeter_ExponentialBuckets) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_ExponentialBuckets.ProtoReflect.Descriptor instead.
func (*FluxMeter_ExponentialBuckets) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{3, 2}
}

func (x *FluxMeter_ExponentialBuckets) GetStart() float64 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *FluxMeter_ExponentialBuckets) GetFactor() float64 {
	if x != nil {
		return x.Factor
	}
	return 0
}

func (x *FluxMeter_ExponentialBuckets) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

// ExponentialBucketsRange creates `count` number of buckets where the lowest bucket is `min` and the highest
// bucket is `max`. The final +inf bucket is not counted.
type FluxMeter_ExponentialBucketsRange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Lowest bucket.
	Min float64 `protobuf:"fixed64,1,opt,name=min,proto3" json:"min,omitempty" validate:"gt=0.0"` // @gotags: validate:"gt=0.0"
	// Highest bucket.
	Max float64 `protobuf:"fixed64,2,opt,name=max,proto3" json:"max,omitempty"`
	// Number of buckets.
	Count int32 `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty" validate:"gt=0"` // @gotags: validate:"gt=0"
}

func (x *FluxMeter_ExponentialBucketsRange) Reset() {
	*x = FluxMeter_ExponentialBucketsRange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_ExponentialBucketsRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_ExponentialBucketsRange) ProtoMessage() {}

func (x *FluxMeter_ExponentialBucketsRange) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_ExponentialBucketsRange.ProtoReflect.Descriptor instead.
func (*FluxMeter_ExponentialBucketsRange) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{3, 3}
}

func (x *FluxMeter_ExponentialBucketsRange) GetMin() float64 {
	if x != nil {
		return x.Min
	}
	return 0
}

func (x *FluxMeter_ExponentialBucketsRange) GetMax() float64 {
	if x != nil {
		return x.Max
	}
	return 0
}

func (x *FluxMeter_ExponentialBucketsRange) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

// Raw rego rules are compiled 1:1 to rego queries
//
// High-level extractor-based rules are compiled into a single rego query.
type Rule_Rego struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Source code of the rego module.
	//
	// Note: Must include a "package" declaration.
	Source string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty" validate:"required"` // @gotags: validate:"required"
	// Query string to extract a value (eg. `data.<mymodulename>.<variablename>`).
	//
	// Note: The module name must match the package name from the "source".
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *Rule_Rego) Reset() {
	*x = Rule_Rego{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Rule_Rego) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rule_Rego) ProtoMessage() {}

func (x *Rule_Rego) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rule_Rego.ProtoReflect.Descriptor instead.
func (*Rule_Rego) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{5, 0}
}

func (x *Rule_Rego) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *Rule_Rego) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

type RateLimiter_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Time after which the limit for a given label value will be reset.
	LimitResetInterval *durationpb.Duration `protobuf:"bytes,1,opt,name=limit_reset_interval,json=limitResetInterval,proto3" json:"limit_reset_interval,omitempty" default:"60s"` // @gotags: default:"60s"
	// Specifies which label the ratelimiter should be keyed by.
	//
	// Rate limiting is done independently for each value of the
	// [label](/concepts/integrations/flow-control/flow-label.md) with given key.
	// Eg., to give each user a separate limit, assuming you have a _user_ flow
	// label set up, set `label_key: "user"`.
	LabelKey string `protobuf:"bytes,2,opt,name=label_key,json=labelKey,proto3" json:"label_key,omitempty" validate:"required"` // @gotags: validate:"required"
	// Configuration of lazy-syncing behaviour of ratelimiter
	LazySync *RateLimiter_Parameters_LazySync `protobuf:"bytes,3,opt,name=lazy_sync,json=lazySync,proto3" json:"lazy_sync,omitempty"`
}

func (x *RateLimiter_Parameters) Reset() {
	*x = RateLimiter_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_Parameters) ProtoMessage() {}

func (x *RateLimiter_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_Parameters.ProtoReflect.Descriptor instead.
func (*RateLimiter_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{12, 0}
}

func (x *RateLimiter_Parameters) GetLimitResetInterval() *durationpb.Duration {
	if x != nil {
		return x.LimitResetInterval
	}
	return nil
}

func (x *RateLimiter_Parameters) GetLabelKey() string {
	if x != nil {
		return x.LabelKey
	}
	return ""
}

func (x *RateLimiter_Parameters) GetLazySync() *RateLimiter_Parameters_LazySync {
	if x != nil {
		return x.LazySync
	}
	return nil
}

type RateLimiter_Override struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Value of the label for which the override should be applied.
	LabelValue string `protobuf:"bytes,1,opt,name=label_value,json=labelValue,proto3" json:"label_value,omitempty" validate:"required"` // @gotags: validate:"required"
	// Amount by which the _in\_ports.limit_ should be multiplied for this label value.
	LimitScaleFactor float64 `protobuf:"fixed64,2,opt,name=limit_scale_factor,json=limitScaleFactor,proto3" json:"limit_scale_factor,omitempty" default:"1.0"` // @gotags: default:"1.0"
}

func (x *RateLimiter_Override) Reset() {
	*x = RateLimiter_Override{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_Override) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_Override) ProtoMessage() {}

func (x *RateLimiter_Override) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_Override.ProtoReflect.Descriptor instead.
func (*RateLimiter_Override) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{12, 1}
}

func (x *RateLimiter_Override) GetLabelValue() string {
	if x != nil {
		return x.LabelValue
	}
	return ""
}

func (x *RateLimiter_Override) GetLimitScaleFactor() float64 {
	if x != nil {
		return x.LimitScaleFactor
	}
	return 0
}

// Dynamic Configuration for the rate limiter
type RateLimiter_DynamicConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Allows to specify different limits for particular label values.
	Overrides []*RateLimiter_Override `protobuf:"bytes,1,rep,name=overrides,proto3" json:"overrides,omitempty" validate:"dive"` // @gotags: validate:"dive"
}

func (x *RateLimiter_DynamicConfig) Reset() {
	*x = RateLimiter_DynamicConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_DynamicConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_DynamicConfig) ProtoMessage() {}

func (x *RateLimiter_DynamicConfig) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_DynamicConfig.ProtoReflect.Descriptor instead.
func (*RateLimiter_DynamicConfig) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{12, 2}
}

func (x *RateLimiter_DynamicConfig) GetOverrides() []*RateLimiter_Override {
	if x != nil {
		return x.Overrides
	}
	return nil
}

// Inputs for the RateLimiter component
type RateLimiter_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Number of flows allowed per _limit\_reset\_interval_ per each label.
	// Negative values disable the ratelimiter.
	//
	// :::tip
	//
	// Negative limit can be useful to _conditionally_ enable the ratelimiter
	// under certain circumstances. [Decider](#decider) might be helpful.
	//
	// :::
	Limit *InPort `protobuf:"bytes,1,opt,name=limit,proto3" json:"limit,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *RateLimiter_Ins) Reset() {
	*x = RateLimiter_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_Ins) ProtoMessage() {}

func (x *RateLimiter_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_Ins.ProtoReflect.Descriptor instead.
func (*RateLimiter_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{12, 3}
}

func (x *RateLimiter_Ins) GetLimit() *InPort {
	if x != nil {
		return x.Limit
	}
	return nil
}

type RateLimiter_Parameters_LazySync struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Enables lazy sync
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty" default:"false"` // @gotags: default:"false"
	// Number of times to lazy sync within the _limit\_reset\_interval_.
	NumSync uint32 `protobuf:"varint,2,opt,name=num_sync,json=numSync,proto3" json:"num_sync,omitempty" default:"5" validate:"gt=0"` // @gotags: default:"5" validate:"gt=0"
}

func (x *RateLimiter_Parameters_LazySync) Reset() {
	*x = RateLimiter_Parameters_LazySync{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_Parameters_LazySync) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_Parameters_LazySync) ProtoMessage() {}

func (x *RateLimiter_Parameters_LazySync) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_Parameters_LazySync.ProtoReflect.Descriptor instead.
func (*RateLimiter_Parameters_LazySync) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{12, 0, 0}
}

func (x *RateLimiter_Parameters_LazySync) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *RateLimiter_Parameters_LazySync) GetNumSync() uint32 {
	if x != nil {
		return x.NumSync
	}
	return 0
}

// Workload defines a class of requests that preferably have similar properties such as response latency or desired priority.
type Scheduler_Workload struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Parameters associated with flows matching the label matcher.
	Parameters *Scheduler_Workload_Parameters `protobuf:"bytes,1,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Label Matcher to select a Workload based on
	// [flow labels](/concepts/integrations/flow-control/flow-label.md).
	LabelMatcher *LabelMatcher `protobuf:"bytes,2,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *Scheduler_Workload) Reset() {
	*x = Scheduler_Workload{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler_Workload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler_Workload) ProtoMessage() {}

func (x *Scheduler_Workload) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler_Workload.ProtoReflect.Descriptor instead.
func (*Scheduler_Workload) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{14, 0}
}

func (x *Scheduler_Workload) GetParameters() *Scheduler_Workload_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *Scheduler_Workload) GetLabelMatcher() *LabelMatcher {
	if x != nil {
		return x.LabelMatcher
	}
	return nil
}

// Scheduler parameters
type Scheduler_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// List of workloads to be used in scheduler.
	//
	// Categorizing [flows](/concepts/integrations/flow-control/flow-control.md#flow) into workloads
	// allows for load-shedding to be "smarter" than just "randomly deny 50% of
	// requests". There are two aspects of this "smartness":
	//   - Scheduler can more precisely calculate concurrency if it understands
	//     that flows belonging to different classes have different weights (eg.
	//     inserts vs lookups).
	//   - Setting different priorities to different workloads lets the scheduler
	//     avoid dropping important traffic during overload.
	//
	// Each workload in this list specifies also a matcher that's used to
	// determine which flow will be categorized into which workload.
	// In case of multiple matching workloads, the first matching one will be used.
	// If none of workloads match, `default_workload` will be used.
	//
	// :::info
	//
	// See also [workload definition in the concepts
	// section](/concepts/integrations/flow-control/components/concurrency-limiter.md#workload).
	//
	// :::
	Workloads []*Scheduler_Workload `protobuf:"bytes,1,rep,name=workloads,proto3" json:"workloads,omitempty" validate:"dive"` // @gotags: validate:"dive"
	// Parameters to be used if none of workloads specified in `workloads` match.
	DefaultWorkloadParameters *Scheduler_Workload_Parameters `protobuf:"bytes,2,opt,name=default_workload_parameters,json=defaultWorkloadParameters,proto3" json:"default_workload_parameters,omitempty"`
	// Automatically estimate the size of a request in each workload, based on
	// historical latency. Each workload's `tokens` will be set to average
	// latency of flows in that workload during last few seconds (exact duration
	// of this average can change).
	AutoTokens bool `protobuf:"varint,3,opt,name=auto_tokens,json=autoTokens,proto3" json:"auto_tokens,omitempty" default:"true"` // @gotags: default:"true"
	// Timeout as a factor of tokens for a flow in a workload
	//
	// If a flow is not able to get tokens within `timeout_factor * tokens` of duration,
	// it will be rejected.
	//
	// This value impacts the prioritization and fairness because the larger the timeout the higher the chance a request has to get scheduled.
	TimeoutFactor float64 `protobuf:"fixed64,4,opt,name=timeout_factor,json=timeoutFactor,proto3" json:"timeout_factor,omitempty" validate:"gte=0.0" default:"0.5"` // @gotags: validate:"gte=0.0" default:"0.5"
	// Max Timeout is the value with which the flow timeout calculated by `timeout_factor` is capped
	//
	// :::caution
	//
	// This timeout needs to be strictly less than the timeout set on the
	// client for the whole GRPC call:
	// * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
	// * in case of libraries, timeout configured... TODO.
	//
	// We're using fail-open logic in integrations, so if the GRPC timeout
	// fires first, the flow will end up being unconditionally allowed while
	// it're still waiting on the scheduler.
	//
	// To avoid such cases, the end-to-end GRPC timeout should also contain
	// some headroom for constant overhead like serialization, etc. Default
	// value for GRPC timeouts is 500ms, giving 50ms of headeroom, so when
	// tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
	//
	// :::
	MaxTimeout *durationpb.Duration `protobuf:"bytes,5,opt,name=max_timeout,json=maxTimeout,proto3" json:"max_timeout,omitempty" default:"0.49s"` // @gotags: default:"0.49s"
}

func (x *Scheduler_Parameters) Reset() {
	*x = Scheduler_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[30]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler_Parameters) ProtoMessage() {}

func (x *Scheduler_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[30]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler_Parameters.ProtoReflect.Descriptor instead.
func (*Scheduler_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{14, 1}
}

func (x *Scheduler_Parameters) GetWorkloads() []*Scheduler_Workload {
	if x != nil {
		return x.Workloads
	}
	return nil
}

func (x *Scheduler_Parameters) GetDefaultWorkloadParameters() *Scheduler_Workload_Parameters {
	if x != nil {
		return x.DefaultWorkloadParameters
	}
	return nil
}

func (x *Scheduler_Parameters) GetAutoTokens() bool {
	if x != nil {
		return x.AutoTokens
	}
	return false
}

func (x *Scheduler_Parameters) GetTimeoutFactor() float64 {
	if x != nil {
		return x.TimeoutFactor
	}
	return 0
}

func (x *Scheduler_Parameters) GetMaxTimeout() *durationpb.Duration {
	if x != nil {
		return x.MaxTimeout
	}
	return nil
}

// Output for the Scheduler component.
type Scheduler_Outs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Accepted concurrency is actual concurrency on a control point that this
	// scheduler is applied on.
	//
	// :::info
	//
	// Concurrency is a unitless number describing mean number of
	// [flows](/concepts/integrations/flow-control/flow-control.md#flow) being
	// concurrently processed by the system (system = control point).
	// Concurrency is calculated as _work_ done per unit of time (so
	// work-seconds per world-seconds). Work-seconds are computed based on
	// token-weights of of flows (which are either estimated via `auto_tokens`
	// or specified by `Workload.tokens`).
	//
	// :::
	//
	// Value of this signal is aggregated from all the relevant schedulers.
	AcceptedConcurrency *OutPort `protobuf:"bytes,1,opt,name=accepted_concurrency,json=acceptedConcurrency,proto3" json:"accepted_concurrency,omitempty"`
	// Incoming concurrency is concurrency that'd be needed to accept all the
	// flows entering the scheduler.
	//
	// This is computed in the same way as `accepted_concurrency`, but summing
	// up work-seconds from all the flows entering scheduler, including
	// rejected ones.
	IncomingConcurrency *OutPort `protobuf:"bytes,2,opt,name=incoming_concurrency,json=incomingConcurrency,proto3" json:"incoming_concurrency,omitempty"`
}

func (x *Scheduler_Outs) Reset() {
	*x = Scheduler_Outs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[31]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler_Outs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler_Outs) ProtoMessage() {}

func (x *Scheduler_Outs) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[31]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler_Outs.ProtoReflect.Descriptor instead.
func (*Scheduler_Outs) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{14, 2}
}

func (x *Scheduler_Outs) GetAcceptedConcurrency() *OutPort {
	if x != nil {
		return x.AcceptedConcurrency
	}
	return nil
}

func (x *Scheduler_Outs) GetIncomingConcurrency() *OutPort {
	if x != nil {
		return x.IncomingConcurrency
	}
	return nil
}

// Parameters defines parameters such as priority, tokens and fairness key that are applicable to flows within a workload.
type Scheduler_Workload_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Describes priority level of the requests within the workload.
	// Priority level ranges from 0 to 255.
	// Higher numbers means higher priority level.
	// Priority levels have non-linear effect on the workload scheduling. The following formula is used to determine the position of a request in the queue based on virtual finish time:
	//
	// $$
	// \text{virtual\_finish\_time} = \text{virtual\_time} + \left(\text{tokens} \cdot \left(\text{256} - \text{priority}\right)\right)
	// $$
	Priority uint32 `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty" validate:"gte=0,lte=255" default:"0"` // @gotags: validate:"gte=0,lte=255" default:"0"
	// Tokens determines the cost of admitting a single request the workload, which is typically defined as milliseconds of response latency.
	// This override is applicable only if `auto_tokens` is set to false.
	Tokens int64 `protobuf:"varint,2,opt,name=tokens,proto3" json:"tokens,omitempty" default:"1" validate:"gt=0"` // @gotags: default:"1" validate:"gt=0"
	// Fairness key is a label key that can be used to provide fairness within a workload.
	// Any [flow label](/concepts/integrations/flow-control/flow-label.md) can be used here. Eg. if
	// you have a classifier that sets `user` flow label, you might want to set
	// `fairness_key = "user"`.
	FairnessKey string `protobuf:"bytes,3,opt,name=fairness_key,json=fairnessKey,proto3" json:"fairness_key,omitempty"`
}

func (x *Scheduler_Workload_Parameters) Reset() {
	*x = Scheduler_Workload_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[32]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler_Workload_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler_Workload_Parameters) ProtoMessage() {}

func (x *Scheduler_Workload_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[32]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler_Workload_Parameters.ProtoReflect.Descriptor instead.
func (*Scheduler_Workload_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{14, 0, 0}
}

func (x *Scheduler_Workload_Parameters) GetPriority() uint32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *Scheduler_Workload_Parameters) GetTokens() int64 {
	if x != nil {
		return x.Tokens
	}
	return 0
}

func (x *Scheduler_Workload_Parameters) GetFairnessKey() string {
	if x != nil {
		return x.FairnessKey
	}
	return ""
}

// Dynamic Configuration for LoadActuator
type LoadActuator_DynamicConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Decides whether to run the load actuator in dry-run mode. Dry run mode ensures that no traffic gets dropped by this load actuator.
	// Useful for observing the behavior of Load Actuator without disrupting any real traffic.
	DryRun bool `protobuf:"varint,1,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
}

func (x *LoadActuator_DynamicConfig) Reset() {
	*x = LoadActuator_DynamicConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[33]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadActuator_DynamicConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadActuator_DynamicConfig) ProtoMessage() {}

func (x *LoadActuator_DynamicConfig) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[33]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadActuator_DynamicConfig.ProtoReflect.Descriptor instead.
func (*LoadActuator_DynamicConfig) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{15, 0}
}

func (x *LoadActuator_DynamicConfig) GetDryRun() bool {
	if x != nil {
		return x.DryRun
	}
	return false
}

// Input for the Load Actuator component.
type LoadActuator_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Load multiplier is ratio of [incoming
	// concurrency](#scheduler-outs) that needs to be accepted.
	LoadMultiplier *InPort `protobuf:"bytes,1,opt,name=load_multiplier,json=loadMultiplier,proto3" json:"load_multiplier,omitempty"`
}

func (x *LoadActuator_Ins) Reset() {
	*x = LoadActuator_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[34]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadActuator_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadActuator_Ins) ProtoMessage() {}

func (x *LoadActuator_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[34]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadActuator_Ins.ProtoReflect.Descriptor instead.
func (*LoadActuator_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{15, 1}
}

func (x *LoadActuator_Ins) GetLoadMultiplier() *InPort {
	if x != nil {
		return x.LoadMultiplier
	}
	return nil
}

// Inputs for the AIMDConcurrencyController component.
type AIMDConcurrencyController_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The signal to the controller.
	Signal *InPort `protobuf:"bytes,1,opt,name=signal,proto3" json:"signal,omitempty"`
	// The setpoint to the controller.
	Setpoint *InPort `protobuf:"bytes,2,opt,name=setpoint,proto3" json:"setpoint,omitempty"`
}

func (x *AIMDConcurrencyController_Ins) Reset() {
	*x = AIMDConcurrencyController_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[35]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AIMDConcurrencyController_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AIMDConcurrencyController_Ins) ProtoMessage() {}

func (x *AIMDConcurrencyController_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[35]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AIMDConcurrencyController_Ins.ProtoReflect.Descriptor instead.
func (*AIMDConcurrencyController_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{16, 0}
}

func (x *AIMDConcurrencyController_Ins) GetSignal() *InPort {
	if x != nil {
		return x.Signal
	}
	return nil
}

func (x *AIMDConcurrencyController_Ins) GetSetpoint() *InPort {
	if x != nil {
		return x.Setpoint
	}
	return nil
}

// Outputs for the AIMDConcurrencyController component.
type AIMDConcurrencyController_Outs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Is overload is a boolean signal that indicates whether the service is overloaded based on the deviation of the signal from the setpoint taking into account some tolerance.
	IsOverload *OutPort `protobuf:"bytes,1,opt,name=is_overload,json=isOverload,proto3" json:"is_overload,omitempty"`
	// Desired Load multiplier is the ratio of desired concurrency to the incoming concurrency.
	DesiredLoadMultiplier *OutPort `protobuf:"bytes,2,opt,name=desired_load_multiplier,json=desiredLoadMultiplier,proto3" json:"desired_load_multiplier,omitempty"`
	// Observed Load multiplier is the ratio of accepted concurrency to the incoming concurrency.
	ObservedLoadMultiplier *OutPort `protobuf:"bytes,3,opt,name=observed_load_multiplier,json=observedLoadMultiplier,proto3" json:"observed_load_multiplier,omitempty"`
	// Accepted concurrency is the number of concurrent requests that are accepted by the service.
	AcceptedConcurrency *OutPort `protobuf:"bytes,4,opt,name=accepted_concurrency,json=acceptedConcurrency,proto3" json:"accepted_concurrency,omitempty"`
	// IncomingConcurrency is the number of concurrent requests that are received by the service.
	IncomingConcurrency *OutPort `protobuf:"bytes,5,opt,name=incoming_concurrency,json=incomingConcurrency,proto3" json:"incoming_concurrency,omitempty"`
}

func (x *AIMDConcurrencyController_Outs) Reset() {
	*x = AIMDConcurrencyController_Outs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[36]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AIMDConcurrencyController_Outs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AIMDConcurrencyController_Outs) ProtoMessage() {}

func (x *AIMDConcurrencyController_Outs) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[36]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AIMDConcurrencyController_Outs.ProtoReflect.Descriptor instead.
func (*AIMDConcurrencyController_Outs) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{16, 1}
}

func (x *AIMDConcurrencyController_Outs) GetIsOverload() *OutPort {
	if x != nil {
		return x.IsOverload
	}
	return nil
}

func (x *AIMDConcurrencyController_Outs) GetDesiredLoadMultiplier() *OutPort {
	if x != nil {
		return x.DesiredLoadMultiplier
	}
	return nil
}

func (x *AIMDConcurrencyController_Outs) GetObservedLoadMultiplier() *OutPort {
	if x != nil {
		return x.ObservedLoadMultiplier
	}
	return nil
}

func (x *AIMDConcurrencyController_Outs) GetAcceptedConcurrency() *OutPort {
	if x != nil {
		return x.AcceptedConcurrency
	}
	return nil
}

func (x *AIMDConcurrencyController_Outs) GetIncomingConcurrency() *OutPort {
	if x != nil {
		return x.IncomingConcurrency
	}
	return nil
}

var File_aperture_policy_language_v1_flowcontrol_proto protoreflect.FileDescriptor

var file_aperture_policy_language_v1_flowcontrol_proto_rawDesc = []byte{
	0x0a, 0x2d, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x66, 0x6c,
	0x6f, 0x77, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x1b, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x1a, 0x2f, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2f, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f,
	0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x27, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2f, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x70, 0x6f, 0x72, 0x74, 0x73,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x30, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2f, 0x76, 0x31, 0x2f, 0x73, 0x74, 0x64, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e,
	0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xb4, 0x01, 0x0a, 0x0c, 0x46, 0x6c, 0x6f,
	0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x57, 0x0a, 0x10, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f,
	0x72, 0x52, 0x0f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74,
	0x6f, 0x72, 0x12, 0x4b, 0x0a, 0x0c, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68,
	0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x65, 0x72, 0x52, 0x0b, 0x66, 0x6c, 0x6f, 0x77, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x22,
	0x4c, 0x0a, 0x0f, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74,
	0x6f, 0x72, 0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x5f, 0x67, 0x72, 0x6f, 0x75,
	0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x47, 0x72,
	0x6f, 0x75, 0x70, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x22, 0x82, 0x01,
	0x0a, 0x0b, 0x46, 0x6c, 0x6f, 0x77, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x12, 0x23, 0x0a,
	0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x50, 0x6f, 0x69,
	0x6e, 0x74, 0x12, 0x4e, 0x0a, 0x0d, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x74, 0x63,
	0x68, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x4d, 0x61, 0x74,
	0x63, 0x68, 0x65, 0x72, 0x52, 0x0c, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x65, 0x72, 0x22, 0xec, 0x06, 0x0a, 0x09, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72,
	0x12, 0x4e, 0x0a, 0x0d, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f,
	0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74,
	0x6f, 0x72, 0x52, 0x0c, 0x66, 0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72,
	0x12, 0x5d, 0x0a, 0x0e, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65,
	0x74, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72,
	0x2e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x48, 0x00,
	0x52, 0x0d, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12,
	0x5d, 0x0a, 0x0e, 0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74,
	0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x2e,
	0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x48, 0x00, 0x52,
	0x0d, 0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x6c,
	0x0a, 0x13, 0x65, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x62, 0x75,
	0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x39, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65,
	0x74, 0x65, 0x72, 0x2e, 0x45, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42,
	0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x48, 0x00, 0x52, 0x12, 0x65, 0x78, 0x70, 0x6f, 0x6e, 0x65,
	0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x7c, 0x0a, 0x19,
	0x65, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x62, 0x75, 0x63, 0x6b,
	0x65, 0x74, 0x73, 0x5f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x3e, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c,
	0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x45, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74,
	0x69, 0x61, 0x6c, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x48,
	0x00, 0x52, 0x17, 0x65, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75,
	0x63, 0x6b, 0x65, 0x74, 0x73, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x61, 0x74,
	0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x0c, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x4b, 0x65, 0x79, 0x1a,
	0x29, 0x0a, 0x0d, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73,
	0x12, 0x18, 0x0a, 0x07, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
	0x01, 0x52, 0x07, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x1a, 0x51, 0x0a, 0x0d, 0x4c, 0x69,
	0x6e, 0x65, 0x61, 0x72, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x73,
	0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72,
	0x74, 0x12, 0x14, 0x0a, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01,
	0x52, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x1a, 0x58, 0x0a,
	0x12, 0x45, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75, 0x63, 0x6b,
	0x65, 0x74, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x01, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x61, 0x63,
	0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x06, 0x66, 0x61, 0x63, 0x74, 0x6f,
	0x72, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x1a, 0x53, 0x0a, 0x17, 0x45, 0x78, 0x70, 0x6f, 0x6e,
	0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x52, 0x61, 0x6e,
	0x67, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x69, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52,
	0x03, 0x6d, 0x69, 0x6e, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x61, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x01, 0x52, 0x03, 0x6d, 0x61, 0x78, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x42, 0x13, 0x0a, 0x11,
	0x68, 0x69, 0x73, 0x74, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74,
	0x73, 0x22, 0x83, 0x02, 0x0a, 0x0a, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x69, 0x66, 0x69, 0x65, 0x72,
	0x12, 0x4e, 0x0a, 0x0d, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f,
	0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74,
	0x6f, 0x72, 0x52, 0x0c, 0x66, 0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72,
	0x12, 0x48, 0x0a, 0x05, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x32, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6c,
	0x61, 0x73, 0x73, 0x69, 0x66, 0x69, 0x65, 0x72, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x52, 0x05, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x1a, 0x5b, 0x0a, 0x0a, 0x52, 0x75,
	0x6c, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x37, 0x0a, 0x05, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x52, 0x05, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xea, 0x01, 0x0a, 0x04, 0x52, 0x75, 0x6c, 0x65,
	0x12, 0x46, 0x0a, 0x09, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x09, 0x65,
	0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x3c, 0x0a, 0x04, 0x72, 0x65, 0x67, 0x6f,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x2e, 0x52, 0x65, 0x67, 0x6f, 0x48, 0x00,
	0x52, 0x04, 0x72, 0x65, 0x67, 0x6f, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65,
	0x74, 0x72, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x74, 0x65, 0x6c, 0x65, 0x6d,
	0x65, 0x74, 0x72, 0x79, 0x1a, 0x34, 0x0a, 0x04, 0x52, 0x65, 0x67, 0x6f, 0x12, 0x16, 0x0a, 0x06,
	0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x6f,
	0x75, 0x72, 0x63, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x42, 0x08, 0x0a, 0x06, 0x73, 0x6f,
	0x75, 0x72, 0x63, 0x65, 0x22, 0xd3, 0x02, 0x0a, 0x09, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74,
	0x6f, 0x72, 0x12, 0x14, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x48, 0x00, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x40, 0x0a, 0x04, 0x6a, 0x73, 0x6f, 0x6e,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74,
	0x6f, 0x72, 0x48, 0x00, 0x52, 0x04, 0x6a, 0x73, 0x6f, 0x6e, 0x12, 0x49, 0x0a, 0x07, 0x61, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x07, 0x61, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x3d, 0x0a, 0x03, 0x6a, 0x77, 0x74, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x4a, 0x57, 0x54, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x48, 0x00, 0x52,
	0x03, 0x6a, 0x77, 0x74, 0x12, 0x59, 0x0a, 0x0e, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x74, 0x65, 0x6d,
	0x70, 0x6c, 0x61, 0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x74, 0x68, 0x54,
	0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x48, 0x00,
	0x52, 0x0d, 0x70, 0x61, 0x74, 0x68, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x73, 0x42,
	0x09, 0x0a, 0x07, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x22, 0x3d, 0x0a, 0x0d, 0x4a, 0x53,
	0x4f, 0x4e, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x66,
	0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12,
	0x18, 0x0a, 0x07, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x07, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x22, 0x26, 0x0a, 0x10, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x12, 0x0a,
	0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x72, 0x6f,
	0x6d, 0x22, 0x45, 0x0a, 0x0c, 0x4a, 0x57, 0x54, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f,
	0x72, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x21, 0x0a, 0x0c, 0x6a, 0x73, 0x6f, 0x6e, 0x5f, 0x70, 0x6f,
	0x69, 0x6e, 0x74, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6a, 0x73, 0x6f,
	0x6e, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x22, 0xc7, 0x01, 0x0a, 0x13, 0x50, 0x61, 0x74,
	0x68, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72,
	0x12, 0x6d, 0x0a, 0x0f, 0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x5f, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x44, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x74, 0x68, 0x54, 0x65, 0x6d, 0x70,
	0x6c, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x54, 0x65, 0x6d, 0x70,
	0x6c, 0x61, 0x74, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52,
	0x0e, 0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x1a,
	0x41, 0x0a, 0x13, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65,
	0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02,
	0x38, 0x01, 0x22, 0xc7, 0x02, 0x0a, 0x0b, 0x46, 0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x74, 0x72,
	0x6f, 0x6c, 0x12, 0x4d, 0x0a, 0x0c, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74,
	0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74,
	0x65, 0x72, 0x48, 0x00, 0x52, 0x0b, 0x72, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65,
	0x72, 0x12, 0x62, 0x0a, 0x13, 0x63, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79,
	0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6e,
	0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x48,
	0x00, 0x52, 0x12, 0x63, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x4c, 0x69,
	0x6d, 0x69, 0x74, 0x65, 0x72, 0x12, 0x78, 0x0a, 0x1b, 0x61, 0x69, 0x6d, 0x64, 0x5f, 0x63, 0x6f,
	0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f,
	0x6c, 0x6c, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x36, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x49, 0x4d, 0x44, 0x43, 0x6f, 0x6e,
	0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c,
	0x65, 0x72, 0x48, 0x00, 0x52, 0x19, 0x61, 0x69, 0x6d, 0x64, 0x43, 0x6f, 0x6e, 0x63, 0x75, 0x72,
	0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x42,
	0x0b, 0x0a, 0x09, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x22, 0x9c, 0x07, 0x0a,
	0x0b, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x08,
	0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74,
	0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e,
	0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x4e, 0x0a, 0x0d, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x73, 0x65,
	0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x53,
	0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x0c, 0x66, 0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c,
	0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x53, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
	0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69,
	0x74, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a,
	0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x2c, 0x0a, 0x12, 0x64, 0x79,
	0x6e, 0x61, 0x6d, 0x69, 0x63, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4b, 0x65, 0x79, 0x12, 0x5d, 0x0a, 0x0e, 0x64, 0x65, 0x66, 0x61,
	0x75, 0x6c, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x36, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52,
	0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x2e, 0x44, 0x79, 0x6e, 0x61, 0x6d,
	0x69, 0x63, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0d, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c,
	0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x1a, 0x92, 0x02, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61,
	0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x4b, 0x0a, 0x14, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5f,
	0x72, 0x65, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52,
	0x12, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x52, 0x65, 0x73, 0x65, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x72,
	0x76, 0x61, 0x6c, 0x12, 0x1b, 0x0a, 0x09, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6b, 0x65, 0x79,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x4b, 0x65, 0x79,
	0x12, 0x59, 0x0a, 0x09, 0x6c, 0x61, 0x7a, 0x79, 0x5f, 0x73, 0x79, 0x6e, 0x63, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x3c, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x2e, 0x50, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x2e, 0x4c, 0x61, 0x7a, 0x79, 0x53, 0x79, 0x6e,
	0x63, 0x52, 0x08, 0x6c, 0x61, 0x7a, 0x79, 0x53, 0x79, 0x6e, 0x63, 0x1a, 0x3f, 0x0a, 0x08, 0x4c,
	0x61, 0x7a, 0x79, 0x53, 0x79, 0x6e, 0x63, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c,
	0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65,
	0x64, 0x12, 0x19, 0x0a, 0x08, 0x6e, 0x75, 0x6d, 0x5f, 0x73, 0x79, 0x6e, 0x63, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x07, 0x6e, 0x75, 0x6d, 0x53, 0x79, 0x6e, 0x63, 0x1a, 0x59, 0x0a, 0x08,
	0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x6c, 0x61, 0x62, 0x65,
	0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x6c,
	0x61, 0x62, 0x65, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x2c, 0x0a, 0x12, 0x6c, 0x69, 0x6d,
	0x69, 0x74, 0x5f, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x5f, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x10, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x53, 0x63, 0x61, 0x6c,
	0x65, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x1a, 0x60, 0x0a, 0x0d, 0x44, 0x79, 0x6e, 0x61, 0x6d,
	0x69, 0x63, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x4f, 0x0a, 0x09, 0x6f, 0x76, 0x65, 0x72,
	0x72, 0x69, 0x64, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69,
	0x6d, 0x69, 0x74, 0x65, 0x72, 0x2e, 0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x52, 0x09,
	0x6f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x1a, 0x40, 0x0a, 0x03, 0x49, 0x6e, 0x73,
	0x12, 0x39, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e,
	0x50, 0x6f, 0x72, 0x74, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x22, 0x92, 0x02, 0x0a, 0x12,
	0x43, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x4c, 0x69, 0x6d, 0x69, 0x74,
	0x65, 0x72, 0x12, 0x4e, 0x0a, 0x0d, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63,
	0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65,
	0x63, 0x74, 0x6f, 0x72, 0x52, 0x0c, 0x66, 0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74,
	0x6f, 0x72, 0x12, 0x44, 0x0a, 0x09, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x52, 0x09, 0x73,
	0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x50, 0x0a, 0x0d, 0x6c, 0x6f, 0x61, 0x64,
	0x5f, 0x61, 0x63, 0x74, 0x75, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f,
	0x61, 0x64, 0x41, 0x63, 0x74, 0x75, 0x61, 0x74, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x0c, 0x6c, 0x6f,
	0x61, 0x64, 0x41, 0x63, 0x74, 0x75, 0x61, 0x74, 0x6f, 0x72, 0x42, 0x14, 0x0a, 0x12, 0x61, 0x63,
	0x74, 0x75, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79,
	0x22, 0xdf, 0x07, 0x0a, 0x09, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x48,
	0x0a, 0x09, 0x6f, 0x75, 0x74, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x2b, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x4f, 0x75, 0x74, 0x73, 0x52, 0x08,
	0x6f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x51, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61,
	0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64,
	0x75, 0x6c, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52,
	0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x1a, 0x9b, 0x02, 0x0a, 0x08,
	0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x5a, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61,
	0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64,
	0x75, 0x6c, 0x65, 0x72, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x50, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65,
	0x74, 0x65, 0x72, 0x73, 0x12, 0x4e, 0x0a, 0x0d, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6d, 0x61,
	0x74, 0x63, 0x68, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x4d,
	0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x52, 0x0c, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x4d, 0x61, 0x74,
	0x63, 0x68, 0x65, 0x72, 0x1a, 0x63, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
	0x72, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x12, 0x16,
	0x0a, 0x06, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06,
	0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x66, 0x61, 0x69, 0x72, 0x6e, 0x65,
	0x73, 0x73, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x66, 0x61,
	0x69, 0x72, 0x6e, 0x65, 0x73, 0x73, 0x4b, 0x65, 0x79, 0x1a, 0xdb, 0x02, 0x0a, 0x0a, 0x50, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x4d, 0x0a, 0x09, 0x77, 0x6f, 0x72, 0x6b,
	0x6c, 0x6f, 0x61, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75,
	0x6c, 0x65, 0x72, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x09, 0x77, 0x6f,
	0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x12, 0x7a, 0x0a, 0x1b, 0x64, 0x65, 0x66, 0x61, 0x75,
	0x6c, 0x74, 0x5f, 0x77, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x70, 0x61, 0x72, 0x61,
	0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64,
	0x75, 0x6c, 0x65, 0x72, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x50, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x19, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c,
	0x74, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
	0x65, 0x72, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x75, 0x74, 0x6f, 0x5f, 0x74, 0x6f, 0x6b, 0x65,
	0x6e, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x61, 0x75, 0x74, 0x6f, 0x54, 0x6f,
	0x6b, 0x65, 0x6e, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f,
	0x66, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0d, 0x74, 0x69,
	0x6d, 0x65, 0x6f, 0x75, 0x74, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x3a, 0x0a, 0x0b, 0x6d,
	0x61, 0x78, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0a, 0x6d, 0x61, 0x78,
	0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x1a, 0xb8, 0x01, 0x0a, 0x04, 0x4f, 0x75, 0x74, 0x73,
	0x12, 0x57, 0x0a, 0x14, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x65, 0x64, 0x5f, 0x63, 0x6f, 0x6e,
	0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74,
	0x50, 0x6f, 0x72, 0x74, 0x52, 0x13, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x65, 0x64, 0x43, 0x6f,
	0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x12, 0x57, 0x0a, 0x14, 0x69, 0x6e, 0x63,
	0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63,
	0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x13, 0x69,
	0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e,
	0x63, 0x79, 0x22, 0xe5, 0x02, 0x0a, 0x0c, 0x4c, 0x6f, 0x61, 0x64, 0x41, 0x63, 0x74, 0x75, 0x61,
	0x74, 0x6f, 0x72, 0x12, 0x48, 0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x41, 0x63, 0x74, 0x75, 0x61, 0x74, 0x6f, 0x72,
	0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x2c, 0x0a,
	0x12, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f,
	0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x64, 0x79, 0x6e, 0x61, 0x6d,
	0x69, 0x63, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4b, 0x65, 0x79, 0x12, 0x5e, 0x0a, 0x0e, 0x64,
	0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x41, 0x63, 0x74, 0x75, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x44,
	0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0d, 0x64, 0x65,
	0x66, 0x61, 0x75, 0x6c, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x1a, 0x28, 0x0a, 0x0d, 0x44,
	0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x17, 0x0a, 0x07,
	0x64, 0x72, 0x79, 0x5f, 0x72, 0x75, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x64,
	0x72, 0x79, 0x52, 0x75, 0x6e, 0x1a, 0x53, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x4c, 0x0a, 0x0f,
	0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x0e, 0x6c, 0x6f, 0x61, 0x64,
	0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x22, 0x9c, 0x0b, 0x0a, 0x19, 0x41,
	0x49, 0x4d, 0x44, 0x43, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f,
	0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x12, 0x55, 0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70,
	0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x49, 0x4d, 0x44, 0x43, 0x6f, 0x6e,
	0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c,
	0x65, 0x72, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12,
	0x58, 0x0a, 0x09, 0x6f, 0x75, 0x74, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x3b, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x41, 0x49, 0x4d, 0x44, 0x43, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79,
	0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x2e, 0x4f, 0x75, 0x74, 0x73, 0x52,
	0x08, 0x6f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x4e, 0x0a, 0x0d, 0x66, 0x6c, 0x6f,
	0x77, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46,
	0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x0c, 0x66, 0x6c, 0x6f,
	0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x64, 0x0a, 0x14, 0x73, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x5f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
	0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e,
	0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x13, 0x73, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x72, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12,
	0x6b, 0x0a, 0x13, 0x67, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x70, 0x61, 0x72, 0x61,
	0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x72, 0x61, 0x64, 0x69,
	0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x2e, 0x50, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x12, 0x67, 0x72, 0x61, 0x64, 0x69, 0x65,
	0x6e, 0x74, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x2e, 0x0a, 0x13,
	0x6d, 0x61, 0x78, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c,
	0x69, 0x65, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x01, 0x52, 0x11, 0x6d, 0x61, 0x78, 0x4c, 0x6f,
	0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x20,
	0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x5f,
	0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x5f, 0x69, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74,
	0x18, 0x07, 0x20, 0x01, 0x28, 0x01, 0x52, 0x1d, 0x6c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74,
	0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x49, 0x6e, 0x63, 0x72,
	0x65, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x5e, 0x0a, 0x12, 0x61, 0x6c, 0x65, 0x72, 0x74, 0x65, 0x72,
	0x5f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x2f, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x41, 0x6c, 0x65, 0x72, 0x74, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
	0x72, 0x73, 0x52, 0x11, 0x61, 0x6c, 0x65, 0x72, 0x74, 0x65, 0x72, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x2c, 0x0a, 0x12, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63,
	0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x09, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x10, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x4b, 0x65, 0x79, 0x12, 0x5e, 0x0a, 0x0e, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x63,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x41, 0x63,
	0x74, 0x75, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x52, 0x0d, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x43, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x1a, 0x83, 0x01, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x3b, 0x0a, 0x06, 0x73,
	0x69, 0x67, 0x6e, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74,
	0x52, 0x06, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x12, 0x3f, 0x0a, 0x08, 0x73, 0x65, 0x74, 0x70,
	0x6f, 0x69, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52,
	0x08, 0x73, 0x65, 0x74, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x1a, 0xbd, 0x03, 0x0a, 0x04, 0x4f, 0x75,
	0x74, 0x73, 0x12, 0x45, 0x0a, 0x0b, 0x69, 0x73, 0x5f, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x0a, 0x69,
	0x73, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x5c, 0x0a, 0x17, 0x64, 0x65, 0x73,
	0x69, 0x72, 0x65, 0x64, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70,
	0x6c, 0x69, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74,
	0x52, 0x15, 0x64, 0x65, 0x73, 0x69, 0x72, 0x65, 0x64, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c,
	0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x12, 0x5e, 0x0a, 0x18, 0x6f, 0x62, 0x73, 0x65, 0x72,
	0x76, 0x65, 0x64, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c,
	0x69, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52,
	0x16, 0x6f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c,
	0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x12, 0x57, 0x0a, 0x14, 0x61, 0x63, 0x63, 0x65, 0x70,
	0x74, 0x65, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x13, 0x61, 0x63, 0x63,
	0x65, 0x70, 0x74, 0x65, 0x64, 0x43, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79,
	0x12, 0x57, 0x0a, 0x14, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x6f, 0x6e,
	0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74,
	0x50, 0x6f, 0x72, 0x74, 0x52, 0x13, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x43, 0x6f,
	0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x42, 0xad, 0x02, 0x0a, 0x33, 0x63, 0x6f,
	0x6d, 0x2e, 0x66, 0x6c, 0x75, 0x78, 0x6e, 0x69, 0x6e, 0x6a, 0x61, 0x2e, 0x67, 0x65, 0x6e, 0x65,
	0x72, 0x61, 0x74, 0x65, 0x64, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x42, 0x10, 0x46, 0x6c, 0x6f, 0x77, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x50, 0x72,
	0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x55, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f,
	0x6d, 0x2f, 0x66, 0x6c, 0x75, 0x78, 0x6e, 0x69, 0x6e, 0x6a, 0x61, 0x2f, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x2f, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2f, 0x76,
	0x31, 0x3b, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x76, 0x31, 0xa2, 0x02, 0x03, 0x41,
	0x50, 0x4c, 0xaa, 0x02, 0x1b, 0x41, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x4c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x56, 0x31,
	0xca, 0x02, 0x1b, 0x41, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x5c, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x5c, 0x4c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x5c, 0x56, 0x31, 0xe2, 0x02,
	0x27, 0x41, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x5c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x5c, 0x4c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x5c, 0x56, 0x31, 0x5c, 0x47, 0x50, 0x42,
	0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x1e, 0x41, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x3a, 0x3a, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x3a, 0x3a, 0x4c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x3a, 0x3a, 0x56, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x33,
}

var (
	file_aperture_policy_language_v1_flowcontrol_proto_rawDescOnce sync.Once
	file_aperture_policy_language_v1_flowcontrol_proto_rawDescData = file_aperture_policy_language_v1_flowcontrol_proto_rawDesc
)

func file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP() []byte {
	file_aperture_policy_language_v1_flowcontrol_proto_rawDescOnce.Do(func() {
		file_aperture_policy_language_v1_flowcontrol_proto_rawDescData = protoimpl.X.CompressGZIP(file_aperture_policy_language_v1_flowcontrol_proto_rawDescData)
	})
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescData
}

var file_aperture_policy_language_v1_flowcontrol_proto_msgTypes = make([]protoimpl.MessageInfo, 37)
var file_aperture_policy_language_v1_flowcontrol_proto_goTypes = []interface{}{
	(*FlowSelector)(nil),                      // 0: aperture.policy.language.v1.FlowSelector
	(*ServiceSelector)(nil),                   // 1: aperture.policy.language.v1.ServiceSelector
	(*FlowMatcher)(nil),                       // 2: aperture.policy.language.v1.FlowMatcher
	(*FluxMeter)(nil),                         // 3: aperture.policy.language.v1.FluxMeter
	(*Classifier)(nil),                        // 4: aperture.policy.language.v1.Classifier
	(*Rule)(nil),                              // 5: aperture.policy.language.v1.Rule
	(*Extractor)(nil),                         // 6: aperture.policy.language.v1.Extractor
	(*JSONExtractor)(nil),                     // 7: aperture.policy.language.v1.JSONExtractor
	(*AddressExtractor)(nil),                  // 8: aperture.policy.language.v1.AddressExtractor
	(*JWTExtractor)(nil),                      // 9: aperture.policy.language.v1.JWTExtractor
	(*PathTemplateMatcher)(nil),               // 10: aperture.policy.language.v1.PathTemplateMatcher
	(*FlowControl)(nil),                       // 11: aperture.policy.language.v1.FlowControl
	(*RateLimiter)(nil),                       // 12: aperture.policy.language.v1.RateLimiter
	(*ConcurrencyLimiter)(nil),                // 13: aperture.policy.language.v1.ConcurrencyLimiter
	(*Scheduler)(nil),                         // 14: aperture.policy.language.v1.Scheduler
	(*LoadActuator)(nil),                      // 15: aperture.policy.language.v1.LoadActuator
	(*AIMDConcurrencyController)(nil),         // 16: aperture.policy.language.v1.AIMDConcurrencyController
	(*FluxMeter_StaticBuckets)(nil),           // 17: aperture.policy.language.v1.FluxMeter.StaticBuckets
	(*FluxMeter_LinearBuckets)(nil),           // 18: aperture.policy.language.v1.FluxMeter.LinearBuckets
	(*FluxMeter_ExponentialBuckets)(nil),      // 19: aperture.policy.language.v1.FluxMeter.ExponentialBuckets
	(*FluxMeter_ExponentialBucketsRange)(nil), // 20: aperture.policy.language.v1.FluxMeter.ExponentialBucketsRange
	nil,                                     // 21: aperture.policy.language.v1.Classifier.RulesEntry
	(*Rule_Rego)(nil),                       // 22: aperture.policy.language.v1.Rule.Rego
	nil,                                     // 23: aperture.policy.language.v1.PathTemplateMatcher.TemplateValuesEntry
	(*RateLimiter_Parameters)(nil),          // 24: aperture.policy.language.v1.RateLimiter.Parameters
	(*RateLimiter_Override)(nil),            // 25: aperture.policy.language.v1.RateLimiter.Override
	(*RateLimiter_DynamicConfig)(nil),       // 26: aperture.policy.language.v1.RateLimiter.DynamicConfig
	(*RateLimiter_Ins)(nil),                 // 27: aperture.policy.language.v1.RateLimiter.Ins
	(*RateLimiter_Parameters_LazySync)(nil), // 28: aperture.policy.language.v1.RateLimiter.Parameters.LazySync
	(*Scheduler_Workload)(nil),              // 29: aperture.policy.language.v1.Scheduler.Workload
	(*Scheduler_Parameters)(nil),            // 30: aperture.policy.language.v1.Scheduler.Parameters
	(*Scheduler_Outs)(nil),                  // 31: aperture.policy.language.v1.Scheduler.Outs
	(*Scheduler_Workload_Parameters)(nil),   // 32: aperture.policy.language.v1.Scheduler.Workload.Parameters
	(*LoadActuator_DynamicConfig)(nil),      // 33: aperture.policy.language.v1.LoadActuator.DynamicConfig
	(*LoadActuator_Ins)(nil),                // 34: aperture.policy.language.v1.LoadActuator.Ins
	(*AIMDConcurrencyController_Ins)(nil),   // 35: aperture.policy.language.v1.AIMDConcurrencyController.Ins
	(*AIMDConcurrencyController_Outs)(nil),  // 36: aperture.policy.language.v1.AIMDConcurrencyController.Outs
	(*LabelMatcher)(nil),                    // 37: aperture.policy.language.v1.LabelMatcher
	(*GradientController_Parameters)(nil),   // 38: aperture.policy.language.v1.GradientController.Parameters
	(*Alerter_Parameters)(nil),              // 39: aperture.policy.language.v1.Alerter.Parameters
	(*durationpb.Duration)(nil),             // 40: google.protobuf.Duration
	(*InPort)(nil),                          // 41: aperture.policy.language.v1.InPort
	(*OutPort)(nil),                         // 42: aperture.policy.language.v1.OutPort
}
var file_aperture_policy_language_v1_flowcontrol_proto_depIdxs = []int32{
	1,  // 0: aperture.policy.language.v1.FlowSelector.service_selector:type_name -> aperture.policy.language.v1.ServiceSelector
	2,  // 1: aperture.policy.language.v1.FlowSelector.flow_matcher:type_name -> aperture.policy.language.v1.FlowMatcher
	37, // 2: aperture.policy.language.v1.FlowMatcher.label_matcher:type_name -> aperture.policy.language.v1.LabelMatcher
	0,  // 3: aperture.policy.language.v1.FluxMeter.flow_selector:type_name -> aperture.policy.language.v1.FlowSelector
	17, // 4: aperture.policy.language.v1.FluxMeter.static_buckets:type_name -> aperture.policy.language.v1.FluxMeter.StaticBuckets
	18, // 5: aperture.policy.language.v1.FluxMeter.linear_buckets:type_name -> aperture.policy.language.v1.FluxMeter.LinearBuckets
	19, // 6: aperture.policy.language.v1.FluxMeter.exponential_buckets:type_name -> aperture.policy.language.v1.FluxMeter.ExponentialBuckets
	20, // 7: aperture.policy.language.v1.FluxMeter.exponential_buckets_range:type_name -> aperture.policy.language.v1.FluxMeter.ExponentialBucketsRange
	0,  // 8: aperture.policy.language.v1.Classifier.flow_selector:type_name -> aperture.policy.language.v1.FlowSelector
	21, // 9: aperture.policy.language.v1.Classifier.rules:type_name -> aperture.policy.language.v1.Classifier.RulesEntry
	6,  // 10: aperture.policy.language.v1.Rule.extractor:type_name -> aperture.policy.language.v1.Extractor
	22, // 11: aperture.policy.language.v1.Rule.rego:type_name -> aperture.policy.language.v1.Rule.Rego
	7,  // 12: aperture.policy.language.v1.Extractor.json:type_name -> aperture.policy.language.v1.JSONExtractor
	8,  // 13: aperture.policy.language.v1.Extractor.address:type_name -> aperture.policy.language.v1.AddressExtractor
	9,  // 14: aperture.policy.language.v1.Extractor.jwt:type_name -> aperture.policy.language.v1.JWTExtractor
	10, // 15: aperture.policy.language.v1.Extractor.path_templates:type_name -> aperture.policy.language.v1.PathTemplateMatcher
	23, // 16: aperture.policy.language.v1.PathTemplateMatcher.template_values:type_name -> aperture.policy.language.v1.PathTemplateMatcher.TemplateValuesEntry
	12, // 17: aperture.policy.language.v1.FlowControl.rate_limiter:type_name -> aperture.policy.language.v1.RateLimiter
	13, // 18: aperture.policy.language.v1.FlowControl.concurrency_limiter:type_name -> aperture.policy.language.v1.ConcurrencyLimiter
	16, // 19: aperture.policy.language.v1.FlowControl.aimd_concurrency_controller:type_name -> aperture.policy.language.v1.AIMDConcurrencyController
	27, // 20: aperture.policy.language.v1.RateLimiter.in_ports:type_name -> aperture.policy.language.v1.RateLimiter.Ins
	0,  // 21: aperture.policy.language.v1.RateLimiter.flow_selector:type_name -> aperture.policy.language.v1.FlowSelector
	24, // 22: aperture.policy.language.v1.RateLimiter.parameters:type_name -> aperture.policy.language.v1.RateLimiter.Parameters
	26, // 23: aperture.policy.language.v1.RateLimiter.default_config:type_name -> aperture.policy.language.v1.RateLimiter.DynamicConfig
	0,  // 24: aperture.policy.language.v1.ConcurrencyLimiter.flow_selector:type_name -> aperture.policy.language.v1.FlowSelector
	14, // 25: aperture.policy.language.v1.ConcurrencyLimiter.scheduler:type_name -> aperture.policy.language.v1.Scheduler
	15, // 26: aperture.policy.language.v1.ConcurrencyLimiter.load_actuator:type_name -> aperture.policy.language.v1.LoadActuator
	31, // 27: aperture.policy.language.v1.Scheduler.out_ports:type_name -> aperture.policy.language.v1.Scheduler.Outs
	30, // 28: aperture.policy.language.v1.Scheduler.parameters:type_name -> aperture.policy.language.v1.Scheduler.Parameters
	34, // 29: aperture.policy.language.v1.LoadActuator.in_ports:type_name -> aperture.policy.language.v1.LoadActuator.Ins
	33, // 30: aperture.policy.language.v1.LoadActuator.default_config:type_name -> aperture.policy.language.v1.LoadActuator.DynamicConfig
	35, // 31: aperture.policy.language.v1.AIMDConcurrencyController.in_ports:type_name -> aperture.policy.language.v1.AIMDConcurrencyController.Ins
	36, // 32: aperture.policy.language.v1.AIMDConcurrencyController.out_ports:type_name -> aperture.policy.language.v1.AIMDConcurrencyController.Outs
	0,  // 33: aperture.policy.language.v1.AIMDConcurrencyController.flow_selector:type_name -> aperture.policy.language.v1.FlowSelector
	30, // 34: aperture.policy.language.v1.AIMDConcurrencyController.scheduler_parameters:type_name -> aperture.policy.language.v1.Scheduler.Parameters
	38, // 35: aperture.policy.language.v1.AIMDConcurrencyController.gradient_parameters:type_name -> aperture.policy.language.v1.GradientController.Parameters
	39, // 36: aperture.policy.language.v1.AIMDConcurrencyController.alerter_parameters:type_name -> aperture.policy.language.v1.Alerter.Parameters
	33, // 37: aperture.policy.language.v1.AIMDConcurrencyController.default_config:type_name -> aperture.policy.language.v1.LoadActuator.DynamicConfig
	5,  // 38: aperture.policy.language.v1.Classifier.RulesEntry.value:type_name -> aperture.policy.language.v1.Rule
	40, // 39: aperture.policy.language.v1.RateLimiter.Parameters.limit_reset_interval:type_name -> google.protobuf.Duration
	28, // 40: aperture.policy.language.v1.RateLimiter.Parameters.lazy_sync:type_name -> aperture.policy.language.v1.RateLimiter.Parameters.LazySync
	25, // 41: aperture.policy.language.v1.RateLimiter.DynamicConfig.overrides:type_name -> aperture.policy.language.v1.RateLimiter.Override
	41, // 42: aperture.policy.language.v1.RateLimiter.Ins.limit:type_name -> aperture.policy.language.v1.InPort
	32, // 43: aperture.policy.language.v1.Scheduler.Workload.parameters:type_name -> aperture.policy.language.v1.Scheduler.Workload.Parameters
	37, // 44: aperture.policy.language.v1.Scheduler.Workload.label_matcher:type_name -> aperture.policy.language.v1.LabelMatcher
	29, // 45: aperture.policy.language.v1.Scheduler.Parameters.workloads:type_name -> aperture.policy.language.v1.Scheduler.Workload
	32, // 46: aperture.policy.language.v1.Scheduler.Parameters.default_workload_parameters:type_name -> aperture.policy.language.v1.Scheduler.Workload.Parameters
	40, // 47: aperture.policy.language.v1.Scheduler.Parameters.max_timeout:type_name -> google.protobuf.Duration
	42, // 48: aperture.policy.language.v1.Scheduler.Outs.accepted_concurrency:type_name -> aperture.policy.language.v1.OutPort
	42, // 49: aperture.policy.language.v1.Scheduler.Outs.incoming_concurrency:type_name -> aperture.policy.language.v1.OutPort
	41, // 50: aperture.policy.language.v1.LoadActuator.Ins.load_multiplier:type_name -> aperture.policy.language.v1.InPort
	41, // 51: aperture.policy.language.v1.AIMDConcurrencyController.Ins.signal:type_name -> aperture.policy.language.v1.InPort
	41, // 52: aperture.policy.language.v1.AIMDConcurrencyController.Ins.setpoint:type_name -> aperture.policy.language.v1.InPort
	42, // 53: aperture.policy.language.v1.AIMDConcurrencyController.Outs.is_overload:type_name -> aperture.policy.language.v1.OutPort
	42, // 54: aperture.policy.language.v1.AIMDConcurrencyController.Outs.desired_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	42, // 55: aperture.policy.language.v1.AIMDConcurrencyController.Outs.observed_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	42, // 56: aperture.policy.language.v1.AIMDConcurrencyController.Outs.accepted_concurrency:type_name -> aperture.policy.language.v1.OutPort
	42, // 57: aperture.policy.language.v1.AIMDConcurrencyController.Outs.incoming_concurrency:type_name -> aperture.policy.language.v1.OutPort
	58, // [58:58] is the sub-list for method output_type
	58, // [58:58] is the sub-list for method input_type
	58, // [58:58] is the sub-list for extension type_name
	58, // [58:58] is the sub-list for extension extendee
	0,  // [0:58] is the sub-list for field type_name
}

func init() { file_aperture_policy_language_v1_flowcontrol_proto_init() }
func file_aperture_policy_language_v1_flowcontrol_proto_init() {
	if File_aperture_policy_language_v1_flowcontrol_proto != nil {
		return
	}
	file_aperture_policy_language_v1_label_matcher_proto_init()
	file_aperture_policy_language_v1_ports_proto_init()
	file_aperture_policy_language_v1_std_components_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FlowSelector); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ServiceSelector); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FlowMatcher); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Classifier); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Rule); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Extractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*JSONExtractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddressExtractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*JWTExtractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PathTemplateMatcher); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FlowControl); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ConcurrencyLimiter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadActuator); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AIMDConcurrencyController); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_StaticBuckets); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_LinearBuckets); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_ExponentialBuckets); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_ExponentialBucketsRange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Rule_Rego); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_Override); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_DynamicConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_Parameters_LazySync); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler_Workload); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler_Outs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler_Workload_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadActuator_DynamicConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadActuator_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AIMDConcurrencyController_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AIMDConcurrencyController_Outs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[3].OneofWrappers = []interface{}{
		(*FluxMeter_StaticBuckets_)(nil),
		(*FluxMeter_LinearBuckets_)(nil),
		(*FluxMeter_ExponentialBuckets_)(nil),
		(*FluxMeter_ExponentialBucketsRange_)(nil),
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[5].OneofWrappers = []interface{}{
		(*Rule_Extractor)(nil),
		(*Rule_Rego_)(nil),
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[6].OneofWrappers = []interface{}{
		(*Extractor_From)(nil),
		(*Extractor_Json)(nil),
		(*Extractor_Address)(nil),
		(*Extractor_Jwt)(nil),
		(*Extractor_PathTemplates)(nil),
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[11].OneofWrappers = []interface{}{
		(*FlowControl_RateLimiter)(nil),
		(*FlowControl_ConcurrencyLimiter)(nil),
		(*FlowControl_AimdConcurrencyController)(nil),
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[13].OneofWrappers = []interface{}{
		(*ConcurrencyLimiter_LoadActuator)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_aperture_policy_language_v1_flowcontrol_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   37,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_aperture_policy_language_v1_flowcontrol_proto_goTypes,
		DependencyIndexes: file_aperture_policy_language_v1_flowcontrol_proto_depIdxs,
		MessageInfos:      file_aperture_policy_language_v1_flowcontrol_proto_msgTypes,
	}.Build()
	File_aperture_policy_language_v1_flowcontrol_proto = out.File
	file_aperture_policy_language_v1_flowcontrol_proto_rawDesc = nil
	file_aperture_policy_language_v1_flowcontrol_proto_goTypes = nil
	file_aperture_policy_language_v1_flowcontrol_proto_depIdxs = nil
}
