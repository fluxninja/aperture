// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.31.0
// 	protoc        (unknown)
// source: aperture/policy/language/v1/flowcontrol.proto

package languagev1

import (
	v1 "github.com/fluxninja/aperture/v2/api/gen/proto/go/aperture/flowcontrol/check/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// FlowControl Resources
type FlowControlResources struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Flux Meters are installed in the data-plane and form the observability leg of the feedback loop.
	//
	// Flux Meter created metrics can be consumed as input to the circuit through the PromQL component.
	FluxMeters map[string]*FluxMeter `protobuf:"bytes,1,rep,name=flux_meters,json=fluxMeters,proto3" json:"flux_meters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" validate:"dive"` // @gotags: validate:"dive"
	// Classifiers are installed in the data-plane and are used to label the requests based on payload content.
	//
	// The flow labels created by Classifiers can be matched by Flux Meters to create metrics for control purposes.
	Classifiers []*Classifier `protobuf:"bytes,2,rep,name=classifiers,proto3" json:"classifiers,omitempty" validate:"dive"` // @gotags: validate:"dive"
}

func (x *FlowControlResources) Reset() {
	*x = FlowControlResources{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FlowControlResources) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowControlResources) ProtoMessage() {}

func (x *FlowControlResources) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowControlResources.ProtoReflect.Descriptor instead.
func (*FlowControlResources) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{0}
}

func (x *FlowControlResources) GetFluxMeters() map[string]*FluxMeter {
	if x != nil {
		return x.FluxMeters
	}
	return nil
}

func (x *FlowControlResources) GetClassifiers() []*Classifier {
	if x != nil {
		return x.Classifiers
	}
	return nil
}

// _Flow Control_ encompasses components that manage the flow of requests or access to features within a service.
type FlowControl struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Component:
	//
	//	*FlowControl_QuotaScheduler
	//	*FlowControl_RateLimiter
	//	*FlowControl_LoadScheduler
	//	*FlowControl_AdaptiveLoadScheduler
	//	*FlowControl_Sampler
	//	*FlowControl_LoadRamp
	//	*FlowControl_AimdLoadScheduler
	//	*FlowControl_RangeDrivenLoadScheduler
	//	*FlowControl_AiadLoadScheduler
	//	*FlowControl_Private
	Component isFlowControl_Component `protobuf_oneof:"component"`
}

func (x *FlowControl) Reset() {
	*x = FlowControl{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FlowControl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowControl) ProtoMessage() {}

func (x *FlowControl) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowControl.ProtoReflect.Descriptor instead.
func (*FlowControl) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{1}
}

func (m *FlowControl) GetComponent() isFlowControl_Component {
	if m != nil {
		return m.Component
	}
	return nil
}

func (x *FlowControl) GetQuotaScheduler() *QuotaScheduler {
	if x, ok := x.GetComponent().(*FlowControl_QuotaScheduler); ok {
		return x.QuotaScheduler
	}
	return nil
}

func (x *FlowControl) GetRateLimiter() *RateLimiter {
	if x, ok := x.GetComponent().(*FlowControl_RateLimiter); ok {
		return x.RateLimiter
	}
	return nil
}

func (x *FlowControl) GetLoadScheduler() *LoadScheduler {
	if x, ok := x.GetComponent().(*FlowControl_LoadScheduler); ok {
		return x.LoadScheduler
	}
	return nil
}

func (x *FlowControl) GetAdaptiveLoadScheduler() *AdaptiveLoadScheduler {
	if x, ok := x.GetComponent().(*FlowControl_AdaptiveLoadScheduler); ok {
		return x.AdaptiveLoadScheduler
	}
	return nil
}

func (x *FlowControl) GetSampler() *Sampler {
	if x, ok := x.GetComponent().(*FlowControl_Sampler); ok {
		return x.Sampler
	}
	return nil
}

func (x *FlowControl) GetLoadRamp() *LoadRamp {
	if x, ok := x.GetComponent().(*FlowControl_LoadRamp); ok {
		return x.LoadRamp
	}
	return nil
}

func (x *FlowControl) GetAimdLoadScheduler() *AIMDLoadScheduler {
	if x, ok := x.GetComponent().(*FlowControl_AimdLoadScheduler); ok {
		return x.AimdLoadScheduler
	}
	return nil
}

func (x *FlowControl) GetRangeDrivenLoadScheduler() *RangeDrivenLoadScheduler {
	if x, ok := x.GetComponent().(*FlowControl_RangeDrivenLoadScheduler); ok {
		return x.RangeDrivenLoadScheduler
	}
	return nil
}

func (x *FlowControl) GetAiadLoadScheduler() *AIADLoadScheduler {
	if x, ok := x.GetComponent().(*FlowControl_AiadLoadScheduler); ok {
		return x.AiadLoadScheduler
	}
	return nil
}

func (x *FlowControl) GetPrivate() *anypb.Any {
	if x, ok := x.GetComponent().(*FlowControl_Private); ok {
		return x.Private
	}
	return nil
}

type isFlowControl_Component interface {
	isFlowControl_Component()
}

type FlowControl_QuotaScheduler struct {
	QuotaScheduler *QuotaScheduler `protobuf:"bytes,1,opt,name=quota_scheduler,json=quotaScheduler,proto3,oneof"`
}

type FlowControl_RateLimiter struct {
	// _Rate Limiter_ provides service protection by applying rate limits using the token bucket algorithm.
	RateLimiter *RateLimiter `protobuf:"bytes,6,opt,name=rate_limiter,json=rateLimiter,proto3,oneof"`
}

type FlowControl_LoadScheduler struct {
	// _Load Scheduler_ provides service protection by creating a prioritized workload queue in front of the service using Weighted Fair Queuing.
	LoadScheduler *LoadScheduler `protobuf:"bytes,7,opt,name=load_scheduler,json=loadScheduler,proto3,oneof"`
}

type FlowControl_AdaptiveLoadScheduler struct {
	// _Adaptive Load Scheduler_ component does additive increase of load multiplier during non-overload state. During overload, the load multiplier is throttled based on the provided strategy.
	// Deprecated: v3.0.0. Use _AIMD Load Scheduler_ instead.
	AdaptiveLoadScheduler *AdaptiveLoadScheduler `protobuf:"bytes,8,opt,name=adaptive_load_scheduler,json=adaptiveLoadScheduler,proto3,oneof" validate:"deprecated"` // @gotags: validate:"deprecated"
}

type FlowControl_Sampler struct {
	// Sampler is a component that regulates the flow of requests to the service by allowing only the specified percentage of requests or sticky sessions.
	Sampler *Sampler `protobuf:"bytes,9,opt,name=sampler,proto3,oneof"`
}

type FlowControl_LoadRamp struct {
	// _Load Ramp_ smoothly regulates the flow of requests over specified steps.
	LoadRamp *LoadRamp `protobuf:"bytes,10,opt,name=load_ramp,json=loadRamp,proto3,oneof"`
}

type FlowControl_AimdLoadScheduler struct {
	// AIMD Load Scheduler.
	AimdLoadScheduler *AIMDLoadScheduler `protobuf:"bytes,11,opt,name=aimd_load_scheduler,json=aimdLoadScheduler,proto3,oneof"`
}

type FlowControl_RangeDrivenLoadScheduler struct {
	// Range Driven Load Scheduler.
	RangeDrivenLoadScheduler *RangeDrivenLoadScheduler `protobuf:"bytes,12,opt,name=range_driven_load_scheduler,json=rangeDrivenLoadScheduler,proto3,oneof"`
}

type FlowControl_AiadLoadScheduler struct {
	// AIAD Load Scheduler.
	AiadLoadScheduler *AIADLoadScheduler `protobuf:"bytes,13,opt,name=aiad_load_scheduler,json=aiadLoadScheduler,proto3,oneof"`
}

type FlowControl_Private struct {
	// Extends flow control with private components.
	Private *anypb.Any `protobuf:"bytes,1000,opt,name=private,proto3,oneof"`
}

func (*FlowControl_QuotaScheduler) isFlowControl_Component() {}

func (*FlowControl_RateLimiter) isFlowControl_Component() {}

func (*FlowControl_LoadScheduler) isFlowControl_Component() {}

func (*FlowControl_AdaptiveLoadScheduler) isFlowControl_Component() {}

func (*FlowControl_Sampler) isFlowControl_Component() {}

func (*FlowControl_LoadRamp) isFlowControl_Component() {}

func (*FlowControl_AimdLoadScheduler) isFlowControl_Component() {}

func (*FlowControl_RangeDrivenLoadScheduler) isFlowControl_Component() {}

func (*FlowControl_AiadLoadScheduler) isFlowControl_Component() {}

func (*FlowControl_Private) isFlowControl_Component() {}

// Schedules the traffic based on token-bucket based quotas.
type QuotaScheduler struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	InPorts     *RateLimiter_Ins        `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty" validate:"required"`             // @gotags: validate:"required"
	Selectors   []*Selector             `protobuf:"bytes,2,rep,name=selectors,proto3" json:"selectors,omitempty" validate:"required,gt=0,dive"`                        // @gotags: validate:"required,gt=0,dive"
	RateLimiter *RateLimiter_Parameters `protobuf:"bytes,3,opt,name=rate_limiter,json=rateLimiter,proto3" json:"rate_limiter,omitempty" validate:"required"` // @gotags: validate:"required"
	Scheduler   *Scheduler              `protobuf:"bytes,4,opt,name=scheduler,proto3" json:"scheduler,omitempty"`
}

func (x *QuotaScheduler) Reset() {
	*x = QuotaScheduler{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QuotaScheduler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuotaScheduler) ProtoMessage() {}

func (x *QuotaScheduler) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QuotaScheduler.ProtoReflect.Descriptor instead.
func (*QuotaScheduler) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{2}
}

func (x *QuotaScheduler) GetInPorts() *RateLimiter_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *QuotaScheduler) GetSelectors() []*Selector {
	if x != nil {
		return x.Selectors
	}
	return nil
}

func (x *QuotaScheduler) GetRateLimiter() *RateLimiter_Parameters {
	if x != nil {
		return x.RateLimiter
	}
	return nil
}

func (x *QuotaScheduler) GetScheduler() *Scheduler {
	if x != nil {
		return x.Scheduler
	}
	return nil
}

// Limits the traffic on a control point to specified rate
//
// :::info
//
// See also [_Rate Limiter_ overview](/concepts/rate-limiter.md).
//
// :::
//
// RateLimiting is done on per-label-value (`label_key`) basis and it uses the _Token Bucket Algorithm_.
type RateLimiter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the RateLimiter component
	InPorts *RateLimiter_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty" validate:"required"` // @gotags: validate:"required"
	// Parameters for the RateLimiter component
	Parameters *RateLimiter_Parameters `protobuf:"bytes,2,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Selectors for the component.
	Selectors []*Selector `protobuf:"bytes,3,rep,name=selectors,proto3" json:"selectors,omitempty" validate:"required,gt=0,dive"` // @gotags: validate:"required,gt=0,dive"
	// RequestParameters for the component
	RequestParameters *RateLimiter_RequestParameters `protobuf:"bytes,4,opt,name=request_parameters,json=requestParameters,proto3" json:"request_parameters,omitempty"`
}

func (x *RateLimiter) Reset() {
	*x = RateLimiter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter) ProtoMessage() {}

func (x *RateLimiter) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter.ProtoReflect.Descriptor instead.
func (*RateLimiter) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{3}
}

func (x *RateLimiter) GetInPorts() *RateLimiter_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *RateLimiter) GetParameters() *RateLimiter_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *RateLimiter) GetSelectors() []*Selector {
	if x != nil {
		return x.Selectors
	}
	return nil
}

func (x *RateLimiter) GetRequestParameters() *RateLimiter_RequestParameters {
	if x != nil {
		return x.RequestParameters
	}
	return nil
}

// _Load Scheduler_ creates a queue for flows in front of a service to provide active service protection
//
// :::info
//
// See also [_Load Scheduler_ overview](/concepts/scheduler/load-scheduler.md).
//
// :::
//
// To make scheduling decisions the Flows are mapped into Workloads by providing match rules.
// A workload determines the priority and cost of admitting each Flow that belongs to it.
// Scheduling of Flows is based on Weighted Fair Queuing principles.
//
// The signal at port `load_multiplier` determines the fraction of incoming tokens that get admitted. The signals gets acted on once every 10 seconds.
type LoadScheduler struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the LoadScheduler component.
	InPorts *LoadScheduler_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty" validate:"required"` // @gotags: validate:"required"
	// Output ports for the LoadScheduler component.
	OutPorts   *LoadScheduler_Outs       `protobuf:"bytes,2,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
	Parameters *LoadScheduler_Parameters `protobuf:"bytes,5,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Decides whether to run the load scheduler in dry-run mode. In dry run mode the scheduler acts as pass through to all flow and does not queue flows.
	// It is useful for observing the behavior of load scheduler without disrupting any real traffic.
	DryRun bool `protobuf:"varint,6,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	// Configuration key for setting dry run mode through dynamic configuration.
	DryRunConfigKey string `protobuf:"bytes,7,opt,name=dry_run_config_key,json=dryRunConfigKey,proto3" json:"dry_run_config_key,omitempty"`
}

func (x *LoadScheduler) Reset() {
	*x = LoadScheduler{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadScheduler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadScheduler) ProtoMessage() {}

func (x *LoadScheduler) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadScheduler.ProtoReflect.Descriptor instead.
func (*LoadScheduler) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{4}
}

func (x *LoadScheduler) GetInPorts() *LoadScheduler_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *LoadScheduler) GetOutPorts() *LoadScheduler_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

func (x *LoadScheduler) GetParameters() *LoadScheduler_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *LoadScheduler) GetDryRun() bool {
	if x != nil {
		return x.DryRun
	}
	return false
}

func (x *LoadScheduler) GetDryRunConfigKey() string {
	if x != nil {
		return x.DryRunConfigKey
	}
	return ""
}

// Weighted Fair Queuing-based workload scheduler
//
// :::note
//
// Each Agent instantiates an independent copy of the scheduler, but output
// signals for accepted and incoming token rate are aggregated across all agents.
//
// :::
type Scheduler struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// List of workloads to be used in scheduler.
	//
	// Categorizing flows into workloads
	// allows for load throttling to be "intelligent" instead of queueing flows in an arbitrary order.
	// There are two aspects of this "intelligence":
	//   - Scheduler can more precisely calculate concurrency if it understands
	//     that flows belonging to different classes have different weights (for example, insert queries compared to select queries).
	//   - Setting different priorities to different workloads lets the scheduler
	//     avoid dropping important traffic during overload.
	//
	// Each workload in this list specifies also a matcher that is used to
	// determine which flow will be categorized into which workload.
	// In case of multiple matching workloads, the first matching one will be used.
	// If none of workloads match, `default_workload` will be used.
	//
	// :::info
	//
	// See also [workload definition in the concepts
	// section](/concepts/scheduler/scheduler.md#workload).
	//
	// :::
	Workloads []*Scheduler_Workload `protobuf:"bytes,1,rep,name=workloads,proto3" json:"workloads,omitempty" validate:"dive"` // @gotags: validate:"dive"
	// Parameters to be used if none of workloads specified in `workloads` match.
	DefaultWorkloadParameters *Scheduler_Workload_Parameters `protobuf:"bytes,2,opt,name=default_workload_parameters,json=defaultWorkloadParameters,proto3" json:"default_workload_parameters,omitempty"`
	// Decision deadline margin is the amount of time that the scheduler will
	// subtract from the request deadline to determine the deadline for the
	// decision. This is to ensure that the scheduler has enough time to
	// make a decision before the request deadline happens, accounting for
	// processing delays.
	// The request deadline is based on the
	// [gRPC deadline](https://grpc.io/blog/deadlines) or the
	// [`grpc-timeout` HTTP header](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests).
	//
	// Fail-open logic is use for flow control APIs, so if the gRPC deadline
	// reaches, the flow will end up being unconditionally allowed while
	// it is still waiting on the scheduler.
	// This field employs the [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json) JSON representation from Protocol Buffers. The format accommodates fractional seconds up to nine digits after the decimal point, offering nanosecond precision. Every duration value must be suffixed with an "s" to indicate 'seconds.' For example, a value of "10s" would signify a duration of 10 seconds.
	DecisionDeadlineMargin *durationpb.Duration `protobuf:"bytes,6,opt,name=decision_deadline_margin,json=decisionDeadlineMargin,proto3" json:"decision_deadline_margin,omitempty" default:"0.01s"` // @gotags: default:"0.01s"
	// * Key for a flow label that can be used to override the default number of tokens for this request.
	// * The value associated with this key must be a valid number.
	// * If this parameter is not provided, the number of tokens for the flow will be determined by the matched workload's token count.
	TokensLabelKey string `protobuf:"bytes,7,opt,name=tokens_label_key,json=tokensLabelKey,proto3" json:"tokens_label_key,omitempty"`
	// * Key for a flow label that can be used to override the default priority for this flow.
	// * The value associated with this key must be a valid number. Higher numbers means higher priority.
	// * If this parameter is not provided, the priority for the flow will be determined by the matched workload's priority.
	PriorityLabelKey string `protobuf:"bytes,8,opt,name=priority_label_key,json=priorityLabelKey,proto3" json:"priority_label_key,omitempty"`
	// This field allows you to override the default HTTP status code (`503 Service Unavailable`) that is returned when a request is denied.
	DeniedResponseStatusCode v1.StatusCode `protobuf:"varint,9,opt,name=denied_response_status_code,json=deniedResponseStatusCode,proto3,enum=aperture.flowcontrol.check.v1.StatusCode" json:"denied_response_status_code,omitempty"`
}

func (x *Scheduler) Reset() {
	*x = Scheduler{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler) ProtoMessage() {}

func (x *Scheduler) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler.ProtoReflect.Descriptor instead.
func (*Scheduler) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{5}
}

func (x *Scheduler) GetWorkloads() []*Scheduler_Workload {
	if x != nil {
		return x.Workloads
	}
	return nil
}

func (x *Scheduler) GetDefaultWorkloadParameters() *Scheduler_Workload_Parameters {
	if x != nil {
		return x.DefaultWorkloadParameters
	}
	return nil
}

func (x *Scheduler) GetDecisionDeadlineMargin() *durationpb.Duration {
	if x != nil {
		return x.DecisionDeadlineMargin
	}
	return nil
}

func (x *Scheduler) GetTokensLabelKey() string {
	if x != nil {
		return x.TokensLabelKey
	}
	return ""
}

func (x *Scheduler) GetPriorityLabelKey() string {
	if x != nil {
		return x.PriorityLabelKey
	}
	return ""
}

func (x *Scheduler) GetDeniedResponseStatusCode() v1.StatusCode {
	if x != nil {
		return x.DeniedResponseStatusCode
	}
	return v1.StatusCode(0)
}

// _AIMD Load Scheduler_ uses a Gradient Controller to throttle the token rate based on the deviation of the signal from the setpoint.
// It takes a signal and setpoint as inputs and reduces token rate proportionally (or any arbitrary power) based on deviation of the signal from setpoint.
// During recovery, it increases the token rate linearly until the system is not overloaded.
type AIMDLoadScheduler struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the _AIMD Load Scheduler_.
	InPorts *AIMDLoadScheduler_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty"`
	// Output ports for the _AIMD Load Scheduler_.
	OutPorts *AIMDLoadScheduler_Outs `protobuf:"bytes,2,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
	// Parameters for the _AIMD Load Scheduler_.
	Parameters *AIMDLoadScheduler_Parameters `protobuf:"bytes,3,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Decides whether to run the load scheduler in dry-run mode. In dry run mode the scheduler acts as pass through to all flow and does not queue flows.
	// It is useful for observing the behavior of load scheduler without disrupting any real traffic.
	DryRun bool `protobuf:"varint,4,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	// Configuration key for setting dry run mode through dynamic configuration.
	DryRunConfigKey string `protobuf:"bytes,5,opt,name=dry_run_config_key,json=dryRunConfigKey,proto3" json:"dry_run_config_key,omitempty"`
}

func (x *AIMDLoadScheduler) Reset() {
	*x = AIMDLoadScheduler{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AIMDLoadScheduler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AIMDLoadScheduler) ProtoMessage() {}

func (x *AIMDLoadScheduler) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AIMDLoadScheduler.ProtoReflect.Descriptor instead.
func (*AIMDLoadScheduler) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{6}
}

func (x *AIMDLoadScheduler) GetInPorts() *AIMDLoadScheduler_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *AIMDLoadScheduler) GetOutPorts() *AIMDLoadScheduler_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

func (x *AIMDLoadScheduler) GetParameters() *AIMDLoadScheduler_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *AIMDLoadScheduler) GetDryRun() bool {
	if x != nil {
		return x.DryRun
	}
	return false
}

func (x *AIMDLoadScheduler) GetDryRunConfigKey() string {
	if x != nil {
		return x.DryRunConfigKey
	}
	return ""
}

// _Range Load Scheduler_ uses the [polynomial range function](#polynomial-range-function) to throttle the token rate based on the range of the signal.
type RangeDrivenLoadScheduler struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the _Range Load Scheduler_.
	InPorts *RangeDrivenLoadScheduler_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty"`
	// Output ports for the _Range Load Scheduler_.
	OutPorts *RangeDrivenLoadScheduler_Outs `protobuf:"bytes,2,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
	// Parameters for the _Range Load Scheduler_.
	Parameters *RangeDrivenLoadScheduler_Parameters `protobuf:"bytes,3,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Decides whether to run the load scheduler in dry-run mode. In dry run mode the scheduler acts as pass through to all flow and does not queue flows.
	// It is useful for observing the behavior of load scheduler without disrupting any real traffic.
	DryRun bool `protobuf:"varint,4,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	// Configuration key for setting dry run mode through dynamic configuration.
	DryRunConfigKey string `protobuf:"bytes,5,opt,name=dry_run_config_key,json=dryRunConfigKey,proto3" json:"dry_run_config_key,omitempty"`
}

func (x *RangeDrivenLoadScheduler) Reset() {
	*x = RangeDrivenLoadScheduler{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RangeDrivenLoadScheduler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RangeDrivenLoadScheduler) ProtoMessage() {}

func (x *RangeDrivenLoadScheduler) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RangeDrivenLoadScheduler.ProtoReflect.Descriptor instead.
func (*RangeDrivenLoadScheduler) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{7}
}

func (x *RangeDrivenLoadScheduler) GetInPorts() *RangeDrivenLoadScheduler_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *RangeDrivenLoadScheduler) GetOutPorts() *RangeDrivenLoadScheduler_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

func (x *RangeDrivenLoadScheduler) GetParameters() *RangeDrivenLoadScheduler_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *RangeDrivenLoadScheduler) GetDryRun() bool {
	if x != nil {
		return x.DryRun
	}
	return false
}

func (x *RangeDrivenLoadScheduler) GetDryRunConfigKey() string {
	if x != nil {
		return x.DryRunConfigKey
	}
	return ""
}

// _AIAD Load Scheduler_ reduces the token rate linearly over time while in overload state.
// During recovery, it increases the token rate linearly until the system is not overloaded.
type AIADLoadScheduler struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the _AIAD Load Scheduler_.
	InPorts *AIADLoadScheduler_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty"`
	// Output ports for the _AIAD Load Scheduler_.
	OutPorts *AIADLoadScheduler_Outs `protobuf:"bytes,2,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
	// Parameters for the _AIAD Load Scheduler_.
	Parameters *AIADLoadScheduler_Parameters `protobuf:"bytes,3,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Decides whether to run the load scheduler in dry-run mode. In dry run mode the scheduler acts as pass through to all flow and does not queue flows.
	// It is useful for observing the behavior of load scheduler without disrupting any real traffic.
	DryRun bool `protobuf:"varint,4,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	// Configuration key for setting dry run mode through dynamic configuration.
	DryRunConfigKey string `protobuf:"bytes,5,opt,name=dry_run_config_key,json=dryRunConfigKey,proto3" json:"dry_run_config_key,omitempty"`
	// Overload condition determines the criteria to determine overload state. The default condition is "gt", that is, when the signal is greater than the setpoint. The condition must be one of:
	// <!-- vale off -->
	// - "gt": greater than
	// - "lt": less than
	// - "gte": greater than or equal to
	// - "lte": less than or equal to
	// <!-- vale on -->
	OverloadCondition string `protobuf:"bytes,6,opt,name=overload_condition,json=overloadCondition,proto3" json:"overload_condition,omitempty" default:"gt" validate:"required,oneof=gt lt gte lte"` // @gotags: default:"gt" validate:"required,oneof=gt lt gte lte"
}

func (x *AIADLoadScheduler) Reset() {
	*x = AIADLoadScheduler{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AIADLoadScheduler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AIADLoadScheduler) ProtoMessage() {}

func (x *AIADLoadScheduler) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AIADLoadScheduler.ProtoReflect.Descriptor instead.
func (*AIADLoadScheduler) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{8}
}

func (x *AIADLoadScheduler) GetInPorts() *AIADLoadScheduler_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *AIADLoadScheduler) GetOutPorts() *AIADLoadScheduler_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

func (x *AIADLoadScheduler) GetParameters() *AIADLoadScheduler_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *AIADLoadScheduler) GetDryRun() bool {
	if x != nil {
		return x.DryRun
	}
	return false
}

func (x *AIADLoadScheduler) GetDryRunConfigKey() string {
	if x != nil {
		return x.DryRunConfigKey
	}
	return ""
}

func (x *AIADLoadScheduler) GetOverloadCondition() string {
	if x != nil {
		return x.OverloadCondition
	}
	return ""
}

// The _Adaptive Load Scheduler_ adjusts the accepted token rate based on the deviation of the input signal from the setpoint.
// Deprecated: v3.0.0. Use _AIMD Load Scheduler_ instead.
type AdaptiveLoadScheduler struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Collection of input ports for the _Adaptive Load Scheduler_ component.
	InPorts *AdaptiveLoadScheduler_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty" validate:"required"` // @gotags: validate:"required"
	// Collection of output ports for the _Adaptive Load Scheduler_ component.
	OutPorts *AdaptiveLoadScheduler_Outs `protobuf:"bytes,2,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
	// Parameters for the _Adaptive Load Scheduler_ component.
	Parameters *AdaptiveLoadScheduler_Parameters `protobuf:"bytes,3,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Decides whether to run the load scheduler in dry-run mode. In dry run mode the scheduler acts as pass through to all flow and does not queue flows.
	// It is useful for observing the behavior of load scheduler without disrupting any real traffic.
	DryRun bool `protobuf:"varint,6,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	// Configuration key for setting dry run mode through dynamic configuration.
	DryRunConfigKey string `protobuf:"bytes,7,opt,name=dry_run_config_key,json=dryRunConfigKey,proto3" json:"dry_run_config_key,omitempty"`
}

func (x *AdaptiveLoadScheduler) Reset() {
	*x = AdaptiveLoadScheduler{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AdaptiveLoadScheduler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdaptiveLoadScheduler) ProtoMessage() {}

func (x *AdaptiveLoadScheduler) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdaptiveLoadScheduler.ProtoReflect.Descriptor instead.
func (*AdaptiveLoadScheduler) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{9}
}

func (x *AdaptiveLoadScheduler) GetInPorts() *AdaptiveLoadScheduler_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *AdaptiveLoadScheduler) GetOutPorts() *AdaptiveLoadScheduler_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

func (x *AdaptiveLoadScheduler) GetParameters() *AdaptiveLoadScheduler_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *AdaptiveLoadScheduler) GetDryRun() bool {
	if x != nil {
		return x.DryRun
	}
	return false
}

func (x *AdaptiveLoadScheduler) GetDryRunConfigKey() string {
	if x != nil {
		return x.DryRunConfigKey
	}
	return ""
}

// _Sampler_ is a component that regulates the load at a
// [_Control Point_](/concepts/selector.md/#control-point) by allowing only a specified percentage of
// flows at random or by sticky sessions.
//
// :::info
//
// See also [_Sampler_ overview](/concepts/advanced/load-ramp.md#sampler).
//
// :::
type Sampler struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the _Sampler_.
	InPorts *Sampler_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty"`
	// Parameters for the _Sampler_.
	Parameters *Sampler_Parameters `protobuf:"bytes,2,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Specify certain label values to be always accepted by this _Sampler_ regardless of accept percentage.
	PassThroughLabelValues []string `protobuf:"bytes,5,rep,name=pass_through_label_values,json=passThroughLabelValues,proto3" json:"pass_through_label_values,omitempty"`
	// Configuration key for setting pass through label values through dynamic configuration.
	PassThroughLabelValuesConfigKey string `protobuf:"bytes,6,opt,name=pass_through_label_values_config_key,json=passThroughLabelValuesConfigKey,proto3" json:"pass_through_label_values_config_key,omitempty"`
}

func (x *Sampler) Reset() {
	*x = Sampler{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Sampler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Sampler) ProtoMessage() {}

func (x *Sampler) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Sampler.ProtoReflect.Descriptor instead.
func (*Sampler) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{10}
}

func (x *Sampler) GetInPorts() *Sampler_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *Sampler) GetParameters() *Sampler_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *Sampler) GetPassThroughLabelValues() []string {
	if x != nil {
		return x.PassThroughLabelValues
	}
	return nil
}

func (x *Sampler) GetPassThroughLabelValuesConfigKey() string {
	if x != nil {
		return x.PassThroughLabelValuesConfigKey
	}
	return ""
}

// The _Load Ramp_ produces a smooth and continuous traffic load
// that changes progressively over time, based on the specified steps.
//
// Each step is defined by two parameters:
//   - The `target_accept_percentage`.
//   - The `duration` for the signal to change from the
//     previous step's `target_accept_percentage` to the current step's
//     `target_accept_percentage`.
//
// The percentage of requests accepted starts at the `target_accept_percentage`
// defined in the first step and gradually ramps up or down linearly from
// the previous step's `target_accept_percentage` to the next
// `target_accept_percentage`, over the `duration` specified for each step.
type LoadRamp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	InPorts    *LoadRamp_Ins        `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty"`
	OutPorts   *LoadRamp_Outs       `protobuf:"bytes,2,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
	Parameters *LoadRamp_Parameters `protobuf:"bytes,3,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Specify certain label values to be always accepted by the _Sampler_ regardless of accept percentage.
	PassThroughLabelValues []string `protobuf:"bytes,4,rep,name=pass_through_label_values,json=passThroughLabelValues,proto3" json:"pass_through_label_values,omitempty"`
	// Configuration key for setting pass through label values through dynamic configuration.
	PassThroughLabelValuesConfigKey string `protobuf:"bytes,5,opt,name=pass_through_label_values_config_key,json=passThroughLabelValuesConfigKey,proto3" json:"pass_through_label_values_config_key,omitempty"`
}

func (x *LoadRamp) Reset() {
	*x = LoadRamp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadRamp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadRamp) ProtoMessage() {}

func (x *LoadRamp) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadRamp.ProtoReflect.Descriptor instead.
func (*LoadRamp) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{11}
}

func (x *LoadRamp) GetInPorts() *LoadRamp_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *LoadRamp) GetOutPorts() *LoadRamp_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

func (x *LoadRamp) GetParameters() *LoadRamp_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *LoadRamp) GetPassThroughLabelValues() []string {
	if x != nil {
		return x.PassThroughLabelValues
	}
	return nil
}

func (x *LoadRamp) GetPassThroughLabelValuesConfigKey() string {
	if x != nil {
		return x.PassThroughLabelValuesConfigKey
	}
	return ""
}

// Flux Meter gathers metrics for the traffic that matches its selector.
// The histogram created by Flux Meter measures the workload latency by default.
//
// :::info
//
// See also [Flux Meter overview](/concepts/advanced/flux-meter.md).
//
// :::
// Example:
// ```yaml
// static_buckets:
//
//	buckets: [5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]
//
// selectors:
//   - agent_group: demoapp
//     service: service1-demo-app.demoapp.svc.cluster.local
//     control_point: ingress
//
// attribute_key: response_duration_ms
// ```
type FluxMeter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Latency histogram buckets (in ms) for this Flux Meter.
	//
	// Types that are assignable to HistogramBuckets:
	//
	//	*FluxMeter_StaticBuckets_
	//	*FluxMeter_LinearBuckets_
	//	*FluxMeter_ExponentialBuckets_
	//	*FluxMeter_ExponentialBucketsRange_
	HistogramBuckets isFluxMeter_HistogramBuckets `protobuf_oneof:"histogram_buckets"`
	// Key of the attribute in access log or span from which the metric for this flux meter is read.
	//
	// :::info
	//
	// For list of available attributes in Envoy access logs, refer
	// [Envoy Filter](/self-hosting/integrations/istio/istio.md#envoy-filter)
	//
	// :::
	AttributeKey string `protobuf:"bytes,6,opt,name=attribute_key,json=attributeKey,proto3" json:"attribute_key,omitempty" default:"workload_duration_ms"` // @gotags: default:"workload_duration_ms"
	// Selectors for flows that will be metered by this _Flux Meter_.
	Selectors []*Selector `protobuf:"bytes,7,rep,name=selectors,proto3" json:"selectors,omitempty" validate:"required,gt=0,dive"` // @gotags: validate:"required,gt=0,dive"
}

func (x *FluxMeter) Reset() {
	*x = FluxMeter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter) ProtoMessage() {}

func (x *FluxMeter) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter.ProtoReflect.Descriptor instead.
func (*FluxMeter) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{12}
}

func (m *FluxMeter) GetHistogramBuckets() isFluxMeter_HistogramBuckets {
	if m != nil {
		return m.HistogramBuckets
	}
	return nil
}

func (x *FluxMeter) GetStaticBuckets() *FluxMeter_StaticBuckets {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_StaticBuckets_); ok {
		return x.StaticBuckets
	}
	return nil
}

func (x *FluxMeter) GetLinearBuckets() *FluxMeter_LinearBuckets {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_LinearBuckets_); ok {
		return x.LinearBuckets
	}
	return nil
}

func (x *FluxMeter) GetExponentialBuckets() *FluxMeter_ExponentialBuckets {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_ExponentialBuckets_); ok {
		return x.ExponentialBuckets
	}
	return nil
}

func (x *FluxMeter) GetExponentialBucketsRange() *FluxMeter_ExponentialBucketsRange {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_ExponentialBucketsRange_); ok {
		return x.ExponentialBucketsRange
	}
	return nil
}

func (x *FluxMeter) GetAttributeKey() string {
	if x != nil {
		return x.AttributeKey
	}
	return ""
}

func (x *FluxMeter) GetSelectors() []*Selector {
	if x != nil {
		return x.Selectors
	}
	return nil
}

type isFluxMeter_HistogramBuckets interface {
	isFluxMeter_HistogramBuckets()
}

type FluxMeter_StaticBuckets_ struct {
	StaticBuckets *FluxMeter_StaticBuckets `protobuf:"bytes,2,opt,name=static_buckets,json=staticBuckets,proto3,oneof"`
}

type FluxMeter_LinearBuckets_ struct {
	LinearBuckets *FluxMeter_LinearBuckets `protobuf:"bytes,3,opt,name=linear_buckets,json=linearBuckets,proto3,oneof"`
}

type FluxMeter_ExponentialBuckets_ struct {
	ExponentialBuckets *FluxMeter_ExponentialBuckets `protobuf:"bytes,4,opt,name=exponential_buckets,json=exponentialBuckets,proto3,oneof"`
}

type FluxMeter_ExponentialBucketsRange_ struct {
	ExponentialBucketsRange *FluxMeter_ExponentialBucketsRange `protobuf:"bytes,5,opt,name=exponential_buckets_range,json=exponentialBucketsRange,proto3,oneof"`
}

func (*FluxMeter_StaticBuckets_) isFluxMeter_HistogramBuckets() {}

func (*FluxMeter_LinearBuckets_) isFluxMeter_HistogramBuckets() {}

func (*FluxMeter_ExponentialBuckets_) isFluxMeter_HistogramBuckets() {}

func (*FluxMeter_ExponentialBucketsRange_) isFluxMeter_HistogramBuckets() {}

// Set of classification rules sharing a common selector
//
// :::info
//
// See also [Classifier overview](/concepts/advanced/classifier.md).
//
// :::
// Example
// ```yaml
// selectors:
//   - agent_group: demoapp
//     service: service1-demo-app.demoapp.svc.cluster.local
//     control_point: ingress
//     label_matcher:
//     match_labels:
//     user_tier: gold
//     match_expressions:
//   - key: user_type
//     operator: In
//
// rules:
//
//	user:
//	 extractor:
//	   from: request.http.headers.user-agent
//	telemetry: false
//
// ```
type Classifier struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A map of {key, value} pairs mapping from
	// [flow label](/concepts/flow-label.md) keys to rules that define
	// how to extract and propagate flow labels with that key.
	Rules map[string]*Rule `protobuf:"bytes,2,rep,name=rules,proto3" json:"rules,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" validate:"dive,keys,required,endkeys,required"` // @gotags: validate:"dive,keys,required,endkeys,required"
	// Rego based classification
	//
	// Rego is a policy language used to express complex policies in a concise and declarative way.
	// It can be used to define flow classification rules by writing custom queries that extract values from request metadata.
	// For simple cases, such as directly reading a value from header or a field from JSON body, declarative extractors are recommended.
	Rego *Rego `protobuf:"bytes,3,opt,name=rego,proto3" json:"rego,omitempty"`
	// Selectors for flows that will be classified by this _Classifier_.
	Selectors []*Selector `protobuf:"bytes,4,rep,name=selectors,proto3" json:"selectors,omitempty" validate:"required,gt=0,dive"` // @gotags: validate:"required,gt=0,dive"
}

func (x *Classifier) Reset() {
	*x = Classifier{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Classifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Classifier) ProtoMessage() {}

func (x *Classifier) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Classifier.ProtoReflect.Descriptor instead.
func (*Classifier) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{13}
}

func (x *Classifier) GetRules() map[string]*Rule {
	if x != nil {
		return x.Rules
	}
	return nil
}

func (x *Classifier) GetRego() *Rego {
	if x != nil {
		return x.Rego
	}
	return nil
}

func (x *Classifier) GetSelectors() []*Selector {
	if x != nil {
		return x.Selectors
	}
	return nil
}

// Rule describes a single classification Rule
//
// Example of a JSON extractor:
// ```yaml
// extractor:
//
//	json:
//	  from: request.http.body
//	  pointer: /user/name
//
// ```
type Rule struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Source:
	//
	//	*Rule_Extractor
	Source isRule_Source `protobuf_oneof:"source"`
	// Decides if the created flow label should be available as an attribute in OLAP telemetry and
	// propagated in [baggage](/concepts/flow-label.md#baggage)
	//
	// :::note
	//
	// The flow label is always accessible in Aperture Policies regardless of this setting.
	//
	// :::
	//
	// :::caution
	//
	// When using [FluxNinja extension](/reference/fluxninja.md), telemetry enabled
	// labels are sent to Aperture Cloud for observability. Telemetry should be
	// disabled for sensitive labels.
	//
	// :::
	Telemetry bool `protobuf:"varint,3,opt,name=telemetry,proto3" json:"telemetry,omitempty" default:"true"` // @gotags: default:"true"
}

func (x *Rule) Reset() {
	*x = Rule{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Rule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rule) ProtoMessage() {}

func (x *Rule) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rule.ProtoReflect.Descriptor instead.
func (*Rule) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{14}
}

func (m *Rule) GetSource() isRule_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (x *Rule) GetExtractor() *Extractor {
	if x, ok := x.GetSource().(*Rule_Extractor); ok {
		return x.Extractor
	}
	return nil
}

func (x *Rule) GetTelemetry() bool {
	if x != nil {
		return x.Telemetry
	}
	return false
}

type isRule_Source interface {
	isRule_Source()
}

type Rule_Extractor struct {
	// High-level declarative extractor.
	Extractor *Extractor `protobuf:"bytes,1,opt,name=extractor,proto3,oneof"`
}

func (*Rule_Extractor) isRule_Source() {}

// Rego define a set of labels that are extracted after evaluating a Rego module.
//
// :::info
//
// You can use the [live-preview](/concepts/advanced/classifier.md#live-previewing-requests) feature to first preview the input to the classifier before writing the labeling logic.
//
// :::
//
// Example of Rego module which also disables telemetry visibility of label:
// ```yaml
// rego:
//
//	labels:
//	  user:
//	    telemetry: false
//	module: |
//	  package user_from_cookie
//	  cookies := split(input.attributes.request.http.headers.cookie, "; ")
//	  user := user {
//	      cookie := cookies[_]
//	      startswith(cookie, "session=")
//	      session := substring(cookie, count("session="), -1)
//	      parts := split(session, ".")
//	      object := json.unmarshal(base64url.decode(parts[0]))
//	      user := object.user
//	  }
//
// ```
type Rego struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A map of {key, value} pairs mapping from
	// [flow label](/concepts/flow-label.md) keys to queries that define
	// how to extract and propagate flow labels with that key.
	// The name of the label maps to a variable in the Rego module. It maps to `data.<package>.<label>` variable.
	Labels map[string]*Rego_LabelProperties `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" validate:"required,gt=0,dive,keys,required,endkeys,required"` // @gotags: validate:"required,gt=0,dive,keys,required,endkeys,required"
	// Source code of the Rego module.
	//
	// :::note
	//
	// Must include a "package" declaration.
	//
	// :::
	Module string `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *Rego) Reset() {
	*x = Rego{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Rego) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rego) ProtoMessage() {}

func (x *Rego) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rego.ProtoReflect.Descriptor instead.
func (*Rego) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{15}
}

func (x *Rego) GetLabels() map[string]*Rego_LabelProperties {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Rego) GetModule() string {
	if x != nil {
		return x.Module
	}
	return ""
}

// Defines a high-level way to specify how to extract a flow label value given HTTP request metadata, without a need to write Rego code
//
// There are multiple variants of extractor, specify exactly one.
type Extractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Variant:
	//
	//	*Extractor_From
	//	*Extractor_Json
	//	*Extractor_Address
	//	*Extractor_Jwt
	//	*Extractor_PathTemplates
	Variant isExtractor_Variant `protobuf_oneof:"variant"`
}

func (x *Extractor) Reset() {
	*x = Extractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Extractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Extractor) ProtoMessage() {}

func (x *Extractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Extractor.ProtoReflect.Descriptor instead.
func (*Extractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{16}
}

func (m *Extractor) GetVariant() isExtractor_Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

func (x *Extractor) GetFrom() string {
	if x, ok := x.GetVariant().(*Extractor_From); ok {
		return x.From
	}
	return ""
}

func (x *Extractor) GetJson() *JSONExtractor {
	if x, ok := x.GetVariant().(*Extractor_Json); ok {
		return x.Json
	}
	return nil
}

func (x *Extractor) GetAddress() *AddressExtractor {
	if x, ok := x.GetVariant().(*Extractor_Address); ok {
		return x.Address
	}
	return nil
}

func (x *Extractor) GetJwt() *JWTExtractor {
	if x, ok := x.GetVariant().(*Extractor_Jwt); ok {
		return x.Jwt
	}
	return nil
}

func (x *Extractor) GetPathTemplates() *PathTemplateMatcher {
	if x, ok := x.GetVariant().(*Extractor_PathTemplates); ok {
		return x.PathTemplates
	}
	return nil
}

type isExtractor_Variant interface {
	isExtractor_Variant()
}

type Extractor_From struct {
	// Use an attribute with no conversion
	//
	// Attribute path is a dot-separated path to attribute.
	//
	// Should be either:
	// * one of the fields of [Attribute Context](https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/attribute_context.proto), or
	// * a special `request.http.bearer` pseudo-attribute.
	// For example, `request.http.method` or `request.http.header.user-agent`
	//
	// Note: The same attribute path syntax is shared by other extractor variants,
	// wherever attribute path is needed in their "from" syntax.
	//
	// Example:
	// ```yaml
	// from: request.http.headers.user-agent
	// ```
	From string `protobuf:"bytes,1,opt,name=from,proto3,oneof"`
}

type Extractor_Json struct {
	// Parse JSON, and extract one of the fields.
	Json *JSONExtractor `protobuf:"bytes,2,opt,name=json,proto3,oneof"`
}

type Extractor_Address struct {
	// Display an address as a single string - `<ip>:<port>`.
	Address *AddressExtractor `protobuf:"bytes,3,opt,name=address,proto3,oneof"`
}

type Extractor_Jwt struct {
	// Parse the attribute as JWT and read the payload.
	Jwt *JWTExtractor `protobuf:"bytes,4,opt,name=jwt,proto3,oneof"`
}

type Extractor_PathTemplates struct {
	// Match HTTP Path to given path templates.
	PathTemplates *PathTemplateMatcher `protobuf:"bytes,5,opt,name=path_templates,json=pathTemplates,proto3,oneof"`
}

func (*Extractor_From) isExtractor_Variant() {}

func (*Extractor_Json) isExtractor_Variant() {}

func (*Extractor_Address) isExtractor_Variant() {}

func (*Extractor_Jwt) isExtractor_Variant() {}

func (*Extractor_PathTemplates) isExtractor_Variant() {}

// Parse JSON, and extract one of the fields
//
// Example:
// ```yaml
// from: request.http.body
// pointer: /user/name
// ```
type JSONExtractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Attribute path pointing to some strings - for example, `request.http.body`.
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" validate:"required"` //@gotags: validate:"required"
	// JSON pointer represents a parsed JSON pointer which allows to select a specified field from the payload.
	//
	// Note: Uses [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,
	// for example, `/foo/bar`. If the pointer points into an object, it'd be converted to a string.
	Pointer string `protobuf:"bytes,2,opt,name=pointer,proto3" json:"pointer,omitempty"`
}

func (x *JSONExtractor) Reset() {
	*x = JSONExtractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *JSONExtractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JSONExtractor) ProtoMessage() {}

func (x *JSONExtractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JSONExtractor.ProtoReflect.Descriptor instead.
func (*JSONExtractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{17}
}

func (x *JSONExtractor) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *JSONExtractor) GetPointer() string {
	if x != nil {
		return x.Pointer
	}
	return ""
}

// Display an [Address][ext-authz-address] as a single string, for example, `<ip>:<port>`
//
// IP addresses in attribute context are defined as objects with separate IP and port fields.
// This is a helper to display an address as a single string.
//
// :::caution
//
// This might introduce high-cardinality flow label values.
//
// :::
//
// Example:
// ```yaml
// from: "source.address # or destination.address"
// ```
//
// [ext-authz-address]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address
type AddressExtractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Attribute path pointing to some string - for example, `source.address`.
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" validate:"required"` //@gotags: validate:"required"
}

func (x *AddressExtractor) Reset() {
	*x = AddressExtractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddressExtractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddressExtractor) ProtoMessage() {}

func (x *AddressExtractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddressExtractor.ProtoReflect.Descriptor instead.
func (*AddressExtractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{18}
}

func (x *AddressExtractor) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

// Parse the attribute as JWT and read the payload
//
// Specify a field to be extracted from payload using `json_pointer`.
//
// Note: The signature is not verified against the secret (assuming there's some
// other part of the system that handles such verification).
//
// Example:
// ```yaml
// from: request.http.bearer
// json_pointer: /user/email
// ```
type JWTExtractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// JWT (JSON Web Token) can be extracted from any input attribute, but most likely you'd want to use `request.http.bearer`.
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" validate:"required"` //@gotags: validate:"required"
	// JSON pointer allowing to select a specified field from the payload.
	//
	// Note: Uses [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,
	// for example, `/foo/bar`. If the pointer points into an object, it'd be converted to a string.
	JsonPointer string `protobuf:"bytes,2,opt,name=json_pointer,json=jsonPointer,proto3" json:"json_pointer,omitempty"`
}

func (x *JWTExtractor) Reset() {
	*x = JWTExtractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *JWTExtractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JWTExtractor) ProtoMessage() {}

func (x *JWTExtractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JWTExtractor.ProtoReflect.Descriptor instead.
func (*JWTExtractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{19}
}

func (x *JWTExtractor) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *JWTExtractor) GetJsonPointer() string {
	if x != nil {
		return x.JsonPointer
	}
	return ""
}

// Matches HTTP Path to given path templates
//
// HTTP path will be matched against given path templates.
// If a match occurs, the value associated with the path template will be treated as a result.
// In case of multiple path templates matching, the most specific one will be chosen.
type PathTemplateMatcher struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Template value keys are OpenAPI-inspired path templates.
	//
	//   - Static path segment `/foo` matches a path segment exactly
	//   - `/{param}` matches arbitrary path segment.
	//     (The parameter name is ignored and can be omitted (`{}`))
	//   - The parameter must cover whole segment.
	//   - Additionally, path template can end with `/*` wildcard to match
	//     arbitrary number of trailing segments (0 or more).
	//   - Multiple consecutive `/` are ignored, as well as trailing `/`.
	//   - Parametrized path segments must come after static segments.
	//   - `*`, if present, must come last.
	//   - Most specific template "wins" (`/foo` over `/{}` and `/{}` over `/*`).
	//
	// See also <https://swagger.io/specification/#path-templating-matching>
	//
	// Example:
	// ```yaml
	// /register: register
	// "/user/{userId}": user
	// /static/*: other
	// ```
	TemplateValues map[string]string `protobuf:"bytes,1,rep,name=template_values,json=templateValues,proto3" json:"template_values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" validate:"gt=0,dive,keys,required,endkeys,required"` // @gotags: validate:"gt=0,dive,keys,required,endkeys,required"
}

func (x *PathTemplateMatcher) Reset() {
	*x = PathTemplateMatcher{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PathTemplateMatcher) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PathTemplateMatcher) ProtoMessage() {}

func (x *PathTemplateMatcher) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PathTemplateMatcher.ProtoReflect.Descriptor instead.
func (*PathTemplateMatcher) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{20}
}

func (x *PathTemplateMatcher) GetTemplateValues() map[string]string {
	if x != nil {
		return x.TemplateValues
	}
	return nil
}

// Selects flows based on control point, flow labels, agent group and the service
// that the flow control component
// will operate on.
//
// :::info
//
// See also [Selector overview](/concepts/selector.md).
//
// :::
//
// Example:
// ```yaml
// control_point: ingress
// label_matcher:
//
//	match_labels:
//	  user_tier: gold
//	match_expressions:
//	  - key: query
//	    operator: In
//	    values:
//	      - insert
//	      - delete
//	expression:
//	  label_matches:
//	      - label: user_agent
//	        regex: ^(?!.*Chrome).*Safari
//
// ```
type Selector struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// [Control Point](/concepts/control-point.md)
	// identifies location within services where policies can act on flows.
	// For an SDK based insertion,
	// a _Control Point_ can represent a particular feature or execution
	// block within a service. In case of service mesh or middleware insertion, a
	// _Control Point_ can identify ingress or egress calls or distinct listeners
	// or filter chains.
	ControlPoint string `protobuf:"bytes,1,opt,name=control_point,json=controlPoint,proto3" json:"control_point,omitempty" validate:"required"` // @gotags: validate:"required"
	// [_Agent Group_](/concepts/selector.md#agent-group) this
	// selector applies to.
	//
	// :::info
	//
	// Agent Groups are used to scope policies to a subset of agents connected to the same controller.
	// The agents within an agent group receive exact same policy configuration and
	// form a peer to peer cluster to constantly share state.
	//
	// :::
	AgentGroup string `protobuf:"bytes,2,opt,name=agent_group,json=agentGroup,proto3" json:"agent_group,omitempty" default:"aperture-cloud"` // @gotags: default:"aperture-cloud"
	// The Fully Qualified Domain Name of the
	// [service](/concepts/selector.md) to select.
	//
	// In Kubernetes, this is the FQDN of the Service object.
	//
	// :::info
	//
	// `any` matches all services.
	//
	// :::
	//
	// :::info
	//
	// An entity (for example, Kubernetes pod) might belong to multiple services.
	//
	// :::
	Service string `protobuf:"bytes,3,opt,name=service,proto3" json:"service,omitempty" default:"any"` // @gotags: default:"any"
	// [Label Matcher](/concepts/selector.md#label-matcher)
	// can be used to match flows based on flow labels.
	LabelMatcher *LabelMatcher `protobuf:"bytes,4,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty"`
}

func (x *Selector) Reset() {
	*x = Selector{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Selector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Selector) ProtoMessage() {}

func (x *Selector) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Selector.ProtoReflect.Descriptor instead.
func (*Selector) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{21}
}

func (x *Selector) GetControlPoint() string {
	if x != nil {
		return x.ControlPoint
	}
	return ""
}

func (x *Selector) GetAgentGroup() string {
	if x != nil {
		return x.AgentGroup
	}
	return ""
}

func (x *Selector) GetService() string {
	if x != nil {
		return x.Service
	}
	return ""
}

func (x *Selector) GetLabelMatcher() *LabelMatcher {
	if x != nil {
		return x.LabelMatcher
	}
	return nil
}

type RateLimiter_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Specifies which label the rate limiter should be keyed by.
	//
	// Rate limiting is done independently for each value of the
	// [label](/concepts/flow-label.md) with given key.
	// For example, to give each user a separate limit, assuming you
	// have a _user_ flow
	// label set up, set `label_key: "user"`.
	// If no label key is specified, then all requests matching the
	// selectors will be rate limited based on the global bucket.
	LabelKey string `protobuf:"bytes,1,opt,name=label_key,json=labelKey,proto3" json:"label_key,omitempty"`
	// Interval defines the time interval in which the token bucket
	// will fill tokens specified by `fill_amount` signal.
	// This field employs the [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json) JSON representation from Protocol Buffers. The format accommodates fractional seconds up to nine digits after the decimal point, offering nanosecond precision. Every duration value must be suffixed with an "s" to indicate 'seconds.' For example, a value of "10s" would signify a duration of 10 seconds.
	Interval *durationpb.Duration `protobuf:"bytes,3,opt,name=interval,proto3" json:"interval,omitempty" validate:"required"` // @gotags: validate:"required"
	// Continuous fill determines whether the token bucket should be filled
	// continuously or only on discrete intervals.
	ContinuousFill bool `protobuf:"varint,4,opt,name=continuous_fill,json=continuousFill,proto3" json:"continuous_fill,omitempty" default:"true"` // @gotags: default:"true"
	// Max idle time before token bucket state for a label is removed.
	// If set to 0, the state is never removed.
	// This field employs the [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json) JSON representation from Protocol Buffers. The format accommodates fractional seconds up to nine digits after the decimal point, offering nanosecond precision. Every duration value must be suffixed with an "s" to indicate 'seconds.' For example, a value of "10s" would signify a duration of 10 seconds.
	MaxIdleTime *durationpb.Duration `protobuf:"bytes,5,opt,name=max_idle_time,json=maxIdleTime,proto3" json:"max_idle_time,omitempty" default:"7200s"` // @gotags: default:"7200s"
	// Configuration of lazy-syncing behavior of rate limiter
	LazySync *RateLimiter_Parameters_LazySync `protobuf:"bytes,6,opt,name=lazy_sync,json=lazySync,proto3" json:"lazy_sync,omitempty"`
	// Delays the initial filling of the token bucket.
	// If set to false, the token bucket will start filling immediately
	// after the first request is received. This can potentially lead to
	// more requests being accepted than the specified rate limit during
	// the first interval.
	// When set to true, the token bucket will be given a chance to
	// empty out before the filling starts. The delay is equal to the
	// time it takes to fill the bucket.
	DelayInitialFill bool `protobuf:"varint,7,opt,name=delay_initial_fill,json=delayInitialFill,proto3" json:"delay_initial_fill,omitempty" default:"false"` // @gotags: default:"false"
}

func (x *RateLimiter_Parameters) Reset() {
	*x = RateLimiter_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_Parameters) ProtoMessage() {}

func (x *RateLimiter_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_Parameters.ProtoReflect.Descriptor instead.
func (*RateLimiter_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{3, 0}
}

func (x *RateLimiter_Parameters) GetLabelKey() string {
	if x != nil {
		return x.LabelKey
	}
	return ""
}

func (x *RateLimiter_Parameters) GetInterval() *durationpb.Duration {
	if x != nil {
		return x.Interval
	}
	return nil
}

func (x *RateLimiter_Parameters) GetContinuousFill() bool {
	if x != nil {
		return x.ContinuousFill
	}
	return false
}

func (x *RateLimiter_Parameters) GetMaxIdleTime() *durationpb.Duration {
	if x != nil {
		return x.MaxIdleTime
	}
	return nil
}

func (x *RateLimiter_Parameters) GetLazySync() *RateLimiter_Parameters_LazySync {
	if x != nil {
		return x.LazySync
	}
	return nil
}

func (x *RateLimiter_Parameters) GetDelayInitialFill() bool {
	if x != nil {
		return x.DelayInitialFill
	}
	return false
}

type RateLimiter_RequestParameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Flow label key that will be used to override the number of tokens
	// for this request.
	// This is an optional parameter and takes highest precedence
	// when assigning tokens to a request.
	// The label value must be a valid number.
	TokensLabelKey string `protobuf:"bytes,1,opt,name=tokens_label_key,json=tokensLabelKey,proto3" json:"tokens_label_key,omitempty"`
	// This field allows you to override the default HTTP status code (`429 Too Many Requests`) that is returned when a request is denied.
	DeniedResponseStatusCode v1.StatusCode `protobuf:"varint,2,opt,name=denied_response_status_code,json=deniedResponseStatusCode,proto3,enum=aperture.flowcontrol.check.v1.StatusCode" json:"denied_response_status_code,omitempty"`
}

func (x *RateLimiter_RequestParameters) Reset() {
	*x = RateLimiter_RequestParameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_RequestParameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_RequestParameters) ProtoMessage() {}

func (x *RateLimiter_RequestParameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_RequestParameters.ProtoReflect.Descriptor instead.
func (*RateLimiter_RequestParameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{3, 1}
}

func (x *RateLimiter_RequestParameters) GetTokensLabelKey() string {
	if x != nil {
		return x.TokensLabelKey
	}
	return ""
}

func (x *RateLimiter_RequestParameters) GetDeniedResponseStatusCode() v1.StatusCode {
	if x != nil {
		return x.DeniedResponseStatusCode
	}
	return v1.StatusCode(0)
}

// Inputs for the RateLimiter component
type RateLimiter_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Capacity of the bucket to allow for bursty traffic.
	BucketCapacity *InPort `protobuf:"bytes,1,opt,name=bucket_capacity,json=bucketCapacity,proto3" json:"bucket_capacity,omitempty" validate:"required"` // @gotags: validate:"required"
	// Number of tokens to fill within an `interval`.
	FillAmount *InPort `protobuf:"bytes,2,opt,name=fill_amount,json=fillAmount,proto3" json:"fill_amount,omitempty" validate:"required"` // @gotags: validate:"required"
	// PassThrough port determines whether all requests
	PassThrough *InPort `protobuf:"bytes,3,opt,name=pass_through,json=passThrough,proto3" json:"pass_through,omitempty"`
}

func (x *RateLimiter_Ins) Reset() {
	*x = RateLimiter_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_Ins) ProtoMessage() {}

func (x *RateLimiter_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_Ins.ProtoReflect.Descriptor instead.
func (*RateLimiter_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{3, 2}
}

func (x *RateLimiter_Ins) GetBucketCapacity() *InPort {
	if x != nil {
		return x.BucketCapacity
	}
	return nil
}

func (x *RateLimiter_Ins) GetFillAmount() *InPort {
	if x != nil {
		return x.FillAmount
	}
	return nil
}

func (x *RateLimiter_Ins) GetPassThrough() *InPort {
	if x != nil {
		return x.PassThrough
	}
	return nil
}

type RateLimiter_Parameters_LazySync struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Enables lazy sync
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty" default:"false"` // @gotags: default:"false"
	// Number of times to lazy sync within the `interval`.
	NumSync uint32 `protobuf:"varint,2,opt,name=num_sync,json=numSync,proto3" json:"num_sync,omitempty" default:"4" validate:"gt=0"` // @gotags: default:"4" validate:"gt=0"
}

func (x *RateLimiter_Parameters_LazySync) Reset() {
	*x = RateLimiter_Parameters_LazySync{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_Parameters_LazySync) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_Parameters_LazySync) ProtoMessage() {}

func (x *RateLimiter_Parameters_LazySync) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_Parameters_LazySync.ProtoReflect.Descriptor instead.
func (*RateLimiter_Parameters_LazySync) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{3, 0, 0}
}

func (x *RateLimiter_Parameters_LazySync) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *RateLimiter_Parameters_LazySync) GetNumSync() uint32 {
	if x != nil {
		return x.NumSync
	}
	return 0
}

// Parameters for _Load Scheduler_ component
type LoadScheduler_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Automatically estimate the size of flows within each workload, based on
	// historical latency. Each workload's `tokens` will be set to average
	// latency of flows in that workload during the last few seconds (exact duration
	// of this average can change).
	// This setting is useful in concurrency limiting use-case, where the
	// concurrency is calculated as `(avg. latency \* in-flight flows)` (Little's Law).
	//
	// The value of tokens estimated takes a lower precedence
	// than the value of `tokens` specified in the workload definition
	// and `tokens` explicitly specified in the flow labels.
	WorkloadLatencyBasedTokens bool `protobuf:"varint,1,opt,name=workload_latency_based_tokens,json=workloadLatencyBasedTokens,proto3" json:"workload_latency_based_tokens,omitempty" default:"false"` // @gotags: default:"false"
	// Configuration of Weighted Fair Queuing-based workload scheduler.
	//
	// Contains configuration of per-agent scheduler
	Scheduler *Scheduler `protobuf:"bytes,2,opt,name=scheduler,proto3" json:"scheduler,omitempty"`
	// Selectors for the component.
	Selectors []*Selector `protobuf:"bytes,3,rep,name=selectors,proto3" json:"selectors,omitempty" validate:"required,gt=0,dive"` // @gotags: validate:"required,gt=0,dive"
}

func (x *LoadScheduler_Parameters) Reset() {
	*x = LoadScheduler_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadScheduler_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadScheduler_Parameters) ProtoMessage() {}

func (x *LoadScheduler_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadScheduler_Parameters.ProtoReflect.Descriptor instead.
func (*LoadScheduler_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{4, 0}
}

func (x *LoadScheduler_Parameters) GetWorkloadLatencyBasedTokens() bool {
	if x != nil {
		return x.WorkloadLatencyBasedTokens
	}
	return false
}

func (x *LoadScheduler_Parameters) GetScheduler() *Scheduler {
	if x != nil {
		return x.Scheduler
	}
	return nil
}

func (x *LoadScheduler_Parameters) GetSelectors() []*Selector {
	if x != nil {
		return x.Selectors
	}
	return nil
}

// Input for the LoadScheduler component.
type LoadScheduler_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Load multiplier is proportion of incoming
	// token rate that needs to be accepted. The signal gets updated once every 10 seconds.
	LoadMultiplier *InPort `protobuf:"bytes,1,opt,name=load_multiplier,json=loadMultiplier,proto3" json:"load_multiplier,omitempty"`
}

func (x *LoadScheduler_Ins) Reset() {
	*x = LoadScheduler_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadScheduler_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadScheduler_Ins) ProtoMessage() {}

func (x *LoadScheduler_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadScheduler_Ins.ProtoReflect.Descriptor instead.
func (*LoadScheduler_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{4, 1}
}

func (x *LoadScheduler_Ins) GetLoadMultiplier() *InPort {
	if x != nil {
		return x.LoadMultiplier
	}
	return nil
}

// Output for the LoadScheduler component.
type LoadScheduler_Outs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Observed load multiplier is the proportion of incoming token rate that is being accepted. The signal gets updated once every 10 seconds.
	ObservedLoadMultiplier *OutPort `protobuf:"bytes,1,opt,name=observed_load_multiplier,json=observedLoadMultiplier,proto3" json:"observed_load_multiplier,omitempty"`
}

func (x *LoadScheduler_Outs) Reset() {
	*x = LoadScheduler_Outs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadScheduler_Outs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadScheduler_Outs) ProtoMessage() {}

func (x *LoadScheduler_Outs) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadScheduler_Outs.ProtoReflect.Descriptor instead.
func (*LoadScheduler_Outs) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{4, 2}
}

func (x *LoadScheduler_Outs) GetObservedLoadMultiplier() *OutPort {
	if x != nil {
		return x.ObservedLoadMultiplier
	}
	return nil
}

// Workload defines a class of flows that preferably have similar properties such as response latency and desired priority.
type Scheduler_Workload struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Parameters associated with flows matching the label matcher.
	Parameters *Scheduler_Workload_Parameters `protobuf:"bytes,1,opt,name=parameters,proto3" json:"parameters,omitempty"`
	// Label Matcher to select a Workload based on
	// [flow labels](/concepts/flow-label.md).
	LabelMatcher *LabelMatcher `protobuf:"bytes,2,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty" validate:"required"` // @gotags: validate:"required"
	// Name of the workload.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *Scheduler_Workload) Reset() {
	*x = Scheduler_Workload{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[30]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler_Workload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler_Workload) ProtoMessage() {}

func (x *Scheduler_Workload) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[30]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler_Workload.ProtoReflect.Descriptor instead.
func (*Scheduler_Workload) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{5, 0}
}

func (x *Scheduler_Workload) GetParameters() *Scheduler_Workload_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *Scheduler_Workload) GetLabelMatcher() *LabelMatcher {
	if x != nil {
		return x.LabelMatcher
	}
	return nil
}

func (x *Scheduler_Workload) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// Parameters such as priority and tokens that are applicable to flows within a workload.
type Scheduler_Workload_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Describes priority level of the flows within the workload.
	// Priority level is unbounded and can be any positive number.
	// Higher numbers means higher priority level.
	// The following formula is used to determine the position of a flow in the queue based on virtual finish time:
	//
	// $$
	// inverted\_priority = {\frac {1} {priority}}
	// $$
	//
	// $$
	// virtual\_finish\_time = virtual\_time + \left(tokens \cdot inverted\_priority\right)
	// $$
	Priority float64 `protobuf:"fixed64,1,opt,name=priority,proto3" json:"priority,omitempty" validate:"gt=0" default:"1.0"` // @gotags: validate:"gt=0" default:"1.0"
	// Tokens determines the cost of admitting a single flow in the workload,
	// which is typically defined as milliseconds of flow latency (time to response or duration of a feature) or
	// simply equal to 1 if the resource being accessed is constrained by the
	// number of flows (3rd party rate limiters).
	// This override is applicable only if tokens for the flow aren't specified
	// in the flow labels.
	Tokens float64 `protobuf:"fixed64,4,opt,name=tokens,proto3" json:"tokens,omitempty" validate:"gte=0" default:"1"` // @gotags: validate:"gte=0" default:"1"
	// Timeout for the flow in the workload.
	// If timeout is provided on the Check call as well, the minimum of the two is picked.
	// If this override is not provided, the timeout provided in the check call is used.
	// 0 timeout value implies that the request will not wait in the queue and will be accepted or dropped immediately.
	// This field employs the [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json) JSON representation from Protocol Buffers. The format accommodates fractional seconds up to nine digits after the decimal point, offering nanosecond precision. Every duration value must be suffixed with an "s" to indicate 'seconds.' For example, a value of "10s" would signify a duration of 10 seconds.
	QueueTimeout *durationpb.Duration `protobuf:"bytes,3,opt,name=queue_timeout,json=queueTimeout,proto3" json:"queue_timeout,omitempty"`
}

func (x *Scheduler_Workload_Parameters) Reset() {
	*x = Scheduler_Workload_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[31]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler_Workload_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler_Workload_Parameters) ProtoMessage() {}

func (x *Scheduler_Workload_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[31]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler_Workload_Parameters.ProtoReflect.Descriptor instead.
func (*Scheduler_Workload_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{5, 0, 0}
}

func (x *Scheduler_Workload_Parameters) GetPriority() float64 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *Scheduler_Workload_Parameters) GetTokens() float64 {
	if x != nil {
		return x.Tokens
	}
	return 0
}

func (x *Scheduler_Workload_Parameters) GetQueueTimeout() *durationpb.Duration {
	if x != nil {
		return x.QueueTimeout
	}
	return nil
}

// Input ports for the _AIMD Load Scheduler_.
type AIMDLoadScheduler_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The input signal to the controller.
	Signal *InPort `protobuf:"bytes,1,opt,name=signal,proto3" json:"signal,omitempty" validate:"required"` // @gotags: validate:"required"
	// The setpoint input to the controller.
	Setpoint *InPort `protobuf:"bytes,2,opt,name=setpoint,proto3" json:"setpoint,omitempty" validate:"required"` // @gotags: validate:"required"
	// The `overload_confirmation` port provides additional criteria to determine overload state which
	// results in _Flow_ throttling at the service.
	OverloadConfirmation *InPort `protobuf:"bytes,3,opt,name=overload_confirmation,json=overloadConfirmation,proto3" json:"overload_confirmation,omitempty"`
}

func (x *AIMDLoadScheduler_Ins) Reset() {
	*x = AIMDLoadScheduler_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[32]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AIMDLoadScheduler_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AIMDLoadScheduler_Ins) ProtoMessage() {}

func (x *AIMDLoadScheduler_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[32]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AIMDLoadScheduler_Ins.ProtoReflect.Descriptor instead.
func (*AIMDLoadScheduler_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{6, 0}
}

func (x *AIMDLoadScheduler_Ins) GetSignal() *InPort {
	if x != nil {
		return x.Signal
	}
	return nil
}

func (x *AIMDLoadScheduler_Ins) GetSetpoint() *InPort {
	if x != nil {
		return x.Setpoint
	}
	return nil
}

func (x *AIMDLoadScheduler_Ins) GetOverloadConfirmation() *InPort {
	if x != nil {
		return x.OverloadConfirmation
	}
	return nil
}

// Output ports for the _AIMD Load Scheduler_.
type AIMDLoadScheduler_Outs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A Boolean signal that indicates whether the service is in overload state.
	IsOverload *OutPort `protobuf:"bytes,1,opt,name=is_overload,json=isOverload,proto3" json:"is_overload,omitempty"`
	// Desired Load multiplier is the ratio of desired token rate to the incoming token rate.
	DesiredLoadMultiplier *OutPort `protobuf:"bytes,2,opt,name=desired_load_multiplier,json=desiredLoadMultiplier,proto3" json:"desired_load_multiplier,omitempty"`
	// Observed Load multiplier is the ratio of accepted token rate to the incoming token rate.
	ObservedLoadMultiplier *OutPort `protobuf:"bytes,3,opt,name=observed_load_multiplier,json=observedLoadMultiplier,proto3" json:"observed_load_multiplier,omitempty"`
}

func (x *AIMDLoadScheduler_Outs) Reset() {
	*x = AIMDLoadScheduler_Outs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[33]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AIMDLoadScheduler_Outs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AIMDLoadScheduler_Outs) ProtoMessage() {}

func (x *AIMDLoadScheduler_Outs) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[33]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AIMDLoadScheduler_Outs.ProtoReflect.Descriptor instead.
func (*AIMDLoadScheduler_Outs) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{6, 1}
}

func (x *AIMDLoadScheduler_Outs) GetIsOverload() *OutPort {
	if x != nil {
		return x.IsOverload
	}
	return nil
}

func (x *AIMDLoadScheduler_Outs) GetDesiredLoadMultiplier() *OutPort {
	if x != nil {
		return x.DesiredLoadMultiplier
	}
	return nil
}

func (x *AIMDLoadScheduler_Outs) GetObservedLoadMultiplier() *OutPort {
	if x != nil {
		return x.ObservedLoadMultiplier
	}
	return nil
}

type AIMDLoadScheduler_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Parameters for the _Load Scheduler_.
	LoadScheduler *LoadScheduler_Parameters `protobuf:"bytes,1,opt,name=load_scheduler,json=loadScheduler,proto3" json:"load_scheduler,omitempty" validate:"required"` // @gotags: validate:"required"
	// Parameters for the Gradient Controller.
	Gradient *GradientController_Parameters `protobuf:"bytes,2,opt,name=gradient,proto3" json:"gradient,omitempty" validate:"required"` // @gotags: validate:"required"
	// The maximum load multiplier that can be reached during recovery from an overload state.
	// - Helps protect the service from request bursts while the system is still recovering.
	// - Once this value is reached, the scheduler enters the pass-through mode, allowing requests to bypass the scheduler and be sent directly to the service.
	// - The pass-through mode gets disabled if the system enters the overload state again.
	MaxLoadMultiplier float64 `protobuf:"fixed64,3,opt,name=max_load_multiplier,json=maxLoadMultiplier,proto3" json:"max_load_multiplier,omitempty" default:"2.0" validate:"gt=0"` // @gotags: default:"2.0" validate:"gt=0"
	// Linear increment to load multiplier every 10 seconds while the system is
	// not in the overloaded state, up until the `max_load_multiplier` is reached.
	LoadMultiplierLinearIncrement float64 `protobuf:"fixed64,4,opt,name=load_multiplier_linear_increment,json=loadMultiplierLinearIncrement,proto3" json:"load_multiplier_linear_increment,omitempty" default:"0.025" validate:"gte=0"` // @gotags: default:"0.025" validate:"gte=0"
	// Configuration parameters for the embedded Alerter.
	Alerter *Alerter_Parameters `protobuf:"bytes,5,opt,name=alerter,proto3" json:"alerter,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *AIMDLoadScheduler_Parameters) Reset() {
	*x = AIMDLoadScheduler_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[34]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AIMDLoadScheduler_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AIMDLoadScheduler_Parameters) ProtoMessage() {}

func (x *AIMDLoadScheduler_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[34]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AIMDLoadScheduler_Parameters.ProtoReflect.Descriptor instead.
func (*AIMDLoadScheduler_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{6, 2}
}

func (x *AIMDLoadScheduler_Parameters) GetLoadScheduler() *LoadScheduler_Parameters {
	if x != nil {
		return x.LoadScheduler
	}
	return nil
}

func (x *AIMDLoadScheduler_Parameters) GetGradient() *GradientController_Parameters {
	if x != nil {
		return x.Gradient
	}
	return nil
}

func (x *AIMDLoadScheduler_Parameters) GetMaxLoadMultiplier() float64 {
	if x != nil {
		return x.MaxLoadMultiplier
	}
	return 0
}

func (x *AIMDLoadScheduler_Parameters) GetLoadMultiplierLinearIncrement() float64 {
	if x != nil {
		return x.LoadMultiplierLinearIncrement
	}
	return 0
}

func (x *AIMDLoadScheduler_Parameters) GetAlerter() *Alerter_Parameters {
	if x != nil {
		return x.Alerter
	}
	return nil
}

// Input ports for the _Range Load Scheduler_.
type RangeDrivenLoadScheduler_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The input signal to the controller.
	Signal *InPort `protobuf:"bytes,1,opt,name=signal,proto3" json:"signal,omitempty" validate:"required"` // @gotags: validate:"required"
	// The `overload_confirmation` port provides additional criteria to determine overload state which
	// results in _Flow_ throttling at the service.
	OverloadConfirmation *InPort `protobuf:"bytes,3,opt,name=overload_confirmation,json=overloadConfirmation,proto3" json:"overload_confirmation,omitempty"`
}

func (x *RangeDrivenLoadScheduler_Ins) Reset() {
	*x = RangeDrivenLoadScheduler_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[35]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RangeDrivenLoadScheduler_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RangeDrivenLoadScheduler_Ins) ProtoMessage() {}

func (x *RangeDrivenLoadScheduler_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[35]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RangeDrivenLoadScheduler_Ins.ProtoReflect.Descriptor instead.
func (*RangeDrivenLoadScheduler_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{7, 0}
}

func (x *RangeDrivenLoadScheduler_Ins) GetSignal() *InPort {
	if x != nil {
		return x.Signal
	}
	return nil
}

func (x *RangeDrivenLoadScheduler_Ins) GetOverloadConfirmation() *InPort {
	if x != nil {
		return x.OverloadConfirmation
	}
	return nil
}

// Output ports for the _Range Load Scheduler_.
type RangeDrivenLoadScheduler_Outs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A Boolean signal that indicates whether the service is in overload state.
	IsOverload *OutPort `protobuf:"bytes,1,opt,name=is_overload,json=isOverload,proto3" json:"is_overload,omitempty"`
	// Desired Load multiplier is the ratio of desired token rate to the incoming token rate.
	DesiredLoadMultiplier *OutPort `protobuf:"bytes,2,opt,name=desired_load_multiplier,json=desiredLoadMultiplier,proto3" json:"desired_load_multiplier,omitempty"`
	// Observed Load multiplier is the ratio of accepted token rate to the incoming token rate.
	ObservedLoadMultiplier *OutPort `protobuf:"bytes,3,opt,name=observed_load_multiplier,json=observedLoadMultiplier,proto3" json:"observed_load_multiplier,omitempty"`
}

func (x *RangeDrivenLoadScheduler_Outs) Reset() {
	*x = RangeDrivenLoadScheduler_Outs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[36]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RangeDrivenLoadScheduler_Outs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RangeDrivenLoadScheduler_Outs) ProtoMessage() {}

func (x *RangeDrivenLoadScheduler_Outs) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[36]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RangeDrivenLoadScheduler_Outs.ProtoReflect.Descriptor instead.
func (*RangeDrivenLoadScheduler_Outs) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{7, 1}
}

func (x *RangeDrivenLoadScheduler_Outs) GetIsOverload() *OutPort {
	if x != nil {
		return x.IsOverload
	}
	return nil
}

func (x *RangeDrivenLoadScheduler_Outs) GetDesiredLoadMultiplier() *OutPort {
	if x != nil {
		return x.DesiredLoadMultiplier
	}
	return nil
}

func (x *RangeDrivenLoadScheduler_Outs) GetObservedLoadMultiplier() *OutPort {
	if x != nil {
		return x.ObservedLoadMultiplier
	}
	return nil
}

type RangeDrivenLoadScheduler_Datapoint struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SignalValue    float64 `protobuf:"fixed64,1,opt,name=signal_value,json=signalValue,proto3" json:"signal_value,omitempty"`
	LoadMultiplier float64 `protobuf:"fixed64,2,opt,name=load_multiplier,json=loadMultiplier,proto3" json:"load_multiplier,omitempty" validate:"gte=0,lte=1"` // @gotags: validate:"gte=0,lte=1"
}

func (x *RangeDrivenLoadScheduler_Datapoint) Reset() {
	*x = RangeDrivenLoadScheduler_Datapoint{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[37]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RangeDrivenLoadScheduler_Datapoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RangeDrivenLoadScheduler_Datapoint) ProtoMessage() {}

func (x *RangeDrivenLoadScheduler_Datapoint) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[37]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RangeDrivenLoadScheduler_Datapoint.ProtoReflect.Descriptor instead.
func (*RangeDrivenLoadScheduler_Datapoint) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{7, 2}
}

func (x *RangeDrivenLoadScheduler_Datapoint) GetSignalValue() float64 {
	if x != nil {
		return x.SignalValue
	}
	return 0
}

func (x *RangeDrivenLoadScheduler_Datapoint) GetLoadMultiplier() float64 {
	if x != nil {
		return x.LoadMultiplier
	}
	return 0
}

type RangeDrivenLoadScheduler_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Parameters for the _Load Scheduler_.
	LoadScheduler *LoadScheduler_Parameters `protobuf:"bytes,1,opt,name=load_scheduler,json=loadScheduler,proto3" json:"load_scheduler,omitempty" validate:"required"` // @gotags: validate:"required"
	// Starting data-point of the throttling range
	LowThrottleThreshold *RangeDrivenLoadScheduler_Datapoint `protobuf:"bytes,2,opt,name=low_throttle_threshold,json=lowThrottleThreshold,proto3" json:"low_throttle_threshold,omitempty" validate:"required"` // @gotags: validate:"required"
	// Ending data-point of the throttling range
	HighThrottleThreshold *RangeDrivenLoadScheduler_Datapoint `protobuf:"bytes,3,opt,name=high_throttle_threshold,json=highThrottleThreshold,proto3" json:"high_throttle_threshold,omitempty" validate:"required"` // @gotags: validate:"required"
	// Degree determines shape of the throttling curve.
	// degree=1: linear
	// degree=2: quadratic
	// degree=3: cubic
	Degree float64 `protobuf:"fixed64,4,opt,name=degree,proto3" json:"degree,omitempty" validate:"required"` // @gotags: validate:"required"
	// Configuration parameters for the embedded Alerter.
	Alerter *Alerter_Parameters `protobuf:"bytes,5,opt,name=alerter,proto3" json:"alerter,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *RangeDrivenLoadScheduler_Parameters) Reset() {
	*x = RangeDrivenLoadScheduler_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[38]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RangeDrivenLoadScheduler_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RangeDrivenLoadScheduler_Parameters) ProtoMessage() {}

func (x *RangeDrivenLoadScheduler_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[38]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RangeDrivenLoadScheduler_Parameters.ProtoReflect.Descriptor instead.
func (*RangeDrivenLoadScheduler_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{7, 3}
}

func (x *RangeDrivenLoadScheduler_Parameters) GetLoadScheduler() *LoadScheduler_Parameters {
	if x != nil {
		return x.LoadScheduler
	}
	return nil
}

func (x *RangeDrivenLoadScheduler_Parameters) GetLowThrottleThreshold() *RangeDrivenLoadScheduler_Datapoint {
	if x != nil {
		return x.LowThrottleThreshold
	}
	return nil
}

func (x *RangeDrivenLoadScheduler_Parameters) GetHighThrottleThreshold() *RangeDrivenLoadScheduler_Datapoint {
	if x != nil {
		return x.HighThrottleThreshold
	}
	return nil
}

func (x *RangeDrivenLoadScheduler_Parameters) GetDegree() float64 {
	if x != nil {
		return x.Degree
	}
	return 0
}

func (x *RangeDrivenLoadScheduler_Parameters) GetAlerter() *Alerter_Parameters {
	if x != nil {
		return x.Alerter
	}
	return nil
}

// Input ports for the _AIAD Load Scheduler_.
type AIADLoadScheduler_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The input signal to the controller.
	Signal *InPort `protobuf:"bytes,1,opt,name=signal,proto3" json:"signal,omitempty" validate:"required"` // @gotags: validate:"required"
	// The setpoint input to the controller.
	Setpoint *InPort `protobuf:"bytes,2,opt,name=setpoint,proto3" json:"setpoint,omitempty" validate:"required"` // @gotags: validate:"required"
	// The `overload_confirmation` port provides additional criteria to determine overload state which
	// results in _Flow_ throttling at the service.
	OverloadConfirmation *InPort `protobuf:"bytes,3,opt,name=overload_confirmation,json=overloadConfirmation,proto3" json:"overload_confirmation,omitempty"`
}

func (x *AIADLoadScheduler_Ins) Reset() {
	*x = AIADLoadScheduler_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[39]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AIADLoadScheduler_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AIADLoadScheduler_Ins) ProtoMessage() {}

func (x *AIADLoadScheduler_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[39]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AIADLoadScheduler_Ins.ProtoReflect.Descriptor instead.
func (*AIADLoadScheduler_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{8, 0}
}

func (x *AIADLoadScheduler_Ins) GetSignal() *InPort {
	if x != nil {
		return x.Signal
	}
	return nil
}

func (x *AIADLoadScheduler_Ins) GetSetpoint() *InPort {
	if x != nil {
		return x.Setpoint
	}
	return nil
}

func (x *AIADLoadScheduler_Ins) GetOverloadConfirmation() *InPort {
	if x != nil {
		return x.OverloadConfirmation
	}
	return nil
}

// Output ports for the _AIAD Load Scheduler_.
type AIADLoadScheduler_Outs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A Boolean signal that indicates whether the service is in overload state.
	IsOverload *OutPort `protobuf:"bytes,1,opt,name=is_overload,json=isOverload,proto3" json:"is_overload,omitempty"`
	// Desired Load multiplier is the ratio of desired token rate to the incoming token rate.
	DesiredLoadMultiplier *OutPort `protobuf:"bytes,2,opt,name=desired_load_multiplier,json=desiredLoadMultiplier,proto3" json:"desired_load_multiplier,omitempty"`
	// Observed Load multiplier is the ratio of accepted token rate to the incoming token rate.
	ObservedLoadMultiplier *OutPort `protobuf:"bytes,3,opt,name=observed_load_multiplier,json=observedLoadMultiplier,proto3" json:"observed_load_multiplier,omitempty"`
}

func (x *AIADLoadScheduler_Outs) Reset() {
	*x = AIADLoadScheduler_Outs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[40]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AIADLoadScheduler_Outs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AIADLoadScheduler_Outs) ProtoMessage() {}

func (x *AIADLoadScheduler_Outs) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[40]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AIADLoadScheduler_Outs.ProtoReflect.Descriptor instead.
func (*AIADLoadScheduler_Outs) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{8, 1}
}

func (x *AIADLoadScheduler_Outs) GetIsOverload() *OutPort {
	if x != nil {
		return x.IsOverload
	}
	return nil
}

func (x *AIADLoadScheduler_Outs) GetDesiredLoadMultiplier() *OutPort {
	if x != nil {
		return x.DesiredLoadMultiplier
	}
	return nil
}

func (x *AIADLoadScheduler_Outs) GetObservedLoadMultiplier() *OutPort {
	if x != nil {
		return x.ObservedLoadMultiplier
	}
	return nil
}

type AIADLoadScheduler_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Parameters for the _Load Scheduler_.
	LoadScheduler *LoadScheduler_Parameters `protobuf:"bytes,1,opt,name=load_scheduler,json=loadScheduler,proto3" json:"load_scheduler,omitempty" validate:"required"` // @gotags: validate:"required"
	// The minimum load multiplier that can be reached during an overload state.
	MinLoadMultiplier float64 `protobuf:"fixed64,2,opt,name=min_load_multiplier,json=minLoadMultiplier,proto3" json:"min_load_multiplier,omitempty" default:"0.0" validate:"gte=0"` // @gotags: default:"0.0" validate:"gte=0"
	// Linear decrement to load multiplier every 10 seconds while the system is
	// in the overloaded state, up until the `min_load_multiplier` is reached.
	LoadMultiplierLinearDecrement float64 `protobuf:"fixed64,3,opt,name=load_multiplier_linear_decrement,json=loadMultiplierLinearDecrement,proto3" json:"load_multiplier_linear_decrement,omitempty" default:"0.05" validate:"gte=0"` // @gotags: default:"0.05" validate:"gte=0"
	// The maximum load multiplier that can be reached during recovery from an overload state.
	// - Helps protect the service from request bursts while the system is still recovering.
	// - Once this value is reached, the scheduler enters the pass-through mode, allowing requests to bypass the scheduler and be sent directly to the service.
	// - The pass-through mode gets disabled if the system enters the overload state again.
	MaxLoadMultiplier float64 `protobuf:"fixed64,4,opt,name=max_load_multiplier,json=maxLoadMultiplier,proto3" json:"max_load_multiplier,omitempty" default:"2.0" validate:"gte=0"` // @gotags: default:"2.0" validate:"gte=0"
	// Linear increment to load multiplier every 10 seconds while the system is
	// not in the overloaded state, up until the `max_load_multiplier` is reached.
	LoadMultiplierLinearIncrement float64 `protobuf:"fixed64,5,opt,name=load_multiplier_linear_increment,json=loadMultiplierLinearIncrement,proto3" json:"load_multiplier_linear_increment,omitempty" default:"0.025" validate:"gte=0"` // @gotags: default:"0.025" validate:"gte=0"
	// Configuration parameters for the embedded Alerter.
	Alerter *Alerter_Parameters `protobuf:"bytes,7,opt,name=alerter,proto3" json:"alerter,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *AIADLoadScheduler_Parameters) Reset() {
	*x = AIADLoadScheduler_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[41]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AIADLoadScheduler_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AIADLoadScheduler_Parameters) ProtoMessage() {}

func (x *AIADLoadScheduler_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[41]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AIADLoadScheduler_Parameters.ProtoReflect.Descriptor instead.
func (*AIADLoadScheduler_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{8, 2}
}

func (x *AIADLoadScheduler_Parameters) GetLoadScheduler() *LoadScheduler_Parameters {
	if x != nil {
		return x.LoadScheduler
	}
	return nil
}

func (x *AIADLoadScheduler_Parameters) GetMinLoadMultiplier() float64 {
	if x != nil {
		return x.MinLoadMultiplier
	}
	return 0
}

func (x *AIADLoadScheduler_Parameters) GetLoadMultiplierLinearDecrement() float64 {
	if x != nil {
		return x.LoadMultiplierLinearDecrement
	}
	return 0
}

func (x *AIADLoadScheduler_Parameters) GetMaxLoadMultiplier() float64 {
	if x != nil {
		return x.MaxLoadMultiplier
	}
	return 0
}

func (x *AIADLoadScheduler_Parameters) GetLoadMultiplierLinearIncrement() float64 {
	if x != nil {
		return x.LoadMultiplierLinearIncrement
	}
	return 0
}

func (x *AIADLoadScheduler_Parameters) GetAlerter() *Alerter_Parameters {
	if x != nil {
		return x.Alerter
	}
	return nil
}

// Parameters for the _Adaptive Load Scheduler_ component.
type AdaptiveLoadScheduler_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Parameters for the _Load Scheduler_.
	LoadScheduler *LoadScheduler_Parameters `protobuf:"bytes,1,opt,name=load_scheduler,json=loadScheduler,proto3" json:"load_scheduler,omitempty" validate:"required"` // @gotags: validate:"required"
	// Parameters for the _Gradient Controller_.
	Gradient *GradientController_Parameters `protobuf:"bytes,2,opt,name=gradient,proto3" json:"gradient,omitempty" validate:"required"` // @gotags: validate:"required"
	// The maximum load multiplier that can be reached during recovery from an overload state.
	// - Helps protect the service from request bursts while the system is still recovering.
	// - Once this value is reached, the scheduler enters the pass-through mode, allowing requests to bypass the scheduler and be sent directly to the service.
	// - The pass-through mode gets disabled if the system enters the overload state again.
	MaxLoadMultiplier float64 `protobuf:"fixed64,3,opt,name=max_load_multiplier,json=maxLoadMultiplier,proto3" json:"max_load_multiplier,omitempty" default:"2.0"` // @gotags: default:"2.0"
	// Linear increment to load multiplier every 10 seconds while the system is
	// not in the overloaded state, up until the `max_load_multiplier` is reached.
	LoadMultiplierLinearIncrement float64 `protobuf:"fixed64,4,opt,name=load_multiplier_linear_increment,json=loadMultiplierLinearIncrement,proto3" json:"load_multiplier_linear_increment,omitempty" default:"0.0025"` // @gotags: default:"0.0025"
	// Configuration parameters for the embedded Alerter.
	Alerter *Alerter_Parameters `protobuf:"bytes,5,opt,name=alerter,proto3" json:"alerter,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *AdaptiveLoadScheduler_Parameters) Reset() {
	*x = AdaptiveLoadScheduler_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[42]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AdaptiveLoadScheduler_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdaptiveLoadScheduler_Parameters) ProtoMessage() {}

func (x *AdaptiveLoadScheduler_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[42]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdaptiveLoadScheduler_Parameters.ProtoReflect.Descriptor instead.
func (*AdaptiveLoadScheduler_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{9, 0}
}

func (x *AdaptiveLoadScheduler_Parameters) GetLoadScheduler() *LoadScheduler_Parameters {
	if x != nil {
		return x.LoadScheduler
	}
	return nil
}

func (x *AdaptiveLoadScheduler_Parameters) GetGradient() *GradientController_Parameters {
	if x != nil {
		return x.Gradient
	}
	return nil
}

func (x *AdaptiveLoadScheduler_Parameters) GetMaxLoadMultiplier() float64 {
	if x != nil {
		return x.MaxLoadMultiplier
	}
	return 0
}

func (x *AdaptiveLoadScheduler_Parameters) GetLoadMultiplierLinearIncrement() float64 {
	if x != nil {
		return x.LoadMultiplierLinearIncrement
	}
	return 0
}

func (x *AdaptiveLoadScheduler_Parameters) GetAlerter() *Alerter_Parameters {
	if x != nil {
		return x.Alerter
	}
	return nil
}

// Input ports for the _Adaptive Load Scheduler_ component.
type AdaptiveLoadScheduler_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The input signal to the controller.
	Signal *InPort `protobuf:"bytes,1,opt,name=signal,proto3" json:"signal,omitempty" validate:"required"` // @gotags: validate:"required"
	// The setpoint input to the controller.
	Setpoint *InPort `protobuf:"bytes,2,opt,name=setpoint,proto3" json:"setpoint,omitempty" validate:"required"` // @gotags: validate:"required"
	// The `overload_confirmation` port provides additional criteria to determine overload state which
	// results in _Flow_ throttling at the service.
	OverloadConfirmation *InPort `protobuf:"bytes,3,opt,name=overload_confirmation,json=overloadConfirmation,proto3" json:"overload_confirmation,omitempty"`
}

func (x *AdaptiveLoadScheduler_Ins) Reset() {
	*x = AdaptiveLoadScheduler_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[43]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AdaptiveLoadScheduler_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdaptiveLoadScheduler_Ins) ProtoMessage() {}

func (x *AdaptiveLoadScheduler_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[43]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdaptiveLoadScheduler_Ins.ProtoReflect.Descriptor instead.
func (*AdaptiveLoadScheduler_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{9, 1}
}

func (x *AdaptiveLoadScheduler_Ins) GetSignal() *InPort {
	if x != nil {
		return x.Signal
	}
	return nil
}

func (x *AdaptiveLoadScheduler_Ins) GetSetpoint() *InPort {
	if x != nil {
		return x.Setpoint
	}
	return nil
}

func (x *AdaptiveLoadScheduler_Ins) GetOverloadConfirmation() *InPort {
	if x != nil {
		return x.OverloadConfirmation
	}
	return nil
}

// Output ports for the _Adaptive Load Scheduler_ component.
type AdaptiveLoadScheduler_Outs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A Boolean signal that indicates whether the service is in overload state.
	IsOverload *OutPort `protobuf:"bytes,1,opt,name=is_overload,json=isOverload,proto3" json:"is_overload,omitempty"`
	// Desired Load multiplier is the ratio of desired token rate to the incoming token rate.
	DesiredLoadMultiplier *OutPort `protobuf:"bytes,2,opt,name=desired_load_multiplier,json=desiredLoadMultiplier,proto3" json:"desired_load_multiplier,omitempty"`
	// Observed Load multiplier is the ratio of accepted token rate to the incoming token rate.
	ObservedLoadMultiplier *OutPort `protobuf:"bytes,3,opt,name=observed_load_multiplier,json=observedLoadMultiplier,proto3" json:"observed_load_multiplier,omitempty"`
}

func (x *AdaptiveLoadScheduler_Outs) Reset() {
	*x = AdaptiveLoadScheduler_Outs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[44]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AdaptiveLoadScheduler_Outs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdaptiveLoadScheduler_Outs) ProtoMessage() {}

func (x *AdaptiveLoadScheduler_Outs) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[44]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdaptiveLoadScheduler_Outs.ProtoReflect.Descriptor instead.
func (*AdaptiveLoadScheduler_Outs) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{9, 2}
}

func (x *AdaptiveLoadScheduler_Outs) GetIsOverload() *OutPort {
	if x != nil {
		return x.IsOverload
	}
	return nil
}

func (x *AdaptiveLoadScheduler_Outs) GetDesiredLoadMultiplier() *OutPort {
	if x != nil {
		return x.DesiredLoadMultiplier
	}
	return nil
}

func (x *AdaptiveLoadScheduler_Outs) GetObservedLoadMultiplier() *OutPort {
	if x != nil {
		return x.ObservedLoadMultiplier
	}
	return nil
}

type Sampler_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The flow label key for identifying sessions.
	//   - When label key is specified, _Sampler_ acts as a sticky filter.
	//     The series of flows with the same value of label key get the same
	//     decision provided that the `accept_percentage` is same or higher.
	//   - When label key is not specified, _Sampler_ acts as a stateless filter.
	//     Percentage of flows are selected randomly for rejection.
	LabelKey string `protobuf:"bytes,2,opt,name=label_key,json=labelKey,proto3" json:"label_key,omitempty"`
	// Selectors for the component.
	Selectors []*Selector `protobuf:"bytes,3,rep,name=selectors,proto3" json:"selectors,omitempty" validate:"required,gt=0,dive"` // @gotags: validate:"required,gt=0,dive"
	// This field allows you to override the default HTTP status code (`503 Service Unavailable`) that is returned when a request is denied.
	DeniedResponseStatusCode v1.StatusCode `protobuf:"varint,4,opt,name=denied_response_status_code,json=deniedResponseStatusCode,proto3,enum=aperture.flowcontrol.check.v1.StatusCode" json:"denied_response_status_code,omitempty"`
	// Ramp component can accept flows with `ramp_mode` flag set.
	RampMode bool `protobuf:"varint,5,opt,name=ramp_mode,json=rampMode,proto3" json:"ramp_mode,omitempty" default:"false"` // @gotags: default:"false"
}

func (x *Sampler_Parameters) Reset() {
	*x = Sampler_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[45]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Sampler_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Sampler_Parameters) ProtoMessage() {}

func (x *Sampler_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[45]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Sampler_Parameters.ProtoReflect.Descriptor instead.
func (*Sampler_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{10, 0}
}

func (x *Sampler_Parameters) GetLabelKey() string {
	if x != nil {
		return x.LabelKey
	}
	return ""
}

func (x *Sampler_Parameters) GetSelectors() []*Selector {
	if x != nil {
		return x.Selectors
	}
	return nil
}

func (x *Sampler_Parameters) GetDeniedResponseStatusCode() v1.StatusCode {
	if x != nil {
		return x.DeniedResponseStatusCode
	}
	return v1.StatusCode(0)
}

func (x *Sampler_Parameters) GetRampMode() bool {
	if x != nil {
		return x.RampMode
	}
	return false
}

type Sampler_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The percentage of requests to accept.
	AcceptPercentage *InPort `protobuf:"bytes,1,opt,name=accept_percentage,json=acceptPercentage,proto3" json:"accept_percentage,omitempty"`
}

func (x *Sampler_Ins) Reset() {
	*x = Sampler_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[46]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Sampler_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Sampler_Ins) ProtoMessage() {}

func (x *Sampler_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[46]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Sampler_Ins.ProtoReflect.Descriptor instead.
func (*Sampler_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{10, 1}
}

func (x *Sampler_Ins) GetAcceptPercentage() *InPort {
	if x != nil {
		return x.AcceptPercentage
	}
	return nil
}

// Parameters for the _Load Ramp_ component.
type LoadRamp_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Parameters for the _Sampler_.
	Sampler *Sampler_Parameters         `protobuf:"bytes,1,opt,name=sampler,proto3" json:"sampler,omitempty" validate:"required"` // @gotags: validate:"required"
	Steps   []*LoadRamp_Parameters_Step `protobuf:"bytes,2,rep,name=steps,proto3" json:"steps,omitempty" validate:"required,gt=0,dive"`     // @gotags: validate:"required,gt=0,dive"
}

func (x *LoadRamp_Parameters) Reset() {
	*x = LoadRamp_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[47]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadRamp_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadRamp_Parameters) ProtoMessage() {}

func (x *LoadRamp_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[47]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadRamp_Parameters.ProtoReflect.Descriptor instead.
func (*LoadRamp_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{11, 0}
}

func (x *LoadRamp_Parameters) GetSampler() *Sampler_Parameters {
	if x != nil {
		return x.Sampler
	}
	return nil
}

func (x *LoadRamp_Parameters) GetSteps() []*LoadRamp_Parameters_Step {
	if x != nil {
		return x.Steps
	}
	return nil
}

// Inputs for the _Load Ramp_ component.
type LoadRamp_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Whether to progress the _Load Ramp_ towards the next step.
	Forward *InPort `protobuf:"bytes,1,opt,name=forward,proto3" json:"forward,omitempty"`
	// Whether to progress the _Load Ramp_ towards the previous step.
	Backward *InPort `protobuf:"bytes,2,opt,name=backward,proto3" json:"backward,omitempty"`
	// Whether to reset the _Load Ramp_ to the first step.
	Reset_ *InPort `protobuf:"bytes,3,opt,name=reset,proto3" json:"reset,omitempty"`
}

func (x *LoadRamp_Ins) Reset() {
	*x = LoadRamp_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[48]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadRamp_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadRamp_Ins) ProtoMessage() {}

func (x *LoadRamp_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[48]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadRamp_Ins.ProtoReflect.Descriptor instead.
func (*LoadRamp_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{11, 1}
}

func (x *LoadRamp_Ins) GetForward() *InPort {
	if x != nil {
		return x.Forward
	}
	return nil
}

func (x *LoadRamp_Ins) GetBackward() *InPort {
	if x != nil {
		return x.Backward
	}
	return nil
}

func (x *LoadRamp_Ins) GetReset_() *InPort {
	if x != nil {
		return x.Reset_
	}
	return nil
}

// Outputs for the _Load Ramp_ component.
type LoadRamp_Outs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The percentage of flows being accepted by the _Load Ramp_.
	AcceptPercentage *OutPort `protobuf:"bytes,1,opt,name=accept_percentage,json=acceptPercentage,proto3" json:"accept_percentage,omitempty"`
	// A Boolean signal indicating whether the _Load Ramp_ is at the start of signal generation.
	AtStart *OutPort `protobuf:"bytes,2,opt,name=at_start,json=atStart,proto3" json:"at_start,omitempty"`
	// A Boolean signal indicating whether the _Load Ramp_ is at the end of signal generation.
	AtEnd *OutPort `protobuf:"bytes,3,opt,name=at_end,json=atEnd,proto3" json:"at_end,omitempty"`
}

func (x *LoadRamp_Outs) Reset() {
	*x = LoadRamp_Outs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[49]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadRamp_Outs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadRamp_Outs) ProtoMessage() {}

func (x *LoadRamp_Outs) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[49]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadRamp_Outs.ProtoReflect.Descriptor instead.
func (*LoadRamp_Outs) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{11, 2}
}

func (x *LoadRamp_Outs) GetAcceptPercentage() *OutPort {
	if x != nil {
		return x.AcceptPercentage
	}
	return nil
}

func (x *LoadRamp_Outs) GetAtStart() *OutPort {
	if x != nil {
		return x.AtStart
	}
	return nil
}

func (x *LoadRamp_Outs) GetAtEnd() *OutPort {
	if x != nil {
		return x.AtEnd
	}
	return nil
}

type LoadRamp_Parameters_Step struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The value of the step.
	TargetAcceptPercentage float64 `protobuf:"fixed64,1,opt,name=target_accept_percentage,json=targetAcceptPercentage,proto3" json:"target_accept_percentage,omitempty" validate:"gte=0,lte=100"` // @gotags: validate:"gte=0,lte=100"
	// Duration for which the step is active.
	// This field employs the [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json) JSON representation from Protocol Buffers. The format accommodates fractional seconds up to nine digits after the decimal point, offering nanosecond precision. Every duration value must be suffixed with an "s" to indicate 'seconds.' For example, a value of "10s" would signify a duration of 10 seconds.
	Duration *durationpb.Duration `protobuf:"bytes,2,opt,name=duration,proto3" json:"duration,omitempty" validate:"required"` // @gotags: validate:"required"
	// This field allows you to override the default HTTP status code (`503 Service Unavailable`) that is returned when a request is denied.
	DeniedResponseStatusCode v1.StatusCode `protobuf:"varint,3,opt,name=denied_response_status_code,json=deniedResponseStatusCode,proto3,enum=aperture.flowcontrol.check.v1.StatusCode" json:"denied_response_status_code,omitempty"`
}

func (x *LoadRamp_Parameters_Step) Reset() {
	*x = LoadRamp_Parameters_Step{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[50]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadRamp_Parameters_Step) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadRamp_Parameters_Step) ProtoMessage() {}

func (x *LoadRamp_Parameters_Step) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[50]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadRamp_Parameters_Step.ProtoReflect.Descriptor instead.
func (*LoadRamp_Parameters_Step) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{11, 0, 0}
}

func (x *LoadRamp_Parameters_Step) GetTargetAcceptPercentage() float64 {
	if x != nil {
		return x.TargetAcceptPercentage
	}
	return 0
}

func (x *LoadRamp_Parameters_Step) GetDuration() *durationpb.Duration {
	if x != nil {
		return x.Duration
	}
	return nil
}

func (x *LoadRamp_Parameters_Step) GetDeniedResponseStatusCode() v1.StatusCode {
	if x != nil {
		return x.DeniedResponseStatusCode
	}
	return v1.StatusCode(0)
}

// StaticBuckets holds the static value of the buckets where latency histogram will be stored.
type FluxMeter_StaticBuckets struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The buckets in which latency histogram will be stored.
	Buckets []float64 `protobuf:"fixed64,1,rep,packed,name=buckets,proto3" json:"buckets,omitempty" default:"[5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]"` // @gotags: default:"[5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]"
}

func (x *FluxMeter_StaticBuckets) Reset() {
	*x = FluxMeter_StaticBuckets{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[51]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_StaticBuckets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_StaticBuckets) ProtoMessage() {}

func (x *FluxMeter_StaticBuckets) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[51]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_StaticBuckets.ProtoReflect.Descriptor instead.
func (*FluxMeter_StaticBuckets) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{12, 0}
}

func (x *FluxMeter_StaticBuckets) GetBuckets() []float64 {
	if x != nil {
		return x.Buckets
	}
	return nil
}

// LinearBuckets creates `count` number of buckets, each `width` wide, where the lowest bucket has an
// upper bound of `start`. The final +inf bucket is not counted.
type FluxMeter_LinearBuckets struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Upper bound of the lowest bucket.
	Start float64 `protobuf:"fixed64,1,opt,name=start,proto3" json:"start,omitempty"`
	// Width of each bucket.
	Width float64 `protobuf:"fixed64,2,opt,name=width,proto3" json:"width,omitempty"`
	// Number of buckets.
	Count int32 `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty" validate:"gt=0"` // @gotags: validate:"gt=0"
}

func (x *FluxMeter_LinearBuckets) Reset() {
	*x = FluxMeter_LinearBuckets{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[52]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_LinearBuckets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_LinearBuckets) ProtoMessage() {}

func (x *FluxMeter_LinearBuckets) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[52]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_LinearBuckets.ProtoReflect.Descriptor instead.
func (*FluxMeter_LinearBuckets) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{12, 1}
}

func (x *FluxMeter_LinearBuckets) GetStart() float64 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *FluxMeter_LinearBuckets) GetWidth() float64 {
	if x != nil {
		return x.Width
	}
	return 0
}

func (x *FluxMeter_LinearBuckets) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

// ExponentialBuckets creates `count` number of buckets where the lowest bucket has an upper bound of `start`
// and each following bucket's upper bound is `factor` times the previous bucket's upper bound. The final +inf
// bucket is not counted.
type FluxMeter_ExponentialBuckets struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Upper bound of the lowest bucket.
	Start float64 `protobuf:"fixed64,1,opt,name=start,proto3" json:"start,omitempty" validate:"gt=0.0"` // @gotags: validate:"gt=0.0"
	// Factor to be multiplied to the previous bucket's upper bound to calculate the following bucket's upper bound.
	Factor float64 `protobuf:"fixed64,2,opt,name=factor,proto3" json:"factor,omitempty" validate:"gt=1.0"` // @gotags: validate:"gt=1.0"
	// Number of buckets.
	Count int32 `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty" validate:"gt=0"` // @gotags: validate:"gt=0"
}

func (x *FluxMeter_ExponentialBuckets) Reset() {
	*x = FluxMeter_ExponentialBuckets{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[53]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_ExponentialBuckets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_ExponentialBuckets) ProtoMessage() {}

func (x *FluxMeter_ExponentialBuckets) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[53]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_ExponentialBuckets.ProtoReflect.Descriptor instead.
func (*FluxMeter_ExponentialBuckets) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{12, 2}
}

func (x *FluxMeter_ExponentialBuckets) GetStart() float64 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *FluxMeter_ExponentialBuckets) GetFactor() float64 {
	if x != nil {
		return x.Factor
	}
	return 0
}

func (x *FluxMeter_ExponentialBuckets) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

// ExponentialBucketsRange creates `count` number of buckets where the lowest bucket is `min` and the highest
// bucket is `max`. The final +inf bucket is not counted.
type FluxMeter_ExponentialBucketsRange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Lowest bucket.
	Min float64 `protobuf:"fixed64,1,opt,name=min,proto3" json:"min,omitempty" validate:"gt=0.0"` // @gotags: validate:"gt=0.0"
	// Highest bucket.
	Max float64 `protobuf:"fixed64,2,opt,name=max,proto3" json:"max,omitempty"`
	// Number of buckets.
	Count int32 `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty" validate:"gt=0"` // @gotags: validate:"gt=0"
}

func (x *FluxMeter_ExponentialBucketsRange) Reset() {
	*x = FluxMeter_ExponentialBucketsRange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[54]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_ExponentialBucketsRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_ExponentialBucketsRange) ProtoMessage() {}

func (x *FluxMeter_ExponentialBucketsRange) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[54]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_ExponentialBucketsRange.ProtoReflect.Descriptor instead.
func (*FluxMeter_ExponentialBucketsRange) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{12, 3}
}

func (x *FluxMeter_ExponentialBucketsRange) GetMin() float64 {
	if x != nil {
		return x.Min
	}
	return 0
}

func (x *FluxMeter_ExponentialBucketsRange) GetMax() float64 {
	if x != nil {
		return x.Max
	}
	return 0
}

func (x *FluxMeter_ExponentialBucketsRange) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

type Rego_LabelProperties struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Decides if the created flow label should be available as an attribute in OLAP telemetry and
	// propagated in [baggage](/concepts/flow-label.md#baggage)
	//
	// :::note
	//
	// The flow label is always accessible in Aperture Policies regardless of this setting.
	//
	// :::
	//
	// :::caution
	//
	// When using [FluxNinja extension](/reference/fluxninja.md), telemetry enabled
	// labels are sent to Aperture Cloud for observability. Telemetry should
	// be disabled for sensitive labels.
	//
	// :::
	Telemetry bool `protobuf:"varint,1,opt,name=telemetry,proto3" json:"telemetry,omitempty" default:"true"` // @gotags: default:"true"
}

func (x *Rego_LabelProperties) Reset() {
	*x = Rego_LabelProperties{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[56]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Rego_LabelProperties) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rego_LabelProperties) ProtoMessage() {}

func (x *Rego_LabelProperties) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[56]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rego_LabelProperties.ProtoReflect.Descriptor instead.
func (*Rego_LabelProperties) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{15, 0}
}

func (x *Rego_LabelProperties) GetTelemetry() bool {
	if x != nil {
		return x.Telemetry
	}
	return false
}

var File_aperture_policy_language_v1_flowcontrol_proto protoreflect.FileDescriptor

var file_aperture_policy_language_v1_flowcontrol_proto_rawDesc = []byte{
	0x0a, 0x2d, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x66, 0x6c,
	0x6f, 0x77, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x1b, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x1a, 0x29, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x66, 0x6c, 0x6f, 0x77, 0x63, 0x6f, 0x6e, 0x74, 0x72,
	0x6f, 0x6c, 0x2f, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x2f, 0x76, 0x31, 0x2f, 0x63, 0x68, 0x65, 0x63,
	0x6b, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2f, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2f, 0x76, 0x31, 0x2f, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68,
	0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x27, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x1a, 0x30, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x73,
	0x74, 0x64, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x1a, 0x19, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x2f, 0x61, 0x6e, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f,
	0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xac,
	0x02, 0x0a, 0x14, 0x46, 0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x52, 0x65,
	0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x12, 0x62, 0x0a, 0x0b, 0x66, 0x6c, 0x75, 0x78, 0x5f,
	0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x41, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x43,
	0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x2e,
	0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52,
	0x0a, 0x66, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x49, 0x0a, 0x0b, 0x63,
	0x6c, 0x61, 0x73, 0x73, 0x69, 0x66, 0x69, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x27, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x43,
	0x6c, 0x61, 0x73, 0x73, 0x69, 0x66, 0x69, 0x65, 0x72, 0x52, 0x0b, 0x63, 0x6c, 0x61, 0x73, 0x73,
	0x69, 0x66, 0x69, 0x65, 0x72, 0x73, 0x1a, 0x65, 0x0a, 0x0f, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65,
	0x74, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x3c, 0x0a, 0x05, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74,
	0x65, 0x72, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xfb, 0x06,
	0x0a, 0x0b, 0x46, 0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x12, 0x56, 0x0a,
	0x0f, 0x71, 0x75, 0x6f, 0x74, 0x61, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x51, 0x75, 0x6f, 0x74, 0x61, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75,
	0x6c, 0x65, 0x72, 0x48, 0x00, 0x52, 0x0e, 0x71, 0x75, 0x6f, 0x74, 0x61, 0x53, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x4d, 0x0a, 0x0c, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x6c, 0x69,
	0x6d, 0x69, 0x74, 0x65, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69,
	0x6d, 0x69, 0x74, 0x65, 0x72, 0x48, 0x00, 0x52, 0x0b, 0x72, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d,
	0x69, 0x74, 0x65, 0x72, 0x12, 0x53, 0x0a, 0x0e, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x73, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53,
	0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x48, 0x00, 0x52, 0x0d, 0x6c, 0x6f, 0x61, 0x64,
	0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x6c, 0x0a, 0x17, 0x61, 0x64, 0x61,
	0x70, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x64,
	0x75, 0x6c, 0x65, 0x72, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x64, 0x61, 0x70, 0x74, 0x69, 0x76,
	0x65, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x48, 0x00,
	0x52, 0x15, 0x61, 0x64, 0x61, 0x70, 0x74, 0x69, 0x76, 0x65, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63,
	0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x40, 0x0a, 0x07, 0x73, 0x61, 0x6d, 0x70, 0x6c,
	0x65, 0x72, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x48, 0x00,
	0x52, 0x07, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x12, 0x44, 0x0a, 0x09, 0x6c, 0x6f, 0x61,
	0x64, 0x5f, 0x72, 0x61, 0x6d, 0x70, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x52,
	0x61, 0x6d, 0x70, 0x48, 0x00, 0x52, 0x08, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x12,
	0x60, 0x0a, 0x13, 0x61, 0x69, 0x6d, 0x64, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x73, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x49, 0x4d, 0x44, 0x4c,
	0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x48, 0x00, 0x52, 0x11,
	0x61, 0x69, 0x6d, 0x64, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
	0x72, 0x12, 0x76, 0x0a, 0x1b, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x64, 0x72, 0x69, 0x76, 0x65,
	0x6e, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72,
	0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x44, 0x72, 0x69, 0x76, 0x65, 0x6e,
	0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x48, 0x00, 0x52,
	0x18, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x44, 0x72, 0x69, 0x76, 0x65, 0x6e, 0x4c, 0x6f, 0x61, 0x64,
	0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x60, 0x0a, 0x13, 0x61, 0x69, 0x61,
	0x64, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72,
	0x18, 0x0d, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x49, 0x41, 0x44, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x48, 0x00, 0x52, 0x11, 0x61, 0x69, 0x61, 0x64, 0x4c, 0x6f,
	0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x31, 0x0a, 0x07, 0x70,
	0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x18, 0xe8, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
	0x41, 0x6e, 0x79, 0x48, 0x00, 0x52, 0x07, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x42, 0x0b,
	0x0a, 0x09, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x22, 0xbc, 0x02, 0x0a, 0x0e,
	0x51, 0x75, 0x6f, 0x74, 0x61, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x47,
	0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x2c, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52,
	0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07,
	0x69, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x43, 0x0a, 0x09, 0x73, 0x65, 0x6c, 0x65, 0x63,
	0x74, 0x6f, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f,
	0x72, 0x52, 0x09, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x12, 0x56, 0x0a, 0x0c,
	0x72, 0x61, 0x74, 0x65, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x33, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72,
	0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0b, 0x72, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d,
	0x69, 0x74, 0x65, 0x72, 0x12, 0x44, 0x0a, 0x09, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
	0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x52,
	0x09, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x22, 0xfe, 0x08, 0x0a, 0x0b, 0x52,
	0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x08, 0x69, 0x6e,
	0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c,
	0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f,
	0x72, 0x74, 0x73, 0x12, 0x53, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
	0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65,
	0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x43, 0x0a, 0x09, 0x73, 0x65, 0x6c, 0x65,
	0x63, 0x74, 0x6f, 0x72, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74,
	0x6f, 0x72, 0x52, 0x09, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x12, 0x69, 0x0a,
	0x12, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
	0x65, 0x72, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69,
	0x74, 0x65, 0x72, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x11, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x1a, 0x92, 0x03, 0x0a, 0x0a, 0x50, 0x61, 0x72,
	0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x6c, 0x61, 0x62, 0x65, 0x6c,
	0x5f, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x61, 0x62, 0x65,
	0x6c, 0x4b, 0x65, 0x79, 0x12, 0x35, 0x0a, 0x08, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x52, 0x08, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12, 0x27, 0x0a, 0x0f, 0x63,
	0x6f, 0x6e, 0x74, 0x69, 0x6e, 0x75, 0x6f, 0x75, 0x73, 0x5f, 0x66, 0x69, 0x6c, 0x6c, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x63, 0x6f, 0x6e, 0x74, 0x69, 0x6e, 0x75, 0x6f, 0x75, 0x73,
	0x46, 0x69, 0x6c, 0x6c, 0x12, 0x3d, 0x0a, 0x0d, 0x6d, 0x61, 0x78, 0x5f, 0x69, 0x64, 0x6c, 0x65,
	0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0b, 0x6d, 0x61, 0x78, 0x49, 0x64, 0x6c, 0x65, 0x54,
	0x69, 0x6d, 0x65, 0x12, 0x59, 0x0a, 0x09, 0x6c, 0x61, 0x7a, 0x79, 0x5f, 0x73, 0x79, 0x6e, 0x63,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3c, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72,
	0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x2e, 0x4c, 0x61, 0x7a, 0x79,
	0x53, 0x79, 0x6e, 0x63, 0x52, 0x08, 0x6c, 0x61, 0x7a, 0x79, 0x53, 0x79, 0x6e, 0x63, 0x12, 0x2c,
	0x0a, 0x12, 0x64, 0x65, 0x6c, 0x61, 0x79, 0x5f, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x5f,
	0x66, 0x69, 0x6c, 0x6c, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x10, 0x64, 0x65, 0x6c, 0x61,
	0x79, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x46, 0x69, 0x6c, 0x6c, 0x1a, 0x3f, 0x0a, 0x08,
	0x4c, 0x61, 0x7a, 0x79, 0x53, 0x79, 0x6e, 0x63, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61, 0x62,
	0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c,
	0x65, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x6e, 0x75, 0x6d, 0x5f, 0x73, 0x79, 0x6e, 0x63, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x6e, 0x75, 0x6d, 0x53, 0x79, 0x6e, 0x63, 0x1a, 0xa7, 0x01,
	0x0a, 0x11, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
	0x65, 0x72, 0x73, 0x12, 0x28, 0x0a, 0x10, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x5f, 0x6c, 0x61,
	0x62, 0x65, 0x6c, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74,
	0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x4b, 0x65, 0x79, 0x12, 0x68, 0x0a,
	0x1b, 0x64, 0x65, 0x6e, 0x69, 0x65, 0x64, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x66, 0x6c,
	0x6f, 0x77, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x2e,
	0x76, 0x31, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43, 0x6f, 0x64, 0x65, 0x52, 0x18, 0x64,
	0x65, 0x6e, 0x69, 0x65, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x43, 0x6f, 0x64, 0x65, 0x1a, 0xe1, 0x01, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12,
	0x4c, 0x0a, 0x0f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69,
	0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x0e, 0x62,
	0x75, 0x63, 0x6b, 0x65, 0x74, 0x43, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x12, 0x44, 0x0a,
	0x0b, 0x66, 0x69, 0x6c, 0x6c, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x0a, 0x66, 0x69, 0x6c, 0x6c, 0x41, 0x6d, 0x6f,
	0x75, 0x6e, 0x74, 0x12, 0x46, 0x0a, 0x0c, 0x70, 0x61, 0x73, 0x73, 0x5f, 0x74, 0x68, 0x72, 0x6f,
	0x75, 0x67, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x0b,
	0x70, 0x61, 0x73, 0x73, 0x54, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x22, 0xdf, 0x05, 0x0a, 0x0d,
	0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x49, 0x0a,
	0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x2e, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f,
	0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x49, 0x6e, 0x73, 0x52,
	0x07, 0x69, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x4c, 0x0a, 0x09, 0x6f, 0x75, 0x74, 0x5f,
	0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63,
	0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x4f, 0x75, 0x74, 0x73, 0x52, 0x08, 0x6f, 0x75,
	0x74, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x55, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65,
	0x74, 0x65, 0x72, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
	0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x17, 0x0a,
	0x07, 0x64, 0x72, 0x79, 0x5f, 0x72, 0x75, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06,
	0x64, 0x72, 0x79, 0x52, 0x75, 0x6e, 0x12, 0x2b, 0x0a, 0x12, 0x64, 0x72, 0x79, 0x5f, 0x72, 0x75,
	0x6e, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x07, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0f, 0x64, 0x72, 0x79, 0x52, 0x75, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x4b, 0x65, 0x79, 0x1a, 0xda, 0x01, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
	0x72, 0x73, 0x12, 0x41, 0x0a, 0x1d, 0x77, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6c,
	0x61, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x64, 0x5f, 0x74, 0x6f, 0x6b,
	0x65, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1a, 0x77, 0x6f, 0x72, 0x6b, 0x6c,
	0x6f, 0x61, 0x64, 0x4c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x42, 0x61, 0x73, 0x65, 0x64, 0x54,
	0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x12, 0x44, 0x0a, 0x09, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c,
	0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72,
	0x52, 0x09, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x43, 0x0a, 0x09, 0x73,
	0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x6c,
	0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x09, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73,
	0x1a, 0x53, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x4c, 0x0a, 0x0f, 0x6c, 0x6f, 0x61, 0x64, 0x5f,
	0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49,
	0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x0e, 0x6c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69,
	0x70, 0x6c, 0x69, 0x65, 0x72, 0x1a, 0x66, 0x0a, 0x04, 0x4f, 0x75, 0x74, 0x73, 0x12, 0x5e, 0x0a,
	0x18, 0x6f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d,
	0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75,
	0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x16, 0x6f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x4c,
	0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x22, 0xbd, 0x06,
	0x0a, 0x09, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x4d, 0x0a, 0x09, 0x77,
	0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x52,
	0x09, 0x77, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x12, 0x7a, 0x0a, 0x1b, 0x64, 0x65,
	0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x77, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x70,
	0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x3a, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63,
	0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64,
	0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x19, 0x64, 0x65, 0x66,
	0x61, 0x75, 0x6c, 0x74, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x50, 0x61, 0x72, 0x61,
	0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x53, 0x0a, 0x18, 0x64, 0x65, 0x63, 0x69, 0x73, 0x69,
	0x6f, 0x6e, 0x5f, 0x64, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x6d, 0x61, 0x72, 0x67,
	0x69, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x52, 0x16, 0x64, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x44, 0x65, 0x61,
	0x64, 0x6c, 0x69, 0x6e, 0x65, 0x4d, 0x61, 0x72, 0x67, 0x69, 0x6e, 0x12, 0x28, 0x0a, 0x10, 0x74,
	0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x5f, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6b, 0x65, 0x79, 0x18,
	0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x4c, 0x61, 0x62,
	0x65, 0x6c, 0x4b, 0x65, 0x79, 0x12, 0x2c, 0x0a, 0x12, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74,
	0x79, 0x5f, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x10, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x4c, 0x61, 0x62, 0x65, 0x6c,
	0x4b, 0x65, 0x79, 0x12, 0x68, 0x0a, 0x1b, 0x64, 0x65, 0x6e, 0x69, 0x65, 0x64, 0x5f, 0x72, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x5f, 0x63, 0x6f,
	0x64, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x66, 0x6c, 0x6f, 0x77, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e,
	0x63, 0x68, 0x65, 0x63, 0x6b, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43,
	0x6f, 0x64, 0x65, 0x52, 0x18, 0x64, 0x65, 0x6e, 0x69, 0x65, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43, 0x6f, 0x64, 0x65, 0x1a, 0xcd, 0x02,
	0x0a, 0x08, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x5a, 0x0a, 0x0a, 0x70, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x2e,
	0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61,
	0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x4e, 0x0a, 0x0d, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f,
	0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x61, 0x62, 0x65,
	0x6c, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x52, 0x0c, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x4d,
	0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x1a, 0x80, 0x01, 0x0a, 0x0a, 0x50,
	0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x72, 0x69,
	0x6f, 0x72, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x08, 0x70, 0x72, 0x69,
	0x6f, 0x72, 0x69, 0x74, 0x79, 0x12, 0x16, 0x0a, 0x06, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x01, 0x52, 0x06, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x12, 0x3e, 0x0a,
	0x0d, 0x71, 0x75, 0x65, 0x75, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52,
	0x0c, 0x71, 0x75, 0x65, 0x75, 0x65, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x22, 0xcc, 0x09,
	0x0a, 0x11, 0x41, 0x49, 0x4d, 0x44, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75,
	0x6c, 0x65, 0x72, 0x12, 0x4d, 0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x41, 0x49, 0x4d, 0x44, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f, 0x72,
	0x74, 0x73, 0x12, 0x50, 0x0a, 0x09, 0x6f, 0x75, 0x74, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x41, 0x49, 0x4d, 0x44, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x4f, 0x75, 0x74, 0x73, 0x52, 0x08, 0x6f, 0x75, 0x74, 0x50,
	0x6f, 0x72, 0x74, 0x73, 0x12, 0x59, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
	0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x39, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x49, 0x4d, 0x44, 0x4c, 0x6f, 0x61, 0x64, 0x53,
	0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
	0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12,
	0x17, 0x0a, 0x07, 0x64, 0x72, 0x79, 0x5f, 0x72, 0x75, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x06, 0x64, 0x72, 0x79, 0x52, 0x75, 0x6e, 0x12, 0x2b, 0x0a, 0x12, 0x64, 0x72, 0x79, 0x5f,
	0x72, 0x75, 0x6e, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x64, 0x72, 0x79, 0x52, 0x75, 0x6e, 0x43, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x4b, 0x65, 0x79, 0x1a, 0xdd, 0x01, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x3b, 0x0a,
	0x06, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f,
	0x72, 0x74, 0x52, 0x06, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x12, 0x3f, 0x0a, 0x08, 0x73, 0x65,
	0x74, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72,
	0x74, 0x52, 0x08, 0x73, 0x65, 0x74, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x58, 0x0a, 0x15, 0x6f,
	0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52,
	0x14, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x8b, 0x02, 0x0a, 0x04, 0x4f, 0x75, 0x74, 0x73, 0x12, 0x45,
	0x0a, 0x0b, 0x69, 0x73, 0x5f, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x0a, 0x69, 0x73, 0x4f, 0x76, 0x65,
	0x72, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x5c, 0x0a, 0x17, 0x64, 0x65, 0x73, 0x69, 0x72, 0x65, 0x64,
	0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x15, 0x64, 0x65,
	0x73, 0x69, 0x72, 0x65, 0x64, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c,
	0x69, 0x65, 0x72, 0x12, 0x5e, 0x0a, 0x18, 0x6f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x5f,
	0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x16, 0x6f, 0x62, 0x73,
	0x65, 0x72, 0x76, 0x65, 0x64, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c,
	0x69, 0x65, 0x72, 0x1a, 0x86, 0x03, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
	0x72, 0x73, 0x12, 0x5c, 0x0a, 0x0e, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x64,
	0x75, 0x6c, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
	0x73, 0x52, 0x0d, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72,
	0x12, 0x56, 0x0a, 0x08, 0x67, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x47, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
	0x6c, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x08,
	0x67, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6e, 0x74, 0x12, 0x2e, 0x0a, 0x13, 0x6d, 0x61, 0x78, 0x5f,
	0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x01, 0x52, 0x11, 0x6d, 0x61, 0x78, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x75,
	0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x20, 0x6c, 0x6f, 0x61, 0x64,
	0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x5f, 0x6c, 0x69, 0x6e, 0x65,
	0x61, 0x72, 0x5f, 0x69, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x01, 0x52, 0x1d, 0x6c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69,
	0x65, 0x72, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x49, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e,
	0x74, 0x12, 0x49, 0x0a, 0x07, 0x61, 0x6c, 0x65, 0x72, 0x74, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x41, 0x6c, 0x65, 0x72, 0x74, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
	0x65, 0x72, 0x73, 0x52, 0x07, 0x61, 0x6c, 0x65, 0x72, 0x74, 0x65, 0x72, 0x22, 0xb7, 0x0a, 0x0a,
	0x18, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x44, 0x72, 0x69, 0x76, 0x65, 0x6e, 0x4c, 0x6f, 0x61, 0x64,
	0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x54, 0x0a, 0x08, 0x69, 0x6e, 0x5f,
	0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x39, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x44,
	0x72, 0x69, 0x76, 0x65, 0x6e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c,
	0x65, 0x72, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12,
	0x57, 0x0a, 0x09, 0x6f, 0x75, 0x74, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x44, 0x72, 0x69, 0x76, 0x65, 0x6e, 0x4c, 0x6f, 0x61, 0x64,
	0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x4f, 0x75, 0x74, 0x73, 0x52, 0x08,
	0x6f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x60, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61,
	0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x40, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65,
	0x44, 0x72, 0x69, 0x76, 0x65, 0x6e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75,
	0x6c, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a,
	0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x17, 0x0a, 0x07, 0x64, 0x72,
	0x79, 0x5f, 0x72, 0x75, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x64, 0x72, 0x79,
	0x52, 0x75, 0x6e, 0x12, 0x2b, 0x0a, 0x12, 0x64, 0x72, 0x79, 0x5f, 0x72, 0x75, 0x6e, 0x5f, 0x63,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0f, 0x64, 0x72, 0x79, 0x52, 0x75, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4b, 0x65, 0x79,
	0x1a, 0x9c, 0x01, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x3b, 0x0a, 0x06, 0x73, 0x69, 0x67, 0x6e,
	0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x06, 0x73,
	0x69, 0x67, 0x6e, 0x61, 0x6c, 0x12, 0x58, 0x0a, 0x15, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61,
	0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x14, 0x6f, 0x76, 0x65, 0x72, 0x6c,
	0x6f, 0x61, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x1a,
	0x8b, 0x02, 0x0a, 0x04, 0x4f, 0x75, 0x74, 0x73, 0x12, 0x45, 0x0a, 0x0b, 0x69, 0x73, 0x5f, 0x6f,
	0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50,
	0x6f, 0x72, 0x74, 0x52, 0x0a, 0x69, 0x73, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x12,
	0x5c, 0x0a, 0x17, 0x64, 0x65, 0x73, 0x69, 0x72, 0x65, 0x64, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f,
	0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f,
	0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x15, 0x64, 0x65, 0x73, 0x69, 0x72, 0x65, 0x64, 0x4c,
	0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x12, 0x5e, 0x0a,
	0x18, 0x6f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d,
	0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75,
	0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x16, 0x6f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x4c,
	0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x1a, 0x57, 0x0a,
	0x09, 0x44, 0x61, 0x74, 0x61, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x69,
	0x67, 0x6e, 0x61, 0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01,
	0x52, 0x0b, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x27, 0x0a,
	0x0f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0e, 0x6c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74,
	0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x1a, 0xbd, 0x03, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x5c, 0x0a, 0x0e, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x73, 0x63,
	0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64,
	0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65,
	0x74, 0x65, 0x72, 0x73, 0x52, 0x0d, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75,
	0x6c, 0x65, 0x72, 0x12, 0x75, 0x0a, 0x16, 0x6c, 0x6f, 0x77, 0x5f, 0x74, 0x68, 0x72, 0x6f, 0x74,
	0x74, 0x6c, 0x65, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x3f, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x44, 0x72, 0x69, 0x76, 0x65, 0x6e, 0x4c, 0x6f, 0x61,
	0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x70,
	0x6f, 0x69, 0x6e, 0x74, 0x52, 0x14, 0x6c, 0x6f, 0x77, 0x54, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c,
	0x65, 0x54, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x12, 0x77, 0x0a, 0x17, 0x68, 0x69,
	0x67, 0x68, 0x5f, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x5f, 0x74, 0x68, 0x72, 0x65,
	0x73, 0x68, 0x6f, 0x6c, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3f, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x44,
	0x72, 0x69, 0x76, 0x65, 0x6e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c,
	0x65, 0x72, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x15, 0x68, 0x69,
	0x67, 0x68, 0x54, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x54, 0x68, 0x72, 0x65, 0x73, 0x68,
	0x6f, 0x6c, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x64, 0x65, 0x67, 0x72, 0x65, 0x65, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x01, 0x52, 0x06, 0x64, 0x65, 0x67, 0x72, 0x65, 0x65, 0x12, 0x49, 0x0a, 0x07, 0x61,
	0x6c, 0x65, 0x72, 0x74, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x6c, 0x65, 0x72, 0x74,
	0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x07, 0x61,
	0x6c, 0x65, 0x72, 0x74, 0x65, 0x72, 0x22, 0x9c, 0x0a, 0x0a, 0x11, 0x41, 0x49, 0x41, 0x44, 0x4c,
	0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x4d, 0x0a, 0x08,
	0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x49, 0x41,
	0x44, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x49,
	0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x50, 0x0a, 0x09, 0x6f,
	0x75, 0x74, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x49, 0x41,
	0x44, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x4f,
	0x75, 0x74, 0x73, 0x52, 0x08, 0x6f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x59, 0x0a,
	0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x39, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x41, 0x49, 0x41, 0x44, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
	0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x17, 0x0a, 0x07, 0x64, 0x72, 0x79, 0x5f,
	0x72, 0x75, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x64, 0x72, 0x79, 0x52, 0x75,
	0x6e, 0x12, 0x2b, 0x0a, 0x12, 0x64, 0x72, 0x79, 0x5f, 0x72, 0x75, 0x6e, 0x5f, 0x63, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x64,
	0x72, 0x79, 0x52, 0x75, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4b, 0x65, 0x79, 0x12, 0x2d,
	0x0a, 0x12, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x64, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x11, 0x6f, 0x76, 0x65, 0x72,
	0x6c, 0x6f, 0x61, 0x64, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0xdd, 0x01,
	0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x3b, 0x0a, 0x06, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x06, 0x73, 0x69, 0x67, 0x6e,
	0x61, 0x6c, 0x12, 0x3f, 0x0a, 0x08, 0x73, 0x65, 0x74, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x08, 0x73, 0x65, 0x74, 0x70, 0x6f,
	0x69, 0x6e, 0x74, 0x12, 0x58, 0x0a, 0x15, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x5f,
	0x63, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x14, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61,
	0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x8b, 0x02,
	0x0a, 0x04, 0x4f, 0x75, 0x74, 0x73, 0x12, 0x45, 0x0a, 0x0b, 0x69, 0x73, 0x5f, 0x6f, 0x76, 0x65,
	0x72, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72,
	0x74, 0x52, 0x0a, 0x69, 0x73, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x5c, 0x0a,
	0x17, 0x64, 0x65, 0x73, 0x69, 0x72, 0x65, 0x64, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75,
	0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74,
	0x50, 0x6f, 0x72, 0x74, 0x52, 0x15, 0x64, 0x65, 0x73, 0x69, 0x72, 0x65, 0x64, 0x4c, 0x6f, 0x61,
	0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x12, 0x5e, 0x0a, 0x18, 0x6f,
	0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c,
	0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50,
	0x6f, 0x72, 0x74, 0x52, 0x16, 0x6f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x4c, 0x6f, 0x61,
	0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x1a, 0xa7, 0x03, 0x0a, 0x0a,
	0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x5c, 0x0a, 0x0e, 0x6c, 0x6f,
	0x61, 0x64, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x35, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x50,
	0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0d, 0x6c, 0x6f, 0x61, 0x64, 0x53,
	0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x2e, 0x0a, 0x13, 0x6d, 0x69, 0x6e, 0x5f,
	0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x11, 0x6d, 0x69, 0x6e, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x75,
	0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x20, 0x6c, 0x6f, 0x61, 0x64,
	0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x5f, 0x6c, 0x69, 0x6e, 0x65,
	0x61, 0x72, 0x5f, 0x64, 0x65, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x01, 0x52, 0x1d, 0x6c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69,
	0x65, 0x72, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x44, 0x65, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e,
	0x74, 0x12, 0x2e, 0x0a, 0x13, 0x6d, 0x61, 0x78, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75,
	0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x52, 0x11,
	0x6d, 0x61, 0x78, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65,
	0x72, 0x12, 0x47, 0x0a, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70,
	0x6c, 0x69, 0x65, 0x72, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x5f, 0x69, 0x6e, 0x63, 0x72,
	0x65, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x01, 0x52, 0x1d, 0x6c, 0x6f, 0x61,
	0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x4c, 0x69, 0x6e, 0x65, 0x61,
	0x72, 0x49, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x49, 0x0a, 0x07, 0x61, 0x6c,
	0x65, 0x72, 0x74, 0x65, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x6c, 0x65, 0x72, 0x74, 0x65,
	0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x07, 0x61, 0x6c,
	0x65, 0x72, 0x74, 0x65, 0x72, 0x22, 0xdc, 0x09, 0x0a, 0x15, 0x41, 0x64, 0x61, 0x70, 0x74, 0x69,
	0x76, 0x65, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12,
	0x51, 0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x36, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x41, 0x64, 0x61, 0x70, 0x74, 0x69, 0x76, 0x65, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f, 0x72,
	0x74, 0x73, 0x12, 0x54, 0x0a, 0x09, 0x6f, 0x75, 0x74, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x41, 0x64, 0x61, 0x70, 0x74, 0x69, 0x76, 0x65, 0x4c, 0x6f, 0x61, 0x64,
	0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x4f, 0x75, 0x74, 0x73, 0x52, 0x08,
	0x6f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x5d, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61,
	0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3d, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x64, 0x61, 0x70, 0x74,
	0x69, 0x76, 0x65, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72,
	0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72,
	0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x17, 0x0a, 0x07, 0x64, 0x72, 0x79, 0x5f, 0x72,
	0x75, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x64, 0x72, 0x79, 0x52, 0x75, 0x6e,
	0x12, 0x2b, 0x0a, 0x12, 0x64, 0x72, 0x79, 0x5f, 0x72, 0x75, 0x6e, 0x5f, 0x63, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x64, 0x72,
	0x79, 0x52, 0x75, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4b, 0x65, 0x79, 0x1a, 0x86, 0x03,
	0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x5c, 0x0a, 0x0e,
	0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72,
	0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0d, 0x6c, 0x6f, 0x61,
	0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x56, 0x0a, 0x08, 0x67, 0x72,
	0x61, 0x64, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x72, 0x61, 0x64, 0x69,
	0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x2e, 0x50, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x08, 0x67, 0x72, 0x61, 0x64, 0x69, 0x65,
	0x6e, 0x74, 0x12, 0x2e, 0x0a, 0x13, 0x6d, 0x61, 0x78, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d,
	0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x01, 0x52,
	0x11, 0x6d, 0x61, 0x78, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69,
	0x65, 0x72, 0x12, 0x47, 0x0a, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69,
	0x70, 0x6c, 0x69, 0x65, 0x72, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x5f, 0x69, 0x6e, 0x63,
	0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x52, 0x1d, 0x6c, 0x6f,
	0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x4c, 0x69, 0x6e, 0x65,
	0x61, 0x72, 0x49, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x49, 0x0a, 0x07, 0x61,
	0x6c, 0x65, 0x72, 0x74, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x6c, 0x65, 0x72, 0x74,
	0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x07, 0x61,
	0x6c, 0x65, 0x72, 0x74, 0x65, 0x72, 0x1a, 0xdd, 0x01, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x3b,
	0x0a, 0x06, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50,
	0x6f, 0x72, 0x74, 0x52, 0x06, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x12, 0x3f, 0x0a, 0x08, 0x73,
	0x65, 0x74, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f,
	0x72, 0x74, 0x52, 0x08, 0x73, 0x65, 0x74, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x58, 0x0a, 0x15,
	0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74,
	0x52, 0x14, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x72,
	0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x8b, 0x02, 0x0a, 0x04, 0x4f, 0x75, 0x74, 0x73, 0x12,
	0x45, 0x0a, 0x0b, 0x69, 0x73, 0x5f, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x0a, 0x69, 0x73, 0x4f, 0x76,
	0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x5c, 0x0a, 0x17, 0x64, 0x65, 0x73, 0x69, 0x72, 0x65,
	0x64, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65,
	0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x15, 0x64,
	0x65, 0x73, 0x69, 0x72, 0x65, 0x64, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70,
	0x6c, 0x69, 0x65, 0x72, 0x12, 0x5e, 0x0a, 0x18, 0x6f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64,
	0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x16, 0x6f, 0x62,
	0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70,
	0x6c, 0x69, 0x65, 0x72, 0x22, 0xfa, 0x04, 0x0a, 0x07, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72,
	0x12, 0x43, 0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x28, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e,
	0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x4f, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
	0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x2e,
	0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61,
	0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x39, 0x0a, 0x19, 0x70, 0x61, 0x73, 0x73, 0x5f, 0x74,
	0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x5f, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x09, 0x52, 0x16, 0x70, 0x61, 0x73, 0x73, 0x54,
	0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65,
	0x73, 0x12, 0x4d, 0x0a, 0x24, 0x70, 0x61, 0x73, 0x73, 0x5f, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67,
	0x68, 0x5f, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x5f, 0x63,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x1f, 0x70, 0x61, 0x73, 0x73, 0x54, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x4c, 0x61, 0x62, 0x65,
	0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4b, 0x65, 0x79,
	0x1a, 0xf5, 0x01, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12,
	0x1b, 0x0a, 0x09, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x08, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x4b, 0x65, 0x79, 0x12, 0x43, 0x0a, 0x09,
	0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x25, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65,
	0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x09, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72,
	0x73, 0x12, 0x68, 0x0a, 0x1b, 0x64, 0x65, 0x6e, 0x69, 0x65, 0x64, 0x5f, 0x72, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x5f, 0x63, 0x6f, 0x64, 0x65,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x66, 0x6c, 0x6f, 0x77, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x63, 0x68,
	0x65, 0x63, 0x6b, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43, 0x6f, 0x64,
	0x65, 0x52, 0x18, 0x64, 0x65, 0x6e, 0x69, 0x65, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x72,
	0x61, 0x6d, 0x70, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08,
	0x72, 0x61, 0x6d, 0x70, 0x4d, 0x6f, 0x64, 0x65, 0x1a, 0x57, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12,
	0x50, 0x0a, 0x11, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x5f, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e,
	0x74, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52,
	0x10, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67,
	0x65, 0x22, 0x9d, 0x09, 0x0a, 0x08, 0x4c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x12, 0x44,
	0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c,
	0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50,
	0x6f, 0x72, 0x74, 0x73, 0x12, 0x47, 0x0a, 0x09, 0x6f, 0x75, 0x74, 0x5f, 0x70, 0x6f, 0x72, 0x74,
	0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x2e, 0x4f,
	0x75, 0x74, 0x73, 0x52, 0x08, 0x6f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x50, 0x0a,
	0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x30, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x4c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
	0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12,
	0x39, 0x0a, 0x19, 0x70, 0x61, 0x73, 0x73, 0x5f, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x5f,
	0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03,
	0x28, 0x09, 0x52, 0x16, 0x70, 0x61, 0x73, 0x73, 0x54, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x4c,
	0x61, 0x62, 0x65, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x4d, 0x0a, 0x24, 0x70, 0x61,
	0x73, 0x73, 0x5f, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x5f, 0x6c, 0x61, 0x62, 0x65, 0x6c,
	0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x6b,
	0x65, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x1f, 0x70, 0x61, 0x73, 0x73, 0x54, 0x68,
	0x72, 0x6f, 0x75, 0x67, 0x68, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73,
	0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4b, 0x65, 0x79, 0x1a, 0x88, 0x03, 0x0a, 0x0a, 0x50, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x49, 0x0a, 0x07, 0x73, 0x61, 0x6d, 0x70,
	0x6c, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x2e,
	0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x07, 0x73, 0x61, 0x6d, 0x70,
	0x6c, 0x65, 0x72, 0x12, 0x4b, 0x0a, 0x05, 0x73, 0x74, 0x65, 0x70, 0x73, 0x18, 0x02, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x35, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65,
	0x74, 0x65, 0x72, 0x73, 0x2e, 0x53, 0x74, 0x65, 0x70, 0x52, 0x05, 0x73, 0x74, 0x65, 0x70, 0x73,
	0x1a, 0xe1, 0x01, 0x0a, 0x04, 0x53, 0x74, 0x65, 0x70, 0x12, 0x38, 0x0a, 0x18, 0x74, 0x61, 0x72,
	0x67, 0x65, 0x74, 0x5f, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x5f, 0x70, 0x65, 0x72, 0x63, 0x65,
	0x6e, 0x74, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x16, 0x74, 0x61, 0x72,
	0x67, 0x65, 0x74, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74,
	0x61, 0x67, 0x65, 0x12, 0x35, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x52, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x68, 0x0a, 0x1b, 0x64, 0x65,
	0x6e, 0x69, 0x65, 0x64, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x73, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x66, 0x6c, 0x6f, 0x77, 0x63,
	0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x2e, 0x76, 0x31, 0x2e,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43, 0x6f, 0x64, 0x65, 0x52, 0x18, 0x64, 0x65, 0x6e, 0x69,
	0x65, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x43, 0x6f, 0x64, 0x65, 0x1a, 0xc0, 0x01, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x3d, 0x0a, 0x07,
	0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f,
	0x72, 0x74, 0x52, 0x07, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x12, 0x3f, 0x0a, 0x08, 0x62,
	0x61, 0x63, 0x6b, 0x77, 0x61, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f,
	0x72, 0x74, 0x52, 0x08, 0x62, 0x61, 0x63, 0x6b, 0x77, 0x61, 0x72, 0x64, 0x12, 0x39, 0x0a, 0x05,
	0x72, 0x65, 0x73, 0x65, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74,
	0x52, 0x05, 0x72, 0x65, 0x73, 0x65, 0x74, 0x1a, 0xd7, 0x01, 0x0a, 0x04, 0x4f, 0x75, 0x74, 0x73,
	0x12, 0x51, 0x0a, 0x11, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x5f, 0x70, 0x65, 0x72, 0x63, 0x65,
	0x6e, 0x74, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72,
	0x74, 0x52, 0x10, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74,
	0x61, 0x67, 0x65, 0x12, 0x3f, 0x0a, 0x08, 0x61, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x07, 0x61, 0x74, 0x53,
	0x74, 0x61, 0x72, 0x74, 0x12, 0x3b, 0x0a, 0x06, 0x61, 0x74, 0x5f, 0x65, 0x6e, 0x64, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x05, 0x61, 0x74, 0x45, 0x6e,
	0x64, 0x22, 0xe1, 0x06, 0x0a, 0x09, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x12,
	0x5d, 0x0a, 0x0e, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74,
	0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x2e,
	0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x48, 0x00, 0x52,
	0x0d, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x5d,
	0x0a, 0x0e, 0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x4c,
	0x69, 0x6e, 0x65, 0x61, 0x72, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x48, 0x00, 0x52, 0x0d,
	0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x6c, 0x0a,
	0x13, 0x65, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x62, 0x75, 0x63,
	0x6b, 0x65, 0x74, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x39, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74,
	0x65, 0x72, 0x2e, 0x45, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75,
	0x63, 0x6b, 0x65, 0x74, 0x73, 0x48, 0x00, 0x52, 0x12, 0x65, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e,
	0x74, 0x69, 0x61, 0x6c, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x7c, 0x0a, 0x19, 0x65,
	0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65,
	0x74, 0x73, 0x5f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3e,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x75,
	0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x45, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69,
	0x61, 0x6c, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x48, 0x00,
	0x52, 0x17, 0x65, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75, 0x63,
	0x6b, 0x65, 0x74, 0x73, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x61, 0x74, 0x74,
	0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0c, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x4b, 0x65, 0x79, 0x12, 0x43,
	0x0a, 0x09, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x25, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x09, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74,
	0x6f, 0x72, 0x73, 0x1a, 0x29, 0x0a, 0x0d, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x42, 0x75, 0x63,
	0x6b, 0x65, 0x74, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x01, 0x52, 0x07, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x1a, 0x51,
	0x0a, 0x0d, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12,
	0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05,
	0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x12, 0x14, 0x0a, 0x05, 0x63,
	0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x63, 0x6f, 0x75, 0x6e,
	0x74, 0x1a, 0x58, 0x0a, 0x12, 0x45, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c,
	0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x16, 0x0a,
	0x06, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x06, 0x66,
	0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x1a, 0x53, 0x0a, 0x17, 0x45,
	0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74,
	0x73, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x69, 0x6e, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x01, 0x52, 0x03, 0x6d, 0x69, 0x6e, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x61, 0x78, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x03, 0x6d, 0x61, 0x78, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f,
	0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74,
	0x42, 0x13, 0x0a, 0x11, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x5f, 0x62, 0x75,
	0x63, 0x6b, 0x65, 0x74, 0x73, 0x22, 0xaf, 0x02, 0x0a, 0x0a, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x69,
	0x66, 0x69, 0x65, 0x72, 0x12, 0x48, 0x0a, 0x05, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x18, 0x02, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x69, 0x66, 0x69, 0x65, 0x72, 0x2e, 0x52, 0x75, 0x6c,
	0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x05, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x35,
	0x0a, 0x04, 0x72, 0x65, 0x67, 0x6f, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x6f, 0x52,
	0x04, 0x72, 0x65, 0x67, 0x6f, 0x12, 0x43, 0x0a, 0x09, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f,
	0x72, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52,
	0x09, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x1a, 0x5b, 0x0a, 0x0a, 0x52, 0x75,
	0x6c, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x37, 0x0a, 0x05, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x52, 0x05, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x76, 0x0a, 0x04, 0x52, 0x75, 0x6c, 0x65, 0x12,
	0x46, 0x0a, 0x09, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x09, 0x65, 0x78,
	0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x65, 0x6c, 0x65, 0x6d,
	0x65, 0x74, 0x72, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x74, 0x65, 0x6c, 0x65,
	0x6d, 0x65, 0x74, 0x72, 0x79, 0x42, 0x08, 0x0a, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x22,
	0x84, 0x02, 0x0a, 0x04, 0x52, 0x65, 0x67, 0x6f, 0x12, 0x45, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65,
	0x6c, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x6f, 0x2e, 0x4c, 0x61, 0x62, 0x65,
	0x6c, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x12,
	0x16, 0x0a, 0x06, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x06, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x1a, 0x2f, 0x0a, 0x0f, 0x4c, 0x61, 0x62, 0x65, 0x6c,
	0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x65,
	0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x74,
	0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x1a, 0x6c, 0x0a, 0x0b, 0x4c, 0x61, 0x62, 0x65,
	0x6c, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x47, 0x0a, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x6f, 0x2e, 0x4c, 0x61, 0x62, 0x65,
	0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x52, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xd3, 0x02, 0x0a, 0x09, 0x45, 0x78, 0x74, 0x72, 0x61,
	0x63, 0x74, 0x6f, 0x72, 0x12, 0x14, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x48, 0x00, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x40, 0x0a, 0x04, 0x6a, 0x73,
	0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x45, 0x78, 0x74, 0x72, 0x61,
	0x63, 0x74, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x04, 0x6a, 0x73, 0x6f, 0x6e, 0x12, 0x49, 0x0a, 0x07,
	0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x07,
	0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x3d, 0x0a, 0x03, 0x6a, 0x77, 0x74, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x4a, 0x57, 0x54, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x48,
	0x00, 0x52, 0x03, 0x6a, 0x77, 0x74, 0x12, 0x59, 0x0a, 0x0e, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x74,
	0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x74,
	0x68, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72,
	0x48, 0x00, 0x52, 0x0d, 0x70, 0x61, 0x74, 0x68, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65,
	0x73, 0x42, 0x09, 0x0a, 0x07, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x22, 0x3d, 0x0a, 0x0d,
	0x4a, 0x53, 0x4f, 0x4e, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x12, 0x0a,
	0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x72, 0x6f,
	0x6d, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x07, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x22, 0x26, 0x0a, 0x10, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12,
	0x12, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66,
	0x72, 0x6f, 0x6d, 0x22, 0x45, 0x0a, 0x0c, 0x4a, 0x57, 0x54, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63,
	0x74, 0x6f, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x21, 0x0a, 0x0c, 0x6a, 0x73, 0x6f, 0x6e, 0x5f,
	0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6a,
	0x73, 0x6f, 0x6e, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x22, 0xc7, 0x01, 0x0a, 0x13, 0x50,
	0x61, 0x74, 0x68, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x65, 0x72, 0x12, 0x6d, 0x0a, 0x0f, 0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x5f, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x44, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x74, 0x68, 0x54, 0x65,
	0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x54, 0x65,
	0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72,
	0x79, 0x52, 0x0e, 0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65,
	0x73, 0x1a, 0x41, 0x0a, 0x13, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x56, 0x61, 0x6c,
	0x75, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x3a, 0x02, 0x38, 0x01, 0x22, 0xba, 0x01, 0x0a, 0x08, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f,
	0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x5f, 0x70, 0x6f, 0x69,
	0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f,
	0x6c, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x5f,
	0x67, 0x72, 0x6f, 0x75, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x61, 0x67, 0x65,
	0x6e, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x12, 0x4e, 0x0a, 0x0d, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68,
	0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x4d, 0x61, 0x74, 0x63,
	0x68, 0x65, 0x72, 0x52, 0x0c, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65,
	0x72, 0x42, 0xb0, 0x02, 0x0a, 0x33, 0x63, 0x6f, 0x6d, 0x2e, 0x66, 0x6c, 0x75, 0x78, 0x6e, 0x69,
	0x6e, 0x6a, 0x61, 0x2e, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x42, 0x10, 0x46, 0x6c, 0x6f, 0x77, 0x63,
	0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x58, 0x67,
	0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x6c, 0x75, 0x78, 0x6e, 0x69,
	0x6e, 0x6a, 0x61, 0x2f, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x76, 0x32, 0x2f,
	0x61, 0x70, 0x69, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f,
	0x2f, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2f, 0x76, 0x31, 0x3b, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x76, 0x31, 0xa2, 0x02, 0x03, 0x41, 0x50, 0x4c, 0xaa, 0x02, 0x1b,
	0x41, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x4c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x56, 0x31, 0xca, 0x02, 0x1b, 0x41, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x5c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x5c, 0x4c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x5c, 0x56, 0x31, 0xe2, 0x02, 0x27, 0x41, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x5c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x5c, 0x4c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x5c, 0x56, 0x31, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61, 0x64,
	0x61, 0x74, 0x61, 0xea, 0x02, 0x1e, 0x41, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x3a, 0x3a,
	0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x3a, 0x3a, 0x4c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x3a, 0x3a, 0x56, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_aperture_policy_language_v1_flowcontrol_proto_rawDescOnce sync.Once
	file_aperture_policy_language_v1_flowcontrol_proto_rawDescData = file_aperture_policy_language_v1_flowcontrol_proto_rawDesc
)

func file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP() []byte {
	file_aperture_policy_language_v1_flowcontrol_proto_rawDescOnce.Do(func() {
		file_aperture_policy_language_v1_flowcontrol_proto_rawDescData = protoimpl.X.CompressGZIP(file_aperture_policy_language_v1_flowcontrol_proto_rawDescData)
	})
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescData
}

var file_aperture_policy_language_v1_flowcontrol_proto_msgTypes = make([]protoimpl.MessageInfo, 59)
var file_aperture_policy_language_v1_flowcontrol_proto_goTypes = []interface{}{
	(*FlowControlResources)(nil),                // 0: aperture.policy.language.v1.FlowControlResources
	(*FlowControl)(nil),                         // 1: aperture.policy.language.v1.FlowControl
	(*QuotaScheduler)(nil),                      // 2: aperture.policy.language.v1.QuotaScheduler
	(*RateLimiter)(nil),                         // 3: aperture.policy.language.v1.RateLimiter
	(*LoadScheduler)(nil),                       // 4: aperture.policy.language.v1.LoadScheduler
	(*Scheduler)(nil),                           // 5: aperture.policy.language.v1.Scheduler
	(*AIMDLoadScheduler)(nil),                   // 6: aperture.policy.language.v1.AIMDLoadScheduler
	(*RangeDrivenLoadScheduler)(nil),            // 7: aperture.policy.language.v1.RangeDrivenLoadScheduler
	(*AIADLoadScheduler)(nil),                   // 8: aperture.policy.language.v1.AIADLoadScheduler
	(*AdaptiveLoadScheduler)(nil),               // 9: aperture.policy.language.v1.AdaptiveLoadScheduler
	(*Sampler)(nil),                             // 10: aperture.policy.language.v1.Sampler
	(*LoadRamp)(nil),                            // 11: aperture.policy.language.v1.LoadRamp
	(*FluxMeter)(nil),                           // 12: aperture.policy.language.v1.FluxMeter
	(*Classifier)(nil),                          // 13: aperture.policy.language.v1.Classifier
	(*Rule)(nil),                                // 14: aperture.policy.language.v1.Rule
	(*Rego)(nil),                                // 15: aperture.policy.language.v1.Rego
	(*Extractor)(nil),                           // 16: aperture.policy.language.v1.Extractor
	(*JSONExtractor)(nil),                       // 17: aperture.policy.language.v1.JSONExtractor
	(*AddressExtractor)(nil),                    // 18: aperture.policy.language.v1.AddressExtractor
	(*JWTExtractor)(nil),                        // 19: aperture.policy.language.v1.JWTExtractor
	(*PathTemplateMatcher)(nil),                 // 20: aperture.policy.language.v1.PathTemplateMatcher
	(*Selector)(nil),                            // 21: aperture.policy.language.v1.Selector
	nil,                                         // 22: aperture.policy.language.v1.FlowControlResources.FluxMetersEntry
	(*RateLimiter_Parameters)(nil),              // 23: aperture.policy.language.v1.RateLimiter.Parameters
	(*RateLimiter_RequestParameters)(nil),       // 24: aperture.policy.language.v1.RateLimiter.RequestParameters
	(*RateLimiter_Ins)(nil),                     // 25: aperture.policy.language.v1.RateLimiter.Ins
	(*RateLimiter_Parameters_LazySync)(nil),     // 26: aperture.policy.language.v1.RateLimiter.Parameters.LazySync
	(*LoadScheduler_Parameters)(nil),            // 27: aperture.policy.language.v1.LoadScheduler.Parameters
	(*LoadScheduler_Ins)(nil),                   // 28: aperture.policy.language.v1.LoadScheduler.Ins
	(*LoadScheduler_Outs)(nil),                  // 29: aperture.policy.language.v1.LoadScheduler.Outs
	(*Scheduler_Workload)(nil),                  // 30: aperture.policy.language.v1.Scheduler.Workload
	(*Scheduler_Workload_Parameters)(nil),       // 31: aperture.policy.language.v1.Scheduler.Workload.Parameters
	(*AIMDLoadScheduler_Ins)(nil),               // 32: aperture.policy.language.v1.AIMDLoadScheduler.Ins
	(*AIMDLoadScheduler_Outs)(nil),              // 33: aperture.policy.language.v1.AIMDLoadScheduler.Outs
	(*AIMDLoadScheduler_Parameters)(nil),        // 34: aperture.policy.language.v1.AIMDLoadScheduler.Parameters
	(*RangeDrivenLoadScheduler_Ins)(nil),        // 35: aperture.policy.language.v1.RangeDrivenLoadScheduler.Ins
	(*RangeDrivenLoadScheduler_Outs)(nil),       // 36: aperture.policy.language.v1.RangeDrivenLoadScheduler.Outs
	(*RangeDrivenLoadScheduler_Datapoint)(nil),  // 37: aperture.policy.language.v1.RangeDrivenLoadScheduler.Datapoint
	(*RangeDrivenLoadScheduler_Parameters)(nil), // 38: aperture.policy.language.v1.RangeDrivenLoadScheduler.Parameters
	(*AIADLoadScheduler_Ins)(nil),               // 39: aperture.policy.language.v1.AIADLoadScheduler.Ins
	(*AIADLoadScheduler_Outs)(nil),              // 40: aperture.policy.language.v1.AIADLoadScheduler.Outs
	(*AIADLoadScheduler_Parameters)(nil),        // 41: aperture.policy.language.v1.AIADLoadScheduler.Parameters
	(*AdaptiveLoadScheduler_Parameters)(nil),    // 42: aperture.policy.language.v1.AdaptiveLoadScheduler.Parameters
	(*AdaptiveLoadScheduler_Ins)(nil),           // 43: aperture.policy.language.v1.AdaptiveLoadScheduler.Ins
	(*AdaptiveLoadScheduler_Outs)(nil),          // 44: aperture.policy.language.v1.AdaptiveLoadScheduler.Outs
	(*Sampler_Parameters)(nil),                  // 45: aperture.policy.language.v1.Sampler.Parameters
	(*Sampler_Ins)(nil),                         // 46: aperture.policy.language.v1.Sampler.Ins
	(*LoadRamp_Parameters)(nil),                 // 47: aperture.policy.language.v1.LoadRamp.Parameters
	(*LoadRamp_Ins)(nil),                        // 48: aperture.policy.language.v1.LoadRamp.Ins
	(*LoadRamp_Outs)(nil),                       // 49: aperture.policy.language.v1.LoadRamp.Outs
	(*LoadRamp_Parameters_Step)(nil),            // 50: aperture.policy.language.v1.LoadRamp.Parameters.Step
	(*FluxMeter_StaticBuckets)(nil),             // 51: aperture.policy.language.v1.FluxMeter.StaticBuckets
	(*FluxMeter_LinearBuckets)(nil),             // 52: aperture.policy.language.v1.FluxMeter.LinearBuckets
	(*FluxMeter_ExponentialBuckets)(nil),        // 53: aperture.policy.language.v1.FluxMeter.ExponentialBuckets
	(*FluxMeter_ExponentialBucketsRange)(nil),   // 54: aperture.policy.language.v1.FluxMeter.ExponentialBucketsRange
	nil,                                   // 55: aperture.policy.language.v1.Classifier.RulesEntry
	(*Rego_LabelProperties)(nil),          // 56: aperture.policy.language.v1.Rego.LabelProperties
	nil,                                   // 57: aperture.policy.language.v1.Rego.LabelsEntry
	nil,                                   // 58: aperture.policy.language.v1.PathTemplateMatcher.TemplateValuesEntry
	(*anypb.Any)(nil),                     // 59: google.protobuf.Any
	(*durationpb.Duration)(nil),           // 60: google.protobuf.Duration
	(v1.StatusCode)(0),                    // 61: aperture.flowcontrol.check.v1.StatusCode
	(*LabelMatcher)(nil),                  // 62: aperture.policy.language.v1.LabelMatcher
	(*InPort)(nil),                        // 63: aperture.policy.language.v1.InPort
	(*OutPort)(nil),                       // 64: aperture.policy.language.v1.OutPort
	(*GradientController_Parameters)(nil), // 65: aperture.policy.language.v1.GradientController.Parameters
	(*Alerter_Parameters)(nil),            // 66: aperture.policy.language.v1.Alerter.Parameters
}
var file_aperture_policy_language_v1_flowcontrol_proto_depIdxs = []int32{
	22,  // 0: aperture.policy.language.v1.FlowControlResources.flux_meters:type_name -> aperture.policy.language.v1.FlowControlResources.FluxMetersEntry
	13,  // 1: aperture.policy.language.v1.FlowControlResources.classifiers:type_name -> aperture.policy.language.v1.Classifier
	2,   // 2: aperture.policy.language.v1.FlowControl.quota_scheduler:type_name -> aperture.policy.language.v1.QuotaScheduler
	3,   // 3: aperture.policy.language.v1.FlowControl.rate_limiter:type_name -> aperture.policy.language.v1.RateLimiter
	4,   // 4: aperture.policy.language.v1.FlowControl.load_scheduler:type_name -> aperture.policy.language.v1.LoadScheduler
	9,   // 5: aperture.policy.language.v1.FlowControl.adaptive_load_scheduler:type_name -> aperture.policy.language.v1.AdaptiveLoadScheduler
	10,  // 6: aperture.policy.language.v1.FlowControl.sampler:type_name -> aperture.policy.language.v1.Sampler
	11,  // 7: aperture.policy.language.v1.FlowControl.load_ramp:type_name -> aperture.policy.language.v1.LoadRamp
	6,   // 8: aperture.policy.language.v1.FlowControl.aimd_load_scheduler:type_name -> aperture.policy.language.v1.AIMDLoadScheduler
	7,   // 9: aperture.policy.language.v1.FlowControl.range_driven_load_scheduler:type_name -> aperture.policy.language.v1.RangeDrivenLoadScheduler
	8,   // 10: aperture.policy.language.v1.FlowControl.aiad_load_scheduler:type_name -> aperture.policy.language.v1.AIADLoadScheduler
	59,  // 11: aperture.policy.language.v1.FlowControl.private:type_name -> google.protobuf.Any
	25,  // 12: aperture.policy.language.v1.QuotaScheduler.in_ports:type_name -> aperture.policy.language.v1.RateLimiter.Ins
	21,  // 13: aperture.policy.language.v1.QuotaScheduler.selectors:type_name -> aperture.policy.language.v1.Selector
	23,  // 14: aperture.policy.language.v1.QuotaScheduler.rate_limiter:type_name -> aperture.policy.language.v1.RateLimiter.Parameters
	5,   // 15: aperture.policy.language.v1.QuotaScheduler.scheduler:type_name -> aperture.policy.language.v1.Scheduler
	25,  // 16: aperture.policy.language.v1.RateLimiter.in_ports:type_name -> aperture.policy.language.v1.RateLimiter.Ins
	23,  // 17: aperture.policy.language.v1.RateLimiter.parameters:type_name -> aperture.policy.language.v1.RateLimiter.Parameters
	21,  // 18: aperture.policy.language.v1.RateLimiter.selectors:type_name -> aperture.policy.language.v1.Selector
	24,  // 19: aperture.policy.language.v1.RateLimiter.request_parameters:type_name -> aperture.policy.language.v1.RateLimiter.RequestParameters
	28,  // 20: aperture.policy.language.v1.LoadScheduler.in_ports:type_name -> aperture.policy.language.v1.LoadScheduler.Ins
	29,  // 21: aperture.policy.language.v1.LoadScheduler.out_ports:type_name -> aperture.policy.language.v1.LoadScheduler.Outs
	27,  // 22: aperture.policy.language.v1.LoadScheduler.parameters:type_name -> aperture.policy.language.v1.LoadScheduler.Parameters
	30,  // 23: aperture.policy.language.v1.Scheduler.workloads:type_name -> aperture.policy.language.v1.Scheduler.Workload
	31,  // 24: aperture.policy.language.v1.Scheduler.default_workload_parameters:type_name -> aperture.policy.language.v1.Scheduler.Workload.Parameters
	60,  // 25: aperture.policy.language.v1.Scheduler.decision_deadline_margin:type_name -> google.protobuf.Duration
	61,  // 26: aperture.policy.language.v1.Scheduler.denied_response_status_code:type_name -> aperture.flowcontrol.check.v1.StatusCode
	32,  // 27: aperture.policy.language.v1.AIMDLoadScheduler.in_ports:type_name -> aperture.policy.language.v1.AIMDLoadScheduler.Ins
	33,  // 28: aperture.policy.language.v1.AIMDLoadScheduler.out_ports:type_name -> aperture.policy.language.v1.AIMDLoadScheduler.Outs
	34,  // 29: aperture.policy.language.v1.AIMDLoadScheduler.parameters:type_name -> aperture.policy.language.v1.AIMDLoadScheduler.Parameters
	35,  // 30: aperture.policy.language.v1.RangeDrivenLoadScheduler.in_ports:type_name -> aperture.policy.language.v1.RangeDrivenLoadScheduler.Ins
	36,  // 31: aperture.policy.language.v1.RangeDrivenLoadScheduler.out_ports:type_name -> aperture.policy.language.v1.RangeDrivenLoadScheduler.Outs
	38,  // 32: aperture.policy.language.v1.RangeDrivenLoadScheduler.parameters:type_name -> aperture.policy.language.v1.RangeDrivenLoadScheduler.Parameters
	39,  // 33: aperture.policy.language.v1.AIADLoadScheduler.in_ports:type_name -> aperture.policy.language.v1.AIADLoadScheduler.Ins
	40,  // 34: aperture.policy.language.v1.AIADLoadScheduler.out_ports:type_name -> aperture.policy.language.v1.AIADLoadScheduler.Outs
	41,  // 35: aperture.policy.language.v1.AIADLoadScheduler.parameters:type_name -> aperture.policy.language.v1.AIADLoadScheduler.Parameters
	43,  // 36: aperture.policy.language.v1.AdaptiveLoadScheduler.in_ports:type_name -> aperture.policy.language.v1.AdaptiveLoadScheduler.Ins
	44,  // 37: aperture.policy.language.v1.AdaptiveLoadScheduler.out_ports:type_name -> aperture.policy.language.v1.AdaptiveLoadScheduler.Outs
	42,  // 38: aperture.policy.language.v1.AdaptiveLoadScheduler.parameters:type_name -> aperture.policy.language.v1.AdaptiveLoadScheduler.Parameters
	46,  // 39: aperture.policy.language.v1.Sampler.in_ports:type_name -> aperture.policy.language.v1.Sampler.Ins
	45,  // 40: aperture.policy.language.v1.Sampler.parameters:type_name -> aperture.policy.language.v1.Sampler.Parameters
	48,  // 41: aperture.policy.language.v1.LoadRamp.in_ports:type_name -> aperture.policy.language.v1.LoadRamp.Ins
	49,  // 42: aperture.policy.language.v1.LoadRamp.out_ports:type_name -> aperture.policy.language.v1.LoadRamp.Outs
	47,  // 43: aperture.policy.language.v1.LoadRamp.parameters:type_name -> aperture.policy.language.v1.LoadRamp.Parameters
	51,  // 44: aperture.policy.language.v1.FluxMeter.static_buckets:type_name -> aperture.policy.language.v1.FluxMeter.StaticBuckets
	52,  // 45: aperture.policy.language.v1.FluxMeter.linear_buckets:type_name -> aperture.policy.language.v1.FluxMeter.LinearBuckets
	53,  // 46: aperture.policy.language.v1.FluxMeter.exponential_buckets:type_name -> aperture.policy.language.v1.FluxMeter.ExponentialBuckets
	54,  // 47: aperture.policy.language.v1.FluxMeter.exponential_buckets_range:type_name -> aperture.policy.language.v1.FluxMeter.ExponentialBucketsRange
	21,  // 48: aperture.policy.language.v1.FluxMeter.selectors:type_name -> aperture.policy.language.v1.Selector
	55,  // 49: aperture.policy.language.v1.Classifier.rules:type_name -> aperture.policy.language.v1.Classifier.RulesEntry
	15,  // 50: aperture.policy.language.v1.Classifier.rego:type_name -> aperture.policy.language.v1.Rego
	21,  // 51: aperture.policy.language.v1.Classifier.selectors:type_name -> aperture.policy.language.v1.Selector
	16,  // 52: aperture.policy.language.v1.Rule.extractor:type_name -> aperture.policy.language.v1.Extractor
	57,  // 53: aperture.policy.language.v1.Rego.labels:type_name -> aperture.policy.language.v1.Rego.LabelsEntry
	17,  // 54: aperture.policy.language.v1.Extractor.json:type_name -> aperture.policy.language.v1.JSONExtractor
	18,  // 55: aperture.policy.language.v1.Extractor.address:type_name -> aperture.policy.language.v1.AddressExtractor
	19,  // 56: aperture.policy.language.v1.Extractor.jwt:type_name -> aperture.policy.language.v1.JWTExtractor
	20,  // 57: aperture.policy.language.v1.Extractor.path_templates:type_name -> aperture.policy.language.v1.PathTemplateMatcher
	58,  // 58: aperture.policy.language.v1.PathTemplateMatcher.template_values:type_name -> aperture.policy.language.v1.PathTemplateMatcher.TemplateValuesEntry
	62,  // 59: aperture.policy.language.v1.Selector.label_matcher:type_name -> aperture.policy.language.v1.LabelMatcher
	12,  // 60: aperture.policy.language.v1.FlowControlResources.FluxMetersEntry.value:type_name -> aperture.policy.language.v1.FluxMeter
	60,  // 61: aperture.policy.language.v1.RateLimiter.Parameters.interval:type_name -> google.protobuf.Duration
	60,  // 62: aperture.policy.language.v1.RateLimiter.Parameters.max_idle_time:type_name -> google.protobuf.Duration
	26,  // 63: aperture.policy.language.v1.RateLimiter.Parameters.lazy_sync:type_name -> aperture.policy.language.v1.RateLimiter.Parameters.LazySync
	61,  // 64: aperture.policy.language.v1.RateLimiter.RequestParameters.denied_response_status_code:type_name -> aperture.flowcontrol.check.v1.StatusCode
	63,  // 65: aperture.policy.language.v1.RateLimiter.Ins.bucket_capacity:type_name -> aperture.policy.language.v1.InPort
	63,  // 66: aperture.policy.language.v1.RateLimiter.Ins.fill_amount:type_name -> aperture.policy.language.v1.InPort
	63,  // 67: aperture.policy.language.v1.RateLimiter.Ins.pass_through:type_name -> aperture.policy.language.v1.InPort
	5,   // 68: aperture.policy.language.v1.LoadScheduler.Parameters.scheduler:type_name -> aperture.policy.language.v1.Scheduler
	21,  // 69: aperture.policy.language.v1.LoadScheduler.Parameters.selectors:type_name -> aperture.policy.language.v1.Selector
	63,  // 70: aperture.policy.language.v1.LoadScheduler.Ins.load_multiplier:type_name -> aperture.policy.language.v1.InPort
	64,  // 71: aperture.policy.language.v1.LoadScheduler.Outs.observed_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	31,  // 72: aperture.policy.language.v1.Scheduler.Workload.parameters:type_name -> aperture.policy.language.v1.Scheduler.Workload.Parameters
	62,  // 73: aperture.policy.language.v1.Scheduler.Workload.label_matcher:type_name -> aperture.policy.language.v1.LabelMatcher
	60,  // 74: aperture.policy.language.v1.Scheduler.Workload.Parameters.queue_timeout:type_name -> google.protobuf.Duration
	63,  // 75: aperture.policy.language.v1.AIMDLoadScheduler.Ins.signal:type_name -> aperture.policy.language.v1.InPort
	63,  // 76: aperture.policy.language.v1.AIMDLoadScheduler.Ins.setpoint:type_name -> aperture.policy.language.v1.InPort
	63,  // 77: aperture.policy.language.v1.AIMDLoadScheduler.Ins.overload_confirmation:type_name -> aperture.policy.language.v1.InPort
	64,  // 78: aperture.policy.language.v1.AIMDLoadScheduler.Outs.is_overload:type_name -> aperture.policy.language.v1.OutPort
	64,  // 79: aperture.policy.language.v1.AIMDLoadScheduler.Outs.desired_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	64,  // 80: aperture.policy.language.v1.AIMDLoadScheduler.Outs.observed_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	27,  // 81: aperture.policy.language.v1.AIMDLoadScheduler.Parameters.load_scheduler:type_name -> aperture.policy.language.v1.LoadScheduler.Parameters
	65,  // 82: aperture.policy.language.v1.AIMDLoadScheduler.Parameters.gradient:type_name -> aperture.policy.language.v1.GradientController.Parameters
	66,  // 83: aperture.policy.language.v1.AIMDLoadScheduler.Parameters.alerter:type_name -> aperture.policy.language.v1.Alerter.Parameters
	63,  // 84: aperture.policy.language.v1.RangeDrivenLoadScheduler.Ins.signal:type_name -> aperture.policy.language.v1.InPort
	63,  // 85: aperture.policy.language.v1.RangeDrivenLoadScheduler.Ins.overload_confirmation:type_name -> aperture.policy.language.v1.InPort
	64,  // 86: aperture.policy.language.v1.RangeDrivenLoadScheduler.Outs.is_overload:type_name -> aperture.policy.language.v1.OutPort
	64,  // 87: aperture.policy.language.v1.RangeDrivenLoadScheduler.Outs.desired_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	64,  // 88: aperture.policy.language.v1.RangeDrivenLoadScheduler.Outs.observed_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	27,  // 89: aperture.policy.language.v1.RangeDrivenLoadScheduler.Parameters.load_scheduler:type_name -> aperture.policy.language.v1.LoadScheduler.Parameters
	37,  // 90: aperture.policy.language.v1.RangeDrivenLoadScheduler.Parameters.low_throttle_threshold:type_name -> aperture.policy.language.v1.RangeDrivenLoadScheduler.Datapoint
	37,  // 91: aperture.policy.language.v1.RangeDrivenLoadScheduler.Parameters.high_throttle_threshold:type_name -> aperture.policy.language.v1.RangeDrivenLoadScheduler.Datapoint
	66,  // 92: aperture.policy.language.v1.RangeDrivenLoadScheduler.Parameters.alerter:type_name -> aperture.policy.language.v1.Alerter.Parameters
	63,  // 93: aperture.policy.language.v1.AIADLoadScheduler.Ins.signal:type_name -> aperture.policy.language.v1.InPort
	63,  // 94: aperture.policy.language.v1.AIADLoadScheduler.Ins.setpoint:type_name -> aperture.policy.language.v1.InPort
	63,  // 95: aperture.policy.language.v1.AIADLoadScheduler.Ins.overload_confirmation:type_name -> aperture.policy.language.v1.InPort
	64,  // 96: aperture.policy.language.v1.AIADLoadScheduler.Outs.is_overload:type_name -> aperture.policy.language.v1.OutPort
	64,  // 97: aperture.policy.language.v1.AIADLoadScheduler.Outs.desired_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	64,  // 98: aperture.policy.language.v1.AIADLoadScheduler.Outs.observed_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	27,  // 99: aperture.policy.language.v1.AIADLoadScheduler.Parameters.load_scheduler:type_name -> aperture.policy.language.v1.LoadScheduler.Parameters
	66,  // 100: aperture.policy.language.v1.AIADLoadScheduler.Parameters.alerter:type_name -> aperture.policy.language.v1.Alerter.Parameters
	27,  // 101: aperture.policy.language.v1.AdaptiveLoadScheduler.Parameters.load_scheduler:type_name -> aperture.policy.language.v1.LoadScheduler.Parameters
	65,  // 102: aperture.policy.language.v1.AdaptiveLoadScheduler.Parameters.gradient:type_name -> aperture.policy.language.v1.GradientController.Parameters
	66,  // 103: aperture.policy.language.v1.AdaptiveLoadScheduler.Parameters.alerter:type_name -> aperture.policy.language.v1.Alerter.Parameters
	63,  // 104: aperture.policy.language.v1.AdaptiveLoadScheduler.Ins.signal:type_name -> aperture.policy.language.v1.InPort
	63,  // 105: aperture.policy.language.v1.AdaptiveLoadScheduler.Ins.setpoint:type_name -> aperture.policy.language.v1.InPort
	63,  // 106: aperture.policy.language.v1.AdaptiveLoadScheduler.Ins.overload_confirmation:type_name -> aperture.policy.language.v1.InPort
	64,  // 107: aperture.policy.language.v1.AdaptiveLoadScheduler.Outs.is_overload:type_name -> aperture.policy.language.v1.OutPort
	64,  // 108: aperture.policy.language.v1.AdaptiveLoadScheduler.Outs.desired_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	64,  // 109: aperture.policy.language.v1.AdaptiveLoadScheduler.Outs.observed_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	21,  // 110: aperture.policy.language.v1.Sampler.Parameters.selectors:type_name -> aperture.policy.language.v1.Selector
	61,  // 111: aperture.policy.language.v1.Sampler.Parameters.denied_response_status_code:type_name -> aperture.flowcontrol.check.v1.StatusCode
	63,  // 112: aperture.policy.language.v1.Sampler.Ins.accept_percentage:type_name -> aperture.policy.language.v1.InPort
	45,  // 113: aperture.policy.language.v1.LoadRamp.Parameters.sampler:type_name -> aperture.policy.language.v1.Sampler.Parameters
	50,  // 114: aperture.policy.language.v1.LoadRamp.Parameters.steps:type_name -> aperture.policy.language.v1.LoadRamp.Parameters.Step
	63,  // 115: aperture.policy.language.v1.LoadRamp.Ins.forward:type_name -> aperture.policy.language.v1.InPort
	63,  // 116: aperture.policy.language.v1.LoadRamp.Ins.backward:type_name -> aperture.policy.language.v1.InPort
	63,  // 117: aperture.policy.language.v1.LoadRamp.Ins.reset:type_name -> aperture.policy.language.v1.InPort
	64,  // 118: aperture.policy.language.v1.LoadRamp.Outs.accept_percentage:type_name -> aperture.policy.language.v1.OutPort
	64,  // 119: aperture.policy.language.v1.LoadRamp.Outs.at_start:type_name -> aperture.policy.language.v1.OutPort
	64,  // 120: aperture.policy.language.v1.LoadRamp.Outs.at_end:type_name -> aperture.policy.language.v1.OutPort
	60,  // 121: aperture.policy.language.v1.LoadRamp.Parameters.Step.duration:type_name -> google.protobuf.Duration
	61,  // 122: aperture.policy.language.v1.LoadRamp.Parameters.Step.denied_response_status_code:type_name -> aperture.flowcontrol.check.v1.StatusCode
	14,  // 123: aperture.policy.language.v1.Classifier.RulesEntry.value:type_name -> aperture.policy.language.v1.Rule
	56,  // 124: aperture.policy.language.v1.Rego.LabelsEntry.value:type_name -> aperture.policy.language.v1.Rego.LabelProperties
	125, // [125:125] is the sub-list for method output_type
	125, // [125:125] is the sub-list for method input_type
	125, // [125:125] is the sub-list for extension type_name
	125, // [125:125] is the sub-list for extension extendee
	0,   // [0:125] is the sub-list for field type_name
}

func init() { file_aperture_policy_language_v1_flowcontrol_proto_init() }
func file_aperture_policy_language_v1_flowcontrol_proto_init() {
	if File_aperture_policy_language_v1_flowcontrol_proto != nil {
		return
	}
	file_aperture_policy_language_v1_label_matcher_proto_init()
	file_aperture_policy_language_v1_ports_proto_init()
	file_aperture_policy_language_v1_std_components_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FlowControlResources); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FlowControl); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QuotaScheduler); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadScheduler); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AIMDLoadScheduler); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RangeDrivenLoadScheduler); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AIADLoadScheduler); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AdaptiveLoadScheduler); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Sampler); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadRamp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Classifier); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Rule); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Rego); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Extractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*JSONExtractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddressExtractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*JWTExtractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PathTemplateMatcher); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Selector); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_RequestParameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_Parameters_LazySync); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadScheduler_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadScheduler_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadScheduler_Outs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler_Workload); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler_Workload_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AIMDLoadScheduler_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AIMDLoadScheduler_Outs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AIMDLoadScheduler_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RangeDrivenLoadScheduler_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RangeDrivenLoadScheduler_Outs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[37].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RangeDrivenLoadScheduler_Datapoint); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[38].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RangeDrivenLoadScheduler_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[39].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AIADLoadScheduler_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[40].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AIADLoadScheduler_Outs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[41].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AIADLoadScheduler_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[42].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AdaptiveLoadScheduler_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[43].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AdaptiveLoadScheduler_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[44].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AdaptiveLoadScheduler_Outs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[45].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Sampler_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[46].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Sampler_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[47].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadRamp_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[48].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadRamp_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[49].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadRamp_Outs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[50].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadRamp_Parameters_Step); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[51].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_StaticBuckets); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[52].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_LinearBuckets); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[53].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_ExponentialBuckets); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[54].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_ExponentialBucketsRange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[56].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Rego_LabelProperties); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[1].OneofWrappers = []interface{}{
		(*FlowControl_QuotaScheduler)(nil),
		(*FlowControl_RateLimiter)(nil),
		(*FlowControl_LoadScheduler)(nil),
		(*FlowControl_AdaptiveLoadScheduler)(nil),
		(*FlowControl_Sampler)(nil),
		(*FlowControl_LoadRamp)(nil),
		(*FlowControl_AimdLoadScheduler)(nil),
		(*FlowControl_RangeDrivenLoadScheduler)(nil),
		(*FlowControl_AiadLoadScheduler)(nil),
		(*FlowControl_Private)(nil),
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[12].OneofWrappers = []interface{}{
		(*FluxMeter_StaticBuckets_)(nil),
		(*FluxMeter_LinearBuckets_)(nil),
		(*FluxMeter_ExponentialBuckets_)(nil),
		(*FluxMeter_ExponentialBucketsRange_)(nil),
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[14].OneofWrappers = []interface{}{
		(*Rule_Extractor)(nil),
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[16].OneofWrappers = []interface{}{
		(*Extractor_From)(nil),
		(*Extractor_Json)(nil),
		(*Extractor_Address)(nil),
		(*Extractor_Jwt)(nil),
		(*Extractor_PathTemplates)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_aperture_policy_language_v1_flowcontrol_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   59,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_aperture_policy_language_v1_flowcontrol_proto_goTypes,
		DependencyIndexes: file_aperture_policy_language_v1_flowcontrol_proto_depIdxs,
		MessageInfos:      file_aperture_policy_language_v1_flowcontrol_proto_msgTypes,
	}.Build()
	File_aperture_policy_language_v1_flowcontrol_proto = out.File
	file_aperture_policy_language_v1_flowcontrol_proto_rawDesc = nil
	file_aperture_policy_language_v1_flowcontrol_proto_goTypes = nil
	file_aperture_policy_language_v1_flowcontrol_proto_depIdxs = nil
}
