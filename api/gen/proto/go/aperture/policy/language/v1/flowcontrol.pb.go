// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.30.0
// 	protoc        (unknown)
// source: aperture/policy/language/v1/flowcontrol.proto

package languagev1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Describes which flow in which service a [flow control
// component](/concepts/flow-control/flow-control.md#components) should apply
// to
//
// :::info
//
// See also [FlowSelector overview](/concepts/flow-control/flow-selector.md).
//
// :::
type FlowSelector struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Match agent group and service
	ServiceSelector *ServiceSelector `protobuf:"bytes,1,opt,name=service_selector,json=serviceSelector,proto3" json:"service_selector,omitempty" validate:"required"` // @gotags: validate:"required"
	// Match control points and labels
	FlowMatcher *FlowMatcher `protobuf:"bytes,2,opt,name=flow_matcher,json=flowMatcher,proto3" json:"flow_matcher,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *FlowSelector) Reset() {
	*x = FlowSelector{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FlowSelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowSelector) ProtoMessage() {}

func (x *FlowSelector) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowSelector.ProtoReflect.Descriptor instead.
func (*FlowSelector) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{0}
}

func (x *FlowSelector) GetServiceSelector() *ServiceSelector {
	if x != nil {
		return x.ServiceSelector
	}
	return nil
}

func (x *FlowSelector) GetFlowMatcher() *FlowMatcher {
	if x != nil {
		return x.FlowMatcher
	}
	return nil
}

// Describes which service a [flow control or observability
// component](/concepts/flow-control/flow-control.md#components) should apply
// to
//
// :::info
//
// See also [FlowSelector overview](/concepts/flow-control/flow-selector.md).
//
// :::
type ServiceSelector struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Which [agent-group](/concepts/flow-control/flow-selector.md#agent-group) this
	// selector applies to.
	//
	// :::info
	//
	// Agent Groups are used to scope policies to a subset of agents connected to the same controller.
	// This is especially useful in the Kubernetes sidecar installation because service discovery is switched off in that mode.
	// The agents within an agent group form a peer to peer cluster and constantly share state.
	//
	// :::
	AgentGroup string `protobuf:"bytes,1,opt,name=agent_group,json=agentGroup,proto3" json:"agent_group,omitempty" default:"default"` // @gotags: default:"default"
	// The Fully Qualified Domain Name of the
	// [service](/concepts/flow-control/flow-selector.md) to select.
	//
	// In Kubernetes, this is the FQDN of the Service object.
	//
	// :::info
	//
	// `any` matches all services.
	//
	// :::
	//
	// :::info
	//
	// In the Kubernetes sidecar installation mode, service discovery is switched off by default.
	// To scope policies to services, the `service` should be set to `any` and instead, `agent_group` name should be used.
	//
	// :::
	//
	// :::info
	//
	// An entity (for example, Kubernetes pod) might belong to multiple services.
	//
	// :::
	Service string `protobuf:"bytes,2,opt,name=service,proto3" json:"service,omitempty" default:"any"` // @gotags: default:"any"
}

func (x *ServiceSelector) Reset() {
	*x = ServiceSelector{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ServiceSelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServiceSelector) ProtoMessage() {}

func (x *ServiceSelector) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServiceSelector.ProtoReflect.Descriptor instead.
func (*ServiceSelector) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{1}
}

func (x *ServiceSelector) GetAgentGroup() string {
	if x != nil {
		return x.AgentGroup
	}
	return ""
}

func (x *ServiceSelector) GetService() string {
	if x != nil {
		return x.Service
	}
	return ""
}

// Describes which flows a [flow control
// component](/concepts/flow-control/flow-control.md#components) should apply
// to
//
// :::info
//
// See also [FlowSelector overview](/concepts/flow-control/flow-selector.md).
//
// :::
// Example:
// ```yaml
// control_point: ingress
// label_matcher:
//
//	match_labels:
//	  user_tier: gold
//	match_expressions:
//	  - key: query
//	    operator: In
//	    values:
//	      - insert
//	      - delete
//	expression:
//	  label_matches:
//	      - label: user_agent
//	        regex: ^(?!.*Chrome).*Safari
//
// ```
type FlowMatcher struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// [Control Point](/concepts/flow-control/flow-selector.md#control-point)
	// identifies the location of a Flow within a Service. For an SDK based insertion, a Control Point can represent a particular feature or execution
	// block within a Service. In case of Service Mesh or Middleware insertion, a Control Point can identify ingress or egress calls or distinct listeners
	// or filter chains.
	ControlPoint string `protobuf:"bytes,1,opt,name=control_point,json=controlPoint,proto3" json:"control_point,omitempty" validate:"required"` // @gotags: validate:"required"
	// Label matcher allows to add _additional_ condition on
	// [flow labels](/concepts/flow-control/flow-label.md)
	// must also be satisfied (in addition to service+control point matching)
	//
	// :::info
	//
	// See also [Label Matcher overview](/concepts/flow-control/flow-selector.md#label-matcher).
	//
	// :::
	//
	// :::note
	//
	// [Classifiers](#classifier) _can_ use flow labels created by some other
	// classifier, but only if they were created at some previous control point
	// (and propagated in baggage).
	//
	// This limitation does not apply to selectors of other entities, like
	// Flux Meters or Actuators. It's valid to create a flow label on a control
	// point using classifier, and immediately use it for matching on the same
	// control point.
	//
	// :::
	LabelMatcher *LabelMatcher `protobuf:"bytes,2,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty"`
}

func (x *FlowMatcher) Reset() {
	*x = FlowMatcher{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FlowMatcher) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowMatcher) ProtoMessage() {}

func (x *FlowMatcher) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowMatcher.ProtoReflect.Descriptor instead.
func (*FlowMatcher) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{2}
}

func (x *FlowMatcher) GetControlPoint() string {
	if x != nil {
		return x.ControlPoint
	}
	return ""
}

func (x *FlowMatcher) GetLabelMatcher() *LabelMatcher {
	if x != nil {
		return x.LabelMatcher
	}
	return nil
}

// FlowControl Resources
type FlowControlResources struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Flux Meters are installed in the data-plane and form the observability leg of the feedback loop.
	//
	// Flux Meter created metrics can be consumed as input to the circuit through the PromQL component.
	FluxMeters map[string]*FluxMeter `protobuf:"bytes,1,rep,name=flux_meters,json=fluxMeters,proto3" json:"flux_meters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" validate:"dive"` // @gotags: validate:"dive"
	// Classifiers are installed in the data-plane and are used to label the requests based on payload content.
	//
	// The flow labels created by Classifiers can be matched by Flux Meters to create metrics for control purposes.
	Classifiers []*Classifier `protobuf:"bytes,2,rep,name=classifiers,proto3" json:"classifiers,omitempty" validate:"dive"` // @gotags: validate:"dive"
}

func (x *FlowControlResources) Reset() {
	*x = FlowControlResources{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FlowControlResources) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowControlResources) ProtoMessage() {}

func (x *FlowControlResources) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowControlResources.ProtoReflect.Descriptor instead.
func (*FlowControlResources) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{3}
}

func (x *FlowControlResources) GetFluxMeters() map[string]*FluxMeter {
	if x != nil {
		return x.FluxMeters
	}
	return nil
}

func (x *FlowControlResources) GetClassifiers() []*Classifier {
	if x != nil {
		return x.Classifiers
	}
	return nil
}

// Flux Meter gathers metrics for the traffic that matches its selector.
// The histogram created by Flux Meter measures the workload latency by default.
//
// :::info
//
// See also [Flux Meter overview](/concepts/flow-control/resources/flux-meter.md).
//
// :::
// Example:
// ```yaml
// static_buckets:
//
//	buckets: [5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]
//
// flow_selector:
//
//	service_selector:
//	   agent_group: demoapp
//	   service: service1-demo-app.demoapp.svc.cluster.local
//	flow_matcher:
//	   control_point: ingress
//
// attribute_key: response_duration_ms
// ```
type FluxMeter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The selection criteria for the traffic that will be measured.
	FlowSelector *FlowSelector `protobuf:"bytes,1,opt,name=flow_selector,json=flowSelector,proto3" json:"flow_selector,omitempty"`
	// Latency histogram buckets (in ms) for this Flux Meter.
	//
	// Types that are assignable to HistogramBuckets:
	//
	//	*FluxMeter_StaticBuckets_
	//	*FluxMeter_LinearBuckets_
	//	*FluxMeter_ExponentialBuckets_
	//	*FluxMeter_ExponentialBucketsRange_
	HistogramBuckets isFluxMeter_HistogramBuckets `protobuf_oneof:"histogram_buckets"`
	// Key of the attribute in access log or span from which the metric for this flux meter is read.
	//
	// :::info
	//
	// For list of available attributes in Envoy access logs, refer
	// [Envoy Filter](/get-started/integrations/flow-control/envoy/istio.md#envoy-filter)
	//
	// :::
	AttributeKey string `protobuf:"bytes,6,opt,name=attribute_key,json=attributeKey,proto3" json:"attribute_key,omitempty" default:"workload_duration_ms"` // @gotags: default:"workload_duration_ms"
}

func (x *FluxMeter) Reset() {
	*x = FluxMeter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter) ProtoMessage() {}

func (x *FluxMeter) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter.ProtoReflect.Descriptor instead.
func (*FluxMeter) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{4}
}

func (x *FluxMeter) GetFlowSelector() *FlowSelector {
	if x != nil {
		return x.FlowSelector
	}
	return nil
}

func (m *FluxMeter) GetHistogramBuckets() isFluxMeter_HistogramBuckets {
	if m != nil {
		return m.HistogramBuckets
	}
	return nil
}

func (x *FluxMeter) GetStaticBuckets() *FluxMeter_StaticBuckets {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_StaticBuckets_); ok {
		return x.StaticBuckets
	}
	return nil
}

func (x *FluxMeter) GetLinearBuckets() *FluxMeter_LinearBuckets {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_LinearBuckets_); ok {
		return x.LinearBuckets
	}
	return nil
}

func (x *FluxMeter) GetExponentialBuckets() *FluxMeter_ExponentialBuckets {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_ExponentialBuckets_); ok {
		return x.ExponentialBuckets
	}
	return nil
}

func (x *FluxMeter) GetExponentialBucketsRange() *FluxMeter_ExponentialBucketsRange {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_ExponentialBucketsRange_); ok {
		return x.ExponentialBucketsRange
	}
	return nil
}

func (x *FluxMeter) GetAttributeKey() string {
	if x != nil {
		return x.AttributeKey
	}
	return ""
}

type isFluxMeter_HistogramBuckets interface {
	isFluxMeter_HistogramBuckets()
}

type FluxMeter_StaticBuckets_ struct {
	StaticBuckets *FluxMeter_StaticBuckets `protobuf:"bytes,2,opt,name=static_buckets,json=staticBuckets,proto3,oneof"`
}

type FluxMeter_LinearBuckets_ struct {
	LinearBuckets *FluxMeter_LinearBuckets `protobuf:"bytes,3,opt,name=linear_buckets,json=linearBuckets,proto3,oneof"`
}

type FluxMeter_ExponentialBuckets_ struct {
	ExponentialBuckets *FluxMeter_ExponentialBuckets `protobuf:"bytes,4,opt,name=exponential_buckets,json=exponentialBuckets,proto3,oneof"`
}

type FluxMeter_ExponentialBucketsRange_ struct {
	ExponentialBucketsRange *FluxMeter_ExponentialBucketsRange `protobuf:"bytes,5,opt,name=exponential_buckets_range,json=exponentialBucketsRange,proto3,oneof"`
}

func (*FluxMeter_StaticBuckets_) isFluxMeter_HistogramBuckets() {}

func (*FluxMeter_LinearBuckets_) isFluxMeter_HistogramBuckets() {}

func (*FluxMeter_ExponentialBuckets_) isFluxMeter_HistogramBuckets() {}

func (*FluxMeter_ExponentialBucketsRange_) isFluxMeter_HistogramBuckets() {}

// Set of classification rules sharing a common selector
//
// :::info
//
// See also [Classifier overview](/concepts/flow-control/resources/classifier.md).
//
// :::
// Example
// ```yaml
// flow_selector:
//
//	service_selector:
//	   agent_group: demoapp
//	   service: service1-demo-app.demoapp.svc.cluster.local
//	flow_matcher:
//	   control_point: ingress
//	   label_matcher:
//	      match_labels:
//	        user_tier: gold
//	      match_expressions:
//	        - key: user_type
//	          operator: In
//
// rules:
//
//	user:
//	 extractor:
//	   from: request.http.headers.user-agent
//	telemetry: false
//
// ```
type Classifier struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Defines where to apply the flow classification rule.
	FlowSelector *FlowSelector `protobuf:"bytes,1,opt,name=flow_selector,json=flowSelector,proto3" json:"flow_selector,omitempty" validate:"required"` // @gotags: validate:"required"
	// A map of {key, value} pairs mapping from
	// [flow label](/concepts/flow-control/flow-label.md) keys to rules that define
	// how to extract and propagate flow labels with that key.
	Rules map[string]*Rule `protobuf:"bytes,2,rep,name=rules,proto3" json:"rules,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" validate:"dive,keys,required,endkeys,required"` // @gotags: validate:"dive,keys,required,endkeys,required"
	// Rego based classification
	//
	// Rego is a policy language used to express complex policies in a concise and declarative way.
	// It can be used to define flow classification rules by writing custom queries that extract values from request metadata.
	// For simple cases, such as directly reading a value from header or a field from JSON body, declarative extractors are recommended.
	Rego *Rego `protobuf:"bytes,3,opt,name=rego,proto3" json:"rego,omitempty"`
}

func (x *Classifier) Reset() {
	*x = Classifier{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Classifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Classifier) ProtoMessage() {}

func (x *Classifier) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Classifier.ProtoReflect.Descriptor instead.
func (*Classifier) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{5}
}

func (x *Classifier) GetFlowSelector() *FlowSelector {
	if x != nil {
		return x.FlowSelector
	}
	return nil
}

func (x *Classifier) GetRules() map[string]*Rule {
	if x != nil {
		return x.Rules
	}
	return nil
}

func (x *Classifier) GetRego() *Rego {
	if x != nil {
		return x.Rego
	}
	return nil
}

// Rule describes a single classification Rule
//
// Example of a JSON extractor:
// ```yaml
// extractor:
//
//	json:
//	  from: request.http.body
//	  pointer: /user/name
//
// ```
type Rule struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Source:
	//
	//	*Rule_Extractor
	//	*Rule_Rego_
	Source isRule_Source `protobuf_oneof:"source"`
	// Decides if the created flow label should be available as an attribute in OLAP telemetry and
	// propagated in [baggage](/concepts/flow-control/flow-label.md#baggage)
	//
	// :::note
	//
	// The flow label is always accessible in Aperture Policies regardless of this setting.
	//
	// :::
	//
	// :::caution
	//
	// When using [FluxNinja ARC extension](arc/extension.md), telemetry enabled
	// labels are sent to FluxNinja ARC for observability. Telemetry should be disabled for
	// sensitive labels.
	//
	// :::
	Telemetry bool `protobuf:"varint,3,opt,name=telemetry,proto3" json:"telemetry,omitempty" default:"true"` // @gotags: default:"true"
}

func (x *Rule) Reset() {
	*x = Rule{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Rule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rule) ProtoMessage() {}

func (x *Rule) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rule.ProtoReflect.Descriptor instead.
func (*Rule) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{6}
}

func (m *Rule) GetSource() isRule_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (x *Rule) GetExtractor() *Extractor {
	if x, ok := x.GetSource().(*Rule_Extractor); ok {
		return x.Extractor
	}
	return nil
}

func (x *Rule) GetRego() *Rule_Rego {
	if x, ok := x.GetSource().(*Rule_Rego_); ok {
		return x.Rego
	}
	return nil
}

func (x *Rule) GetTelemetry() bool {
	if x != nil {
		return x.Telemetry
	}
	return false
}

type isRule_Source interface {
	isRule_Source()
}

type Rule_Extractor struct {
	// High-level declarative extractor.
	Extractor *Extractor `protobuf:"bytes,1,opt,name=extractor,proto3,oneof"`
}

type Rule_Rego_ struct {
	// Rego module to extract a value from.
	//
	// Deprecated: 1.5.0
	Rego *Rule_Rego `protobuf:"bytes,2,opt,name=rego,proto3,oneof"`
}

func (*Rule_Extractor) isRule_Source() {}

func (*Rule_Rego_) isRule_Source() {}

// Rego define a set of labels that are extracted after evaluating a Rego module.
//
// :::info
//
// You can use the [live-preview](/concepts/flow-control/resources/classifier.md#live-previewing-requests) feature to first preview the input to the classifier before writing the labeling logic.
//
// :::
//
// :::info
//
// Special Rego variables:
// - `data.<package>.tokens`: Number of tokens for this request. This value is used by rate limiters and concurrency limiters when making decisions. The value provided here will override any value provided in the policy configuration for the workload. When this label is provided, it is not emitted as part of flow labels or telemetry and is solely used while processing the request.
//
// :::
//
// Example of Rego module which also disables telemetry visibility of label:
// ```yaml
// rego:
//
//	labels:
//	  user:
//	    telemetry: false
//	module: |
//	  package user_from_cookie
//	  cookies := split(input.attributes.request.http.headers.cookie, "; ")
//	  user := user {
//	      cookie := cookies[_]
//	      startswith(cookie, "session=")
//	      session := substring(cookie, count("session="), -1)
//	      parts := split(session, ".")
//	      object := json.unmarshal(base64url.decode(parts[0]))
//	      user := object.user
//	  }
//
// ```
type Rego struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A map of {key, value} pairs mapping from
	// [flow label](/concepts/flow-control/flow-label.md) keys to queries that define
	// how to extract and propagate flow labels with that key.
	// The name of the label maps to a variable in the Rego module. It maps to `data.<package>.<label>` variable.
	Labels map[string]*Rego_LabelProperties `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" validate:"required,gt=0,dive,keys,required,endkeys,required"` // @gotags: validate:"required,gt=0,dive,keys,required,endkeys,required"
	// Source code of the Rego module.
	//
	// :::Note
	//
	// Must include a "package" declaration.
	//
	// :::
	Module string `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *Rego) Reset() {
	*x = Rego{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Rego) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rego) ProtoMessage() {}

func (x *Rego) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rego.ProtoReflect.Descriptor instead.
func (*Rego) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{7}
}

func (x *Rego) GetLabels() map[string]*Rego_LabelProperties {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Rego) GetModule() string {
	if x != nil {
		return x.Module
	}
	return ""
}

// Defines a high-level way to specify how to extract a flow label value given HTTP request metadata, without a need to write Rego code
//
// There are multiple variants of extractor, specify exactly one.
type Extractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Variant:
	//
	//	*Extractor_From
	//	*Extractor_Json
	//	*Extractor_Address
	//	*Extractor_Jwt
	//	*Extractor_PathTemplates
	Variant isExtractor_Variant `protobuf_oneof:"variant"`
}

func (x *Extractor) Reset() {
	*x = Extractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Extractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Extractor) ProtoMessage() {}

func (x *Extractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Extractor.ProtoReflect.Descriptor instead.
func (*Extractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{8}
}

func (m *Extractor) GetVariant() isExtractor_Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

func (x *Extractor) GetFrom() string {
	if x, ok := x.GetVariant().(*Extractor_From); ok {
		return x.From
	}
	return ""
}

func (x *Extractor) GetJson() *JSONExtractor {
	if x, ok := x.GetVariant().(*Extractor_Json); ok {
		return x.Json
	}
	return nil
}

func (x *Extractor) GetAddress() *AddressExtractor {
	if x, ok := x.GetVariant().(*Extractor_Address); ok {
		return x.Address
	}
	return nil
}

func (x *Extractor) GetJwt() *JWTExtractor {
	if x, ok := x.GetVariant().(*Extractor_Jwt); ok {
		return x.Jwt
	}
	return nil
}

func (x *Extractor) GetPathTemplates() *PathTemplateMatcher {
	if x, ok := x.GetVariant().(*Extractor_PathTemplates); ok {
		return x.PathTemplates
	}
	return nil
}

type isExtractor_Variant interface {
	isExtractor_Variant()
}

type Extractor_From struct {
	// Use an attribute with no conversion
	//
	// Attribute path is a dot-separated path to attribute.
	//
	// Should be either:
	// * one of the fields of [Attribute Context](https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/attribute_context.proto), or
	// * a special `request.http.bearer` pseudo-attribute.
	// For example, `request.http.method` or `request.http.header.user-agent`
	//
	// Note: The same attribute path syntax is shared by other extractor variants,
	// wherever attribute path is needed in their "from" syntax.
	//
	// Example:
	// ```yaml
	// from: request.http.headers.user-agent
	// ```
	From string `protobuf:"bytes,1,opt,name=from,proto3,oneof"`
}

type Extractor_Json struct {
	// Parse JSON, and extract one of the fields.
	Json *JSONExtractor `protobuf:"bytes,2,opt,name=json,proto3,oneof"`
}

type Extractor_Address struct {
	// Display an address as a single string - `<ip>:<port>`.
	Address *AddressExtractor `protobuf:"bytes,3,opt,name=address,proto3,oneof"`
}

type Extractor_Jwt struct {
	// Parse the attribute as JWT and read the payload.
	Jwt *JWTExtractor `protobuf:"bytes,4,opt,name=jwt,proto3,oneof"`
}

type Extractor_PathTemplates struct {
	// Match HTTP Path to given path templates.
	PathTemplates *PathTemplateMatcher `protobuf:"bytes,5,opt,name=path_templates,json=pathTemplates,proto3,oneof"`
}

func (*Extractor_From) isExtractor_Variant() {}

func (*Extractor_Json) isExtractor_Variant() {}

func (*Extractor_Address) isExtractor_Variant() {}

func (*Extractor_Jwt) isExtractor_Variant() {}

func (*Extractor_PathTemplates) isExtractor_Variant() {}

// Parse JSON, and extract one of the fields
//
// Example:
// ```yaml
// from: request.http.body
// pointer: /user/name
// ```
type JSONExtractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Attribute path pointing to some strings - for example, `request.http.body`.
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" validate:"required"` //@gotags: validate:"required"
	// JSON pointer represents a parsed JSON pointer which allows to select a specified field from the payload.
	//
	// Note: Uses [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,
	// for example, `/foo/bar`. If the pointer points into an object, it'd be converted to a string.
	Pointer string `protobuf:"bytes,2,opt,name=pointer,proto3" json:"pointer,omitempty"`
}

func (x *JSONExtractor) Reset() {
	*x = JSONExtractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *JSONExtractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JSONExtractor) ProtoMessage() {}

func (x *JSONExtractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JSONExtractor.ProtoReflect.Descriptor instead.
func (*JSONExtractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{9}
}

func (x *JSONExtractor) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *JSONExtractor) GetPointer() string {
	if x != nil {
		return x.Pointer
	}
	return ""
}

// Display an [Address][ext-authz-address] as a single string, for example, `<ip>:<port>`
//
// IP addresses in attribute context are defined as objects with separate IP and port fields.
// This is a helper to display an address as a single string.
//
// :::caution
//
// This might introduce high-cardinality flow label values.
//
// :::
//
// Example:
// ```yaml
// from: "source.address # or destination.address"
// ```
//
// [ext-authz-address]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address
type AddressExtractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Attribute path pointing to some string - for example, `source.address`.
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" validate:"required"` //@gotags: validate:"required"
}

func (x *AddressExtractor) Reset() {
	*x = AddressExtractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddressExtractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddressExtractor) ProtoMessage() {}

func (x *AddressExtractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddressExtractor.ProtoReflect.Descriptor instead.
func (*AddressExtractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{10}
}

func (x *AddressExtractor) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

// Parse the attribute as JWT and read the payload
//
// Specify a field to be extracted from payload using `json_pointer`.
//
// Note: The signature is not verified against the secret (assuming there's some
// other part of the system that handles such verification).
//
// Example:
// ```yaml
// from: request.http.bearer
// json_pointer: /user/email
// ```
type JWTExtractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// JWT (JSON Web Token) can be extracted from any input attribute, but most likely you'd want to use `request.http.bearer`.
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" validate:"required"` //@gotags: validate:"required"
	// JSON pointer allowing to select a specified field from the payload.
	//
	// Note: Uses [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,
	// for example, `/foo/bar`. If the pointer points into an object, it'd be converted to a string.
	JsonPointer string `protobuf:"bytes,2,opt,name=json_pointer,json=jsonPointer,proto3" json:"json_pointer,omitempty"`
}

func (x *JWTExtractor) Reset() {
	*x = JWTExtractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *JWTExtractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JWTExtractor) ProtoMessage() {}

func (x *JWTExtractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JWTExtractor.ProtoReflect.Descriptor instead.
func (*JWTExtractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{11}
}

func (x *JWTExtractor) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *JWTExtractor) GetJsonPointer() string {
	if x != nil {
		return x.JsonPointer
	}
	return ""
}

// Matches HTTP Path to given path templates
//
// HTTP path will be matched against given path templates.
// If a match occurs, the value associated with the path template will be treated as a result.
// In case of multiple path templates matching, the most specific one will be chosen.
type PathTemplateMatcher struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Template value keys are OpenAPI-inspired path templates.
	//
	//   - Static path segment `/foo` matches a path segment exactly
	//   - `/{param}` matches arbitrary path segment.
	//     (The parameter name is ignored and can be omitted (`{}`))
	//   - The parameter must cover whole segment.
	//   - Additionally, path template can end with `/*` wildcard to match
	//     arbitrary number of trailing segments (0 or more).
	//   - Multiple consecutive `/` are ignored, as well as trailing `/`.
	//   - Parametrized path segments must come after static segments.
	//   - `*`, if present, must come last.
	//   - Most specific template "wins" (`/foo` over `/{}` and `/{}` over `/*`).
	//
	// See also <https://swagger.io/specification/#path-templating-matching>
	//
	// Example:
	// ```yaml
	// /register: register
	// "/user/{userId}": user
	// /static/*: other
	// ```
	TemplateValues map[string]string `protobuf:"bytes,1,rep,name=template_values,json=templateValues,proto3" json:"template_values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" validate:"gt=0,dive,keys,required,endkeys,required"` // @gotags: validate:"gt=0,dive,keys,required,endkeys,required"
}

func (x *PathTemplateMatcher) Reset() {
	*x = PathTemplateMatcher{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PathTemplateMatcher) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PathTemplateMatcher) ProtoMessage() {}

func (x *PathTemplateMatcher) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PathTemplateMatcher.ProtoReflect.Descriptor instead.
func (*PathTemplateMatcher) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{12}
}

func (x *PathTemplateMatcher) GetTemplateValues() map[string]string {
	if x != nil {
		return x.TemplateValues
	}
	return nil
}

// FlowControl components are used to regulate requests flow.
type FlowControl struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Component:
	//
	//	*FlowControl_RateLimiter
	//	*FlowControl_ConcurrencyLimiter
	//	*FlowControl_AimdConcurrencyController
	//	*FlowControl_FlowRegulator
	//	*FlowControl_LoadShaper
	//	*FlowControl_LoadShaperSeries
	Component isFlowControl_Component `protobuf_oneof:"component"`
}

func (x *FlowControl) Reset() {
	*x = FlowControl{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FlowControl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowControl) ProtoMessage() {}

func (x *FlowControl) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowControl.ProtoReflect.Descriptor instead.
func (*FlowControl) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{13}
}

func (m *FlowControl) GetComponent() isFlowControl_Component {
	if m != nil {
		return m.Component
	}
	return nil
}

func (x *FlowControl) GetRateLimiter() *RateLimiter {
	if x, ok := x.GetComponent().(*FlowControl_RateLimiter); ok {
		return x.RateLimiter
	}
	return nil
}

func (x *FlowControl) GetConcurrencyLimiter() *ConcurrencyLimiter {
	if x, ok := x.GetComponent().(*FlowControl_ConcurrencyLimiter); ok {
		return x.ConcurrencyLimiter
	}
	return nil
}

func (x *FlowControl) GetAimdConcurrencyController() *AIMDConcurrencyController {
	if x, ok := x.GetComponent().(*FlowControl_AimdConcurrencyController); ok {
		return x.AimdConcurrencyController
	}
	return nil
}

func (x *FlowControl) GetFlowRegulator() *FlowRegulator {
	if x, ok := x.GetComponent().(*FlowControl_FlowRegulator); ok {
		return x.FlowRegulator
	}
	return nil
}

func (x *FlowControl) GetLoadShaper() *LoadShaper {
	if x, ok := x.GetComponent().(*FlowControl_LoadShaper); ok {
		return x.LoadShaper
	}
	return nil
}

func (x *FlowControl) GetLoadShaperSeries() *LoadShaperSeries {
	if x, ok := x.GetComponent().(*FlowControl_LoadShaperSeries); ok {
		return x.LoadShaperSeries
	}
	return nil
}

type isFlowControl_Component interface {
	isFlowControl_Component()
}

type FlowControl_RateLimiter struct {
	// _Rate Limiter_ provides service protection by applying rate limiter.
	RateLimiter *RateLimiter `protobuf:"bytes,1,opt,name=rate_limiter,json=rateLimiter,proto3,oneof"`
}

type FlowControl_ConcurrencyLimiter struct {
	// _Concurrency Limiter_ provides service protection by applying prioritized load shedding of flows using a network scheduler (for example, Weighted Fair Queuing).
	ConcurrencyLimiter *ConcurrencyLimiter `protobuf:"bytes,2,opt,name=concurrency_limiter,json=concurrencyLimiter,proto3,oneof"`
}

type FlowControl_AimdConcurrencyController struct {
	// AIMD Concurrency control component is based on Additive Increase and Multiplicative Decrease of Concurrency. It takes a signal and setpoint as inputs and reduces concurrency limits proportionally (or any arbitrary power) based on deviation of the signal from setpoint. Internally implemented as a nested circuit.
	AimdConcurrencyController *AIMDConcurrencyController `protobuf:"bytes,3,opt,name=aimd_concurrency_controller,json=aimdConcurrencyController,proto3,oneof"`
}

type FlowControl_FlowRegulator struct {
	// Flow Regulator is a component that regulates the flow of requests to the service by allowing only the specified percentage of requests or sticky sessions.
	FlowRegulator *FlowRegulator `protobuf:"bytes,4,opt,name=flow_regulator,json=flowRegulator,proto3,oneof"`
}

type FlowControl_LoadShaper struct {
	// LoadShaper is a component that shapes the load of the service.
	LoadShaper *LoadShaper `protobuf:"bytes,5,opt,name=load_shaper,json=loadShaper,proto3,oneof"`
}

type FlowControl_LoadShaperSeries struct {
	// LoadShaperSeries is a series of LoadShaper components that shape load one after another in series.
	LoadShaperSeries *LoadShaperSeries `protobuf:"bytes,6,opt,name=load_shaper_series,json=loadShaperSeries,proto3,oneof"`
}

func (*FlowControl_RateLimiter) isFlowControl_Component() {}

func (*FlowControl_ConcurrencyLimiter) isFlowControl_Component() {}

func (*FlowControl_AimdConcurrencyController) isFlowControl_Component() {}

func (*FlowControl_FlowRegulator) isFlowControl_Component() {}

func (*FlowControl_LoadShaper) isFlowControl_Component() {}

func (*FlowControl_LoadShaperSeries) isFlowControl_Component() {}

// Limits the traffic on a control point to specified rate
//
// :::info
//
// See also [_Rate Limiter_ overview](/concepts/flow-control/components/rate-limiter.md).
//
// :::
//
// RateLimiting is done on per-label-value basis. Use `label_key`
// to select which label should be used as key.
type RateLimiter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the RateLimiter component
	InPorts *RateLimiter_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty" validate:"required"` // @gotags: validate:"required"
	// Which control point to apply this rate limiter to.
	FlowSelector *FlowSelector `protobuf:"bytes,2,opt,name=flow_selector,json=flowSelector,proto3" json:"flow_selector,omitempty" validate:"required"` // @gotags: validate:"required"
	// Parameters for the RateLimiter component
	Parameters *RateLimiter_Parameters `protobuf:"bytes,3,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Configuration key for DynamicConfig
	DynamicConfigKey string `protobuf:"bytes,4,opt,name=dynamic_config_key,json=dynamicConfigKey,proto3" json:"dynamic_config_key,omitempty"`
	// Default configuration
	DefaultConfig *RateLimiter_DynamicConfig `protobuf:"bytes,5,opt,name=default_config,json=defaultConfig,proto3" json:"default_config,omitempty"`
}

func (x *RateLimiter) Reset() {
	*x = RateLimiter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter) ProtoMessage() {}

func (x *RateLimiter) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter.ProtoReflect.Descriptor instead.
func (*RateLimiter) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{14}
}

func (x *RateLimiter) GetInPorts() *RateLimiter_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *RateLimiter) GetFlowSelector() *FlowSelector {
	if x != nil {
		return x.FlowSelector
	}
	return nil
}

func (x *RateLimiter) GetParameters() *RateLimiter_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *RateLimiter) GetDynamicConfigKey() string {
	if x != nil {
		return x.DynamicConfigKey
	}
	return ""
}

func (x *RateLimiter) GetDefaultConfig() *RateLimiter_DynamicConfig {
	if x != nil {
		return x.DefaultConfig
	}
	return nil
}

// _Concurrency Limiter_ is an actuator component that regulates flows to provide active service protection
//
// :::info
//
// See also [_Concurrency Limiter_ overview](/concepts/flow-control/components/concurrency-limiter.md).
//
// :::
//
// It's based on the actuation strategy (for example, load actuator) and workload scheduling which is based on Weighted Fair Queuing principles.
// Concurrency is calculated in terms of total tokens which translate to (avg. latency \* in-flight requests) (Little's Law).
//
// ConcurrencyLimiter configuration is split into two parts: An actuation
// strategy and a scheduler. At this time, only `load_actuator` strategy is available.
type ConcurrencyLimiter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Flow Selector decides the service and flows at which the concurrency limiter is applied.
	FlowSelector *FlowSelector `protobuf:"bytes,1,opt,name=flow_selector,json=flowSelector,proto3" json:"flow_selector,omitempty" validate:"required"` // @gotags: validate:"required"
	// Configuration of Weighted Fair Queuing-based workload scheduler.
	//
	// Contains configuration of per-agent scheduler, and also defines some
	// output signals.
	Scheduler *Scheduler `protobuf:"bytes,2,opt,name=scheduler,proto3" json:"scheduler,omitempty" validate:"required"` // @gotags: validate:"required"
	// Types that are assignable to ActuationStrategy:
	//
	//	*ConcurrencyLimiter_LoadActuator
	ActuationStrategy isConcurrencyLimiter_ActuationStrategy `protobuf_oneof:"actuation_strategy"`
}

func (x *ConcurrencyLimiter) Reset() {
	*x = ConcurrencyLimiter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ConcurrencyLimiter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConcurrencyLimiter) ProtoMessage() {}

func (x *ConcurrencyLimiter) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConcurrencyLimiter.ProtoReflect.Descriptor instead.
func (*ConcurrencyLimiter) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{15}
}

func (x *ConcurrencyLimiter) GetFlowSelector() *FlowSelector {
	if x != nil {
		return x.FlowSelector
	}
	return nil
}

func (x *ConcurrencyLimiter) GetScheduler() *Scheduler {
	if x != nil {
		return x.Scheduler
	}
	return nil
}

func (m *ConcurrencyLimiter) GetActuationStrategy() isConcurrencyLimiter_ActuationStrategy {
	if m != nil {
		return m.ActuationStrategy
	}
	return nil
}

func (x *ConcurrencyLimiter) GetLoadActuator() *LoadActuator {
	if x, ok := x.GetActuationStrategy().(*ConcurrencyLimiter_LoadActuator); ok {
		return x.LoadActuator
	}
	return nil
}

type isConcurrencyLimiter_ActuationStrategy interface {
	isConcurrencyLimiter_ActuationStrategy()
}

type ConcurrencyLimiter_LoadActuator struct {
	// Actuator based on limiting the accepted concurrency under incoming concurrency * load multiplier.
	//
	// Actuation strategy defines the input signal that will drive the scheduler.
	LoadActuator *LoadActuator `protobuf:"bytes,3,opt,name=load_actuator,json=loadActuator,proto3,oneof"`
}

func (*ConcurrencyLimiter_LoadActuator) isConcurrencyLimiter_ActuationStrategy() {}

// Weighted Fair Queuing-based workload scheduler
//
// :::note
//
// Each Agent instantiates an independent copy of the scheduler, but output
// signals for accepted and incoming concurrency are aggregated across all agents.
//
// :::
//
// See [ConcurrencyLimiter](#concurrency-limiter) for more context.
type Scheduler struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Output ports for the Scheduler component.
	OutPorts *Scheduler_Outs `protobuf:"bytes,1,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
	// Scheduler parameters.
	Parameters *Scheduler_Parameters `protobuf:"bytes,2,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *Scheduler) Reset() {
	*x = Scheduler{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler) ProtoMessage() {}

func (x *Scheduler) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler.ProtoReflect.Descriptor instead.
func (*Scheduler) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{16}
}

func (x *Scheduler) GetOutPorts() *Scheduler_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

func (x *Scheduler) GetParameters() *Scheduler_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

// Takes the load multiplier input signal and publishes it to the schedulers in the data-plane
type LoadActuator struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the Load Actuator component.
	InPorts *LoadActuator_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty"`
	// Configuration key for DynamicConfig.
	DynamicConfigKey string `protobuf:"bytes,2,opt,name=dynamic_config_key,json=dynamicConfigKey,proto3" json:"dynamic_config_key,omitempty"`
	// Default configuration.
	DefaultConfig *LoadActuator_DynamicConfig `protobuf:"bytes,3,opt,name=default_config,json=defaultConfig,proto3" json:"default_config,omitempty"`
}

func (x *LoadActuator) Reset() {
	*x = LoadActuator{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadActuator) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadActuator) ProtoMessage() {}

func (x *LoadActuator) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadActuator.ProtoReflect.Descriptor instead.
func (*LoadActuator) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{17}
}

func (x *LoadActuator) GetInPorts() *LoadActuator_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *LoadActuator) GetDynamicConfigKey() string {
	if x != nil {
		return x.DynamicConfigKey
	}
	return ""
}

func (x *LoadActuator) GetDefaultConfig() *LoadActuator_DynamicConfig {
	if x != nil {
		return x.DefaultConfig
	}
	return nil
}

// High level concurrency control component. Baselines a signal using exponential moving average and applies concurrency limits based on deviation of signal from the baseline. Internally implemented as a nested circuit.
type AIMDConcurrencyController struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the AIMDConcurrencyController component.
	InPorts *AIMDConcurrencyController_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty"`
	// Output ports for the AIMDConcurrencyController component.
	OutPorts *AIMDConcurrencyController_Outs `protobuf:"bytes,2,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
	// Flow Selector decides the service and flows at which the concurrency limiter is applied.
	FlowSelector *FlowSelector `protobuf:"bytes,3,opt,name=flow_selector,json=flowSelector,proto3" json:"flow_selector,omitempty" validate:"required"` // @gotags: validate:"required"
	// Scheduler parameters.
	SchedulerParameters *Scheduler_Parameters `protobuf:"bytes,4,opt,name=scheduler_parameters,json=schedulerParameters,proto3" json:"scheduler_parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Gradient parameters for the controller.
	GradientParameters *GradientController_Parameters `protobuf:"bytes,5,opt,name=gradient_parameters,json=gradientParameters,proto3" json:"gradient_parameters,omitempty"`
	// Current accepted concurrency is multiplied with this number to dynamically calculate the upper concurrency limit of a Service during normal (non-overload) state. This protects the Service from sudden spikes.
	MaxLoadMultiplier float64 `protobuf:"fixed64,6,opt,name=max_load_multiplier,json=maxLoadMultiplier,proto3" json:"max_load_multiplier,omitempty" default:"2.0"` // @gotags: default:"2.0"
	// Linear increment to load multiplier in each execution tick when the system is not in overloaded state.
	LoadMultiplierLinearIncrement float64 `protobuf:"fixed64,7,opt,name=load_multiplier_linear_increment,json=loadMultiplierLinearIncrement,proto3" json:"load_multiplier_linear_increment,omitempty" default:"0.0025"` // @gotags: default:"0.0025"
	// Configuration for embedded Alerter.
	AlerterParameters *Alerter_Parameters `protobuf:"bytes,8,opt,name=alerter_parameters,json=alerterParameters,proto3" json:"alerter_parameters,omitempty"`
	// Dynamic configuration key for load actuation.
	DynamicConfigKey string `protobuf:"bytes,9,opt,name=dynamic_config_key,json=dynamicConfigKey,proto3" json:"dynamic_config_key,omitempty"`
	// Default configuration.
	DefaultConfig *LoadActuator_DynamicConfig `protobuf:"bytes,10,opt,name=default_config,json=defaultConfig,proto3" json:"default_config,omitempty"`
}

func (x *AIMDConcurrencyController) Reset() {
	*x = AIMDConcurrencyController{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AIMDConcurrencyController) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AIMDConcurrencyController) ProtoMessage() {}

func (x *AIMDConcurrencyController) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AIMDConcurrencyController.ProtoReflect.Descriptor instead.
func (*AIMDConcurrencyController) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{18}
}

func (x *AIMDConcurrencyController) GetInPorts() *AIMDConcurrencyController_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *AIMDConcurrencyController) GetOutPorts() *AIMDConcurrencyController_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

func (x *AIMDConcurrencyController) GetFlowSelector() *FlowSelector {
	if x != nil {
		return x.FlowSelector
	}
	return nil
}

func (x *AIMDConcurrencyController) GetSchedulerParameters() *Scheduler_Parameters {
	if x != nil {
		return x.SchedulerParameters
	}
	return nil
}

func (x *AIMDConcurrencyController) GetGradientParameters() *GradientController_Parameters {
	if x != nil {
		return x.GradientParameters
	}
	return nil
}

func (x *AIMDConcurrencyController) GetMaxLoadMultiplier() float64 {
	if x != nil {
		return x.MaxLoadMultiplier
	}
	return 0
}

func (x *AIMDConcurrencyController) GetLoadMultiplierLinearIncrement() float64 {
	if x != nil {
		return x.LoadMultiplierLinearIncrement
	}
	return 0
}

func (x *AIMDConcurrencyController) GetAlerterParameters() *Alerter_Parameters {
	if x != nil {
		return x.AlerterParameters
	}
	return nil
}

func (x *AIMDConcurrencyController) GetDynamicConfigKey() string {
	if x != nil {
		return x.DynamicConfigKey
	}
	return ""
}

func (x *AIMDConcurrencyController) GetDefaultConfig() *LoadActuator_DynamicConfig {
	if x != nil {
		return x.DefaultConfig
	}
	return nil
}

// _Flow Regulator_ is a component that regulates the flow of requests to the service by allowing only the specified percentage of requests or sticky sessions.
type FlowRegulator struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the _Flow Regulator_.
	InPorts *FlowRegulator_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty"`
	// Parameters for the _Flow Regulator_.
	Parameters *FlowRegulator_Parameters `protobuf:"bytes,2,opt,name=parameters,proto3" json:"parameters,omitempty"`
	// Configuration key for DynamicConfig.
	DynamicConfigKey string `protobuf:"bytes,3,opt,name=dynamic_config_key,json=dynamicConfigKey,proto3" json:"dynamic_config_key,omitempty"`
	// Default configuration.
	DefaultConfig *FlowRegulator_DynamicConfig `protobuf:"bytes,4,opt,name=default_config,json=defaultConfig,proto3" json:"default_config,omitempty"`
}

func (x *FlowRegulator) Reset() {
	*x = FlowRegulator{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FlowRegulator) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowRegulator) ProtoMessage() {}

func (x *FlowRegulator) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowRegulator.ProtoReflect.Descriptor instead.
func (*FlowRegulator) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{19}
}

func (x *FlowRegulator) GetInPorts() *FlowRegulator_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *FlowRegulator) GetParameters() *FlowRegulator_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *FlowRegulator) GetDynamicConfigKey() string {
	if x != nil {
		return x.DynamicConfigKey
	}
	return ""
}

func (x *FlowRegulator) GetDefaultConfig() *FlowRegulator_DynamicConfig {
	if x != nil {
		return x.DefaultConfig
	}
	return nil
}

// The _Load Shaper_ produces a smooth and continuous traffic load
// that changes progressively over time, based on the specified steps.
//
// Each step is defined by two parameters:
//   - The `target_accept_percentage`.
//   - The `duration` for the signal to change from the
//     previous step's `target_accept_percentage` to the current step's
//     `target_accept_percentage`.
//
// The percentage of requests accepted starts at the `target_accept_percentage`
// defined in the first step and gradually ramps up or down linearly from
// the previous step's `target_accept_percentage` to the next
// `target_accept_percentage`, over the `duration` specified for each step.
type LoadShaper struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	InPorts    *LoadShaper_Ins        `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty"`
	OutPorts   *LoadShaper_Outs       `protobuf:"bytes,2,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
	Parameters *LoadShaper_Parameters `protobuf:"bytes,3,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Dynamic configuration key for flow regulator.
	DynamicConfigKey string `protobuf:"bytes,9,opt,name=dynamic_config_key,json=dynamicConfigKey,proto3" json:"dynamic_config_key,omitempty"`
	// Default configuration.
	DefaultConfig *FlowRegulator_DynamicConfig `protobuf:"bytes,10,opt,name=default_config,json=defaultConfig,proto3" json:"default_config,omitempty"`
}

func (x *LoadShaper) Reset() {
	*x = LoadShaper{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadShaper) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadShaper) ProtoMessage() {}

func (x *LoadShaper) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadShaper.ProtoReflect.Descriptor instead.
func (*LoadShaper) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{20}
}

func (x *LoadShaper) GetInPorts() *LoadShaper_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *LoadShaper) GetOutPorts() *LoadShaper_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

func (x *LoadShaper) GetParameters() *LoadShaper_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *LoadShaper) GetDynamicConfigKey() string {
	if x != nil {
		return x.DynamicConfigKey
	}
	return ""
}

func (x *LoadShaper) GetDefaultConfig() *FlowRegulator_DynamicConfig {
	if x != nil {
		return x.DefaultConfig
	}
	return nil
}

// _LoadShaperSeries_ is a component that applies a series of _Load Shapers_ in order.
type LoadShaperSeries struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	InPorts    *LoadShaperSeries_Ins        `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty"`
	Parameters *LoadShaperSeries_Parameters `protobuf:"bytes,2,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *LoadShaperSeries) Reset() {
	*x = LoadShaperSeries{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadShaperSeries) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadShaperSeries) ProtoMessage() {}

func (x *LoadShaperSeries) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadShaperSeries.ProtoReflect.Descriptor instead.
func (*LoadShaperSeries) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{21}
}

func (x *LoadShaperSeries) GetInPorts() *LoadShaperSeries_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *LoadShaperSeries) GetParameters() *LoadShaperSeries_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

// StaticBuckets holds the static value of the buckets where latency histogram will be stored.
type FluxMeter_StaticBuckets struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The buckets in which latency histogram will be stored.
	Buckets []float64 `protobuf:"fixed64,1,rep,packed,name=buckets,proto3" json:"buckets,omitempty" default:"[5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]"` // @gotags: default:"[5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]"
}

func (x *FluxMeter_StaticBuckets) Reset() {
	*x = FluxMeter_StaticBuckets{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_StaticBuckets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_StaticBuckets) ProtoMessage() {}

func (x *FluxMeter_StaticBuckets) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_StaticBuckets.ProtoReflect.Descriptor instead.
func (*FluxMeter_StaticBuckets) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{4, 0}
}

func (x *FluxMeter_StaticBuckets) GetBuckets() []float64 {
	if x != nil {
		return x.Buckets
	}
	return nil
}

// LinearBuckets creates `count` number of buckets, each `width` wide, where the lowest bucket has an
// upper bound of `start`. The final +inf bucket is not counted.
type FluxMeter_LinearBuckets struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Upper bound of the lowest bucket.
	Start float64 `protobuf:"fixed64,1,opt,name=start,proto3" json:"start,omitempty"`
	// Width of each bucket.
	Width float64 `protobuf:"fixed64,2,opt,name=width,proto3" json:"width,omitempty"`
	// Number of buckets.
	Count int32 `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty" validate:"gt=0"` // @gotags: validate:"gt=0"
}

func (x *FluxMeter_LinearBuckets) Reset() {
	*x = FluxMeter_LinearBuckets{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_LinearBuckets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_LinearBuckets) ProtoMessage() {}

func (x *FluxMeter_LinearBuckets) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_LinearBuckets.ProtoReflect.Descriptor instead.
func (*FluxMeter_LinearBuckets) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{4, 1}
}

func (x *FluxMeter_LinearBuckets) GetStart() float64 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *FluxMeter_LinearBuckets) GetWidth() float64 {
	if x != nil {
		return x.Width
	}
	return 0
}

func (x *FluxMeter_LinearBuckets) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

// ExponentialBuckets creates `count` number of buckets where the lowest bucket has an upper bound of `start`
// and each following bucket's upper bound is `factor` times the previous bucket's upper bound. The final +inf
// bucket is not counted.
type FluxMeter_ExponentialBuckets struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Upper bound of the lowest bucket.
	Start float64 `protobuf:"fixed64,1,opt,name=start,proto3" json:"start,omitempty" validate:"gt=0.0"` // @gotags: validate:"gt=0.0"
	// Factor to be multiplied to the previous bucket's upper bound to calculate the following bucket's upper bound.
	Factor float64 `protobuf:"fixed64,2,opt,name=factor,proto3" json:"factor,omitempty" validate:"gt=1.0"` // @gotags: validate:"gt=1.0"
	// Number of buckets.
	Count int32 `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty" validate:"gt=0"` // @gotags: validate:"gt=0"
}

func (x *FluxMeter_ExponentialBuckets) Reset() {
	*x = FluxMeter_ExponentialBuckets{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_ExponentialBuckets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_ExponentialBuckets) ProtoMessage() {}

func (x *FluxMeter_ExponentialBuckets) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_ExponentialBuckets.ProtoReflect.Descriptor instead.
func (*FluxMeter_ExponentialBuckets) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{4, 2}
}

func (x *FluxMeter_ExponentialBuckets) GetStart() float64 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *FluxMeter_ExponentialBuckets) GetFactor() float64 {
	if x != nil {
		return x.Factor
	}
	return 0
}

func (x *FluxMeter_ExponentialBuckets) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

// ExponentialBucketsRange creates `count` number of buckets where the lowest bucket is `min` and the highest
// bucket is `max`. The final +inf bucket is not counted.
type FluxMeter_ExponentialBucketsRange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Lowest bucket.
	Min float64 `protobuf:"fixed64,1,opt,name=min,proto3" json:"min,omitempty" validate:"gt=0.0"` // @gotags: validate:"gt=0.0"
	// Highest bucket.
	Max float64 `protobuf:"fixed64,2,opt,name=max,proto3" json:"max,omitempty"`
	// Number of buckets.
	Count int32 `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty" validate:"gt=0"` // @gotags: validate:"gt=0"
}

func (x *FluxMeter_ExponentialBucketsRange) Reset() {
	*x = FluxMeter_ExponentialBucketsRange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_ExponentialBucketsRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_ExponentialBucketsRange) ProtoMessage() {}

func (x *FluxMeter_ExponentialBucketsRange) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_ExponentialBucketsRange.ProtoReflect.Descriptor instead.
func (*FluxMeter_ExponentialBucketsRange) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{4, 3}
}

func (x *FluxMeter_ExponentialBucketsRange) GetMin() float64 {
	if x != nil {
		return x.Min
	}
	return 0
}

func (x *FluxMeter_ExponentialBucketsRange) GetMax() float64 {
	if x != nil {
		return x.Max
	}
	return 0
}

func (x *FluxMeter_ExponentialBucketsRange) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

// Raw Rego rules are compiled 1:1 to Rego queries
//
// High-level extractor-based rules are compiled into a single Rego query.
//
// Deprecated: 1.5.0
type Rule_Rego struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Source code of the Rego module.
	//
	// Note: Must include a "package" declaration.
	Source string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty" validate:"deprecated,required"` // @gotags: validate:"deprecated,required"
	// Query string to extract a value (for example, `data.<mymodulename>.<variablename>`).
	//
	// Note: The module name must match the package name from the `source`.
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty" validate:"deprecated,required"` // @gotags: validate:"deprecated,required"
}

func (x *Rule_Rego) Reset() {
	*x = Rule_Rego{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Rule_Rego) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rule_Rego) ProtoMessage() {}

func (x *Rule_Rego) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rule_Rego.ProtoReflect.Descriptor instead.
func (*Rule_Rego) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{6, 0}
}

func (x *Rule_Rego) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *Rule_Rego) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

type Rego_LabelProperties struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Decides if the created flow label should be available as an attribute in OLAP telemetry and
	// propagated in [baggage](/concepts/flow-control/flow-label.md#baggage)
	//
	// :::note
	//
	// The flow label is always accessible in Aperture Policies regardless of this setting.
	//
	// :::
	//
	// :::caution
	//
	// When using [FluxNinja ARC extension](arc/extension.md), telemetry enabled
	// labels are sent to FluxNinja ARC for observability. Telemetry should be disabled for
	// sensitive labels.
	//
	// :::
	Telemetry bool `protobuf:"varint,1,opt,name=telemetry,proto3" json:"telemetry,omitempty" default:"true"` // @gotags: default:"true"
}

func (x *Rego_LabelProperties) Reset() {
	*x = Rego_LabelProperties{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Rego_LabelProperties) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rego_LabelProperties) ProtoMessage() {}

func (x *Rego_LabelProperties) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rego_LabelProperties.ProtoReflect.Descriptor instead.
func (*Rego_LabelProperties) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{7, 0}
}

func (x *Rego_LabelProperties) GetTelemetry() bool {
	if x != nil {
		return x.Telemetry
	}
	return false
}

type RateLimiter_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Time after which the limit for a given label value will be reset.
	LimitResetInterval *durationpb.Duration `protobuf:"bytes,1,opt,name=limit_reset_interval,json=limitResetInterval,proto3" json:"limit_reset_interval,omitempty" default:"60s"` // @gotags: default:"60s"
	// Specifies which label the rate limiter should be keyed by.
	//
	// Rate limiting is done independently for each value of the
	// [label](/concepts/flow-control/flow-label.md) with given key.
	// For example, to give each user a separate limit, assuming you
	// have a _user_ flow
	// label set up, set `label_key: "user"`.
	LabelKey string `protobuf:"bytes,2,opt,name=label_key,json=labelKey,proto3" json:"label_key,omitempty" validate:"required"` // @gotags: validate:"required"
	// Configuration of lazy-syncing behaviour of rate limiter
	LazySync *RateLimiter_Parameters_LazySync `protobuf:"bytes,3,opt,name=lazy_sync,json=lazySync,proto3" json:"lazy_sync,omitempty"`
}

func (x *RateLimiter_Parameters) Reset() {
	*x = RateLimiter_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[32]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_Parameters) ProtoMessage() {}

func (x *RateLimiter_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[32]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_Parameters.ProtoReflect.Descriptor instead.
func (*RateLimiter_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{14, 0}
}

func (x *RateLimiter_Parameters) GetLimitResetInterval() *durationpb.Duration {
	if x != nil {
		return x.LimitResetInterval
	}
	return nil
}

func (x *RateLimiter_Parameters) GetLabelKey() string {
	if x != nil {
		return x.LabelKey
	}
	return ""
}

func (x *RateLimiter_Parameters) GetLazySync() *RateLimiter_Parameters_LazySync {
	if x != nil {
		return x.LazySync
	}
	return nil
}

type RateLimiter_Override struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Value of the label for which the override should be applied.
	LabelValue string `protobuf:"bytes,1,opt,name=label_value,json=labelValue,proto3" json:"label_value,omitempty" validate:"required"` // @gotags: validate:"required"
	// Amount by which the `in_ports.limit` should be multiplied for
	// this label value.
	LimitScaleFactor float64 `protobuf:"fixed64,2,opt,name=limit_scale_factor,json=limitScaleFactor,proto3" json:"limit_scale_factor,omitempty" default:"1.0"` // @gotags: default:"1.0"
}

func (x *RateLimiter_Override) Reset() {
	*x = RateLimiter_Override{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[33]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_Override) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_Override) ProtoMessage() {}

func (x *RateLimiter_Override) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[33]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_Override.ProtoReflect.Descriptor instead.
func (*RateLimiter_Override) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{14, 1}
}

func (x *RateLimiter_Override) GetLabelValue() string {
	if x != nil {
		return x.LabelValue
	}
	return ""
}

func (x *RateLimiter_Override) GetLimitScaleFactor() float64 {
	if x != nil {
		return x.LimitScaleFactor
	}
	return 0
}

// Dynamic Configuration for the rate limiter
type RateLimiter_DynamicConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Allows to specify different limits for particular label values.
	Overrides []*RateLimiter_Override `protobuf:"bytes,1,rep,name=overrides,proto3" json:"overrides,omitempty" validate:"dive"` // @gotags: validate:"dive"
}

func (x *RateLimiter_DynamicConfig) Reset() {
	*x = RateLimiter_DynamicConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[34]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_DynamicConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_DynamicConfig) ProtoMessage() {}

func (x *RateLimiter_DynamicConfig) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[34]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_DynamicConfig.ProtoReflect.Descriptor instead.
func (*RateLimiter_DynamicConfig) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{14, 2}
}

func (x *RateLimiter_DynamicConfig) GetOverrides() []*RateLimiter_Override {
	if x != nil {
		return x.Overrides
	}
	return nil
}

// Inputs for the RateLimiter component
type RateLimiter_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Number of flows allowed per `limit_reset_interval` per each label.
	// Negative values disable the rate limiter.
	//
	// :::tip
	//
	// Negative limit can be useful to _conditionally_ enable the rate limiter
	// under certain circumstances. [Decider](#decider) might be helpful.
	//
	// :::
	Limit *InPort `protobuf:"bytes,1,opt,name=limit,proto3" json:"limit,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *RateLimiter_Ins) Reset() {
	*x = RateLimiter_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[35]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_Ins) ProtoMessage() {}

func (x *RateLimiter_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[35]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_Ins.ProtoReflect.Descriptor instead.
func (*RateLimiter_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{14, 3}
}

func (x *RateLimiter_Ins) GetLimit() *InPort {
	if x != nil {
		return x.Limit
	}
	return nil
}

type RateLimiter_Parameters_LazySync struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Enables lazy sync
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty" default:"false"` // @gotags: default:"false"
	// Number of times to lazy sync within the `limit_reset_interval`.
	NumSync uint32 `protobuf:"varint,2,opt,name=num_sync,json=numSync,proto3" json:"num_sync,omitempty" default:"5" validate:"gt=0"` // @gotags: default:"5" validate:"gt=0"
}

func (x *RateLimiter_Parameters_LazySync) Reset() {
	*x = RateLimiter_Parameters_LazySync{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[36]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_Parameters_LazySync) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_Parameters_LazySync) ProtoMessage() {}

func (x *RateLimiter_Parameters_LazySync) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[36]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_Parameters_LazySync.ProtoReflect.Descriptor instead.
func (*RateLimiter_Parameters_LazySync) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{14, 0, 0}
}

func (x *RateLimiter_Parameters_LazySync) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *RateLimiter_Parameters_LazySync) GetNumSync() uint32 {
	if x != nil {
		return x.NumSync
	}
	return 0
}

// Workload defines a class of requests that preferably have similar properties such as response latency or desired priority.
type Scheduler_Workload struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Parameters associated with flows matching the label matcher.
	Parameters *Scheduler_Workload_Parameters `protobuf:"bytes,1,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Label Matcher to select a Workload based on
	// [flow labels](/concepts/flow-control/flow-label.md).
	LabelMatcher *LabelMatcher `protobuf:"bytes,2,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *Scheduler_Workload) Reset() {
	*x = Scheduler_Workload{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[37]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler_Workload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler_Workload) ProtoMessage() {}

func (x *Scheduler_Workload) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[37]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler_Workload.ProtoReflect.Descriptor instead.
func (*Scheduler_Workload) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{16, 0}
}

func (x *Scheduler_Workload) GetParameters() *Scheduler_Workload_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *Scheduler_Workload) GetLabelMatcher() *LabelMatcher {
	if x != nil {
		return x.LabelMatcher
	}
	return nil
}

// Scheduler parameters
type Scheduler_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// List of workloads to be used in scheduler.
	//
	// Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
	// allows for load-shedding to be "intelligent" compared to random rejections.
	// There are two aspects of this "intelligence":
	//   - Scheduler can more precisely calculate concurrency if it understands
	//     that flows belonging to different classes have different weights (for example, insert queries compared to select queries).
	//   - Setting different priorities to different workloads lets the scheduler
	//     avoid dropping important traffic during overload.
	//
	// Each workload in this list specifies also a matcher that is used to
	// determine which flow will be categorized into which workload.
	// In case of multiple matching workloads, the first matching one will be used.
	// If none of workloads match, `default_workload` will be used.
	//
	// :::info
	//
	// See also [workload definition in the concepts
	// section](/concepts/flow-control/components/concurrency-limiter.md#workload).
	//
	// :::
	Workloads []*Scheduler_Workload `protobuf:"bytes,1,rep,name=workloads,proto3" json:"workloads,omitempty" validate:"dive"` // @gotags: validate:"dive"
	// Parameters to be used if none of workloads specified in `workloads` match.
	DefaultWorkloadParameters *Scheduler_Workload_Parameters `protobuf:"bytes,2,opt,name=default_workload_parameters,json=defaultWorkloadParameters,proto3" json:"default_workload_parameters,omitempty"`
	// Automatically estimate the size of a request in each workload, based on
	// historical latency. Each workload's `tokens` will be set to average
	// latency of flows in that workload during last few seconds (exact duration
	// of this average can change).
	// Verify that the `tokens` in workload definitions
	// or the flow aren't set if you want
	// to use this feature.
	AutoTokens bool `protobuf:"varint,3,opt,name=auto_tokens,json=autoTokens,proto3" json:"auto_tokens,omitempty" default:"true"` // @gotags: default:"true"
	// Timeout as a factor of tokens for a flow in a workload in case `auto_tokens` is set to true.
	//
	// If a flow is not able to get tokens within `timeout_factor * tokens` of duration,
	// it will be rejected.
	//
	// This value impacts the prioritization and fairness because the larger the timeout the higher the chance a request has to get scheduled.
	TimeoutFactor float64 `protobuf:"fixed64,4,opt,name=timeout_factor,json=timeoutFactor,proto3" json:"timeout_factor,omitempty" validate:"gte=0.0" default:"0.5"` // @gotags: validate:"gte=0.0" default:"0.5"
	// Max Timeout is the value with which the flow timeout is capped.
	// When `auto_tokens` feature is not enabled, this value is used as the
	// timeout for the flow, otherwise it is used as a cap for the timeout.
	//
	// :::caution
	//
	// This timeout needs to be less than the timeout set on the
	// client for the whole GRPC call:
	// * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
	// * in case of libraries, is configured during the client initialization.
	//
	// Fail-open logic is use for flow control APIs, so if the GRPC timeout
	// fires first, the flow will end up being unconditionally allowed while
	// it is still waiting on the scheduler.
	//
	// To avoid such cases, the end-to-end GRPC timeout should also contain
	// some headroom for constant overhead like serialization and other processing delays. Default
	// value for GRPC timeouts is 500ms, giving 10ms of headroom, so when
	// tweaking this timeout, adjust the GRPC timeout accordingly.
	//
	// :::
	MaxTimeout *durationpb.Duration `protobuf:"bytes,5,opt,name=max_timeout,json=maxTimeout,proto3" json:"max_timeout,omitempty" default:"0.49s"` // @gotags: default:"0.49s"
}

func (x *Scheduler_Parameters) Reset() {
	*x = Scheduler_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[38]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler_Parameters) ProtoMessage() {}

func (x *Scheduler_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[38]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler_Parameters.ProtoReflect.Descriptor instead.
func (*Scheduler_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{16, 1}
}

func (x *Scheduler_Parameters) GetWorkloads() []*Scheduler_Workload {
	if x != nil {
		return x.Workloads
	}
	return nil
}

func (x *Scheduler_Parameters) GetDefaultWorkloadParameters() *Scheduler_Workload_Parameters {
	if x != nil {
		return x.DefaultWorkloadParameters
	}
	return nil
}

func (x *Scheduler_Parameters) GetAutoTokens() bool {
	if x != nil {
		return x.AutoTokens
	}
	return false
}

func (x *Scheduler_Parameters) GetTimeoutFactor() float64 {
	if x != nil {
		return x.TimeoutFactor
	}
	return 0
}

func (x *Scheduler_Parameters) GetMaxTimeout() *durationpb.Duration {
	if x != nil {
		return x.MaxTimeout
	}
	return nil
}

// Output for the Scheduler component.
type Scheduler_Outs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Accepted concurrency is actual concurrency on a control point that this
	// scheduler is applied on.
	//
	// :::info
	//
	// Concurrency is a unit less number describing mean number of
	// [flows](/concepts/flow-control/flow-control.md#flow) being
	// concurrently processed by the system (system = control point).
	// Concurrency is calculated as _work_ done per unit of time (so
	// work-seconds per world-seconds). Work-seconds are computed based on
	// token-weights of flows (which are either estimated using the `auto_tokens` feature or specified by `Workload.tokens` setting).
	//
	// :::
	//
	// Value of this signal is aggregated from all the relevant schedulers.
	AcceptedConcurrency *OutPort `protobuf:"bytes,1,opt,name=accepted_concurrency,json=acceptedConcurrency,proto3" json:"accepted_concurrency,omitempty"`
	// Incoming concurrency is concurrency that'd be needed to accept all the
	// flows entering the scheduler.
	//
	// This is computed in the same way as `accepted_concurrency`, but summing
	// up work-seconds from all the flows entering scheduler, including
	// rejected ones.
	IncomingConcurrency *OutPort `protobuf:"bytes,2,opt,name=incoming_concurrency,json=incomingConcurrency,proto3" json:"incoming_concurrency,omitempty"`
}

func (x *Scheduler_Outs) Reset() {
	*x = Scheduler_Outs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[39]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler_Outs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler_Outs) ProtoMessage() {}

func (x *Scheduler_Outs) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[39]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler_Outs.ProtoReflect.Descriptor instead.
func (*Scheduler_Outs) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{16, 2}
}

func (x *Scheduler_Outs) GetAcceptedConcurrency() *OutPort {
	if x != nil {
		return x.AcceptedConcurrency
	}
	return nil
}

func (x *Scheduler_Outs) GetIncomingConcurrency() *OutPort {
	if x != nil {
		return x.IncomingConcurrency
	}
	return nil
}

// Parameters defines parameters such as priority, tokens and fairness key that are applicable to flows within a workload.
type Scheduler_Workload_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Describes priority level of the requests within the workload.
	// Priority level ranges from 0 to 255.
	// Higher numbers means higher priority level.
	// Priority levels have non-linear effect on the workload scheduling. The following formula is used to determine the position of a request in the queue based on virtual finish time:
	//
	// $$
	// \text{virtual\_finish\_time} = \text{virtual\_time} + \left(\text{tokens} \cdot \left(\text{256} - \text{priority}\right)\right)
	// $$
	Priority uint32 `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty" validate:"gte=0,lte=255" default:"0"` // @gotags: validate:"gte=0,lte=255" default:"0"
	// Tokens determines the cost of admitting a single request the workload, which is typically defined as milliseconds of response latency.
	// This override is applicable only if tokens for the request aren't specified in the request.
	Tokens uint64 `protobuf:"varint,2,opt,name=tokens,proto3" json:"tokens,omitempty"`
	// Fairness key is a label key that can be used to provide fairness within a workload.
	// Any [flow label](/concepts/flow-control/flow-label.md) can be used here. For example, if
	// you have a classifier that sets `user` flow label, you might want to set
	// `fairness_key = "user"`.
	FairnessKey string `protobuf:"bytes,3,opt,name=fairness_key,json=fairnessKey,proto3" json:"fairness_key,omitempty"`
}

func (x *Scheduler_Workload_Parameters) Reset() {
	*x = Scheduler_Workload_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[40]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler_Workload_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler_Workload_Parameters) ProtoMessage() {}

func (x *Scheduler_Workload_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[40]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler_Workload_Parameters.ProtoReflect.Descriptor instead.
func (*Scheduler_Workload_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{16, 0, 0}
}

func (x *Scheduler_Workload_Parameters) GetPriority() uint32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *Scheduler_Workload_Parameters) GetTokens() uint64 {
	if x != nil {
		return x.Tokens
	}
	return 0
}

func (x *Scheduler_Workload_Parameters) GetFairnessKey() string {
	if x != nil {
		return x.FairnessKey
	}
	return ""
}

// Dynamic Configuration for LoadActuator
type LoadActuator_DynamicConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Decides whether to run the load actuator in dry-run mode. Dry run mode ensures that no traffic gets dropped by this load actuator.
	// Useful for observing the behavior of Load Actuator without disrupting any real traffic.
	DryRun bool `protobuf:"varint,1,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
}

func (x *LoadActuator_DynamicConfig) Reset() {
	*x = LoadActuator_DynamicConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[41]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadActuator_DynamicConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadActuator_DynamicConfig) ProtoMessage() {}

func (x *LoadActuator_DynamicConfig) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[41]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadActuator_DynamicConfig.ProtoReflect.Descriptor instead.
func (*LoadActuator_DynamicConfig) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{17, 0}
}

func (x *LoadActuator_DynamicConfig) GetDryRun() bool {
	if x != nil {
		return x.DryRun
	}
	return false
}

// Input for the Load Actuator component.
type LoadActuator_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Load multiplier is ratio of [incoming
	// concurrency](#scheduler-outs) that needs to be accepted.
	LoadMultiplier *InPort `protobuf:"bytes,1,opt,name=load_multiplier,json=loadMultiplier,proto3" json:"load_multiplier,omitempty"`
}

func (x *LoadActuator_Ins) Reset() {
	*x = LoadActuator_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[42]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadActuator_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadActuator_Ins) ProtoMessage() {}

func (x *LoadActuator_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[42]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadActuator_Ins.ProtoReflect.Descriptor instead.
func (*LoadActuator_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{17, 1}
}

func (x *LoadActuator_Ins) GetLoadMultiplier() *InPort {
	if x != nil {
		return x.LoadMultiplier
	}
	return nil
}

// Inputs for the AIMDConcurrencyController component.
type AIMDConcurrencyController_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The signal to the controller.
	Signal *InPort `protobuf:"bytes,1,opt,name=signal,proto3" json:"signal,omitempty"`
	// The setpoint to the controller.
	Setpoint *InPort `protobuf:"bytes,2,opt,name=setpoint,proto3" json:"setpoint,omitempty"`
}

func (x *AIMDConcurrencyController_Ins) Reset() {
	*x = AIMDConcurrencyController_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[43]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AIMDConcurrencyController_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AIMDConcurrencyController_Ins) ProtoMessage() {}

func (x *AIMDConcurrencyController_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[43]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AIMDConcurrencyController_Ins.ProtoReflect.Descriptor instead.
func (*AIMDConcurrencyController_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{18, 0}
}

func (x *AIMDConcurrencyController_Ins) GetSignal() *InPort {
	if x != nil {
		return x.Signal
	}
	return nil
}

func (x *AIMDConcurrencyController_Ins) GetSetpoint() *InPort {
	if x != nil {
		return x.Setpoint
	}
	return nil
}

// Outputs for the AIMDConcurrencyController component.
type AIMDConcurrencyController_Outs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Is overload is a Boolean signal that indicates whether the service is overloaded based on the deviation of the signal from the setpoint taking into account some tolerance.
	IsOverload *OutPort `protobuf:"bytes,1,opt,name=is_overload,json=isOverload,proto3" json:"is_overload,omitempty"`
	// Desired Load multiplier is the ratio of desired concurrency to the incoming concurrency.
	DesiredLoadMultiplier *OutPort `protobuf:"bytes,2,opt,name=desired_load_multiplier,json=desiredLoadMultiplier,proto3" json:"desired_load_multiplier,omitempty"`
	// Observed Load multiplier is the ratio of accepted concurrency to the incoming concurrency.
	ObservedLoadMultiplier *OutPort `protobuf:"bytes,3,opt,name=observed_load_multiplier,json=observedLoadMultiplier,proto3" json:"observed_load_multiplier,omitempty"`
	// Accepted concurrency is the number of concurrent requests that are accepted by the service.
	AcceptedConcurrency *OutPort `protobuf:"bytes,4,opt,name=accepted_concurrency,json=acceptedConcurrency,proto3" json:"accepted_concurrency,omitempty"`
	// IncomingConcurrency is the number of concurrent requests that are received by the service.
	IncomingConcurrency *OutPort `protobuf:"bytes,5,opt,name=incoming_concurrency,json=incomingConcurrency,proto3" json:"incoming_concurrency,omitempty"`
}

func (x *AIMDConcurrencyController_Outs) Reset() {
	*x = AIMDConcurrencyController_Outs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[44]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AIMDConcurrencyController_Outs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AIMDConcurrencyController_Outs) ProtoMessage() {}

func (x *AIMDConcurrencyController_Outs) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[44]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AIMDConcurrencyController_Outs.ProtoReflect.Descriptor instead.
func (*AIMDConcurrencyController_Outs) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{18, 1}
}

func (x *AIMDConcurrencyController_Outs) GetIsOverload() *OutPort {
	if x != nil {
		return x.IsOverload
	}
	return nil
}

func (x *AIMDConcurrencyController_Outs) GetDesiredLoadMultiplier() *OutPort {
	if x != nil {
		return x.DesiredLoadMultiplier
	}
	return nil
}

func (x *AIMDConcurrencyController_Outs) GetObservedLoadMultiplier() *OutPort {
	if x != nil {
		return x.ObservedLoadMultiplier
	}
	return nil
}

func (x *AIMDConcurrencyController_Outs) GetAcceptedConcurrency() *OutPort {
	if x != nil {
		return x.AcceptedConcurrency
	}
	return nil
}

func (x *AIMDConcurrencyController_Outs) GetIncomingConcurrency() *OutPort {
	if x != nil {
		return x.IncomingConcurrency
	}
	return nil
}

// Dynamic Configuration for _Flow Regulator_
type FlowRegulator_DynamicConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Specify certain label values to be accepted by this flow filter regardless of accept percentage.
	EnableLabelValues []string `protobuf:"bytes,1,rep,name=enable_label_values,json=enableLabelValues,proto3" json:"enable_label_values,omitempty"`
}

func (x *FlowRegulator_DynamicConfig) Reset() {
	*x = FlowRegulator_DynamicConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[45]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FlowRegulator_DynamicConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowRegulator_DynamicConfig) ProtoMessage() {}

func (x *FlowRegulator_DynamicConfig) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[45]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowRegulator_DynamicConfig.ProtoReflect.Descriptor instead.
func (*FlowRegulator_DynamicConfig) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{19, 0}
}

func (x *FlowRegulator_DynamicConfig) GetEnableLabelValues() []string {
	if x != nil {
		return x.EnableLabelValues
	}
	return nil
}

type FlowRegulator_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// _Flow Selector_ decides the service and flows at which the _Flow Regulator_ is applied.
	FlowSelector *FlowSelector `protobuf:"bytes,1,opt,name=flow_selector,json=flowSelector,proto3" json:"flow_selector,omitempty" validate:"required"` // @gotags: validate:"required"
	// The flow label key for identifying sessions.
	//   - When label key is specified, _Flow Regulator_ acts as a sticky filter.
	//     The series of flows with the same value of label key get the same
	//     decision provided that the `accept_percentage` is same or higher.
	//   - When label key is not specified, _Flow Regulator_ acts as a stateless filter.
	//     Percentage of flows are selected randomly for rejection.
	LabelKey string `protobuf:"bytes,2,opt,name=label_key,json=labelKey,proto3" json:"label_key,omitempty"`
}

func (x *FlowRegulator_Parameters) Reset() {
	*x = FlowRegulator_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[46]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FlowRegulator_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowRegulator_Parameters) ProtoMessage() {}

func (x *FlowRegulator_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[46]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowRegulator_Parameters.ProtoReflect.Descriptor instead.
func (*FlowRegulator_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{19, 1}
}

func (x *FlowRegulator_Parameters) GetFlowSelector() *FlowSelector {
	if x != nil {
		return x.FlowSelector
	}
	return nil
}

func (x *FlowRegulator_Parameters) GetLabelKey() string {
	if x != nil {
		return x.LabelKey
	}
	return ""
}

type FlowRegulator_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The percentage of requests to accept.
	AcceptPercentage *InPort `protobuf:"bytes,1,opt,name=accept_percentage,json=acceptPercentage,proto3" json:"accept_percentage,omitempty"`
}

func (x *FlowRegulator_Ins) Reset() {
	*x = FlowRegulator_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[47]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FlowRegulator_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowRegulator_Ins) ProtoMessage() {}

func (x *FlowRegulator_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[47]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowRegulator_Ins.ProtoReflect.Descriptor instead.
func (*FlowRegulator_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{19, 2}
}

func (x *FlowRegulator_Ins) GetAcceptPercentage() *InPort {
	if x != nil {
		return x.AcceptPercentage
	}
	return nil
}

// Parameters for the _Load Shaper_ component.
type LoadShaper_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Parameters for the _Flow Regulator_.
	FlowRegulatorParameters *FlowRegulator_Parameters     `protobuf:"bytes,1,opt,name=flow_regulator_parameters,json=flowRegulatorParameters,proto3" json:"flow_regulator_parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	Steps                   []*LoadShaper_Parameters_Step `protobuf:"bytes,2,rep,name=steps,proto3" json:"steps,omitempty" validate:"required,gt=0,dive"`                                                                      // @gotags: validate:"required,gt=0,dive"
}

func (x *LoadShaper_Parameters) Reset() {
	*x = LoadShaper_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[48]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadShaper_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadShaper_Parameters) ProtoMessage() {}

func (x *LoadShaper_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[48]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadShaper_Parameters.ProtoReflect.Descriptor instead.
func (*LoadShaper_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{20, 0}
}

func (x *LoadShaper_Parameters) GetFlowRegulatorParameters() *FlowRegulator_Parameters {
	if x != nil {
		return x.FlowRegulatorParameters
	}
	return nil
}

func (x *LoadShaper_Parameters) GetSteps() []*LoadShaper_Parameters_Step {
	if x != nil {
		return x.Steps
	}
	return nil
}

// Inputs for the _Load Shaper_ component.
type LoadShaper_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Whether to progress the _Load Shaper_ towards the next step.
	Forward *InPort `protobuf:"bytes,1,opt,name=forward,proto3" json:"forward,omitempty"`
	// Whether to progress the _Load Shaper_ towards the previous step.
	Backward *InPort `protobuf:"bytes,2,opt,name=backward,proto3" json:"backward,omitempty"`
	// Whether to reset the _Load Shaper_ to the first step.
	Reset_ *InPort `protobuf:"bytes,3,opt,name=reset,proto3" json:"reset,omitempty"`
}

func (x *LoadShaper_Ins) Reset() {
	*x = LoadShaper_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[49]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadShaper_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadShaper_Ins) ProtoMessage() {}

func (x *LoadShaper_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[49]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadShaper_Ins.ProtoReflect.Descriptor instead.
func (*LoadShaper_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{20, 1}
}

func (x *LoadShaper_Ins) GetForward() *InPort {
	if x != nil {
		return x.Forward
	}
	return nil
}

func (x *LoadShaper_Ins) GetBackward() *InPort {
	if x != nil {
		return x.Backward
	}
	return nil
}

func (x *LoadShaper_Ins) GetReset_() *InPort {
	if x != nil {
		return x.Reset_
	}
	return nil
}

// Outputs for the _Load Shaper_ component.
type LoadShaper_Outs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The percentage of flows being accepted by the _Load Shaper_.
	AcceptPercentage *OutPort `protobuf:"bytes,1,opt,name=accept_percentage,json=acceptPercentage,proto3" json:"accept_percentage,omitempty"`
	// A Boolean signal indicating whether the _Load Shaper_ is at the start of signal generation.
	AtStart *OutPort `protobuf:"bytes,2,opt,name=at_start,json=atStart,proto3" json:"at_start,omitempty"`
	// A Boolean signal indicating whether the _Load Shaper_ is at the end of signal generation.
	AtEnd *OutPort `protobuf:"bytes,3,opt,name=at_end,json=atEnd,proto3" json:"at_end,omitempty"`
}

func (x *LoadShaper_Outs) Reset() {
	*x = LoadShaper_Outs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[50]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadShaper_Outs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadShaper_Outs) ProtoMessage() {}

func (x *LoadShaper_Outs) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[50]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadShaper_Outs.ProtoReflect.Descriptor instead.
func (*LoadShaper_Outs) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{20, 2}
}

func (x *LoadShaper_Outs) GetAcceptPercentage() *OutPort {
	if x != nil {
		return x.AcceptPercentage
	}
	return nil
}

func (x *LoadShaper_Outs) GetAtStart() *OutPort {
	if x != nil {
		return x.AtStart
	}
	return nil
}

func (x *LoadShaper_Outs) GetAtEnd() *OutPort {
	if x != nil {
		return x.AtEnd
	}
	return nil
}

type LoadShaper_Parameters_Step struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The value of the step.
	TargetAcceptPercentage float64 `protobuf:"fixed64,1,opt,name=target_accept_percentage,json=targetAcceptPercentage,proto3" json:"target_accept_percentage,omitempty" validate:"gte=0,lte=100"` // @gotags: validate:"gte=0,lte=100"
	// Duration for which the step is active.
	Duration *durationpb.Duration `protobuf:"bytes,2,opt,name=duration,proto3" json:"duration,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *LoadShaper_Parameters_Step) Reset() {
	*x = LoadShaper_Parameters_Step{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[51]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadShaper_Parameters_Step) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadShaper_Parameters_Step) ProtoMessage() {}

func (x *LoadShaper_Parameters_Step) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[51]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadShaper_Parameters_Step.ProtoReflect.Descriptor instead.
func (*LoadShaper_Parameters_Step) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{20, 0, 0}
}

func (x *LoadShaper_Parameters_Step) GetTargetAcceptPercentage() float64 {
	if x != nil {
		return x.TargetAcceptPercentage
	}
	return 0
}

func (x *LoadShaper_Parameters_Step) GetDuration() *durationpb.Duration {
	if x != nil {
		return x.Duration
	}
	return nil
}

type LoadShaperSeries_LoadShaperInstance struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The load shaper.
	LoadShaper *LoadShaper_Parameters `protobuf:"bytes,1,opt,name=load_shaper,json=loadShaper,proto3" json:"load_shaper,omitempty" validate:"required"` // @gotags: validate:"required"
	OutPorts   *LoadShaper_Outs       `protobuf:"bytes,2,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
}

func (x *LoadShaperSeries_LoadShaperInstance) Reset() {
	*x = LoadShaperSeries_LoadShaperInstance{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[52]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadShaperSeries_LoadShaperInstance) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadShaperSeries_LoadShaperInstance) ProtoMessage() {}

func (x *LoadShaperSeries_LoadShaperInstance) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[52]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadShaperSeries_LoadShaperInstance.ProtoReflect.Descriptor instead.
func (*LoadShaperSeries_LoadShaperInstance) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{21, 0}
}

func (x *LoadShaperSeries_LoadShaperInstance) GetLoadShaper() *LoadShaper_Parameters {
	if x != nil {
		return x.LoadShaper
	}
	return nil
}

func (x *LoadShaperSeries_LoadShaperInstance) GetOutPorts() *LoadShaper_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

// Parameters for the _LoadShaperSeries_ component.
type LoadShaperSeries_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// An ordered list of load shapers that get applied in order.
	LoadShapers []*LoadShaperSeries_LoadShaperInstance `protobuf:"bytes,1,rep,name=load_shapers,json=loadShapers,proto3" json:"load_shapers,omitempty" validate:"required,dive"` // @gotags: validate:"required,dive"
}

func (x *LoadShaperSeries_Parameters) Reset() {
	*x = LoadShaperSeries_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[53]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadShaperSeries_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadShaperSeries_Parameters) ProtoMessage() {}

func (x *LoadShaperSeries_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[53]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadShaperSeries_Parameters.ProtoReflect.Descriptor instead.
func (*LoadShaperSeries_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{21, 1}
}

func (x *LoadShaperSeries_Parameters) GetLoadShapers() []*LoadShaperSeries_LoadShaperInstance {
	if x != nil {
		return x.LoadShapers
	}
	return nil
}

// Inputs for the _LoadShaperSeries_ component.
type LoadShaperSeries_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Whether to progress the load shaper series towards the next step.
	Forward *InPort `protobuf:"bytes,1,opt,name=forward,proto3" json:"forward,omitempty"`
	// Whether to progress the load shaper series towards the previous step.
	Backward *InPort `protobuf:"bytes,2,opt,name=backward,proto3" json:"backward,omitempty"`
	// Whether to reset the load shaper series to the first step.
	Reset_ *InPort `protobuf:"bytes,3,opt,name=reset,proto3" json:"reset,omitempty"`
}

func (x *LoadShaperSeries_Ins) Reset() {
	*x = LoadShaperSeries_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[54]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadShaperSeries_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadShaperSeries_Ins) ProtoMessage() {}

func (x *LoadShaperSeries_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[54]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadShaperSeries_Ins.ProtoReflect.Descriptor instead.
func (*LoadShaperSeries_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{21, 2}
}

func (x *LoadShaperSeries_Ins) GetForward() *InPort {
	if x != nil {
		return x.Forward
	}
	return nil
}

func (x *LoadShaperSeries_Ins) GetBackward() *InPort {
	if x != nil {
		return x.Backward
	}
	return nil
}

func (x *LoadShaperSeries_Ins) GetReset_() *InPort {
	if x != nil {
		return x.Reset_
	}
	return nil
}

var File_aperture_policy_language_v1_flowcontrol_proto protoreflect.FileDescriptor

var file_aperture_policy_language_v1_flowcontrol_proto_rawDesc = []byte{
	0x0a, 0x2d, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x66, 0x6c,
	0x6f, 0x77, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x1b, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x1a, 0x2f, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2f, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f,
	0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x27, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2f, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x70, 0x6f, 0x72, 0x74, 0x73,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x30, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2f, 0x76, 0x31, 0x2f, 0x73, 0x74, 0x64, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e,
	0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xb4, 0x01, 0x0a, 0x0c, 0x46, 0x6c, 0x6f,
	0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x57, 0x0a, 0x10, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f,
	0x72, 0x52, 0x0f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74,
	0x6f, 0x72, 0x12, 0x4b, 0x0a, 0x0c, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68,
	0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x65, 0x72, 0x52, 0x0b, 0x66, 0x6c, 0x6f, 0x77, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x22,
	0x4c, 0x0a, 0x0f, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74,
	0x6f, 0x72, 0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x5f, 0x67, 0x72, 0x6f, 0x75,
	0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x47, 0x72,
	0x6f, 0x75, 0x70, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x22, 0x82, 0x01,
	0x0a, 0x0b, 0x46, 0x6c, 0x6f, 0x77, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x12, 0x23, 0x0a,
	0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x50, 0x6f, 0x69,
	0x6e, 0x74, 0x12, 0x4e, 0x0a, 0x0d, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x74, 0x63,
	0x68, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x4d, 0x61, 0x74,
	0x63, 0x68, 0x65, 0x72, 0x52, 0x0c, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x65, 0x72, 0x22, 0xac, 0x02, 0x0a, 0x14, 0x46, 0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x74, 0x72,
	0x6f, 0x6c, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x12, 0x62, 0x0a, 0x0b, 0x66,
	0x6c, 0x75, 0x78, 0x5f, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x41, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46,
	0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72,
	0x63, 0x65, 0x73, 0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x52, 0x0a, 0x66, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12,
	0x49, 0x0a, 0x0b, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x69, 0x66, 0x69, 0x65, 0x72, 0x73, 0x18, 0x02,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x69, 0x66, 0x69, 0x65, 0x72, 0x52, 0x0b, 0x63,
	0x6c, 0x61, 0x73, 0x73, 0x69, 0x66, 0x69, 0x65, 0x72, 0x73, 0x1a, 0x65, 0x0a, 0x0f, 0x46, 0x6c,
	0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a,
	0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12,
	0x3c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x75,
	0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38,
	0x01, 0x22, 0xec, 0x06, 0x0a, 0x09, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x12,
	0x4e, 0x0a, 0x0d, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f,
	0x72, 0x52, 0x0c, 0x66, 0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12,
	0x5d, 0x0a, 0x0e, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74,
	0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x2e,
	0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x48, 0x00, 0x52,
	0x0d, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x5d,
	0x0a, 0x0e, 0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x4c,
	0x69, 0x6e, 0x65, 0x61, 0x72, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x48, 0x00, 0x52, 0x0d,
	0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x6c, 0x0a,
	0x13, 0x65, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x62, 0x75, 0x63,
	0x6b, 0x65, 0x74, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x39, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74,
	0x65, 0x72, 0x2e, 0x45, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75,
	0x63, 0x6b, 0x65, 0x74, 0x73, 0x48, 0x00, 0x52, 0x12, 0x65, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e,
	0x74, 0x69, 0x61, 0x6c, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x7c, 0x0a, 0x19, 0x65,
	0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65,
	0x74, 0x73, 0x5f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3e,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x75,
	0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x45, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69,
	0x61, 0x6c, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x48, 0x00,
	0x52, 0x17, 0x65, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75, 0x63,
	0x6b, 0x65, 0x74, 0x73, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x61, 0x74, 0x74,
	0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0c, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x4b, 0x65, 0x79, 0x1a, 0x29,
	0x0a, 0x0d, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12,
	0x18, 0x0a, 0x07, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x01,
	0x52, 0x07, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x1a, 0x51, 0x0a, 0x0d, 0x4c, 0x69, 0x6e,
	0x65, 0x61, 0x72, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74,
	0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74,
	0x12, 0x14, 0x0a, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52,
	0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x1a, 0x58, 0x0a, 0x12,
	0x45, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75, 0x63, 0x6b, 0x65,
	0x74, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x01, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x61, 0x63, 0x74,
	0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x06, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72,
	0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x1a, 0x53, 0x0a, 0x17, 0x45, 0x78, 0x70, 0x6f, 0x6e, 0x65,
	0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x52, 0x61, 0x6e, 0x67,
	0x65, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x69, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x03,
	0x6d, 0x69, 0x6e, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x61, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01,
	0x52, 0x03, 0x6d, 0x61, 0x78, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x42, 0x13, 0x0a, 0x11, 0x68,
	0x69, 0x73, 0x74, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73,
	0x22, 0xba, 0x02, 0x0a, 0x0a, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x69, 0x66, 0x69, 0x65, 0x72, 0x12,
	0x4e, 0x0a, 0x0d, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f,
	0x72, 0x52, 0x0c, 0x66, 0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12,
	0x48, 0x0a, 0x05, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x32,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6c, 0x61,
	0x73, 0x73, 0x69, 0x66, 0x69, 0x65, 0x72, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x45, 0x6e, 0x74,
	0x72, 0x79, 0x52, 0x05, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x35, 0x0a, 0x04, 0x72, 0x65, 0x67,
	0x6f, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x6f, 0x52, 0x04, 0x72, 0x65, 0x67, 0x6f,
	0x1a, 0x5b, 0x0a, 0x0a, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,
	0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,
	0x12, 0x37, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x21, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x75,
	0x6c, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xea, 0x01,
	0x0a, 0x04, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x46, 0x0a, 0x09, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63,
	0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f,
	0x72, 0x48, 0x00, 0x52, 0x09, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x3c,
	0x0a, 0x04, 0x72, 0x65, 0x67, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x2e,
	0x52, 0x65, 0x67, 0x6f, 0x48, 0x00, 0x52, 0x04, 0x72, 0x65, 0x67, 0x6f, 0x12, 0x1c, 0x0a, 0x09,
	0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x09, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x1a, 0x34, 0x0a, 0x04, 0x52, 0x65,
	0x67, 0x6f, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x71, 0x75,
	0x65, 0x72, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79,
	0x42, 0x08, 0x0a, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x22, 0x84, 0x02, 0x0a, 0x04, 0x52,
	0x65, 0x67, 0x6f, 0x12, 0x45, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x52, 0x65, 0x67, 0x6f, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x45, 0x6e, 0x74,
	0x72, 0x79, 0x52, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x6d, 0x6f,
	0x64, 0x75, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6d, 0x6f, 0x64, 0x75,
	0x6c, 0x65, 0x1a, 0x2f, 0x0a, 0x0f, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65,
	0x72, 0x74, 0x69, 0x65, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74,
	0x72, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65,
	0x74, 0x72, 0x79, 0x1a, 0x6c, 0x0a, 0x0b, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x45, 0x6e, 0x74,
	0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x03, 0x6b, 0x65, 0x79, 0x12, 0x47, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x52, 0x65, 0x67, 0x6f, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x50, 0x72, 0x6f, 0x70,
	0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38,
	0x01, 0x22, 0xd3, 0x02, 0x0a, 0x09, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12,
	0x14, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52,
	0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x40, 0x0a, 0x04, 0x6a, 0x73, 0x6f, 0x6e, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x48,
	0x00, 0x52, 0x04, 0x6a, 0x73, 0x6f, 0x6e, 0x12, 0x49, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78,
	0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x12, 0x3d, 0x0a, 0x03, 0x6a, 0x77, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4a, 0x57,
	0x54, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x03, 0x6a, 0x77,
	0x74, 0x12, 0x59, 0x0a, 0x0e, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61,
	0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x74, 0x68, 0x54, 0x65, 0x6d, 0x70,
	0x6c, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x48, 0x00, 0x52, 0x0d, 0x70,
	0x61, 0x74, 0x68, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x73, 0x42, 0x09, 0x0a, 0x07,
	0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x22, 0x3d, 0x0a, 0x0d, 0x4a, 0x53, 0x4f, 0x4e, 0x45,
	0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x18, 0x0a, 0x07,
	0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70,
	0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x22, 0x26, 0x0a, 0x10, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x72,
	0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x22, 0x45,
	0x0a, 0x0c, 0x4a, 0x57, 0x54, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x12,
	0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x72,
	0x6f, 0x6d, 0x12, 0x21, 0x0a, 0x0c, 0x6a, 0x73, 0x6f, 0x6e, 0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74,
	0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6a, 0x73, 0x6f, 0x6e, 0x50, 0x6f,
	0x69, 0x6e, 0x74, 0x65, 0x72, 0x22, 0xc7, 0x01, 0x0a, 0x13, 0x50, 0x61, 0x74, 0x68, 0x54, 0x65,
	0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x12, 0x6d, 0x0a,
	0x0f, 0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73,
	0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x44, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x74, 0x68, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74,
	0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74,
	0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0e, 0x74, 0x65,
	0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x1a, 0x41, 0x0a, 0x13,
	0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22,
	0xc7, 0x04, 0x0a, 0x0b, 0x46, 0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x12,
	0x4d, 0x0a, 0x0c, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x48,
	0x00, 0x52, 0x0b, 0x72, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x12, 0x62,
	0x0a, 0x13, 0x63, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x6c, 0x69,
	0x6d, 0x69, 0x74, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6e, 0x63, 0x75, 0x72,
	0x72, 0x65, 0x6e, 0x63, 0x79, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x48, 0x00, 0x52, 0x12,
	0x63, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x4c, 0x69, 0x6d, 0x69, 0x74,
	0x65, 0x72, 0x12, 0x78, 0x0a, 0x1b, 0x61, 0x69, 0x6d, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x63, 0x75,
	0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65,
	0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x36, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x49, 0x4d, 0x44, 0x43, 0x6f, 0x6e, 0x63, 0x75, 0x72,
	0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x48,
	0x00, 0x52, 0x19, 0x61, 0x69, 0x6d, 0x64, 0x43, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e,
	0x63, 0x79, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x12, 0x53, 0x0a, 0x0e,
	0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x72, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72,
	0x48, 0x00, 0x52, 0x0d, 0x66, 0x6c, 0x6f, 0x77, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f,
	0x72, 0x12, 0x4a, 0x0a, 0x0b, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x73, 0x68, 0x61, 0x70, 0x65, 0x72,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x68, 0x61, 0x70, 0x65, 0x72, 0x48,
	0x00, 0x52, 0x0a, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x68, 0x61, 0x70, 0x65, 0x72, 0x12, 0x5d, 0x0a,
	0x12, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x73, 0x68, 0x61, 0x70, 0x65, 0x72, 0x5f, 0x73, 0x65, 0x72,
	0x69, 0x65, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x68, 0x61, 0x70,
	0x65, 0x72, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x48, 0x00, 0x52, 0x10, 0x6c, 0x6f, 0x61, 0x64,
	0x53, 0x68, 0x61, 0x70, 0x65, 0x72, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x42, 0x0b, 0x0a, 0x09,
	0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x22, 0x9c, 0x07, 0x0a, 0x0b, 0x52, 0x61,
	0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x08, 0x69, 0x6e, 0x5f,
	0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69,
	0x6d, 0x69, 0x74, 0x65, 0x72, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f, 0x72,
	0x74, 0x73, 0x12, 0x4e, 0x0a, 0x0d, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63,
	0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65,
	0x63, 0x74, 0x6f, 0x72, 0x52, 0x0c, 0x66, 0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74,
	0x6f, 0x72, 0x12, 0x53, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72,
	0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72,
	0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x2c, 0x0a, 0x12, 0x64, 0x79, 0x6e, 0x61, 0x6d,
	0x69, 0x63, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x10, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x4b, 0x65, 0x79, 0x12, 0x5d, 0x0a, 0x0e, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74,
	0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x36, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65,
	0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x2e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0d, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x43, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x1a, 0x92, 0x02, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
	0x65, 0x72, 0x73, 0x12, 0x4b, 0x0a, 0x14, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5f, 0x72, 0x65, 0x73,
	0x65, 0x74, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x12, 0x6c, 0x69,
	0x6d, 0x69, 0x74, 0x52, 0x65, 0x73, 0x65, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c,
	0x12, 0x1b, 0x0a, 0x09, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x4b, 0x65, 0x79, 0x12, 0x59, 0x0a,
	0x09, 0x6c, 0x61, 0x7a, 0x79, 0x5f, 0x73, 0x79, 0x6e, 0x63, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x3c, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52,
	0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x65, 0x74, 0x65, 0x72, 0x73, 0x2e, 0x4c, 0x61, 0x7a, 0x79, 0x53, 0x79, 0x6e, 0x63, 0x52, 0x08,
	0x6c, 0x61, 0x7a, 0x79, 0x53, 0x79, 0x6e, 0x63, 0x1a, 0x3f, 0x0a, 0x08, 0x4c, 0x61, 0x7a, 0x79,
	0x53, 0x79, 0x6e, 0x63, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x19,
	0x0a, 0x08, 0x6e, 0x75, 0x6d, 0x5f, 0x73, 0x79, 0x6e, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x07, 0x6e, 0x75, 0x6d, 0x53, 0x79, 0x6e, 0x63, 0x1a, 0x59, 0x0a, 0x08, 0x4f, 0x76, 0x65,
	0x72, 0x72, 0x69, 0x64, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x6c, 0x61, 0x62, 0x65,
	0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x2c, 0x0a, 0x12, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5f,
	0x73, 0x63, 0x61, 0x6c, 0x65, 0x5f, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x01, 0x52, 0x10, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x46, 0x61,
	0x63, 0x74, 0x6f, 0x72, 0x1a, 0x60, 0x0a, 0x0d, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x4f, 0x0a, 0x09, 0x6f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64,
	0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74,
	0x65, 0x72, 0x2e, 0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x52, 0x09, 0x6f, 0x76, 0x65,
	0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x1a, 0x40, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x39, 0x0a,
	0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72,
	0x74, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x22, 0x92, 0x02, 0x0a, 0x12, 0x43, 0x6f, 0x6e,
	0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x12,
	0x4e, 0x0a, 0x0d, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f,
	0x72, 0x52, 0x0c, 0x66, 0x6c, 0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12,
	0x44, 0x0a, 0x09, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x52, 0x09, 0x73, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x50, 0x0a, 0x0d, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x61, 0x63,
	0x74, 0x75, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x41,
	0x63, 0x74, 0x75, 0x61, 0x74, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x0c, 0x6c, 0x6f, 0x61, 0x64, 0x41,
	0x63, 0x74, 0x75, 0x61, 0x74, 0x6f, 0x72, 0x42, 0x14, 0x0a, 0x12, 0x61, 0x63, 0x74, 0x75, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x22, 0xdf, 0x07,
	0x0a, 0x09, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x48, 0x0a, 0x09, 0x6f,
	0x75, 0x74, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x4f, 0x75, 0x74, 0x73, 0x52, 0x08, 0x6f, 0x75, 0x74,
	0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x51, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
	0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
	0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x1a, 0x9b, 0x02, 0x0a, 0x08, 0x57, 0x6f, 0x72,
	0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x5a, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
	0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
	0x72, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
	0x73, 0x12, 0x4e, 0x0a, 0x0d, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68,
	0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x4d, 0x61, 0x74, 0x63,
	0x68, 0x65, 0x72, 0x52, 0x0c, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65,
	0x72, 0x1a, 0x63, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12,
	0x1a, 0x0a, 0x08, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x08, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x12, 0x16, 0x0a, 0x06, 0x74,
	0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x74, 0x6f, 0x6b,
	0x65, 0x6e, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x66, 0x61, 0x69, 0x72, 0x6e, 0x65, 0x73, 0x73, 0x5f,
	0x6b, 0x65, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x66, 0x61, 0x69, 0x72, 0x6e,
	0x65, 0x73, 0x73, 0x4b, 0x65, 0x79, 0x1a, 0xdb, 0x02, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x4d, 0x0a, 0x09, 0x77, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61,
	0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72,
	0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x09, 0x77, 0x6f, 0x72, 0x6b, 0x6c,
	0x6f, 0x61, 0x64, 0x73, 0x12, 0x7a, 0x0a, 0x1b, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f,
	0x77, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
	0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
	0x72, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x19, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x57, 0x6f,
	0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73,
	0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x75, 0x74, 0x6f, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x61, 0x75, 0x74, 0x6f, 0x54, 0x6f, 0x6b, 0x65, 0x6e,
	0x73, 0x12, 0x25, 0x0a, 0x0e, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x66, 0x61, 0x63,
	0x74, 0x6f, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0d, 0x74, 0x69, 0x6d, 0x65, 0x6f,
	0x75, 0x74, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x3a, 0x0a, 0x0b, 0x6d, 0x61, 0x78, 0x5f,
	0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
	0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0a, 0x6d, 0x61, 0x78, 0x54, 0x69, 0x6d,
	0x65, 0x6f, 0x75, 0x74, 0x1a, 0xb8, 0x01, 0x0a, 0x04, 0x4f, 0x75, 0x74, 0x73, 0x12, 0x57, 0x0a,
	0x14, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x65, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x63, 0x75, 0x72,
	0x72, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72,
	0x74, 0x52, 0x13, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x65, 0x64, 0x43, 0x6f, 0x6e, 0x63, 0x75,
	0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x12, 0x57, 0x0a, 0x14, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69,
	0x6e, 0x67, 0x5f, 0x63, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x13, 0x69, 0x6e, 0x63, 0x6f,
	0x6d, 0x69, 0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x22,
	0xe5, 0x02, 0x0a, 0x0c, 0x4c, 0x6f, 0x61, 0x64, 0x41, 0x63, 0x74, 0x75, 0x61, 0x74, 0x6f, 0x72,
	0x12, 0x48, 0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x41, 0x63, 0x74, 0x75, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x49, 0x6e,
	0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x2c, 0x0a, 0x12, 0x64, 0x79,
	0x6e, 0x61, 0x6d, 0x69, 0x63, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4b, 0x65, 0x79, 0x12, 0x5e, 0x0a, 0x0e, 0x64, 0x65, 0x66, 0x61,
	0x75, 0x6c, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x37, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c,
	0x6f, 0x61, 0x64, 0x41, 0x63, 0x74, 0x75, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x44, 0x79, 0x6e, 0x61,
	0x6d, 0x69, 0x63, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0d, 0x64, 0x65, 0x66, 0x61, 0x75,
	0x6c, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x1a, 0x28, 0x0a, 0x0d, 0x44, 0x79, 0x6e, 0x61,
	0x6d, 0x69, 0x63, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x17, 0x0a, 0x07, 0x64, 0x72, 0x79,
	0x5f, 0x72, 0x75, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x64, 0x72, 0x79, 0x52,
	0x75, 0x6e, 0x1a, 0x53, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x4c, 0x0a, 0x0f, 0x6c, 0x6f, 0x61,
	0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x0e, 0x6c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c,
	0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x22, 0x9c, 0x0b, 0x0a, 0x19, 0x41, 0x49, 0x4d, 0x44,
	0x43, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x6e, 0x74, 0x72,
	0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x12, 0x55, 0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74,
	0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x49, 0x4d, 0x44, 0x43, 0x6f, 0x6e, 0x63, 0x75, 0x72,
	0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x2e,
	0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x58, 0x0a, 0x09,
	0x6f, 0x75, 0x74, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x3b, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x49,
	0x4d, 0x44, 0x43, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x6e,
	0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x2e, 0x4f, 0x75, 0x74, 0x73, 0x52, 0x08, 0x6f, 0x75,
	0x74, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x4e, 0x0a, 0x0d, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x73,
	0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77,
	0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x0c, 0x66, 0x6c, 0x6f, 0x77, 0x53, 0x65,
	0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x64, 0x0a, 0x14, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75,
	0x6c, 0x65, 0x72, 0x5f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72,
	0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x13, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c,
	0x65, 0x72, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x6b, 0x0a, 0x13,
	0x67, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
	0x65, 0x72, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6e, 0x74,
	0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x12, 0x67, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6e, 0x74, 0x50,
	0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x2e, 0x0a, 0x13, 0x6d, 0x61, 0x78,
	0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x01, 0x52, 0x11, 0x6d, 0x61, 0x78, 0x4c, 0x6f, 0x61, 0x64, 0x4d,
	0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x20, 0x6c, 0x6f, 0x61,
	0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x5f, 0x6c, 0x69, 0x6e,
	0x65, 0x61, 0x72, 0x5f, 0x69, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x07, 0x20,
	0x01, 0x28, 0x01, 0x52, 0x1d, 0x6c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c,
	0x69, 0x65, 0x72, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x49, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65,
	0x6e, 0x74, 0x12, 0x5e, 0x0a, 0x12, 0x61, 0x6c, 0x65, 0x72, 0x74, 0x65, 0x72, 0x5f, 0x70, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x6c, 0x65,
	0x72, 0x74, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52,
	0x11, 0x61, 0x6c, 0x65, 0x72, 0x74, 0x65, 0x72, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
	0x72, 0x73, 0x12, 0x2c, 0x0a, 0x12, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x5f, 0x63, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10,
	0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4b, 0x65, 0x79,
	0x12, 0x5e, 0x0a, 0x0e, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x41, 0x63, 0x74, 0x75, 0x61,
	0x74, 0x6f, 0x72, 0x2e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x52, 0x0d, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x1a, 0x83, 0x01, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x3b, 0x0a, 0x06, 0x73, 0x69, 0x67, 0x6e,
	0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x06, 0x73,
	0x69, 0x67, 0x6e, 0x61, 0x6c, 0x12, 0x3f, 0x0a, 0x08, 0x73, 0x65, 0x74, 0x70, 0x6f, 0x69, 0x6e,
	0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x08, 0x73, 0x65,
	0x74, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x1a, 0xbd, 0x03, 0x0a, 0x04, 0x4f, 0x75, 0x74, 0x73, 0x12,
	0x45, 0x0a, 0x0b, 0x69, 0x73, 0x5f, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x0a, 0x69, 0x73, 0x4f, 0x76,
	0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x5c, 0x0a, 0x17, 0x64, 0x65, 0x73, 0x69, 0x72, 0x65,
	0x64, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65,
	0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x15, 0x64,
	0x65, 0x73, 0x69, 0x72, 0x65, 0x64, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70,
	0x6c, 0x69, 0x65, 0x72, 0x12, 0x5e, 0x0a, 0x18, 0x6f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64,
	0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x16, 0x6f, 0x62,
	0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70,
	0x6c, 0x69, 0x65, 0x72, 0x12, 0x57, 0x0a, 0x14, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x65, 0x64,
	0x5f, 0x63, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x13, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74,
	0x65, 0x64, 0x43, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x12, 0x57, 0x0a,
	0x14, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x6f, 0x6e, 0x63, 0x75, 0x72,
	0x72, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72,
	0x74, 0x52, 0x13, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x63, 0x75,
	0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x22, 0xd5, 0x04, 0x0a, 0x0d, 0x46, 0x6c, 0x6f, 0x77, 0x52,
	0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x49, 0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70,
	0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x52, 0x65, 0x67,
	0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f,
	0x72, 0x74, 0x73, 0x12, 0x55, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
	0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61,
	0x74, 0x6f, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a,
	0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x2c, 0x0a, 0x12, 0x64, 0x79,
	0x6e, 0x61, 0x6d, 0x69, 0x63, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4b, 0x65, 0x79, 0x12, 0x5f, 0x0a, 0x0e, 0x64, 0x65, 0x66, 0x61,
	0x75, 0x6c, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x38, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46,
	0x6c, 0x6f, 0x77, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x44, 0x79, 0x6e,
	0x61, 0x6d, 0x69, 0x63, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0d, 0x64, 0x65, 0x66, 0x61,
	0x75, 0x6c, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x1a, 0x3f, 0x0a, 0x0d, 0x44, 0x79, 0x6e,
	0x61, 0x6d, 0x69, 0x63, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x2e, 0x0a, 0x13, 0x65, 0x6e,
	0x61, 0x62, 0x6c, 0x65, 0x5f, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x11, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x4c,
	0x61, 0x62, 0x65, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x1a, 0x79, 0x0a, 0x0a, 0x50, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x4e, 0x0a, 0x0d, 0x66, 0x6c, 0x6f, 0x77,
	0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c,
	0x6f, 0x77, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x0c, 0x66, 0x6c, 0x6f, 0x77,
	0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x1b, 0x0a, 0x09, 0x6c, 0x61, 0x62, 0x65,
	0x6c, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x61, 0x62,
	0x65, 0x6c, 0x4b, 0x65, 0x79, 0x1a, 0x57, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x50, 0x0a, 0x11,
	0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x5f, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67,
	0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x10, 0x61, 0x63,
	0x63, 0x65, 0x70, 0x74, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x22, 0xe9,
	0x08, 0x0a, 0x0a, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x68, 0x61, 0x70, 0x65, 0x72, 0x12, 0x46, 0x0a,
	0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x2b, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f,
	0x61, 0x64, 0x53, 0x68, 0x61, 0x70, 0x65, 0x72, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e,
	0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x49, 0x0a, 0x09, 0x6f, 0x75, 0x74, 0x5f, 0x70, 0x6f, 0x72,
	0x74, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x68, 0x61, 0x70, 0x65,
	0x72, 0x2e, 0x4f, 0x75, 0x74, 0x73, 0x52, 0x08, 0x6f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x73,
	0x12, 0x52, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x68, 0x61, 0x70, 0x65, 0x72, 0x2e, 0x50, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65,
	0x74, 0x65, 0x72, 0x73, 0x12, 0x2c, 0x0a, 0x12, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x5f,
	0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x10, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4b,
	0x65, 0x79, 0x12, 0x5f, 0x0a, 0x0e, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x63, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x38, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x52, 0x65, 0x67,
	0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x52, 0x0d, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x43, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x1a, 0xc7, 0x02, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
	0x72, 0x73, 0x12, 0x71, 0x0a, 0x19, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x72, 0x65, 0x67, 0x75, 0x6c,
	0x61, 0x74, 0x6f, 0x72, 0x5f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f,
	0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x17, 0x66, 0x6c,
	0x6f, 0x77, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x4d, 0x0a, 0x05, 0x73, 0x74, 0x65, 0x70, 0x73, 0x18, 0x02,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x68, 0x61, 0x70, 0x65, 0x72, 0x2e, 0x50, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x2e, 0x53, 0x74, 0x65, 0x70, 0x52, 0x05, 0x73,
	0x74, 0x65, 0x70, 0x73, 0x1a, 0x77, 0x0a, 0x04, 0x53, 0x74, 0x65, 0x70, 0x12, 0x38, 0x0a, 0x18,
	0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x5f, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x5f, 0x70, 0x65,
	0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x16,
	0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x50, 0x65, 0x72, 0x63,
	0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x12, 0x35, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x52, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0xc0, 0x01,
	0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x3d, 0x0a, 0x07, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x07, 0x66, 0x6f, 0x72,
	0x77, 0x61, 0x72, 0x64, 0x12, 0x3f, 0x0a, 0x08, 0x62, 0x61, 0x63, 0x6b, 0x77, 0x61, 0x72, 0x64,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x08, 0x62, 0x61, 0x63,
	0x6b, 0x77, 0x61, 0x72, 0x64, 0x12, 0x39, 0x0a, 0x05, 0x72, 0x65, 0x73, 0x65, 0x74, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x05, 0x72, 0x65, 0x73, 0x65, 0x74,
	0x1a, 0xd7, 0x01, 0x0a, 0x04, 0x4f, 0x75, 0x74, 0x73, 0x12, 0x51, 0x0a, 0x11, 0x61, 0x63, 0x63,
	0x65, 0x70, 0x74, 0x5f, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x10, 0x61, 0x63, 0x63, 0x65,
	0x70, 0x74, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x12, 0x3f, 0x0a, 0x08,
	0x61, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74,
	0x50, 0x6f, 0x72, 0x74, 0x52, 0x07, 0x61, 0x74, 0x53, 0x74, 0x61, 0x72, 0x74, 0x12, 0x3b, 0x0a,
	0x06, 0x61, 0x74, 0x5f, 0x65, 0x6e, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50,
	0x6f, 0x72, 0x74, 0x52, 0x05, 0x61, 0x74, 0x45, 0x6e, 0x64, 0x22, 0xa7, 0x05, 0x0a, 0x10, 0x4c,
	0x6f, 0x61, 0x64, 0x53, 0x68, 0x61, 0x70, 0x65, 0x72, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x12,
	0x4c, 0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x31, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x4c, 0x6f, 0x61, 0x64, 0x53, 0x68, 0x61, 0x70, 0x65, 0x72, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73,
	0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x58, 0x0a,
	0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x38, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x4c, 0x6f, 0x61, 0x64, 0x53, 0x68, 0x61, 0x70, 0x65, 0x72, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73,
	0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72,
	0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x1a, 0xb4, 0x01, 0x0a, 0x12, 0x4c, 0x6f, 0x61, 0x64,
	0x53, 0x68, 0x61, 0x70, 0x65, 0x72, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x53,
	0x0a, 0x0b, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x73, 0x68, 0x61, 0x70, 0x65, 0x72, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x68, 0x61, 0x70, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72,
	0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x68, 0x61,
	0x70, 0x65, 0x72, 0x12, 0x49, 0x0a, 0x09, 0x6f, 0x75, 0x74, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x68, 0x61, 0x70, 0x65, 0x72, 0x2e,
	0x4f, 0x75, 0x74, 0x73, 0x52, 0x08, 0x6f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x1a, 0x71,
	0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x63, 0x0a, 0x0c,
	0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x73, 0x68, 0x61, 0x70, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x40, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x68, 0x61, 0x70, 0x65, 0x72, 0x53, 0x65, 0x72, 0x69, 0x65,
	0x73, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x68, 0x61, 0x70, 0x65, 0x72, 0x49, 0x6e, 0x73, 0x74,
	0x61, 0x6e, 0x63, 0x65, 0x52, 0x0b, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x68, 0x61, 0x70, 0x65, 0x72,
	0x73, 0x1a, 0xc0, 0x01, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x3d, 0x0a, 0x07, 0x66, 0x6f, 0x72,
	0x77, 0x61, 0x72, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52,
	0x07, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x12, 0x3f, 0x0a, 0x08, 0x62, 0x61, 0x63, 0x6b,
	0x77, 0x61, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52,
	0x08, 0x62, 0x61, 0x63, 0x6b, 0x77, 0x61, 0x72, 0x64, 0x12, 0x39, 0x0a, 0x05, 0x72, 0x65, 0x73,
	0x65, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x05, 0x72,
	0x65, 0x73, 0x65, 0x74, 0x42, 0xad, 0x02, 0x0a, 0x33, 0x63, 0x6f, 0x6d, 0x2e, 0x66, 0x6c, 0x75,
	0x78, 0x6e, 0x69, 0x6e, 0x6a, 0x61, 0x2e, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x42, 0x10, 0x46, 0x6c,
	0x6f, 0x77, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01,
	0x5a, 0x55, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x6c, 0x75,
	0x78, 0x6e, 0x69, 0x6e, 0x6a, 0x61, 0x2f, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f,
	0x61, 0x70, 0x69, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f,
	0x2f, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2f, 0x76, 0x31, 0x3b, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x76, 0x31, 0xa2, 0x02, 0x03, 0x41, 0x50, 0x4c, 0xaa, 0x02, 0x1b,
	0x41, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x4c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x56, 0x31, 0xca, 0x02, 0x1b, 0x41, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x5c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x5c, 0x4c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x5c, 0x56, 0x31, 0xe2, 0x02, 0x27, 0x41, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x5c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x5c, 0x4c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x5c, 0x56, 0x31, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61, 0x64,
	0x61, 0x74, 0x61, 0xea, 0x02, 0x1e, 0x41, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x3a, 0x3a,
	0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x3a, 0x3a, 0x4c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x3a, 0x3a, 0x56, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_aperture_policy_language_v1_flowcontrol_proto_rawDescOnce sync.Once
	file_aperture_policy_language_v1_flowcontrol_proto_rawDescData = file_aperture_policy_language_v1_flowcontrol_proto_rawDesc
)

func file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP() []byte {
	file_aperture_policy_language_v1_flowcontrol_proto_rawDescOnce.Do(func() {
		file_aperture_policy_language_v1_flowcontrol_proto_rawDescData = protoimpl.X.CompressGZIP(file_aperture_policy_language_v1_flowcontrol_proto_rawDescData)
	})
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescData
}

var file_aperture_policy_language_v1_flowcontrol_proto_msgTypes = make([]protoimpl.MessageInfo, 55)
var file_aperture_policy_language_v1_flowcontrol_proto_goTypes = []interface{}{
	(*FlowSelector)(nil),                      // 0: aperture.policy.language.v1.FlowSelector
	(*ServiceSelector)(nil),                   // 1: aperture.policy.language.v1.ServiceSelector
	(*FlowMatcher)(nil),                       // 2: aperture.policy.language.v1.FlowMatcher
	(*FlowControlResources)(nil),              // 3: aperture.policy.language.v1.FlowControlResources
	(*FluxMeter)(nil),                         // 4: aperture.policy.language.v1.FluxMeter
	(*Classifier)(nil),                        // 5: aperture.policy.language.v1.Classifier
	(*Rule)(nil),                              // 6: aperture.policy.language.v1.Rule
	(*Rego)(nil),                              // 7: aperture.policy.language.v1.Rego
	(*Extractor)(nil),                         // 8: aperture.policy.language.v1.Extractor
	(*JSONExtractor)(nil),                     // 9: aperture.policy.language.v1.JSONExtractor
	(*AddressExtractor)(nil),                  // 10: aperture.policy.language.v1.AddressExtractor
	(*JWTExtractor)(nil),                      // 11: aperture.policy.language.v1.JWTExtractor
	(*PathTemplateMatcher)(nil),               // 12: aperture.policy.language.v1.PathTemplateMatcher
	(*FlowControl)(nil),                       // 13: aperture.policy.language.v1.FlowControl
	(*RateLimiter)(nil),                       // 14: aperture.policy.language.v1.RateLimiter
	(*ConcurrencyLimiter)(nil),                // 15: aperture.policy.language.v1.ConcurrencyLimiter
	(*Scheduler)(nil),                         // 16: aperture.policy.language.v1.Scheduler
	(*LoadActuator)(nil),                      // 17: aperture.policy.language.v1.LoadActuator
	(*AIMDConcurrencyController)(nil),         // 18: aperture.policy.language.v1.AIMDConcurrencyController
	(*FlowRegulator)(nil),                     // 19: aperture.policy.language.v1.FlowRegulator
	(*LoadShaper)(nil),                        // 20: aperture.policy.language.v1.LoadShaper
	(*LoadShaperSeries)(nil),                  // 21: aperture.policy.language.v1.LoadShaperSeries
	nil,                                       // 22: aperture.policy.language.v1.FlowControlResources.FluxMetersEntry
	(*FluxMeter_StaticBuckets)(nil),           // 23: aperture.policy.language.v1.FluxMeter.StaticBuckets
	(*FluxMeter_LinearBuckets)(nil),           // 24: aperture.policy.language.v1.FluxMeter.LinearBuckets
	(*FluxMeter_ExponentialBuckets)(nil),      // 25: aperture.policy.language.v1.FluxMeter.ExponentialBuckets
	(*FluxMeter_ExponentialBucketsRange)(nil), // 26: aperture.policy.language.v1.FluxMeter.ExponentialBucketsRange
	nil,                                         // 27: aperture.policy.language.v1.Classifier.RulesEntry
	(*Rule_Rego)(nil),                           // 28: aperture.policy.language.v1.Rule.Rego
	(*Rego_LabelProperties)(nil),                // 29: aperture.policy.language.v1.Rego.LabelProperties
	nil,                                         // 30: aperture.policy.language.v1.Rego.LabelsEntry
	nil,                                         // 31: aperture.policy.language.v1.PathTemplateMatcher.TemplateValuesEntry
	(*RateLimiter_Parameters)(nil),              // 32: aperture.policy.language.v1.RateLimiter.Parameters
	(*RateLimiter_Override)(nil),                // 33: aperture.policy.language.v1.RateLimiter.Override
	(*RateLimiter_DynamicConfig)(nil),           // 34: aperture.policy.language.v1.RateLimiter.DynamicConfig
	(*RateLimiter_Ins)(nil),                     // 35: aperture.policy.language.v1.RateLimiter.Ins
	(*RateLimiter_Parameters_LazySync)(nil),     // 36: aperture.policy.language.v1.RateLimiter.Parameters.LazySync
	(*Scheduler_Workload)(nil),                  // 37: aperture.policy.language.v1.Scheduler.Workload
	(*Scheduler_Parameters)(nil),                // 38: aperture.policy.language.v1.Scheduler.Parameters
	(*Scheduler_Outs)(nil),                      // 39: aperture.policy.language.v1.Scheduler.Outs
	(*Scheduler_Workload_Parameters)(nil),       // 40: aperture.policy.language.v1.Scheduler.Workload.Parameters
	(*LoadActuator_DynamicConfig)(nil),          // 41: aperture.policy.language.v1.LoadActuator.DynamicConfig
	(*LoadActuator_Ins)(nil),                    // 42: aperture.policy.language.v1.LoadActuator.Ins
	(*AIMDConcurrencyController_Ins)(nil),       // 43: aperture.policy.language.v1.AIMDConcurrencyController.Ins
	(*AIMDConcurrencyController_Outs)(nil),      // 44: aperture.policy.language.v1.AIMDConcurrencyController.Outs
	(*FlowRegulator_DynamicConfig)(nil),         // 45: aperture.policy.language.v1.FlowRegulator.DynamicConfig
	(*FlowRegulator_Parameters)(nil),            // 46: aperture.policy.language.v1.FlowRegulator.Parameters
	(*FlowRegulator_Ins)(nil),                   // 47: aperture.policy.language.v1.FlowRegulator.Ins
	(*LoadShaper_Parameters)(nil),               // 48: aperture.policy.language.v1.LoadShaper.Parameters
	(*LoadShaper_Ins)(nil),                      // 49: aperture.policy.language.v1.LoadShaper.Ins
	(*LoadShaper_Outs)(nil),                     // 50: aperture.policy.language.v1.LoadShaper.Outs
	(*LoadShaper_Parameters_Step)(nil),          // 51: aperture.policy.language.v1.LoadShaper.Parameters.Step
	(*LoadShaperSeries_LoadShaperInstance)(nil), // 52: aperture.policy.language.v1.LoadShaperSeries.LoadShaperInstance
	(*LoadShaperSeries_Parameters)(nil),         // 53: aperture.policy.language.v1.LoadShaperSeries.Parameters
	(*LoadShaperSeries_Ins)(nil),                // 54: aperture.policy.language.v1.LoadShaperSeries.Ins
	(*LabelMatcher)(nil),                        // 55: aperture.policy.language.v1.LabelMatcher
	(*GradientController_Parameters)(nil),       // 56: aperture.policy.language.v1.GradientController.Parameters
	(*Alerter_Parameters)(nil),                  // 57: aperture.policy.language.v1.Alerter.Parameters
	(*durationpb.Duration)(nil),                 // 58: google.protobuf.Duration
	(*InPort)(nil),                              // 59: aperture.policy.language.v1.InPort
	(*OutPort)(nil),                             // 60: aperture.policy.language.v1.OutPort
}
var file_aperture_policy_language_v1_flowcontrol_proto_depIdxs = []int32{
	1,  // 0: aperture.policy.language.v1.FlowSelector.service_selector:type_name -> aperture.policy.language.v1.ServiceSelector
	2,  // 1: aperture.policy.language.v1.FlowSelector.flow_matcher:type_name -> aperture.policy.language.v1.FlowMatcher
	55, // 2: aperture.policy.language.v1.FlowMatcher.label_matcher:type_name -> aperture.policy.language.v1.LabelMatcher
	22, // 3: aperture.policy.language.v1.FlowControlResources.flux_meters:type_name -> aperture.policy.language.v1.FlowControlResources.FluxMetersEntry
	5,  // 4: aperture.policy.language.v1.FlowControlResources.classifiers:type_name -> aperture.policy.language.v1.Classifier
	0,  // 5: aperture.policy.language.v1.FluxMeter.flow_selector:type_name -> aperture.policy.language.v1.FlowSelector
	23, // 6: aperture.policy.language.v1.FluxMeter.static_buckets:type_name -> aperture.policy.language.v1.FluxMeter.StaticBuckets
	24, // 7: aperture.policy.language.v1.FluxMeter.linear_buckets:type_name -> aperture.policy.language.v1.FluxMeter.LinearBuckets
	25, // 8: aperture.policy.language.v1.FluxMeter.exponential_buckets:type_name -> aperture.policy.language.v1.FluxMeter.ExponentialBuckets
	26, // 9: aperture.policy.language.v1.FluxMeter.exponential_buckets_range:type_name -> aperture.policy.language.v1.FluxMeter.ExponentialBucketsRange
	0,  // 10: aperture.policy.language.v1.Classifier.flow_selector:type_name -> aperture.policy.language.v1.FlowSelector
	27, // 11: aperture.policy.language.v1.Classifier.rules:type_name -> aperture.policy.language.v1.Classifier.RulesEntry
	7,  // 12: aperture.policy.language.v1.Classifier.rego:type_name -> aperture.policy.language.v1.Rego
	8,  // 13: aperture.policy.language.v1.Rule.extractor:type_name -> aperture.policy.language.v1.Extractor
	28, // 14: aperture.policy.language.v1.Rule.rego:type_name -> aperture.policy.language.v1.Rule.Rego
	30, // 15: aperture.policy.language.v1.Rego.labels:type_name -> aperture.policy.language.v1.Rego.LabelsEntry
	9,  // 16: aperture.policy.language.v1.Extractor.json:type_name -> aperture.policy.language.v1.JSONExtractor
	10, // 17: aperture.policy.language.v1.Extractor.address:type_name -> aperture.policy.language.v1.AddressExtractor
	11, // 18: aperture.policy.language.v1.Extractor.jwt:type_name -> aperture.policy.language.v1.JWTExtractor
	12, // 19: aperture.policy.language.v1.Extractor.path_templates:type_name -> aperture.policy.language.v1.PathTemplateMatcher
	31, // 20: aperture.policy.language.v1.PathTemplateMatcher.template_values:type_name -> aperture.policy.language.v1.PathTemplateMatcher.TemplateValuesEntry
	14, // 21: aperture.policy.language.v1.FlowControl.rate_limiter:type_name -> aperture.policy.language.v1.RateLimiter
	15, // 22: aperture.policy.language.v1.FlowControl.concurrency_limiter:type_name -> aperture.policy.language.v1.ConcurrencyLimiter
	18, // 23: aperture.policy.language.v1.FlowControl.aimd_concurrency_controller:type_name -> aperture.policy.language.v1.AIMDConcurrencyController
	19, // 24: aperture.policy.language.v1.FlowControl.flow_regulator:type_name -> aperture.policy.language.v1.FlowRegulator
	20, // 25: aperture.policy.language.v1.FlowControl.load_shaper:type_name -> aperture.policy.language.v1.LoadShaper
	21, // 26: aperture.policy.language.v1.FlowControl.load_shaper_series:type_name -> aperture.policy.language.v1.LoadShaperSeries
	35, // 27: aperture.policy.language.v1.RateLimiter.in_ports:type_name -> aperture.policy.language.v1.RateLimiter.Ins
	0,  // 28: aperture.policy.language.v1.RateLimiter.flow_selector:type_name -> aperture.policy.language.v1.FlowSelector
	32, // 29: aperture.policy.language.v1.RateLimiter.parameters:type_name -> aperture.policy.language.v1.RateLimiter.Parameters
	34, // 30: aperture.policy.language.v1.RateLimiter.default_config:type_name -> aperture.policy.language.v1.RateLimiter.DynamicConfig
	0,  // 31: aperture.policy.language.v1.ConcurrencyLimiter.flow_selector:type_name -> aperture.policy.language.v1.FlowSelector
	16, // 32: aperture.policy.language.v1.ConcurrencyLimiter.scheduler:type_name -> aperture.policy.language.v1.Scheduler
	17, // 33: aperture.policy.language.v1.ConcurrencyLimiter.load_actuator:type_name -> aperture.policy.language.v1.LoadActuator
	39, // 34: aperture.policy.language.v1.Scheduler.out_ports:type_name -> aperture.policy.language.v1.Scheduler.Outs
	38, // 35: aperture.policy.language.v1.Scheduler.parameters:type_name -> aperture.policy.language.v1.Scheduler.Parameters
	42, // 36: aperture.policy.language.v1.LoadActuator.in_ports:type_name -> aperture.policy.language.v1.LoadActuator.Ins
	41, // 37: aperture.policy.language.v1.LoadActuator.default_config:type_name -> aperture.policy.language.v1.LoadActuator.DynamicConfig
	43, // 38: aperture.policy.language.v1.AIMDConcurrencyController.in_ports:type_name -> aperture.policy.language.v1.AIMDConcurrencyController.Ins
	44, // 39: aperture.policy.language.v1.AIMDConcurrencyController.out_ports:type_name -> aperture.policy.language.v1.AIMDConcurrencyController.Outs
	0,  // 40: aperture.policy.language.v1.AIMDConcurrencyController.flow_selector:type_name -> aperture.policy.language.v1.FlowSelector
	38, // 41: aperture.policy.language.v1.AIMDConcurrencyController.scheduler_parameters:type_name -> aperture.policy.language.v1.Scheduler.Parameters
	56, // 42: aperture.policy.language.v1.AIMDConcurrencyController.gradient_parameters:type_name -> aperture.policy.language.v1.GradientController.Parameters
	57, // 43: aperture.policy.language.v1.AIMDConcurrencyController.alerter_parameters:type_name -> aperture.policy.language.v1.Alerter.Parameters
	41, // 44: aperture.policy.language.v1.AIMDConcurrencyController.default_config:type_name -> aperture.policy.language.v1.LoadActuator.DynamicConfig
	47, // 45: aperture.policy.language.v1.FlowRegulator.in_ports:type_name -> aperture.policy.language.v1.FlowRegulator.Ins
	46, // 46: aperture.policy.language.v1.FlowRegulator.parameters:type_name -> aperture.policy.language.v1.FlowRegulator.Parameters
	45, // 47: aperture.policy.language.v1.FlowRegulator.default_config:type_name -> aperture.policy.language.v1.FlowRegulator.DynamicConfig
	49, // 48: aperture.policy.language.v1.LoadShaper.in_ports:type_name -> aperture.policy.language.v1.LoadShaper.Ins
	50, // 49: aperture.policy.language.v1.LoadShaper.out_ports:type_name -> aperture.policy.language.v1.LoadShaper.Outs
	48, // 50: aperture.policy.language.v1.LoadShaper.parameters:type_name -> aperture.policy.language.v1.LoadShaper.Parameters
	45, // 51: aperture.policy.language.v1.LoadShaper.default_config:type_name -> aperture.policy.language.v1.FlowRegulator.DynamicConfig
	54, // 52: aperture.policy.language.v1.LoadShaperSeries.in_ports:type_name -> aperture.policy.language.v1.LoadShaperSeries.Ins
	53, // 53: aperture.policy.language.v1.LoadShaperSeries.parameters:type_name -> aperture.policy.language.v1.LoadShaperSeries.Parameters
	4,  // 54: aperture.policy.language.v1.FlowControlResources.FluxMetersEntry.value:type_name -> aperture.policy.language.v1.FluxMeter
	6,  // 55: aperture.policy.language.v1.Classifier.RulesEntry.value:type_name -> aperture.policy.language.v1.Rule
	29, // 56: aperture.policy.language.v1.Rego.LabelsEntry.value:type_name -> aperture.policy.language.v1.Rego.LabelProperties
	58, // 57: aperture.policy.language.v1.RateLimiter.Parameters.limit_reset_interval:type_name -> google.protobuf.Duration
	36, // 58: aperture.policy.language.v1.RateLimiter.Parameters.lazy_sync:type_name -> aperture.policy.language.v1.RateLimiter.Parameters.LazySync
	33, // 59: aperture.policy.language.v1.RateLimiter.DynamicConfig.overrides:type_name -> aperture.policy.language.v1.RateLimiter.Override
	59, // 60: aperture.policy.language.v1.RateLimiter.Ins.limit:type_name -> aperture.policy.language.v1.InPort
	40, // 61: aperture.policy.language.v1.Scheduler.Workload.parameters:type_name -> aperture.policy.language.v1.Scheduler.Workload.Parameters
	55, // 62: aperture.policy.language.v1.Scheduler.Workload.label_matcher:type_name -> aperture.policy.language.v1.LabelMatcher
	37, // 63: aperture.policy.language.v1.Scheduler.Parameters.workloads:type_name -> aperture.policy.language.v1.Scheduler.Workload
	40, // 64: aperture.policy.language.v1.Scheduler.Parameters.default_workload_parameters:type_name -> aperture.policy.language.v1.Scheduler.Workload.Parameters
	58, // 65: aperture.policy.language.v1.Scheduler.Parameters.max_timeout:type_name -> google.protobuf.Duration
	60, // 66: aperture.policy.language.v1.Scheduler.Outs.accepted_concurrency:type_name -> aperture.policy.language.v1.OutPort
	60, // 67: aperture.policy.language.v1.Scheduler.Outs.incoming_concurrency:type_name -> aperture.policy.language.v1.OutPort
	59, // 68: aperture.policy.language.v1.LoadActuator.Ins.load_multiplier:type_name -> aperture.policy.language.v1.InPort
	59, // 69: aperture.policy.language.v1.AIMDConcurrencyController.Ins.signal:type_name -> aperture.policy.language.v1.InPort
	59, // 70: aperture.policy.language.v1.AIMDConcurrencyController.Ins.setpoint:type_name -> aperture.policy.language.v1.InPort
	60, // 71: aperture.policy.language.v1.AIMDConcurrencyController.Outs.is_overload:type_name -> aperture.policy.language.v1.OutPort
	60, // 72: aperture.policy.language.v1.AIMDConcurrencyController.Outs.desired_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	60, // 73: aperture.policy.language.v1.AIMDConcurrencyController.Outs.observed_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	60, // 74: aperture.policy.language.v1.AIMDConcurrencyController.Outs.accepted_concurrency:type_name -> aperture.policy.language.v1.OutPort
	60, // 75: aperture.policy.language.v1.AIMDConcurrencyController.Outs.incoming_concurrency:type_name -> aperture.policy.language.v1.OutPort
	0,  // 76: aperture.policy.language.v1.FlowRegulator.Parameters.flow_selector:type_name -> aperture.policy.language.v1.FlowSelector
	59, // 77: aperture.policy.language.v1.FlowRegulator.Ins.accept_percentage:type_name -> aperture.policy.language.v1.InPort
	46, // 78: aperture.policy.language.v1.LoadShaper.Parameters.flow_regulator_parameters:type_name -> aperture.policy.language.v1.FlowRegulator.Parameters
	51, // 79: aperture.policy.language.v1.LoadShaper.Parameters.steps:type_name -> aperture.policy.language.v1.LoadShaper.Parameters.Step
	59, // 80: aperture.policy.language.v1.LoadShaper.Ins.forward:type_name -> aperture.policy.language.v1.InPort
	59, // 81: aperture.policy.language.v1.LoadShaper.Ins.backward:type_name -> aperture.policy.language.v1.InPort
	59, // 82: aperture.policy.language.v1.LoadShaper.Ins.reset:type_name -> aperture.policy.language.v1.InPort
	60, // 83: aperture.policy.language.v1.LoadShaper.Outs.accept_percentage:type_name -> aperture.policy.language.v1.OutPort
	60, // 84: aperture.policy.language.v1.LoadShaper.Outs.at_start:type_name -> aperture.policy.language.v1.OutPort
	60, // 85: aperture.policy.language.v1.LoadShaper.Outs.at_end:type_name -> aperture.policy.language.v1.OutPort
	58, // 86: aperture.policy.language.v1.LoadShaper.Parameters.Step.duration:type_name -> google.protobuf.Duration
	48, // 87: aperture.policy.language.v1.LoadShaperSeries.LoadShaperInstance.load_shaper:type_name -> aperture.policy.language.v1.LoadShaper.Parameters
	50, // 88: aperture.policy.language.v1.LoadShaperSeries.LoadShaperInstance.out_ports:type_name -> aperture.policy.language.v1.LoadShaper.Outs
	52, // 89: aperture.policy.language.v1.LoadShaperSeries.Parameters.load_shapers:type_name -> aperture.policy.language.v1.LoadShaperSeries.LoadShaperInstance
	59, // 90: aperture.policy.language.v1.LoadShaperSeries.Ins.forward:type_name -> aperture.policy.language.v1.InPort
	59, // 91: aperture.policy.language.v1.LoadShaperSeries.Ins.backward:type_name -> aperture.policy.language.v1.InPort
	59, // 92: aperture.policy.language.v1.LoadShaperSeries.Ins.reset:type_name -> aperture.policy.language.v1.InPort
	93, // [93:93] is the sub-list for method output_type
	93, // [93:93] is the sub-list for method input_type
	93, // [93:93] is the sub-list for extension type_name
	93, // [93:93] is the sub-list for extension extendee
	0,  // [0:93] is the sub-list for field type_name
}

func init() { file_aperture_policy_language_v1_flowcontrol_proto_init() }
func file_aperture_policy_language_v1_flowcontrol_proto_init() {
	if File_aperture_policy_language_v1_flowcontrol_proto != nil {
		return
	}
	file_aperture_policy_language_v1_label_matcher_proto_init()
	file_aperture_policy_language_v1_ports_proto_init()
	file_aperture_policy_language_v1_std_components_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FlowSelector); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ServiceSelector); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FlowMatcher); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FlowControlResources); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Classifier); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Rule); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Rego); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Extractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*JSONExtractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddressExtractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*JWTExtractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PathTemplateMatcher); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FlowControl); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ConcurrencyLimiter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadActuator); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AIMDConcurrencyController); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FlowRegulator); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadShaper); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadShaperSeries); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_StaticBuckets); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_LinearBuckets); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_ExponentialBuckets); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_ExponentialBucketsRange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Rule_Rego); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Rego_LabelProperties); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_Override); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_DynamicConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_Parameters_LazySync); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[37].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler_Workload); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[38].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[39].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler_Outs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[40].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler_Workload_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[41].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadActuator_DynamicConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[42].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadActuator_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[43].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AIMDConcurrencyController_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[44].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AIMDConcurrencyController_Outs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[45].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FlowRegulator_DynamicConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[46].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FlowRegulator_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[47].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FlowRegulator_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[48].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadShaper_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[49].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadShaper_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[50].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadShaper_Outs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[51].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadShaper_Parameters_Step); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[52].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadShaperSeries_LoadShaperInstance); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[53].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadShaperSeries_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[54].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadShaperSeries_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[4].OneofWrappers = []interface{}{
		(*FluxMeter_StaticBuckets_)(nil),
		(*FluxMeter_LinearBuckets_)(nil),
		(*FluxMeter_ExponentialBuckets_)(nil),
		(*FluxMeter_ExponentialBucketsRange_)(nil),
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[6].OneofWrappers = []interface{}{
		(*Rule_Extractor)(nil),
		(*Rule_Rego_)(nil),
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[8].OneofWrappers = []interface{}{
		(*Extractor_From)(nil),
		(*Extractor_Json)(nil),
		(*Extractor_Address)(nil),
		(*Extractor_Jwt)(nil),
		(*Extractor_PathTemplates)(nil),
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[13].OneofWrappers = []interface{}{
		(*FlowControl_RateLimiter)(nil),
		(*FlowControl_ConcurrencyLimiter)(nil),
		(*FlowControl_AimdConcurrencyController)(nil),
		(*FlowControl_FlowRegulator)(nil),
		(*FlowControl_LoadShaper)(nil),
		(*FlowControl_LoadShaperSeries)(nil),
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[15].OneofWrappers = []interface{}{
		(*ConcurrencyLimiter_LoadActuator)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_aperture_policy_language_v1_flowcontrol_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   55,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_aperture_policy_language_v1_flowcontrol_proto_goTypes,
		DependencyIndexes: file_aperture_policy_language_v1_flowcontrol_proto_depIdxs,
		MessageInfos:      file_aperture_policy_language_v1_flowcontrol_proto_msgTypes,
	}.Build()
	File_aperture_policy_language_v1_flowcontrol_proto = out.File
	file_aperture_policy_language_v1_flowcontrol_proto_rawDesc = nil
	file_aperture_policy_language_v1_flowcontrol_proto_goTypes = nil
	file_aperture_policy_language_v1_flowcontrol_proto_depIdxs = nil
}
