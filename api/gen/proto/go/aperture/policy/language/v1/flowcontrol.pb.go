// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.30.0
// 	protoc        (unknown)
// source: aperture/policy/language/v1/flowcontrol.proto

package languagev1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// FlowControl Resources
type FlowControlResources struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Flux Meters are installed in the data-plane and form the observability leg of the feedback loop.
	//
	// Flux Meter created metrics can be consumed as input to the circuit through the PromQL component.
	FluxMeters map[string]*FluxMeter `protobuf:"bytes,1,rep,name=flux_meters,json=fluxMeters,proto3" json:"flux_meters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" validate:"dive"` // @gotags: validate:"dive"
	// Classifiers are installed in the data-plane and are used to label the requests based on payload content.
	//
	// The flow labels created by Classifiers can be matched by Flux Meters to create metrics for control purposes.
	Classifiers []*Classifier `protobuf:"bytes,2,rep,name=classifiers,proto3" json:"classifiers,omitempty" validate:"dive"` // @gotags: validate:"dive"
}

func (x *FlowControlResources) Reset() {
	*x = FlowControlResources{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FlowControlResources) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowControlResources) ProtoMessage() {}

func (x *FlowControlResources) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowControlResources.ProtoReflect.Descriptor instead.
func (*FlowControlResources) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{0}
}

func (x *FlowControlResources) GetFluxMeters() map[string]*FluxMeter {
	if x != nil {
		return x.FluxMeters
	}
	return nil
}

func (x *FlowControlResources) GetClassifiers() []*Classifier {
	if x != nil {
		return x.Classifiers
	}
	return nil
}

// _Flow Control_ encompasses components that manage the flow of requests or access to features within a service.
type FlowControl struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Component:
	//
	//	*FlowControl_QuotaScheduler
	//	*FlowControl_RateLimiter
	//	*FlowControl_LoadScheduler
	//	*FlowControl_AdaptiveLoadScheduler
	//	*FlowControl_Regulator
	//	*FlowControl_LoadRamp
	//	*FlowControl_LoadRampSeries
	//	*FlowControl_Private
	Component isFlowControl_Component `protobuf_oneof:"component"`
}

func (x *FlowControl) Reset() {
	*x = FlowControl{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FlowControl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowControl) ProtoMessage() {}

func (x *FlowControl) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowControl.ProtoReflect.Descriptor instead.
func (*FlowControl) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{1}
}

func (m *FlowControl) GetComponent() isFlowControl_Component {
	if m != nil {
		return m.Component
	}
	return nil
}

func (x *FlowControl) GetQuotaScheduler() *QuotaScheduler {
	if x, ok := x.GetComponent().(*FlowControl_QuotaScheduler); ok {
		return x.QuotaScheduler
	}
	return nil
}

func (x *FlowControl) GetRateLimiter() *RateLimiter {
	if x, ok := x.GetComponent().(*FlowControl_RateLimiter); ok {
		return x.RateLimiter
	}
	return nil
}

func (x *FlowControl) GetLoadScheduler() *LoadScheduler {
	if x, ok := x.GetComponent().(*FlowControl_LoadScheduler); ok {
		return x.LoadScheduler
	}
	return nil
}

func (x *FlowControl) GetAdaptiveLoadScheduler() *AdaptiveLoadScheduler {
	if x, ok := x.GetComponent().(*FlowControl_AdaptiveLoadScheduler); ok {
		return x.AdaptiveLoadScheduler
	}
	return nil
}

func (x *FlowControl) GetRegulator() *Regulator {
	if x, ok := x.GetComponent().(*FlowControl_Regulator); ok {
		return x.Regulator
	}
	return nil
}

func (x *FlowControl) GetLoadRamp() *LoadRamp {
	if x, ok := x.GetComponent().(*FlowControl_LoadRamp); ok {
		return x.LoadRamp
	}
	return nil
}

func (x *FlowControl) GetLoadRampSeries() *LoadRampSeries {
	if x, ok := x.GetComponent().(*FlowControl_LoadRampSeries); ok {
		return x.LoadRampSeries
	}
	return nil
}

func (x *FlowControl) GetPrivate() *anypb.Any {
	if x, ok := x.GetComponent().(*FlowControl_Private); ok {
		return x.Private
	}
	return nil
}

type isFlowControl_Component interface {
	isFlowControl_Component()
}

type FlowControl_QuotaScheduler struct {
	QuotaScheduler *QuotaScheduler `protobuf:"bytes,1,opt,name=quota_scheduler,json=quotaScheduler,proto3,oneof"`
}

type FlowControl_RateLimiter struct {
	// _Rate Limiter_ provides service protection by applying rate limits using the token bucket algorithm.
	RateLimiter *RateLimiter `protobuf:"bytes,6,opt,name=rate_limiter,json=rateLimiter,proto3,oneof"`
}

type FlowControl_LoadScheduler struct {
	// _Load Scheduler_ provides service protection by creating a prioritized workload queue in front of the service using Weighted Fair Queuing.
	LoadScheduler *LoadScheduler `protobuf:"bytes,7,opt,name=load_scheduler,json=loadScheduler,proto3,oneof"`
}

type FlowControl_AdaptiveLoadScheduler struct {
	// _Adaptive Load Scheduler_ component is based on additive increase and multiplicative decrease of token rate. It takes a signal and setpoint as inputs and reduces token rate proportionally (or any arbitrary power) based on deviation of the signal from setpoint.
	AdaptiveLoadScheduler *AdaptiveLoadScheduler `protobuf:"bytes,8,opt,name=adaptive_load_scheduler,json=adaptiveLoadScheduler,proto3,oneof"`
}

type FlowControl_Regulator struct {
	// Regulator is a component that regulates the flow of requests to the service by allowing only the specified percentage of requests or sticky sessions.
	Regulator *Regulator `protobuf:"bytes,9,opt,name=regulator,proto3,oneof"`
}

type FlowControl_LoadRamp struct {
	// _Load Ramp_ smoothly regulates the flow of requests over specified steps.
	LoadRamp *LoadRamp `protobuf:"bytes,10,opt,name=load_ramp,json=loadRamp,proto3,oneof"`
}

type FlowControl_LoadRampSeries struct {
	// _Load Ramp Series_ is a series of _Load Ramp_ components that can shape load one after another at same or different _Control Points_.
	LoadRampSeries *LoadRampSeries `protobuf:"bytes,11,opt,name=load_ramp_series,json=loadRampSeries,proto3,oneof"`
}

type FlowControl_Private struct {
	// Extends flow control with private components.
	Private *anypb.Any `protobuf:"bytes,1000,opt,name=private,proto3,oneof"`
}

func (*FlowControl_QuotaScheduler) isFlowControl_Component() {}

func (*FlowControl_RateLimiter) isFlowControl_Component() {}

func (*FlowControl_LoadScheduler) isFlowControl_Component() {}

func (*FlowControl_AdaptiveLoadScheduler) isFlowControl_Component() {}

func (*FlowControl_Regulator) isFlowControl_Component() {}

func (*FlowControl_LoadRamp) isFlowControl_Component() {}

func (*FlowControl_LoadRampSeries) isFlowControl_Component() {}

func (*FlowControl_Private) isFlowControl_Component() {}

// Schedules the traffic based on token-bucket based quotas.
type QuotaScheduler struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	InPorts     *RateLimiter_Ins        `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty" validate:"required"`             // @gotags: validate:"required"
	Selectors   []*Selector             `protobuf:"bytes,2,rep,name=selectors,proto3" json:"selectors,omitempty" validate:"required,gt=0,dive"`                        // @gotags: validate:"required,gt=0,dive"
	RateLimiter *RateLimiter_Parameters `protobuf:"bytes,3,opt,name=rate_limiter,json=rateLimiter,proto3" json:"rate_limiter,omitempty" validate:"required"` // @gotags: validate:"required"
	Scheduler   *Scheduler              `protobuf:"bytes,4,opt,name=scheduler,proto3" json:"scheduler,omitempty"`
}

func (x *QuotaScheduler) Reset() {
	*x = QuotaScheduler{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QuotaScheduler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuotaScheduler) ProtoMessage() {}

func (x *QuotaScheduler) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QuotaScheduler.ProtoReflect.Descriptor instead.
func (*QuotaScheduler) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{2}
}

func (x *QuotaScheduler) GetInPorts() *RateLimiter_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *QuotaScheduler) GetSelectors() []*Selector {
	if x != nil {
		return x.Selectors
	}
	return nil
}

func (x *QuotaScheduler) GetRateLimiter() *RateLimiter_Parameters {
	if x != nil {
		return x.RateLimiter
	}
	return nil
}

func (x *QuotaScheduler) GetScheduler() *Scheduler {
	if x != nil {
		return x.Scheduler
	}
	return nil
}

// Limits the traffic on a control point to specified rate
//
// :::info
//
// See also [_Rate Limiter_ overview](/concepts/flow-control/components/rate-limiter.md).
//
// :::
//
// RateLimiting is done on per-label-value (`label_key`) basis and it uses the _Token Bucket Algorithm_.
type RateLimiter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the RateLimiter component
	InPorts *RateLimiter_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty" validate:"required"` // @gotags: validate:"required"
	// Parameters for the RateLimiter component
	Parameters *RateLimiter_Parameters `protobuf:"bytes,2,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Selectors for the component.
	Selectors []*Selector `protobuf:"bytes,3,rep,name=selectors,proto3" json:"selectors,omitempty" validate:"required,gt=0,dive"` // @gotags: validate:"required,gt=0,dive"
}

func (x *RateLimiter) Reset() {
	*x = RateLimiter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter) ProtoMessage() {}

func (x *RateLimiter) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter.ProtoReflect.Descriptor instead.
func (*RateLimiter) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{3}
}

func (x *RateLimiter) GetInPorts() *RateLimiter_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *RateLimiter) GetParameters() *RateLimiter_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *RateLimiter) GetSelectors() []*Selector {
	if x != nil {
		return x.Selectors
	}
	return nil
}

// _Load Scheduler_ creates a queue for flows in front of a service to provide active service protection
//
// :::info
//
// See also [_Load Scheduler_ overview](/concepts/flow-control/components/load-scheduler.md).
//
// :::
//
// To make scheduling decisions the Flows are mapped into Workloads by providing match rules.
// A workload determines the priority and cost of admitting each Flow that belongs to it.
// Scheduling of Flows is based on Weighted Fair Queuing principles.
// _Load Scheduler_ measures and controls the incoming tokens per second, which can translate
// to (avg. latency \* in-flight requests) (Little's Law) in concurrency limiting use-case.
//
// The signal at port `load_multiplier` determines the fraction of incoming tokens that get admitted.
type LoadScheduler struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the LoadScheduler component.
	InPorts *LoadScheduler_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty" validate:"required"` // @gotags: validate:"required"
	// Output ports for the LoadScheduler component.
	OutPorts   *LoadScheduler_Outs       `protobuf:"bytes,2,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
	Parameters *LoadScheduler_Parameters `protobuf:"bytes,5,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Decides whether to run the load scheduler in dry-run mode. In dry run mode the scheduler acts as pass through to all flow and does not queue flows.
	// It is useful for observing the behavior of load scheduler without disrupting any real traffic.
	DryRun bool `protobuf:"varint,6,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	// Configuration key for setting dry run mode through dynamic configuration.
	DryRunConfigKey string `protobuf:"bytes,7,opt,name=dry_run_config_key,json=dryRunConfigKey,proto3" json:"dry_run_config_key,omitempty"`
}

func (x *LoadScheduler) Reset() {
	*x = LoadScheduler{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadScheduler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadScheduler) ProtoMessage() {}

func (x *LoadScheduler) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadScheduler.ProtoReflect.Descriptor instead.
func (*LoadScheduler) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{4}
}

func (x *LoadScheduler) GetInPorts() *LoadScheduler_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *LoadScheduler) GetOutPorts() *LoadScheduler_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

func (x *LoadScheduler) GetParameters() *LoadScheduler_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *LoadScheduler) GetDryRun() bool {
	if x != nil {
		return x.DryRun
	}
	return false
}

func (x *LoadScheduler) GetDryRunConfigKey() string {
	if x != nil {
		return x.DryRunConfigKey
	}
	return ""
}

// Weighted Fair Queuing-based workload scheduler
//
// :::note
//
// Each Agent instantiates an independent copy of the scheduler, but output
// signals for accepted and incoming token rate are aggregated across all agents.
//
// :::
type Scheduler struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// List of workloads to be used in scheduler.
	//
	// Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
	// allows for load throttling to be "intelligent" instead of queueing flows in an arbitrary order.
	// There are two aspects of this "intelligence":
	//   - Scheduler can more precisely calculate concurrency if it understands
	//     that flows belonging to different classes have different weights (for example, insert queries compared to select queries).
	//   - Setting different priorities to different workloads lets the scheduler
	//     avoid dropping important traffic during overload.
	//
	// Each workload in this list specifies also a matcher that is used to
	// determine which flow will be categorized into which workload.
	// In case of multiple matching workloads, the first matching one will be used.
	// If none of workloads match, `default_workload` will be used.
	//
	// :::info
	//
	// See also [workload definition in the concepts
	// section](/concepts/flow-control/components/load-scheduler.md#workload).
	//
	// :::
	Workloads []*Scheduler_Workload `protobuf:"bytes,1,rep,name=workloads,proto3" json:"workloads,omitempty" validate:"dive"` // @gotags: validate:"dive"
	// Parameters to be used if none of workloads specified in `workloads` match.
	DefaultWorkloadParameters *Scheduler_Workload_Parameters `protobuf:"bytes,2,opt,name=default_workload_parameters,json=defaultWorkloadParameters,proto3" json:"default_workload_parameters,omitempty"`
	// Decision deadline margin is the amount of time that the scheduler will
	// subtract from the request deadline to determine the deadline for the
	// decision. This is to ensure that the scheduler has enough time to
	// make a decision before the request deadline happens, accounting for
	// processing delays.
	// The request deadline is based on the
	// [gRPC deadline](https://grpc.io/blog/deadlines) or the
	// [`grpc-timeout` HTTP header](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests).
	//
	// Fail-open logic is use for flow control APIs, so if the gRPC deadline
	// reaches, the flow will end up being unconditionally allowed while
	// it is still waiting on the scheduler.
	DecisionDeadlineMargin *durationpb.Duration `protobuf:"bytes,6,opt,name=decision_deadline_margin,json=decisionDeadlineMargin,proto3" json:"decision_deadline_margin,omitempty" default:"0.01s"` // @gotags: default:"0.01s"
	// * Key for a flow label that can be used to override the default number of tokens for this flow.
	// * The value associated with this key must be a valid uint64 number.
	// * If this parameter is not provided, the number of tokens for the flow will be determined by the matched workload's token count.
	TokensLabelKey string `protobuf:"bytes,7,opt,name=tokens_label_key,json=tokensLabelKey,proto3" json:"tokens_label_key,omitempty" default:"tokens"` // @gotags: default:"tokens"
}

func (x *Scheduler) Reset() {
	*x = Scheduler{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler) ProtoMessage() {}

func (x *Scheduler) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler.ProtoReflect.Descriptor instead.
func (*Scheduler) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{5}
}

func (x *Scheduler) GetWorkloads() []*Scheduler_Workload {
	if x != nil {
		return x.Workloads
	}
	return nil
}

func (x *Scheduler) GetDefaultWorkloadParameters() *Scheduler_Workload_Parameters {
	if x != nil {
		return x.DefaultWorkloadParameters
	}
	return nil
}

func (x *Scheduler) GetDecisionDeadlineMargin() *durationpb.Duration {
	if x != nil {
		return x.DecisionDeadlineMargin
	}
	return nil
}

func (x *Scheduler) GetTokensLabelKey() string {
	if x != nil {
		return x.TokensLabelKey
	}
	return ""
}

// The _Adaptive Load Scheduler_ adjusts the accepted token rate based on the deviation of the input signal from the setpoint.
type AdaptiveLoadScheduler struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Collection of input ports for the _Adaptive Load Scheduler_ component.
	InPorts *AdaptiveLoadScheduler_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty" validate:"required"` // @gotags: validate:"required"
	// Collection of output ports for the _Adaptive Load Scheduler_ component.
	OutPorts *AdaptiveLoadScheduler_Outs `protobuf:"bytes,2,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
	// Parameters for the _Adaptive Load Scheduler_ component.
	Parameters *AdaptiveLoadScheduler_Parameters `protobuf:"bytes,3,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Decides whether to run the load scheduler in dry-run mode. In dry run mode the scheduler acts as pass through to all flow and does not queue flows.
	// It is useful for observing the behavior of load scheduler without disrupting any real traffic.
	DryRun bool `protobuf:"varint,6,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	// Configuration key for setting dry run mode through dynamic configuration.
	DryRunConfigKey string `protobuf:"bytes,7,opt,name=dry_run_config_key,json=dryRunConfigKey,proto3" json:"dry_run_config_key,omitempty"`
}

func (x *AdaptiveLoadScheduler) Reset() {
	*x = AdaptiveLoadScheduler{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AdaptiveLoadScheduler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdaptiveLoadScheduler) ProtoMessage() {}

func (x *AdaptiveLoadScheduler) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdaptiveLoadScheduler.ProtoReflect.Descriptor instead.
func (*AdaptiveLoadScheduler) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{6}
}

func (x *AdaptiveLoadScheduler) GetInPorts() *AdaptiveLoadScheduler_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *AdaptiveLoadScheduler) GetOutPorts() *AdaptiveLoadScheduler_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

func (x *AdaptiveLoadScheduler) GetParameters() *AdaptiveLoadScheduler_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *AdaptiveLoadScheduler) GetDryRun() bool {
	if x != nil {
		return x.DryRun
	}
	return false
}

func (x *AdaptiveLoadScheduler) GetDryRunConfigKey() string {
	if x != nil {
		return x.DryRunConfigKey
	}
	return ""
}

// _Regulator_ is a component that regulates the load at a
// [_Control Point_](/concepts/flow-control/selector.md/#control-point) by allowing only a specified percentage of
// flows at random or by sticky sessions.
//
// :::info
//
// See also [_Load Regulator overview](/concepts/flow-control/components/regulator.md).
//
// :::
type Regulator struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Input ports for the _Regulator_.
	InPorts *Regulator_Ins `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty"`
	// Parameters for the _Regulator_.
	Parameters *Regulator_Parameters `protobuf:"bytes,2,opt,name=parameters,proto3" json:"parameters,omitempty"`
	// Specify certain label values to be always accepted by this _Regulator_ regardless of accept percentage.
	PassThroughLabelValues []string `protobuf:"bytes,5,rep,name=pass_through_label_values,json=passThroughLabelValues,proto3" json:"pass_through_label_values,omitempty"`
	// Configuration key for setting pass through label values through dynamic configuration.
	PassThroughLabelValuesConfigKey string `protobuf:"bytes,6,opt,name=pass_through_label_values_config_key,json=passThroughLabelValuesConfigKey,proto3" json:"pass_through_label_values_config_key,omitempty"`
}

func (x *Regulator) Reset() {
	*x = Regulator{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Regulator) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Regulator) ProtoMessage() {}

func (x *Regulator) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Regulator.ProtoReflect.Descriptor instead.
func (*Regulator) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{7}
}

func (x *Regulator) GetInPorts() *Regulator_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *Regulator) GetParameters() *Regulator_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *Regulator) GetPassThroughLabelValues() []string {
	if x != nil {
		return x.PassThroughLabelValues
	}
	return nil
}

func (x *Regulator) GetPassThroughLabelValuesConfigKey() string {
	if x != nil {
		return x.PassThroughLabelValuesConfigKey
	}
	return ""
}

// The _Load Ramp_ produces a smooth and continuous traffic load
// that changes progressively over time, based on the specified steps.
//
// Each step is defined by two parameters:
//   - The `target_accept_percentage`.
//   - The `duration` for the signal to change from the
//     previous step's `target_accept_percentage` to the current step's
//     `target_accept_percentage`.
//
// The percentage of requests accepted starts at the `target_accept_percentage`
// defined in the first step and gradually ramps up or down linearly from
// the previous step's `target_accept_percentage` to the next
// `target_accept_percentage`, over the `duration` specified for each step.
type LoadRamp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	InPorts    *LoadRamp_Ins        `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty"`
	OutPorts   *LoadRamp_Outs       `protobuf:"bytes,2,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
	Parameters *LoadRamp_Parameters `protobuf:"bytes,3,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
	// Specify certain label values to be always accepted by the _Regulator_ regardless of accept percentage.
	PassThroughLabelValues []string `protobuf:"bytes,4,rep,name=pass_through_label_values,json=passThroughLabelValues,proto3" json:"pass_through_label_values,omitempty"`
	// Configuration key for setting pass through label values through dynamic configuration.
	PassThroughLabelValuesConfigKey string `protobuf:"bytes,5,opt,name=pass_through_label_values_config_key,json=passThroughLabelValuesConfigKey,proto3" json:"pass_through_label_values_config_key,omitempty"`
}

func (x *LoadRamp) Reset() {
	*x = LoadRamp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadRamp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadRamp) ProtoMessage() {}

func (x *LoadRamp) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadRamp.ProtoReflect.Descriptor instead.
func (*LoadRamp) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{8}
}

func (x *LoadRamp) GetInPorts() *LoadRamp_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *LoadRamp) GetOutPorts() *LoadRamp_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

func (x *LoadRamp) GetParameters() *LoadRamp_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *LoadRamp) GetPassThroughLabelValues() []string {
	if x != nil {
		return x.PassThroughLabelValues
	}
	return nil
}

func (x *LoadRamp) GetPassThroughLabelValuesConfigKey() string {
	if x != nil {
		return x.PassThroughLabelValuesConfigKey
	}
	return ""
}

// _LoadRampSeries_ is a component that applies a series of _Load Ramps_ in order.
type LoadRampSeries struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	InPorts    *LoadRampSeries_Ins        `protobuf:"bytes,1,opt,name=in_ports,json=inPorts,proto3" json:"in_ports,omitempty"`
	Parameters *LoadRampSeries_Parameters `protobuf:"bytes,2,opt,name=parameters,proto3" json:"parameters,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *LoadRampSeries) Reset() {
	*x = LoadRampSeries{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadRampSeries) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadRampSeries) ProtoMessage() {}

func (x *LoadRampSeries) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadRampSeries.ProtoReflect.Descriptor instead.
func (*LoadRampSeries) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{9}
}

func (x *LoadRampSeries) GetInPorts() *LoadRampSeries_Ins {
	if x != nil {
		return x.InPorts
	}
	return nil
}

func (x *LoadRampSeries) GetParameters() *LoadRampSeries_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

// Flux Meter gathers metrics for the traffic that matches its selector.
// The histogram created by Flux Meter measures the workload latency by default.
//
// :::info
//
// See also [Flux Meter overview](/concepts/flow-control/resources/flux-meter.md).
//
// :::
// Example:
// ```yaml
// static_buckets:
//
//	buckets: [5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]
//
// selectors:
//   - agent_group: demoapp
//     service: service1-demo-app.demoapp.svc.cluster.local
//     control_point: ingress
//
// attribute_key: response_duration_ms
// ```
type FluxMeter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Latency histogram buckets (in ms) for this Flux Meter.
	//
	// Types that are assignable to HistogramBuckets:
	//
	//	*FluxMeter_StaticBuckets_
	//	*FluxMeter_LinearBuckets_
	//	*FluxMeter_ExponentialBuckets_
	//	*FluxMeter_ExponentialBucketsRange_
	HistogramBuckets isFluxMeter_HistogramBuckets `protobuf_oneof:"histogram_buckets"`
	// Key of the attribute in access log or span from which the metric for this flux meter is read.
	//
	// :::info
	//
	// For list of available attributes in Envoy access logs, refer
	// [Envoy Filter](/integrations/flow-control/envoy/istio.md#envoy-filter)
	//
	// :::
	AttributeKey string `protobuf:"bytes,6,opt,name=attribute_key,json=attributeKey,proto3" json:"attribute_key,omitempty" default:"workload_duration_ms"` // @gotags: default:"workload_duration_ms"
	// Selectors for flows that will be metered by this _Flux Meter_.
	Selectors []*Selector `protobuf:"bytes,7,rep,name=selectors,proto3" json:"selectors,omitempty" validate:"required,gt=0,dive"` // @gotags: validate:"required,gt=0,dive"
}

func (x *FluxMeter) Reset() {
	*x = FluxMeter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter) ProtoMessage() {}

func (x *FluxMeter) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter.ProtoReflect.Descriptor instead.
func (*FluxMeter) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{10}
}

func (m *FluxMeter) GetHistogramBuckets() isFluxMeter_HistogramBuckets {
	if m != nil {
		return m.HistogramBuckets
	}
	return nil
}

func (x *FluxMeter) GetStaticBuckets() *FluxMeter_StaticBuckets {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_StaticBuckets_); ok {
		return x.StaticBuckets
	}
	return nil
}

func (x *FluxMeter) GetLinearBuckets() *FluxMeter_LinearBuckets {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_LinearBuckets_); ok {
		return x.LinearBuckets
	}
	return nil
}

func (x *FluxMeter) GetExponentialBuckets() *FluxMeter_ExponentialBuckets {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_ExponentialBuckets_); ok {
		return x.ExponentialBuckets
	}
	return nil
}

func (x *FluxMeter) GetExponentialBucketsRange() *FluxMeter_ExponentialBucketsRange {
	if x, ok := x.GetHistogramBuckets().(*FluxMeter_ExponentialBucketsRange_); ok {
		return x.ExponentialBucketsRange
	}
	return nil
}

func (x *FluxMeter) GetAttributeKey() string {
	if x != nil {
		return x.AttributeKey
	}
	return ""
}

func (x *FluxMeter) GetSelectors() []*Selector {
	if x != nil {
		return x.Selectors
	}
	return nil
}

type isFluxMeter_HistogramBuckets interface {
	isFluxMeter_HistogramBuckets()
}

type FluxMeter_StaticBuckets_ struct {
	StaticBuckets *FluxMeter_StaticBuckets `protobuf:"bytes,2,opt,name=static_buckets,json=staticBuckets,proto3,oneof"`
}

type FluxMeter_LinearBuckets_ struct {
	LinearBuckets *FluxMeter_LinearBuckets `protobuf:"bytes,3,opt,name=linear_buckets,json=linearBuckets,proto3,oneof"`
}

type FluxMeter_ExponentialBuckets_ struct {
	ExponentialBuckets *FluxMeter_ExponentialBuckets `protobuf:"bytes,4,opt,name=exponential_buckets,json=exponentialBuckets,proto3,oneof"`
}

type FluxMeter_ExponentialBucketsRange_ struct {
	ExponentialBucketsRange *FluxMeter_ExponentialBucketsRange `protobuf:"bytes,5,opt,name=exponential_buckets_range,json=exponentialBucketsRange,proto3,oneof"`
}

func (*FluxMeter_StaticBuckets_) isFluxMeter_HistogramBuckets() {}

func (*FluxMeter_LinearBuckets_) isFluxMeter_HistogramBuckets() {}

func (*FluxMeter_ExponentialBuckets_) isFluxMeter_HistogramBuckets() {}

func (*FluxMeter_ExponentialBucketsRange_) isFluxMeter_HistogramBuckets() {}

// Set of classification rules sharing a common selector
//
// :::info
//
// See also [Classifier overview](/concepts/flow-control/resources/classifier.md).
//
// :::
// Example
// ```yaml
// selectors:
//   - agent_group: demoapp
//     service: service1-demo-app.demoapp.svc.cluster.local
//     control_point: ingress
//     label_matcher:
//     match_labels:
//     user_tier: gold
//     match_expressions:
//   - key: user_type
//     operator: In
//
// rules:
//
//	user:
//	 extractor:
//	   from: request.http.headers.user-agent
//	telemetry: false
//
// ```
type Classifier struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A map of {key, value} pairs mapping from
	// [flow label](/concepts/flow-control/flow-label.md) keys to rules that define
	// how to extract and propagate flow labels with that key.
	Rules map[string]*Rule `protobuf:"bytes,2,rep,name=rules,proto3" json:"rules,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" validate:"dive,keys,required,endkeys,required"` // @gotags: validate:"dive,keys,required,endkeys,required"
	// Rego based classification
	//
	// Rego is a policy language used to express complex policies in a concise and declarative way.
	// It can be used to define flow classification rules by writing custom queries that extract values from request metadata.
	// For simple cases, such as directly reading a value from header or a field from JSON body, declarative extractors are recommended.
	Rego *Rego `protobuf:"bytes,3,opt,name=rego,proto3" json:"rego,omitempty"`
	// Selectors for flows that will be classified by this _Classifier_.
	Selectors []*Selector `protobuf:"bytes,4,rep,name=selectors,proto3" json:"selectors,omitempty" validate:"required,gt=0,dive"` // @gotags: validate:"required,gt=0,dive"
}

func (x *Classifier) Reset() {
	*x = Classifier{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Classifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Classifier) ProtoMessage() {}

func (x *Classifier) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Classifier.ProtoReflect.Descriptor instead.
func (*Classifier) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{11}
}

func (x *Classifier) GetRules() map[string]*Rule {
	if x != nil {
		return x.Rules
	}
	return nil
}

func (x *Classifier) GetRego() *Rego {
	if x != nil {
		return x.Rego
	}
	return nil
}

func (x *Classifier) GetSelectors() []*Selector {
	if x != nil {
		return x.Selectors
	}
	return nil
}

// Rule describes a single classification Rule
//
// Example of a JSON extractor:
// ```yaml
// extractor:
//
//	json:
//	  from: request.http.body
//	  pointer: /user/name
//
// ```
type Rule struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Source:
	//
	//	*Rule_Extractor
	Source isRule_Source `protobuf_oneof:"source"`
	// Decides if the created flow label should be available as an attribute in OLAP telemetry and
	// propagated in [baggage](/concepts/flow-control/flow-label.md#baggage)
	//
	// :::note
	//
	// The flow label is always accessible in Aperture Policies regardless of this setting.
	//
	// :::
	//
	// :::caution
	//
	// When using [FluxNinja ARC extension](/arc/extension.md), telemetry enabled
	// labels are sent to FluxNinja ARC for observability. Telemetry should be disabled for
	// sensitive labels.
	//
	// :::
	Telemetry bool `protobuf:"varint,3,opt,name=telemetry,proto3" json:"telemetry,omitempty" default:"true"` // @gotags: default:"true"
}

func (x *Rule) Reset() {
	*x = Rule{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Rule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rule) ProtoMessage() {}

func (x *Rule) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rule.ProtoReflect.Descriptor instead.
func (*Rule) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{12}
}

func (m *Rule) GetSource() isRule_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (x *Rule) GetExtractor() *Extractor {
	if x, ok := x.GetSource().(*Rule_Extractor); ok {
		return x.Extractor
	}
	return nil
}

func (x *Rule) GetTelemetry() bool {
	if x != nil {
		return x.Telemetry
	}
	return false
}

type isRule_Source interface {
	isRule_Source()
}

type Rule_Extractor struct {
	// High-level declarative extractor.
	Extractor *Extractor `protobuf:"bytes,1,opt,name=extractor,proto3,oneof"`
}

func (*Rule_Extractor) isRule_Source() {}

// Rego define a set of labels that are extracted after evaluating a Rego module.
//
// :::info
//
// You can use the [live-preview](/concepts/flow-control/resources/classifier.md#live-previewing-requests) feature to first preview the input to the classifier before writing the labeling logic.
//
// :::
//
// Example of Rego module which also disables telemetry visibility of label:
// ```yaml
// rego:
//
//	labels:
//	  user:
//	    telemetry: false
//	module: |
//	  package user_from_cookie
//	  cookies := split(input.attributes.request.http.headers.cookie, "; ")
//	  user := user {
//	      cookie := cookies[_]
//	      startswith(cookie, "session=")
//	      session := substring(cookie, count("session="), -1)
//	      parts := split(session, ".")
//	      object := json.unmarshal(base64url.decode(parts[0]))
//	      user := object.user
//	  }
//
// ```
type Rego struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A map of {key, value} pairs mapping from
	// [flow label](/concepts/flow-control/flow-label.md) keys to queries that define
	// how to extract and propagate flow labels with that key.
	// The name of the label maps to a variable in the Rego module. It maps to `data.<package>.<label>` variable.
	Labels map[string]*Rego_LabelProperties `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" validate:"required,gt=0,dive,keys,required,endkeys,required"` // @gotags: validate:"required,gt=0,dive,keys,required,endkeys,required"
	// Source code of the Rego module.
	//
	// :::note
	//
	// Must include a "package" declaration.
	//
	// :::
	Module string `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *Rego) Reset() {
	*x = Rego{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Rego) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rego) ProtoMessage() {}

func (x *Rego) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rego.ProtoReflect.Descriptor instead.
func (*Rego) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{13}
}

func (x *Rego) GetLabels() map[string]*Rego_LabelProperties {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Rego) GetModule() string {
	if x != nil {
		return x.Module
	}
	return ""
}

// Defines a high-level way to specify how to extract a flow label value given HTTP request metadata, without a need to write Rego code
//
// There are multiple variants of extractor, specify exactly one.
type Extractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Variant:
	//
	//	*Extractor_From
	//	*Extractor_Json
	//	*Extractor_Address
	//	*Extractor_Jwt
	//	*Extractor_PathTemplates
	Variant isExtractor_Variant `protobuf_oneof:"variant"`
}

func (x *Extractor) Reset() {
	*x = Extractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Extractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Extractor) ProtoMessage() {}

func (x *Extractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Extractor.ProtoReflect.Descriptor instead.
func (*Extractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{14}
}

func (m *Extractor) GetVariant() isExtractor_Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

func (x *Extractor) GetFrom() string {
	if x, ok := x.GetVariant().(*Extractor_From); ok {
		return x.From
	}
	return ""
}

func (x *Extractor) GetJson() *JSONExtractor {
	if x, ok := x.GetVariant().(*Extractor_Json); ok {
		return x.Json
	}
	return nil
}

func (x *Extractor) GetAddress() *AddressExtractor {
	if x, ok := x.GetVariant().(*Extractor_Address); ok {
		return x.Address
	}
	return nil
}

func (x *Extractor) GetJwt() *JWTExtractor {
	if x, ok := x.GetVariant().(*Extractor_Jwt); ok {
		return x.Jwt
	}
	return nil
}

func (x *Extractor) GetPathTemplates() *PathTemplateMatcher {
	if x, ok := x.GetVariant().(*Extractor_PathTemplates); ok {
		return x.PathTemplates
	}
	return nil
}

type isExtractor_Variant interface {
	isExtractor_Variant()
}

type Extractor_From struct {
	// Use an attribute with no conversion
	//
	// Attribute path is a dot-separated path to attribute.
	//
	// Should be either:
	// * one of the fields of [Attribute Context](https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/attribute_context.proto), or
	// * a special `request.http.bearer` pseudo-attribute.
	// For example, `request.http.method` or `request.http.header.user-agent`
	//
	// Note: The same attribute path syntax is shared by other extractor variants,
	// wherever attribute path is needed in their "from" syntax.
	//
	// Example:
	// ```yaml
	// from: request.http.headers.user-agent
	// ```
	From string `protobuf:"bytes,1,opt,name=from,proto3,oneof"`
}

type Extractor_Json struct {
	// Parse JSON, and extract one of the fields.
	Json *JSONExtractor `protobuf:"bytes,2,opt,name=json,proto3,oneof"`
}

type Extractor_Address struct {
	// Display an address as a single string - `<ip>:<port>`.
	Address *AddressExtractor `protobuf:"bytes,3,opt,name=address,proto3,oneof"`
}

type Extractor_Jwt struct {
	// Parse the attribute as JWT and read the payload.
	Jwt *JWTExtractor `protobuf:"bytes,4,opt,name=jwt,proto3,oneof"`
}

type Extractor_PathTemplates struct {
	// Match HTTP Path to given path templates.
	PathTemplates *PathTemplateMatcher `protobuf:"bytes,5,opt,name=path_templates,json=pathTemplates,proto3,oneof"`
}

func (*Extractor_From) isExtractor_Variant() {}

func (*Extractor_Json) isExtractor_Variant() {}

func (*Extractor_Address) isExtractor_Variant() {}

func (*Extractor_Jwt) isExtractor_Variant() {}

func (*Extractor_PathTemplates) isExtractor_Variant() {}

// Parse JSON, and extract one of the fields
//
// Example:
// ```yaml
// from: request.http.body
// pointer: /user/name
// ```
type JSONExtractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Attribute path pointing to some strings - for example, `request.http.body`.
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" validate:"required"` //@gotags: validate:"required"
	// JSON pointer represents a parsed JSON pointer which allows to select a specified field from the payload.
	//
	// Note: Uses [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,
	// for example, `/foo/bar`. If the pointer points into an object, it'd be converted to a string.
	Pointer string `protobuf:"bytes,2,opt,name=pointer,proto3" json:"pointer,omitempty"`
}

func (x *JSONExtractor) Reset() {
	*x = JSONExtractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *JSONExtractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JSONExtractor) ProtoMessage() {}

func (x *JSONExtractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JSONExtractor.ProtoReflect.Descriptor instead.
func (*JSONExtractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{15}
}

func (x *JSONExtractor) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *JSONExtractor) GetPointer() string {
	if x != nil {
		return x.Pointer
	}
	return ""
}

// Display an [Address][ext-authz-address] as a single string, for example, `<ip>:<port>`
//
// IP addresses in attribute context are defined as objects with separate IP and port fields.
// This is a helper to display an address as a single string.
//
// :::caution
//
// This might introduce high-cardinality flow label values.
//
// :::
//
// Example:
// ```yaml
// from: "source.address # or destination.address"
// ```
//
// [ext-authz-address]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address
type AddressExtractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Attribute path pointing to some string - for example, `source.address`.
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" validate:"required"` //@gotags: validate:"required"
}

func (x *AddressExtractor) Reset() {
	*x = AddressExtractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddressExtractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddressExtractor) ProtoMessage() {}

func (x *AddressExtractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddressExtractor.ProtoReflect.Descriptor instead.
func (*AddressExtractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{16}
}

func (x *AddressExtractor) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

// Parse the attribute as JWT and read the payload
//
// Specify a field to be extracted from payload using `json_pointer`.
//
// Note: The signature is not verified against the secret (assuming there's some
// other part of the system that handles such verification).
//
// Example:
// ```yaml
// from: request.http.bearer
// json_pointer: /user/email
// ```
type JWTExtractor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// JWT (JSON Web Token) can be extracted from any input attribute, but most likely you'd want to use `request.http.bearer`.
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" validate:"required"` //@gotags: validate:"required"
	// JSON pointer allowing to select a specified field from the payload.
	//
	// Note: Uses [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,
	// for example, `/foo/bar`. If the pointer points into an object, it'd be converted to a string.
	JsonPointer string `protobuf:"bytes,2,opt,name=json_pointer,json=jsonPointer,proto3" json:"json_pointer,omitempty"`
}

func (x *JWTExtractor) Reset() {
	*x = JWTExtractor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *JWTExtractor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JWTExtractor) ProtoMessage() {}

func (x *JWTExtractor) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JWTExtractor.ProtoReflect.Descriptor instead.
func (*JWTExtractor) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{17}
}

func (x *JWTExtractor) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *JWTExtractor) GetJsonPointer() string {
	if x != nil {
		return x.JsonPointer
	}
	return ""
}

// Matches HTTP Path to given path templates
//
// HTTP path will be matched against given path templates.
// If a match occurs, the value associated with the path template will be treated as a result.
// In case of multiple path templates matching, the most specific one will be chosen.
type PathTemplateMatcher struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Template value keys are OpenAPI-inspired path templates.
	//
	//   - Static path segment `/foo` matches a path segment exactly
	//   - `/{param}` matches arbitrary path segment.
	//     (The parameter name is ignored and can be omitted (`{}`))
	//   - The parameter must cover whole segment.
	//   - Additionally, path template can end with `/*` wildcard to match
	//     arbitrary number of trailing segments (0 or more).
	//   - Multiple consecutive `/` are ignored, as well as trailing `/`.
	//   - Parametrized path segments must come after static segments.
	//   - `*`, if present, must come last.
	//   - Most specific template "wins" (`/foo` over `/{}` and `/{}` over `/*`).
	//
	// See also <https://swagger.io/specification/#path-templating-matching>
	//
	// Example:
	// ```yaml
	// /register: register
	// "/user/{userId}": user
	// /static/*: other
	// ```
	TemplateValues map[string]string `protobuf:"bytes,1,rep,name=template_values,json=templateValues,proto3" json:"template_values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" validate:"gt=0,dive,keys,required,endkeys,required"` // @gotags: validate:"gt=0,dive,keys,required,endkeys,required"
}

func (x *PathTemplateMatcher) Reset() {
	*x = PathTemplateMatcher{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PathTemplateMatcher) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PathTemplateMatcher) ProtoMessage() {}

func (x *PathTemplateMatcher) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PathTemplateMatcher.ProtoReflect.Descriptor instead.
func (*PathTemplateMatcher) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{18}
}

func (x *PathTemplateMatcher) GetTemplateValues() map[string]string {
	if x != nil {
		return x.TemplateValues
	}
	return nil
}

// Selects flows based on control point, flow labels, agent group and the service
// that the [flow control component](/concepts/flow-control/flow-control.md#components)
// will operate on.
//
// :::info
//
// See also [Selector overview](/concepts/flow-control/selector.md).
//
// :::
//
// Example:
// ```yaml
// control_point: ingress
// label_matcher:
//
//	match_labels:
//	  user_tier: gold
//	match_expressions:
//	  - key: query
//	    operator: In
//	    values:
//	      - insert
//	      - delete
//	expression:
//	  label_matches:
//	      - label: user_agent
//	        regex: ^(?!.*Chrome).*Safari
//
// ```
type Selector struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// [Control Point](/concepts/flow-control/selector.md#control-point)
	// identifies location within services where policies can act on flows.
	// For an SDK based insertion,
	// a _Control Point_ can represent a particular feature or execution
	// block within a service. In case of service mesh or middleware insertion, a
	// _Control Point_ can identify ingress or egress calls or distinct listeners
	// or filter chains.
	ControlPoint string `protobuf:"bytes,1,opt,name=control_point,json=controlPoint,proto3" json:"control_point,omitempty" validate:"required"` // @gotags: validate:"required"
	// [_Agent Group_](/concepts/flow-control/selector.md#agent-group) this
	// selector applies to.
	//
	// :::info
	//
	// Agent Groups are used to scope policies to a subset of agents connected to the same controller.
	// The agents within an agent group receive exact same policy configuration and
	// form a peer to peer cluster to constantly share state.
	//
	// :::
	AgentGroup string `protobuf:"bytes,2,opt,name=agent_group,json=agentGroup,proto3" json:"agent_group,omitempty" default:"default"` // @gotags: default:"default"
	// The Fully Qualified Domain Name of the
	// [service](/concepts/flow-control/selector.md) to select.
	//
	// In Kubernetes, this is the FQDN of the Service object.
	//
	// :::info
	//
	// `any` matches all services.
	//
	// :::
	//
	// :::info
	//
	// An entity (for example, Kubernetes pod) might belong to multiple services.
	//
	// :::
	Service string `protobuf:"bytes,3,opt,name=service,proto3" json:"service,omitempty" default:"any"` // @gotags: default:"any"
	// [Label Matcher](/concepts/flow-control/selector.md#label-matcher)
	// can be used to match flows based on flow labels.
	LabelMatcher *LabelMatcher `protobuf:"bytes,4,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty"`
}

func (x *Selector) Reset() {
	*x = Selector{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Selector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Selector) ProtoMessage() {}

func (x *Selector) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Selector.ProtoReflect.Descriptor instead.
func (*Selector) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{19}
}

func (x *Selector) GetControlPoint() string {
	if x != nil {
		return x.ControlPoint
	}
	return ""
}

func (x *Selector) GetAgentGroup() string {
	if x != nil {
		return x.AgentGroup
	}
	return ""
}

func (x *Selector) GetService() string {
	if x != nil {
		return x.Service
	}
	return ""
}

func (x *Selector) GetLabelMatcher() *LabelMatcher {
	if x != nil {
		return x.LabelMatcher
	}
	return nil
}

type RateLimiter_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Specifies which label the rate limiter should be keyed by.
	//
	// Rate limiting is done independently for each value of the
	// [label](/concepts/flow-control/flow-label.md) with given key.
	// For example, to give each user a separate limit, assuming you
	// have a _user_ flow
	// label set up, set `label_key: "user"`.
	// If no label key is specified, then all requests matching the
	// selectors will be rate limited based on the global bucket.
	LabelKey string `protobuf:"bytes,1,opt,name=label_key,json=labelKey,proto3" json:"label_key,omitempty"`
	// Flow label key that will be used to override the number of tokens
	// for this request.
	// This is an optional parameter and takes highest precedence
	// when assigning tokens to a request.
	// The label value must be a valid uint64 number.
	TokensLabelKey string `protobuf:"bytes,2,opt,name=tokens_label_key,json=tokensLabelKey,proto3" json:"tokens_label_key,omitempty" default:"tokens"` // @gotags: default:"tokens"
	// Interval defines the time interval in which the token bucket
	// will fill tokens specified by `fill_amount` signal.
	Interval *durationpb.Duration `protobuf:"bytes,3,opt,name=interval,proto3" json:"interval,omitempty" validate:"required"` // @gotags: validate:"required"
	// Continuous fill determines whether the token bucket should be filled
	// continuously or only on discrete intervals.
	ContinuousFill bool `protobuf:"varint,4,opt,name=continuous_fill,json=continuousFill,proto3" json:"continuous_fill,omitempty" default:"true"` // @gotags: default:"true"
	// Max idle time before token bucket state for a label is removed.
	// If set to 0, the state is never removed.
	MaxIdleTime *durationpb.Duration `protobuf:"bytes,5,opt,name=max_idle_time,json=maxIdleTime,proto3" json:"max_idle_time,omitempty" default:"7200s"` // @gotags: default:"7200s"
	// Configuration of lazy-syncing behavior of rate limiter
	LazySync *RateLimiter_Parameters_LazySync `protobuf:"bytes,6,opt,name=lazy_sync,json=lazySync,proto3" json:"lazy_sync,omitempty"`
}

func (x *RateLimiter_Parameters) Reset() {
	*x = RateLimiter_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_Parameters) ProtoMessage() {}

func (x *RateLimiter_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_Parameters.ProtoReflect.Descriptor instead.
func (*RateLimiter_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{3, 0}
}

func (x *RateLimiter_Parameters) GetLabelKey() string {
	if x != nil {
		return x.LabelKey
	}
	return ""
}

func (x *RateLimiter_Parameters) GetTokensLabelKey() string {
	if x != nil {
		return x.TokensLabelKey
	}
	return ""
}

func (x *RateLimiter_Parameters) GetInterval() *durationpb.Duration {
	if x != nil {
		return x.Interval
	}
	return nil
}

func (x *RateLimiter_Parameters) GetContinuousFill() bool {
	if x != nil {
		return x.ContinuousFill
	}
	return false
}

func (x *RateLimiter_Parameters) GetMaxIdleTime() *durationpb.Duration {
	if x != nil {
		return x.MaxIdleTime
	}
	return nil
}

func (x *RateLimiter_Parameters) GetLazySync() *RateLimiter_Parameters_LazySync {
	if x != nil {
		return x.LazySync
	}
	return nil
}

// Inputs for the RateLimiter component
type RateLimiter_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Capacity of the bucket.
	BucketCapacity *InPort `protobuf:"bytes,1,opt,name=bucket_capacity,json=bucketCapacity,proto3" json:"bucket_capacity,omitempty" validate:"required"` // @gotags: validate:"required"
	// Number of tokens to fill within an `interval`.
	FillAmount *InPort `protobuf:"bytes,2,opt,name=fill_amount,json=fillAmount,proto3" json:"fill_amount,omitempty" validate:"required"` // @gotags: validate:"required"
	// PassThrough port determines whether all requests
	PassThrough *InPort `protobuf:"bytes,3,opt,name=pass_through,json=passThrough,proto3" json:"pass_through,omitempty"`
}

func (x *RateLimiter_Ins) Reset() {
	*x = RateLimiter_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_Ins) ProtoMessage() {}

func (x *RateLimiter_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_Ins.ProtoReflect.Descriptor instead.
func (*RateLimiter_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{3, 1}
}

func (x *RateLimiter_Ins) GetBucketCapacity() *InPort {
	if x != nil {
		return x.BucketCapacity
	}
	return nil
}

func (x *RateLimiter_Ins) GetFillAmount() *InPort {
	if x != nil {
		return x.FillAmount
	}
	return nil
}

func (x *RateLimiter_Ins) GetPassThrough() *InPort {
	if x != nil {
		return x.PassThrough
	}
	return nil
}

type RateLimiter_Parameters_LazySync struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Enables lazy sync
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty" default:"false"` // @gotags: default:"false"
	// Number of times to lazy sync within the `interval`.
	NumSync uint32 `protobuf:"varint,2,opt,name=num_sync,json=numSync,proto3" json:"num_sync,omitempty" default:"4" validate:"gt=0"` // @gotags: default:"4" validate:"gt=0"
}

func (x *RateLimiter_Parameters_LazySync) Reset() {
	*x = RateLimiter_Parameters_LazySync{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RateLimiter_Parameters_LazySync) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimiter_Parameters_LazySync) ProtoMessage() {}

func (x *RateLimiter_Parameters_LazySync) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimiter_Parameters_LazySync.ProtoReflect.Descriptor instead.
func (*RateLimiter_Parameters_LazySync) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{3, 0, 0}
}

func (x *RateLimiter_Parameters_LazySync) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *RateLimiter_Parameters_LazySync) GetNumSync() uint32 {
	if x != nil {
		return x.NumSync
	}
	return 0
}

// Parameters for _Load Scheduler_ component
type LoadScheduler_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Automatically estimate the size flows within each workload, based on
	// historical latency. Each workload's `tokens` will be set to average
	// latency of flows in that workload during the last few seconds (exact duration
	// of this average can change).
	// This setting is useful in concurrency limiting use-case, where the
	// concurrency is calculated as “(avg. latency \* in-flight flows)`.
	//
	// The value of tokens estimated takes a lower precedence
	// than the value of `tokens` specified in the workload definition
	// and `tokens` explicitly specified in the flow labels.
	WorkloadLatencyBasedTokens bool `protobuf:"varint,1,opt,name=workload_latency_based_tokens,json=workloadLatencyBasedTokens,proto3" json:"workload_latency_based_tokens,omitempty" default:"true"` // @gotags: default:"true"
	// Configuration of Weighted Fair Queuing-based workload scheduler.
	//
	// Contains configuration of per-agent scheduler
	Scheduler *Scheduler `protobuf:"bytes,2,opt,name=scheduler,proto3" json:"scheduler,omitempty"`
	// Selectors for the component.
	Selectors []*Selector `protobuf:"bytes,3,rep,name=selectors,proto3" json:"selectors,omitempty" validate:"required,gt=0,dive"` // @gotags: validate:"required,gt=0,dive"
}

func (x *LoadScheduler_Parameters) Reset() {
	*x = LoadScheduler_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadScheduler_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadScheduler_Parameters) ProtoMessage() {}

func (x *LoadScheduler_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadScheduler_Parameters.ProtoReflect.Descriptor instead.
func (*LoadScheduler_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{4, 0}
}

func (x *LoadScheduler_Parameters) GetWorkloadLatencyBasedTokens() bool {
	if x != nil {
		return x.WorkloadLatencyBasedTokens
	}
	return false
}

func (x *LoadScheduler_Parameters) GetScheduler() *Scheduler {
	if x != nil {
		return x.Scheduler
	}
	return nil
}

func (x *LoadScheduler_Parameters) GetSelectors() []*Selector {
	if x != nil {
		return x.Selectors
	}
	return nil
}

// Input for the LoadScheduler component.
type LoadScheduler_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Load multiplier is proportion of incoming
	// token rate that needs to be accepted.
	LoadMultiplier *InPort `protobuf:"bytes,1,opt,name=load_multiplier,json=loadMultiplier,proto3" json:"load_multiplier,omitempty"`
}

func (x *LoadScheduler_Ins) Reset() {
	*x = LoadScheduler_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadScheduler_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadScheduler_Ins) ProtoMessage() {}

func (x *LoadScheduler_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadScheduler_Ins.ProtoReflect.Descriptor instead.
func (*LoadScheduler_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{4, 1}
}

func (x *LoadScheduler_Ins) GetLoadMultiplier() *InPort {
	if x != nil {
		return x.LoadMultiplier
	}
	return nil
}

// Output for the LoadScheduler component.
type LoadScheduler_Outs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Observed load multiplier is the proportion of incoming token rate that is being accepted.
	ObservedLoadMultiplier *OutPort `protobuf:"bytes,1,opt,name=observed_load_multiplier,json=observedLoadMultiplier,proto3" json:"observed_load_multiplier,omitempty"`
}

func (x *LoadScheduler_Outs) Reset() {
	*x = LoadScheduler_Outs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadScheduler_Outs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadScheduler_Outs) ProtoMessage() {}

func (x *LoadScheduler_Outs) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadScheduler_Outs.ProtoReflect.Descriptor instead.
func (*LoadScheduler_Outs) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{4, 2}
}

func (x *LoadScheduler_Outs) GetObservedLoadMultiplier() *OutPort {
	if x != nil {
		return x.ObservedLoadMultiplier
	}
	return nil
}

// Workload defines a class of flows that preferably have similar properties such as response latency and desired priority.
type Scheduler_Workload struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Parameters associated with flows matching the label matcher.
	Parameters *Scheduler_Workload_Parameters `protobuf:"bytes,1,opt,name=parameters,proto3" json:"parameters,omitempty"`
	// Label Matcher to select a Workload based on
	// [flow labels](/concepts/flow-control/flow-label.md).
	LabelMatcher *LabelMatcher `protobuf:"bytes,2,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty" validate:"required"` // @gotags: validate:"required"
	// Name of the workload.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *Scheduler_Workload) Reset() {
	*x = Scheduler_Workload{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler_Workload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler_Workload) ProtoMessage() {}

func (x *Scheduler_Workload) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler_Workload.ProtoReflect.Descriptor instead.
func (*Scheduler_Workload) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{5, 0}
}

func (x *Scheduler_Workload) GetParameters() *Scheduler_Workload_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *Scheduler_Workload) GetLabelMatcher() *LabelMatcher {
	if x != nil {
		return x.LabelMatcher
	}
	return nil
}

func (x *Scheduler_Workload) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// Parameters such as priority, tokens and fairness key that
// are applicable to flows within a workload.
type Scheduler_Workload_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Describes priority level of the flows within the workload.
	// Priority level ranges from 0 to 255.
	// Higher numbers means higher priority level.
	// Priority levels have non-linear effect on the workload scheduling. The following formula is used to determine the position of a flow in the queue based on virtual finish time:
	//
	// $$
	// \text{virtual\_finish\_time} = \text{virtual\_time} + \left(\text{tokens} \cdot \left(\text{256} - \text{priority}\right)\right)
	// $$
	Priority uint32 `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty" validate:"gte=0,lte=255" default:"0"` // @gotags: validate:"gte=0,lte=255" default:"0"
	// Tokens determines the cost of admitting a single flow in the workload,
	// which is typically defined as milliseconds of flow latency (time to response or duration of a feature) or
	// simply equal to 1 if the resource being accessed is constrained by the
	// number of flows (3rd party rate limiters).
	// This override is applicable only if tokens for the flow aren't specified
	// in the flow labels.
	Tokens uint64 `protobuf:"varint,2,opt,name=tokens,proto3" json:"tokens,omitempty"`
	// Fairness key is a label key that can be used to provide fairness within a workload.
	// Any [flow label](/concepts/flow-control/flow-label.md) can be used here. For example, if
	// you have a classifier that sets `user` flow label, you might want to set
	// `fairness_key = "user"`.
	FairnessKey string `protobuf:"bytes,3,opt,name=fairness_key,json=fairnessKey,proto3" json:"fairness_key,omitempty"`
}

func (x *Scheduler_Workload_Parameters) Reset() {
	*x = Scheduler_Workload_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Scheduler_Workload_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Scheduler_Workload_Parameters) ProtoMessage() {}

func (x *Scheduler_Workload_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Scheduler_Workload_Parameters.ProtoReflect.Descriptor instead.
func (*Scheduler_Workload_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{5, 0, 0}
}

func (x *Scheduler_Workload_Parameters) GetPriority() uint32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *Scheduler_Workload_Parameters) GetTokens() uint64 {
	if x != nil {
		return x.Tokens
	}
	return 0
}

func (x *Scheduler_Workload_Parameters) GetFairnessKey() string {
	if x != nil {
		return x.FairnessKey
	}
	return ""
}

// Parameters for the _Adaptive Load Scheduler_ component.
type AdaptiveLoadScheduler_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Parameters for the _Load Scheduler_.
	LoadScheduler *LoadScheduler_Parameters `protobuf:"bytes,1,opt,name=load_scheduler,json=loadScheduler,proto3" json:"load_scheduler,omitempty" validate:"required"` // @gotags: validate:"required"
	// Parameters for the _Gradient Controller_.
	Gradient *GradientController_Parameters `protobuf:"bytes,2,opt,name=gradient,proto3" json:"gradient,omitempty" validate:"required"` // @gotags: validate:"required"
	// The maximum load multiplier that can be reached during recovery from an overload state.
	// - Helps protect the service from request bursts while the system is still recovering.
	// - Once this value is reached, the scheduler enters the pass-through mode, allowing requests to bypass the scheduler and be sent directly to the service.
	// - Any future overload state is detected by the control policy, and the load multiplier increment cycle is restarted.
	MaxLoadMultiplier float64 `protobuf:"fixed64,3,opt,name=max_load_multiplier,json=maxLoadMultiplier,proto3" json:"max_load_multiplier,omitempty" default:"2.0"` // @gotags: default:"2.0"
	// Linear increment to load multiplier in each execution tick when the system is
	// not in the overloaded state, up until the `max_load_multiplier` is reached.
	LoadMultiplierLinearIncrement float64 `protobuf:"fixed64,4,opt,name=load_multiplier_linear_increment,json=loadMultiplierLinearIncrement,proto3" json:"load_multiplier_linear_increment,omitempty" default:"0.0025"` // @gotags: default:"0.0025"
	// Configuration parameters for the embedded Alerter.
	Alerter *Alerter_Parameters `protobuf:"bytes,5,opt,name=alerter,proto3" json:"alerter,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *AdaptiveLoadScheduler_Parameters) Reset() {
	*x = AdaptiveLoadScheduler_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AdaptiveLoadScheduler_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdaptiveLoadScheduler_Parameters) ProtoMessage() {}

func (x *AdaptiveLoadScheduler_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdaptiveLoadScheduler_Parameters.ProtoReflect.Descriptor instead.
func (*AdaptiveLoadScheduler_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{6, 0}
}

func (x *AdaptiveLoadScheduler_Parameters) GetLoadScheduler() *LoadScheduler_Parameters {
	if x != nil {
		return x.LoadScheduler
	}
	return nil
}

func (x *AdaptiveLoadScheduler_Parameters) GetGradient() *GradientController_Parameters {
	if x != nil {
		return x.Gradient
	}
	return nil
}

func (x *AdaptiveLoadScheduler_Parameters) GetMaxLoadMultiplier() float64 {
	if x != nil {
		return x.MaxLoadMultiplier
	}
	return 0
}

func (x *AdaptiveLoadScheduler_Parameters) GetLoadMultiplierLinearIncrement() float64 {
	if x != nil {
		return x.LoadMultiplierLinearIncrement
	}
	return 0
}

func (x *AdaptiveLoadScheduler_Parameters) GetAlerter() *Alerter_Parameters {
	if x != nil {
		return x.Alerter
	}
	return nil
}

// Input ports for the _Adaptive Load Scheduler_ component.
type AdaptiveLoadScheduler_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The input signal to the controller.
	Signal *InPort `protobuf:"bytes,1,opt,name=signal,proto3" json:"signal,omitempty" validate:"required"` // @gotags: validate:"required"
	// The setpoint input to the controller.
	Setpoint *InPort `protobuf:"bytes,2,opt,name=setpoint,proto3" json:"setpoint,omitempty" validate:"required"` // @gotags: validate:"required"
	// The `overload_confirmation` port provides additional criteria to determine overload state which
	// results in _Flow_ throttling at the service.
	OverloadConfirmation *InPort `protobuf:"bytes,3,opt,name=overload_confirmation,json=overloadConfirmation,proto3" json:"overload_confirmation,omitempty"`
}

func (x *AdaptiveLoadScheduler_Ins) Reset() {
	*x = AdaptiveLoadScheduler_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[30]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AdaptiveLoadScheduler_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdaptiveLoadScheduler_Ins) ProtoMessage() {}

func (x *AdaptiveLoadScheduler_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[30]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdaptiveLoadScheduler_Ins.ProtoReflect.Descriptor instead.
func (*AdaptiveLoadScheduler_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{6, 1}
}

func (x *AdaptiveLoadScheduler_Ins) GetSignal() *InPort {
	if x != nil {
		return x.Signal
	}
	return nil
}

func (x *AdaptiveLoadScheduler_Ins) GetSetpoint() *InPort {
	if x != nil {
		return x.Setpoint
	}
	return nil
}

func (x *AdaptiveLoadScheduler_Ins) GetOverloadConfirmation() *InPort {
	if x != nil {
		return x.OverloadConfirmation
	}
	return nil
}

// Output ports for the _Adaptive Load Scheduler_ component.
type AdaptiveLoadScheduler_Outs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A Boolean signal that indicates whether the service is in overload state.
	IsOverload *OutPort `protobuf:"bytes,1,opt,name=is_overload,json=isOverload,proto3" json:"is_overload,omitempty"`
	// Desired Load multiplier is the ratio of desired token rate to the incoming token rate.
	DesiredLoadMultiplier *OutPort `protobuf:"bytes,2,opt,name=desired_load_multiplier,json=desiredLoadMultiplier,proto3" json:"desired_load_multiplier,omitempty"`
	// Observed Load multiplier is the ratio of accepted token rate to the incoming token rate.
	ObservedLoadMultiplier *OutPort `protobuf:"bytes,3,opt,name=observed_load_multiplier,json=observedLoadMultiplier,proto3" json:"observed_load_multiplier,omitempty"`
}

func (x *AdaptiveLoadScheduler_Outs) Reset() {
	*x = AdaptiveLoadScheduler_Outs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[31]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AdaptiveLoadScheduler_Outs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdaptiveLoadScheduler_Outs) ProtoMessage() {}

func (x *AdaptiveLoadScheduler_Outs) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[31]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdaptiveLoadScheduler_Outs.ProtoReflect.Descriptor instead.
func (*AdaptiveLoadScheduler_Outs) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{6, 2}
}

func (x *AdaptiveLoadScheduler_Outs) GetIsOverload() *OutPort {
	if x != nil {
		return x.IsOverload
	}
	return nil
}

func (x *AdaptiveLoadScheduler_Outs) GetDesiredLoadMultiplier() *OutPort {
	if x != nil {
		return x.DesiredLoadMultiplier
	}
	return nil
}

func (x *AdaptiveLoadScheduler_Outs) GetObservedLoadMultiplier() *OutPort {
	if x != nil {
		return x.ObservedLoadMultiplier
	}
	return nil
}

type Regulator_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The flow label key for identifying sessions.
	//   - When label key is specified, _Regulator_ acts as a sticky filter.
	//     The series of flows with the same value of label key get the same
	//     decision provided that the `accept_percentage` is same or higher.
	//   - When label key is not specified, _Regulator_ acts as a stateless filter.
	//     Percentage of flows are selected randomly for rejection.
	LabelKey string `protobuf:"bytes,2,opt,name=label_key,json=labelKey,proto3" json:"label_key,omitempty"`
	// Selectors for the component.
	Selectors []*Selector `protobuf:"bytes,3,rep,name=selectors,proto3" json:"selectors,omitempty" validate:"required,gt=0,dive"` // @gotags: validate:"required,gt=0,dive"
}

func (x *Regulator_Parameters) Reset() {
	*x = Regulator_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[32]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Regulator_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Regulator_Parameters) ProtoMessage() {}

func (x *Regulator_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[32]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Regulator_Parameters.ProtoReflect.Descriptor instead.
func (*Regulator_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{7, 0}
}

func (x *Regulator_Parameters) GetLabelKey() string {
	if x != nil {
		return x.LabelKey
	}
	return ""
}

func (x *Regulator_Parameters) GetSelectors() []*Selector {
	if x != nil {
		return x.Selectors
	}
	return nil
}

type Regulator_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The percentage of requests to accept.
	AcceptPercentage *InPort `protobuf:"bytes,1,opt,name=accept_percentage,json=acceptPercentage,proto3" json:"accept_percentage,omitempty"`
}

func (x *Regulator_Ins) Reset() {
	*x = Regulator_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[33]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Regulator_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Regulator_Ins) ProtoMessage() {}

func (x *Regulator_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[33]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Regulator_Ins.ProtoReflect.Descriptor instead.
func (*Regulator_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{7, 1}
}

func (x *Regulator_Ins) GetAcceptPercentage() *InPort {
	if x != nil {
		return x.AcceptPercentage
	}
	return nil
}

// Parameters for the _Load Ramp_ component.
type LoadRamp_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Parameters for the _Regulator_.
	Regulator *Regulator_Parameters       `protobuf:"bytes,1,opt,name=regulator,proto3" json:"regulator,omitempty"`
	Steps     []*LoadRamp_Parameters_Step `protobuf:"bytes,2,rep,name=steps,proto3" json:"steps,omitempty" validate:"required,gt=0,dive"` // @gotags: validate:"required,gt=0,dive"
}

func (x *LoadRamp_Parameters) Reset() {
	*x = LoadRamp_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[34]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadRamp_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadRamp_Parameters) ProtoMessage() {}

func (x *LoadRamp_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[34]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadRamp_Parameters.ProtoReflect.Descriptor instead.
func (*LoadRamp_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{8, 0}
}

func (x *LoadRamp_Parameters) GetRegulator() *Regulator_Parameters {
	if x != nil {
		return x.Regulator
	}
	return nil
}

func (x *LoadRamp_Parameters) GetSteps() []*LoadRamp_Parameters_Step {
	if x != nil {
		return x.Steps
	}
	return nil
}

// Inputs for the _Load Ramp_ component.
type LoadRamp_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Whether to progress the _Load Ramp_ towards the next step.
	Forward *InPort `protobuf:"bytes,1,opt,name=forward,proto3" json:"forward,omitempty"`
	// Whether to progress the _Load Ramp_ towards the previous step.
	Backward *InPort `protobuf:"bytes,2,opt,name=backward,proto3" json:"backward,omitempty"`
	// Whether to reset the _Load Ramp_ to the first step.
	Reset_ *InPort `protobuf:"bytes,3,opt,name=reset,proto3" json:"reset,omitempty"`
}

func (x *LoadRamp_Ins) Reset() {
	*x = LoadRamp_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[35]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadRamp_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadRamp_Ins) ProtoMessage() {}

func (x *LoadRamp_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[35]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadRamp_Ins.ProtoReflect.Descriptor instead.
func (*LoadRamp_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{8, 1}
}

func (x *LoadRamp_Ins) GetForward() *InPort {
	if x != nil {
		return x.Forward
	}
	return nil
}

func (x *LoadRamp_Ins) GetBackward() *InPort {
	if x != nil {
		return x.Backward
	}
	return nil
}

func (x *LoadRamp_Ins) GetReset_() *InPort {
	if x != nil {
		return x.Reset_
	}
	return nil
}

// Outputs for the _Load Ramp_ component.
type LoadRamp_Outs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The percentage of flows being accepted by the _Load Ramp_.
	AcceptPercentage *OutPort `protobuf:"bytes,1,opt,name=accept_percentage,json=acceptPercentage,proto3" json:"accept_percentage,omitempty"`
	// A Boolean signal indicating whether the _Load Ramp_ is at the start of signal generation.
	AtStart *OutPort `protobuf:"bytes,2,opt,name=at_start,json=atStart,proto3" json:"at_start,omitempty"`
	// A Boolean signal indicating whether the _Load Ramp_ is at the end of signal generation.
	AtEnd *OutPort `protobuf:"bytes,3,opt,name=at_end,json=atEnd,proto3" json:"at_end,omitempty"`
}

func (x *LoadRamp_Outs) Reset() {
	*x = LoadRamp_Outs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[36]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadRamp_Outs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadRamp_Outs) ProtoMessage() {}

func (x *LoadRamp_Outs) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[36]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadRamp_Outs.ProtoReflect.Descriptor instead.
func (*LoadRamp_Outs) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{8, 2}
}

func (x *LoadRamp_Outs) GetAcceptPercentage() *OutPort {
	if x != nil {
		return x.AcceptPercentage
	}
	return nil
}

func (x *LoadRamp_Outs) GetAtStart() *OutPort {
	if x != nil {
		return x.AtStart
	}
	return nil
}

func (x *LoadRamp_Outs) GetAtEnd() *OutPort {
	if x != nil {
		return x.AtEnd
	}
	return nil
}

type LoadRamp_Parameters_Step struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The value of the step.
	TargetAcceptPercentage float64 `protobuf:"fixed64,1,opt,name=target_accept_percentage,json=targetAcceptPercentage,proto3" json:"target_accept_percentage,omitempty" validate:"gte=0,lte=100"` // @gotags: validate:"gte=0,lte=100"
	// Duration for which the step is active.
	Duration *durationpb.Duration `protobuf:"bytes,2,opt,name=duration,proto3" json:"duration,omitempty" validate:"required"` // @gotags: validate:"required"
}

func (x *LoadRamp_Parameters_Step) Reset() {
	*x = LoadRamp_Parameters_Step{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[37]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadRamp_Parameters_Step) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadRamp_Parameters_Step) ProtoMessage() {}

func (x *LoadRamp_Parameters_Step) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[37]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadRamp_Parameters_Step.ProtoReflect.Descriptor instead.
func (*LoadRamp_Parameters_Step) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{8, 0, 0}
}

func (x *LoadRamp_Parameters_Step) GetTargetAcceptPercentage() float64 {
	if x != nil {
		return x.TargetAcceptPercentage
	}
	return 0
}

func (x *LoadRamp_Parameters_Step) GetDuration() *durationpb.Duration {
	if x != nil {
		return x.Duration
	}
	return nil
}

type LoadRampSeries_LoadRampInstance struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The load ramp.
	LoadRamp *LoadRamp_Parameters `protobuf:"bytes,1,opt,name=load_ramp,json=loadRamp,proto3" json:"load_ramp,omitempty" validate:"required"` // @gotags: validate:"required"
	OutPorts *LoadRamp_Outs       `protobuf:"bytes,2,opt,name=out_ports,json=outPorts,proto3" json:"out_ports,omitempty"`
}

func (x *LoadRampSeries_LoadRampInstance) Reset() {
	*x = LoadRampSeries_LoadRampInstance{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[38]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadRampSeries_LoadRampInstance) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadRampSeries_LoadRampInstance) ProtoMessage() {}

func (x *LoadRampSeries_LoadRampInstance) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[38]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadRampSeries_LoadRampInstance.ProtoReflect.Descriptor instead.
func (*LoadRampSeries_LoadRampInstance) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{9, 0}
}

func (x *LoadRampSeries_LoadRampInstance) GetLoadRamp() *LoadRamp_Parameters {
	if x != nil {
		return x.LoadRamp
	}
	return nil
}

func (x *LoadRampSeries_LoadRampInstance) GetOutPorts() *LoadRamp_Outs {
	if x != nil {
		return x.OutPorts
	}
	return nil
}

// Parameters for the _LoadRampSeries_ component.
type LoadRampSeries_Parameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// An ordered list of load ramps that get applied in order.
	LoadRamps []*LoadRampSeries_LoadRampInstance `protobuf:"bytes,1,rep,name=load_ramps,json=loadRamps,proto3" json:"load_ramps,omitempty" validate:"required,dive"` // @gotags: validate:"required,dive"
}

func (x *LoadRampSeries_Parameters) Reset() {
	*x = LoadRampSeries_Parameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[39]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadRampSeries_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadRampSeries_Parameters) ProtoMessage() {}

func (x *LoadRampSeries_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[39]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadRampSeries_Parameters.ProtoReflect.Descriptor instead.
func (*LoadRampSeries_Parameters) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{9, 1}
}

func (x *LoadRampSeries_Parameters) GetLoadRamps() []*LoadRampSeries_LoadRampInstance {
	if x != nil {
		return x.LoadRamps
	}
	return nil
}

// Inputs for the _LoadRampSeries_ component.
type LoadRampSeries_Ins struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Whether to progress the load ramp series towards the next step.
	Forward *InPort `protobuf:"bytes,1,opt,name=forward,proto3" json:"forward,omitempty"`
	// Whether to progress the load ramp series towards the previous step.
	Backward *InPort `protobuf:"bytes,2,opt,name=backward,proto3" json:"backward,omitempty"`
	// Whether to reset the load ramp series to the first step.
	Reset_ *InPort `protobuf:"bytes,3,opt,name=reset,proto3" json:"reset,omitempty"`
}

func (x *LoadRampSeries_Ins) Reset() {
	*x = LoadRampSeries_Ins{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[40]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoadRampSeries_Ins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadRampSeries_Ins) ProtoMessage() {}

func (x *LoadRampSeries_Ins) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[40]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadRampSeries_Ins.ProtoReflect.Descriptor instead.
func (*LoadRampSeries_Ins) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{9, 2}
}

func (x *LoadRampSeries_Ins) GetForward() *InPort {
	if x != nil {
		return x.Forward
	}
	return nil
}

func (x *LoadRampSeries_Ins) GetBackward() *InPort {
	if x != nil {
		return x.Backward
	}
	return nil
}

func (x *LoadRampSeries_Ins) GetReset_() *InPort {
	if x != nil {
		return x.Reset_
	}
	return nil
}

// StaticBuckets holds the static value of the buckets where latency histogram will be stored.
type FluxMeter_StaticBuckets struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The buckets in which latency histogram will be stored.
	Buckets []float64 `protobuf:"fixed64,1,rep,packed,name=buckets,proto3" json:"buckets,omitempty" default:"[5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]"` // @gotags: default:"[5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]"
}

func (x *FluxMeter_StaticBuckets) Reset() {
	*x = FluxMeter_StaticBuckets{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[41]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_StaticBuckets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_StaticBuckets) ProtoMessage() {}

func (x *FluxMeter_StaticBuckets) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[41]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_StaticBuckets.ProtoReflect.Descriptor instead.
func (*FluxMeter_StaticBuckets) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{10, 0}
}

func (x *FluxMeter_StaticBuckets) GetBuckets() []float64 {
	if x != nil {
		return x.Buckets
	}
	return nil
}

// LinearBuckets creates `count` number of buckets, each `width` wide, where the lowest bucket has an
// upper bound of `start`. The final +inf bucket is not counted.
type FluxMeter_LinearBuckets struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Upper bound of the lowest bucket.
	Start float64 `protobuf:"fixed64,1,opt,name=start,proto3" json:"start,omitempty"`
	// Width of each bucket.
	Width float64 `protobuf:"fixed64,2,opt,name=width,proto3" json:"width,omitempty"`
	// Number of buckets.
	Count int32 `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty" validate:"gt=0"` // @gotags: validate:"gt=0"
}

func (x *FluxMeter_LinearBuckets) Reset() {
	*x = FluxMeter_LinearBuckets{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[42]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_LinearBuckets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_LinearBuckets) ProtoMessage() {}

func (x *FluxMeter_LinearBuckets) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[42]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_LinearBuckets.ProtoReflect.Descriptor instead.
func (*FluxMeter_LinearBuckets) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{10, 1}
}

func (x *FluxMeter_LinearBuckets) GetStart() float64 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *FluxMeter_LinearBuckets) GetWidth() float64 {
	if x != nil {
		return x.Width
	}
	return 0
}

func (x *FluxMeter_LinearBuckets) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

// ExponentialBuckets creates `count` number of buckets where the lowest bucket has an upper bound of `start`
// and each following bucket's upper bound is `factor` times the previous bucket's upper bound. The final +inf
// bucket is not counted.
type FluxMeter_ExponentialBuckets struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Upper bound of the lowest bucket.
	Start float64 `protobuf:"fixed64,1,opt,name=start,proto3" json:"start,omitempty" validate:"gt=0.0"` // @gotags: validate:"gt=0.0"
	// Factor to be multiplied to the previous bucket's upper bound to calculate the following bucket's upper bound.
	Factor float64 `protobuf:"fixed64,2,opt,name=factor,proto3" json:"factor,omitempty" validate:"gt=1.0"` // @gotags: validate:"gt=1.0"
	// Number of buckets.
	Count int32 `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty" validate:"gt=0"` // @gotags: validate:"gt=0"
}

func (x *FluxMeter_ExponentialBuckets) Reset() {
	*x = FluxMeter_ExponentialBuckets{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[43]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_ExponentialBuckets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_ExponentialBuckets) ProtoMessage() {}

func (x *FluxMeter_ExponentialBuckets) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[43]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_ExponentialBuckets.ProtoReflect.Descriptor instead.
func (*FluxMeter_ExponentialBuckets) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{10, 2}
}

func (x *FluxMeter_ExponentialBuckets) GetStart() float64 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *FluxMeter_ExponentialBuckets) GetFactor() float64 {
	if x != nil {
		return x.Factor
	}
	return 0
}

func (x *FluxMeter_ExponentialBuckets) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

// ExponentialBucketsRange creates `count` number of buckets where the lowest bucket is `min` and the highest
// bucket is `max`. The final +inf bucket is not counted.
type FluxMeter_ExponentialBucketsRange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Lowest bucket.
	Min float64 `protobuf:"fixed64,1,opt,name=min,proto3" json:"min,omitempty" validate:"gt=0.0"` // @gotags: validate:"gt=0.0"
	// Highest bucket.
	Max float64 `protobuf:"fixed64,2,opt,name=max,proto3" json:"max,omitempty"`
	// Number of buckets.
	Count int32 `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty" validate:"gt=0"` // @gotags: validate:"gt=0"
}

func (x *FluxMeter_ExponentialBucketsRange) Reset() {
	*x = FluxMeter_ExponentialBucketsRange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[44]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FluxMeter_ExponentialBucketsRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FluxMeter_ExponentialBucketsRange) ProtoMessage() {}

func (x *FluxMeter_ExponentialBucketsRange) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[44]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FluxMeter_ExponentialBucketsRange.ProtoReflect.Descriptor instead.
func (*FluxMeter_ExponentialBucketsRange) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{10, 3}
}

func (x *FluxMeter_ExponentialBucketsRange) GetMin() float64 {
	if x != nil {
		return x.Min
	}
	return 0
}

func (x *FluxMeter_ExponentialBucketsRange) GetMax() float64 {
	if x != nil {
		return x.Max
	}
	return 0
}

func (x *FluxMeter_ExponentialBucketsRange) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

type Rego_LabelProperties struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Decides if the created flow label should be available as an attribute in OLAP telemetry and
	// propagated in [baggage](/concepts/flow-control/flow-label.md#baggage)
	//
	// :::note
	//
	// The flow label is always accessible in Aperture Policies regardless of this setting.
	//
	// :::
	//
	// :::caution
	//
	// When using [FluxNinja ARC extension](/arc/extension.md), telemetry enabled
	// labels are sent to FluxNinja ARC for observability. Telemetry should be disabled for
	// sensitive labels.
	//
	// :::
	Telemetry bool `protobuf:"varint,1,opt,name=telemetry,proto3" json:"telemetry,omitempty" default:"true"` // @gotags: default:"true"
}

func (x *Rego_LabelProperties) Reset() {
	*x = Rego_LabelProperties{}
	if protoimpl.UnsafeEnabled {
		mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[46]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Rego_LabelProperties) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rego_LabelProperties) ProtoMessage() {}

func (x *Rego_LabelProperties) ProtoReflect() protoreflect.Message {
	mi := &file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[46]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rego_LabelProperties.ProtoReflect.Descriptor instead.
func (*Rego_LabelProperties) Descriptor() ([]byte, []int) {
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP(), []int{13, 0}
}

func (x *Rego_LabelProperties) GetTelemetry() bool {
	if x != nil {
		return x.Telemetry
	}
	return false
}

var File_aperture_policy_language_v1_flowcontrol_proto protoreflect.FileDescriptor

var file_aperture_policy_language_v1_flowcontrol_proto_rawDesc = []byte{
	0x0a, 0x2d, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x66, 0x6c,
	0x6f, 0x77, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x1b, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x1a, 0x2f, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2f, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f,
	0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x27, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2f, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x70, 0x6f, 0x72, 0x74, 0x73,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x30, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2f, 0x76, 0x31, 0x2f, 0x73, 0x74, 0x64, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e,
	0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x19, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x61, 0x6e, 0x79, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x22, 0xac, 0x02, 0x0a, 0x14, 0x46, 0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x74,
	0x72, 0x6f, 0x6c, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x12, 0x62, 0x0a, 0x0b,
	0x66, 0x6c, 0x75, 0x78, 0x5f, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x41, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x46, 0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x52, 0x65, 0x73, 0x6f, 0x75,
	0x72, 0x63, 0x65, 0x73, 0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x45,
	0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x66, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x73,
	0x12, 0x49, 0x0a, 0x0b, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x69, 0x66, 0x69, 0x65, 0x72, 0x73, 0x18,
	0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x69, 0x66, 0x69, 0x65, 0x72, 0x52, 0x0b,
	0x63, 0x6c, 0x61, 0x73, 0x73, 0x69, 0x66, 0x69, 0x65, 0x72, 0x73, 0x1a, 0x65, 0x0a, 0x0f, 0x46,
	0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,
	0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,
	0x12, 0x3c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x26, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c,
	0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02,
	0x38, 0x01, 0x22, 0x9e, 0x05, 0x0a, 0x0b, 0x46, 0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x74, 0x72,
	0x6f, 0x6c, 0x12, 0x56, 0x0a, 0x0f, 0x71, 0x75, 0x6f, 0x74, 0x61, 0x5f, 0x73, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x61, 0x70,
	0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x51, 0x75, 0x6f, 0x74, 0x61, 0x53,
	0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x48, 0x00, 0x52, 0x0e, 0x71, 0x75, 0x6f, 0x74,
	0x61, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x4d, 0x0a, 0x0c, 0x72, 0x61,
	0x74, 0x65, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x28, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52,
	0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x48, 0x00, 0x52, 0x0b, 0x72, 0x61,
	0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x12, 0x53, 0x0a, 0x0e, 0x6c, 0x6f, 0x61,
	0x64, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x2a, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x48, 0x00, 0x52,
	0x0d, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x6c,
	0x0a, 0x17, 0x61, 0x64, 0x61, 0x70, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f,
	0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x32, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x64,
	0x61, 0x70, 0x74, 0x69, 0x76, 0x65, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75,
	0x6c, 0x65, 0x72, 0x48, 0x00, 0x52, 0x15, 0x61, 0x64, 0x61, 0x70, 0x74, 0x69, 0x76, 0x65, 0x4c,
	0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x46, 0x0a, 0x09,
	0x72, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x26, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65,
	0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x09, 0x72, 0x65, 0x67, 0x75, 0x6c,
	0x61, 0x74, 0x6f, 0x72, 0x12, 0x44, 0x0a, 0x09, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x72, 0x61, 0x6d,
	0x70, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x48, 0x00,
	0x52, 0x08, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x12, 0x57, 0x0a, 0x10, 0x6c, 0x6f,
	0x61, 0x64, 0x5f, 0x72, 0x61, 0x6d, 0x70, 0x5f, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x18, 0x0b,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x53, 0x65, 0x72, 0x69, 0x65,
	0x73, 0x48, 0x00, 0x52, 0x0e, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x53, 0x65, 0x72,
	0x69, 0x65, 0x73, 0x12, 0x31, 0x0a, 0x07, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x18, 0xe8,
	0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x41, 0x6e, 0x79, 0x48, 0x00, 0x52, 0x07, 0x70,
	0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x42, 0x0b, 0x0a, 0x09, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x6e,
	0x65, 0x6e, 0x74, 0x22, 0xbc, 0x02, 0x0a, 0x0e, 0x51, 0x75, 0x6f, 0x74, 0x61, 0x53, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72,
	0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74,
	0x65, 0x72, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12,
	0x43, 0x0a, 0x09, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x25, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x09, 0x73, 0x65, 0x6c, 0x65, 0x63,
	0x74, 0x6f, 0x72, 0x73, 0x12, 0x56, 0x0a, 0x0c, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x6c, 0x69, 0x6d,
	0x69, 0x74, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d,
	0x69, 0x74, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52,
	0x0b, 0x72, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x12, 0x44, 0x0a, 0x09,
	0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x26, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63,
	0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x52, 0x09, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c,
	0x65, 0x72, 0x22, 0xe5, 0x06, 0x0a, 0x0b, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74,
	0x65, 0x72, 0x12, 0x47, 0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x2e, 0x49,
	0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x53, 0x0a, 0x0a, 0x70,
	0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x33, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61,
	0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65,
	0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73,
	0x12, 0x43, 0x0a, 0x09, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x18, 0x03, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x09, 0x73, 0x65, 0x6c, 0x65,
	0x63, 0x74, 0x6f, 0x72, 0x73, 0x1a, 0x8e, 0x03, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65,
	0x74, 0x65, 0x72, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6b, 0x65,
	0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x4b, 0x65,
	0x79, 0x12, 0x28, 0x0a, 0x10, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x5f, 0x6c, 0x61, 0x62, 0x65,
	0x6c, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x6f, 0x6b,
	0x65, 0x6e, 0x73, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x4b, 0x65, 0x79, 0x12, 0x35, 0x0a, 0x08, 0x69,
	0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
	0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76,
	0x61, 0x6c, 0x12, 0x27, 0x0a, 0x0f, 0x63, 0x6f, 0x6e, 0x74, 0x69, 0x6e, 0x75, 0x6f, 0x75, 0x73,
	0x5f, 0x66, 0x69, 0x6c, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x63, 0x6f, 0x6e,
	0x74, 0x69, 0x6e, 0x75, 0x6f, 0x75, 0x73, 0x46, 0x69, 0x6c, 0x6c, 0x12, 0x3d, 0x0a, 0x0d, 0x6d,
	0x61, 0x78, 0x5f, 0x69, 0x64, 0x6c, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0b, 0x6d,
	0x61, 0x78, 0x49, 0x64, 0x6c, 0x65, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x59, 0x0a, 0x09, 0x6c, 0x61,
	0x7a, 0x79, 0x5f, 0x73, 0x79, 0x6e, 0x63, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3c, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65,
	0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
	0x72, 0x73, 0x2e, 0x4c, 0x61, 0x7a, 0x79, 0x53, 0x79, 0x6e, 0x63, 0x52, 0x08, 0x6c, 0x61, 0x7a,
	0x79, 0x53, 0x79, 0x6e, 0x63, 0x1a, 0x3f, 0x0a, 0x08, 0x4c, 0x61, 0x7a, 0x79, 0x53, 0x79, 0x6e,
	0x63, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x6e,
	0x75, 0x6d, 0x5f, 0x73, 0x79, 0x6e, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x6e,
	0x75, 0x6d, 0x53, 0x79, 0x6e, 0x63, 0x1a, 0xe1, 0x01, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x4c,
	0x0a, 0x0f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74,
	0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x0e, 0x62, 0x75,
	0x63, 0x6b, 0x65, 0x74, 0x43, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x12, 0x44, 0x0a, 0x0b,
	0x66, 0x69, 0x6c, 0x6c, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x0a, 0x66, 0x69, 0x6c, 0x6c, 0x41, 0x6d, 0x6f, 0x75,
	0x6e, 0x74, 0x12, 0x46, 0x0a, 0x0c, 0x70, 0x61, 0x73, 0x73, 0x5f, 0x74, 0x68, 0x72, 0x6f, 0x75,
	0x67, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x0b, 0x70,
	0x61, 0x73, 0x73, 0x54, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x22, 0xdf, 0x05, 0x0a, 0x0d, 0x4c,
	0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x49, 0x0a, 0x08,
	0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61,
	0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07,
	0x69, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x4c, 0x0a, 0x09, 0x6f, 0x75, 0x74, 0x5f, 0x70,
	0x6f, 0x72, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x4f, 0x75, 0x74, 0x73, 0x52, 0x08, 0x6f, 0x75, 0x74,
	0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x55, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
	0x65, 0x72, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73,
	0x52, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x17, 0x0a, 0x07,
	0x64, 0x72, 0x79, 0x5f, 0x72, 0x75, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x64,
	0x72, 0x79, 0x52, 0x75, 0x6e, 0x12, 0x2b, 0x0a, 0x12, 0x64, 0x72, 0x79, 0x5f, 0x72, 0x75, 0x6e,
	0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x0f, 0x64, 0x72, 0x79, 0x52, 0x75, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4b,
	0x65, 0x79, 0x1a, 0xda, 0x01, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
	0x73, 0x12, 0x41, 0x0a, 0x1d, 0x77, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6c, 0x61,
	0x74, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x64, 0x5f, 0x74, 0x6f, 0x6b, 0x65,
	0x6e, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1a, 0x77, 0x6f, 0x72, 0x6b, 0x6c, 0x6f,
	0x61, 0x64, 0x4c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x42, 0x61, 0x73, 0x65, 0x64, 0x54, 0x6f,
	0x6b, 0x65, 0x6e, 0x73, 0x12, 0x44, 0x0a, 0x09, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
	0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x52,
	0x09, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x43, 0x0a, 0x09, 0x73, 0x65,
	0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x6c, 0x65,
	0x63, 0x74, 0x6f, 0x72, 0x52, 0x09, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x1a,
	0x53, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x4c, 0x0a, 0x0f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d,
	0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e,
	0x50, 0x6f, 0x72, 0x74, 0x52, 0x0e, 0x6c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70,
	0x6c, 0x69, 0x65, 0x72, 0x1a, 0x66, 0x0a, 0x04, 0x4f, 0x75, 0x74, 0x73, 0x12, 0x5e, 0x0a, 0x18,
	0x6f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75,
	0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74,
	0x50, 0x6f, 0x72, 0x74, 0x52, 0x16, 0x6f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x4c, 0x6f,
	0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x22, 0x87, 0x05, 0x0a,
	0x09, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x4d, 0x0a, 0x09, 0x77, 0x6f,
	0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x09,
	0x77, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x12, 0x7a, 0x0a, 0x1b, 0x64, 0x65, 0x66,
	0x61, 0x75, 0x6c, 0x74, 0x5f, 0x77, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x70, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x2e,
	0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x19, 0x64, 0x65, 0x66, 0x61,
	0x75, 0x6c, 0x74, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x53, 0x0a, 0x18, 0x64, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f,
	0x6e, 0x5f, 0x64, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x6d, 0x61, 0x72, 0x67, 0x69,
	0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x52, 0x16, 0x64, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x44, 0x65, 0x61, 0x64,
	0x6c, 0x69, 0x6e, 0x65, 0x4d, 0x61, 0x72, 0x67, 0x69, 0x6e, 0x12, 0x28, 0x0a, 0x10, 0x74, 0x6f,
	0x6b, 0x65, 0x6e, 0x73, 0x5f, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x07,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x4c, 0x61, 0x62, 0x65,
	0x6c, 0x4b, 0x65, 0x79, 0x1a, 0xaf, 0x02, 0x0a, 0x08, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61,
	0x64, 0x12, 0x5a, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x57, 0x6f,
	0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
	0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x4e, 0x0a,
	0x0d, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x52,
	0x0c, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x12, 0x12, 0x0a,
	0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
	0x65, 0x1a, 0x63, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12,
	0x1a, 0x0a, 0x08, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x08, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x12, 0x16, 0x0a, 0x06, 0x74,
	0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x74, 0x6f, 0x6b,
	0x65, 0x6e, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x66, 0x61, 0x69, 0x72, 0x6e, 0x65, 0x73, 0x73, 0x5f,
	0x6b, 0x65, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x66, 0x61, 0x69, 0x72, 0x6e,
	0x65, 0x73, 0x73, 0x4b, 0x65, 0x79, 0x22, 0xdc, 0x09, 0x0a, 0x15, 0x41, 0x64, 0x61, 0x70, 0x74,
	0x69, 0x76, 0x65, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72,
	0x12, 0x51, 0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x36, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x41, 0x64, 0x61, 0x70, 0x74, 0x69, 0x76, 0x65, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f,
	0x72, 0x74, 0x73, 0x12, 0x54, 0x0a, 0x09, 0x6f, 0x75, 0x74, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x64, 0x61, 0x70, 0x74, 0x69, 0x76, 0x65, 0x4c, 0x6f, 0x61,
	0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x4f, 0x75, 0x74, 0x73, 0x52,
	0x08, 0x6f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x5d, 0x0a, 0x0a, 0x70, 0x61, 0x72,
	0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3d, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x64, 0x61, 0x70,
	0x74, 0x69, 0x76, 0x65, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
	0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x17, 0x0a, 0x07, 0x64, 0x72, 0x79, 0x5f,
	0x72, 0x75, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x64, 0x72, 0x79, 0x52, 0x75,
	0x6e, 0x12, 0x2b, 0x0a, 0x12, 0x64, 0x72, 0x79, 0x5f, 0x72, 0x75, 0x6e, 0x5f, 0x63, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x64,
	0x72, 0x79, 0x52, 0x75, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4b, 0x65, 0x79, 0x1a, 0x86,
	0x03, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x5c, 0x0a,
	0x0e, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
	0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0d, 0x6c, 0x6f,
	0x61, 0x64, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x12, 0x56, 0x0a, 0x08, 0x67,
	0x72, 0x61, 0x64, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3a, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x72, 0x61, 0x64,
	0x69, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x2e, 0x50,
	0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x08, 0x67, 0x72, 0x61, 0x64, 0x69,
	0x65, 0x6e, 0x74, 0x12, 0x2e, 0x0a, 0x13, 0x6d, 0x61, 0x78, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f,
	0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x01,
	0x52, 0x11, 0x6d, 0x61, 0x78, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c,
	0x69, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74,
	0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x5f, 0x69, 0x6e,
	0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x52, 0x1d, 0x6c,
	0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x4c, 0x69, 0x6e,
	0x65, 0x61, 0x72, 0x49, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x49, 0x0a, 0x07,
	0x61, 0x6c, 0x65, 0x72, 0x74, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x6c, 0x65, 0x72,
	0x74, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x07,
	0x61, 0x6c, 0x65, 0x72, 0x74, 0x65, 0x72, 0x1a, 0xdd, 0x01, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12,
	0x3b, 0x0a, 0x06, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e,
	0x50, 0x6f, 0x72, 0x74, 0x52, 0x06, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x12, 0x3f, 0x0a, 0x08,
	0x73, 0x65, 0x74, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50,
	0x6f, 0x72, 0x74, 0x52, 0x08, 0x73, 0x65, 0x74, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x58, 0x0a,
	0x15, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x72,
	0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61,
	0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c,
	0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72,
	0x74, 0x52, 0x14, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x8b, 0x02, 0x0a, 0x04, 0x4f, 0x75, 0x74, 0x73,
	0x12, 0x45, 0x0a, 0x0b, 0x69, 0x73, 0x5f, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x0a, 0x69, 0x73, 0x4f,
	0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x5c, 0x0a, 0x17, 0x64, 0x65, 0x73, 0x69, 0x72,
	0x65, 0x64, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69,
	0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x15,
	0x64, 0x65, 0x73, 0x69, 0x72, 0x65, 0x64, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69,
	0x70, 0x6c, 0x69, 0x65, 0x72, 0x12, 0x5e, 0x0a, 0x18, 0x6f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x65,
	0x64, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65,
	0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x16, 0x6f,
	0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69,
	0x70, 0x6c, 0x69, 0x65, 0x72, 0x22, 0xf8, 0x03, 0x0a, 0x09, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61,
	0x74, 0x6f, 0x72, 0x12, 0x45, 0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x49, 0x6e,
	0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x51, 0x0a, 0x0a, 0x70, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67,
	0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
	0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x39, 0x0a,
	0x19, 0x70, 0x61, 0x73, 0x73, 0x5f, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x5f, 0x6c, 0x61,
	0x62, 0x65, 0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x09,
	0x52, 0x16, 0x70, 0x61, 0x73, 0x73, 0x54, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x4c, 0x61, 0x62,
	0x65, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x4d, 0x0a, 0x24, 0x70, 0x61, 0x73, 0x73,
	0x5f, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x5f, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x73, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65, 0x79,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x1f, 0x70, 0x61, 0x73, 0x73, 0x54, 0x68, 0x72, 0x6f,
	0x75, 0x67, 0x68, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x43, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x4b, 0x65, 0x79, 0x1a, 0x6e, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6b,
	0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x4b,
	0x65, 0x79, 0x12, 0x43, 0x0a, 0x09, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x18,
	0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x09, 0x73, 0x65,
	0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x1a, 0x57, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x50,
	0x0a, 0x11, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x5f, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74,
	0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x10,
	0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65,
	0x22, 0xb8, 0x08, 0x0a, 0x08, 0x4c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x12, 0x44, 0x0a,
	0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f,
	0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x2e, 0x49, 0x6e, 0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f,
	0x72, 0x74, 0x73, 0x12, 0x47, 0x0a, 0x09, 0x6f, 0x75, 0x74, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x2e, 0x4f, 0x75,
	0x74, 0x73, 0x52, 0x08, 0x6f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x50, 0x0a, 0x0a,
	0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x30, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c,
	0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
	0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x39,
	0x0a, 0x19, 0x70, 0x61, 0x73, 0x73, 0x5f, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x5f, 0x6c,
	0x61, 0x62, 0x65, 0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28,
	0x09, 0x52, 0x16, 0x70, 0x61, 0x73, 0x73, 0x54, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x4c, 0x61,
	0x62, 0x65, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x4d, 0x0a, 0x24, 0x70, 0x61, 0x73,
	0x73, 0x5f, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x5f, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f,
	0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x6b, 0x65,
	0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x1f, 0x70, 0x61, 0x73, 0x73, 0x54, 0x68, 0x72,
	0x6f, 0x75, 0x67, 0x68, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4b, 0x65, 0x79, 0x1a, 0xa3, 0x02, 0x0a, 0x0a, 0x50, 0x61, 0x72,
	0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x4f, 0x0a, 0x09, 0x72, 0x65, 0x67, 0x75, 0x6c,
	0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74,
	0x6f, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x09, 0x72,
	0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x4b, 0x0a, 0x05, 0x73, 0x74, 0x65, 0x70,
	0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x2e, 0x50,
	0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x2e, 0x53, 0x74, 0x65, 0x70, 0x52, 0x05,
	0x73, 0x74, 0x65, 0x70, 0x73, 0x1a, 0x77, 0x0a, 0x04, 0x53, 0x74, 0x65, 0x70, 0x12, 0x38, 0x0a,
	0x18, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x5f, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x5f, 0x70,
	0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52,
	0x16, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x50, 0x65, 0x72,
	0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x12, 0x35, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0xc0,
	0x01, 0x0a, 0x03, 0x49, 0x6e, 0x73, 0x12, 0x3d, 0x0a, 0x07, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x07, 0x66, 0x6f,
	0x72, 0x77, 0x61, 0x72, 0x64, 0x12, 0x3f, 0x0a, 0x08, 0x62, 0x61, 0x63, 0x6b, 0x77, 0x61, 0x72,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x08, 0x62, 0x61,
	0x63, 0x6b, 0x77, 0x61, 0x72, 0x64, 0x12, 0x39, 0x0a, 0x05, 0x72, 0x65, 0x73, 0x65, 0x74, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x05, 0x72, 0x65, 0x73, 0x65,
	0x74, 0x1a, 0xd7, 0x01, 0x0a, 0x04, 0x4f, 0x75, 0x74, 0x73, 0x12, 0x51, 0x0a, 0x11, 0x61, 0x63,
	0x63, 0x65, 0x70, 0x74, 0x5f, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x10, 0x61, 0x63, 0x63,
	0x65, 0x70, 0x74, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x12, 0x3f, 0x0a,
	0x08, 0x61, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x24, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75,
	0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x07, 0x61, 0x74, 0x53, 0x74, 0x61, 0x72, 0x74, 0x12, 0x3b,
	0x0a, 0x06, 0x61, 0x74, 0x5f, 0x65, 0x6e, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x75, 0x74,
	0x50, 0x6f, 0x72, 0x74, 0x52, 0x05, 0x61, 0x74, 0x45, 0x6e, 0x64, 0x22, 0x8f, 0x05, 0x0a, 0x0e,
	0x4c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x12, 0x4a,
	0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x2f, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c,
	0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x2e, 0x49, 0x6e,
	0x73, 0x52, 0x07, 0x69, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x56, 0x0a, 0x0a, 0x70, 0x61,
	0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x36,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61,
	0x64, 0x52, 0x61, 0x6d, 0x70, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x2e, 0x50, 0x61, 0x72, 0x61,
	0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
	0x72, 0x73, 0x1a, 0xaa, 0x01, 0x0a, 0x10, 0x4c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x49,
	0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x4d, 0x0a, 0x09, 0x6c, 0x6f, 0x61, 0x64, 0x5f,
	0x72, 0x61, 0x6d, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d,
	0x70, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x08, 0x6c, 0x6f,
	0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x12, 0x47, 0x0a, 0x09, 0x6f, 0x75, 0x74, 0x5f, 0x70, 0x6f,
	0x72, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70,
	0x2e, 0x4f, 0x75, 0x74, 0x73, 0x52, 0x08, 0x6f, 0x75, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x1a,
	0x69, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x5b, 0x0a,
	0x0a, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x72, 0x61, 0x6d, 0x70, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x3c, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x4c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x2e, 0x4c,
	0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x52,
	0x09, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x61, 0x6d, 0x70, 0x73, 0x1a, 0xc0, 0x01, 0x0a, 0x03, 0x49,
	0x6e, 0x73, 0x12, 0x3d, 0x0a, 0x07, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x07, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72,
	0x64, 0x12, 0x3f, 0x0a, 0x08, 0x62, 0x61, 0x63, 0x6b, 0x77, 0x61, 0x72, 0x64, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x08, 0x62, 0x61, 0x63, 0x6b, 0x77, 0x61,
	0x72, 0x64, 0x12, 0x39, 0x0a, 0x05, 0x72, 0x65, 0x73, 0x65, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x23, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x49, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x05, 0x72, 0x65, 0x73, 0x65, 0x74, 0x22, 0xe1, 0x06,
	0x0a, 0x09, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x12, 0x5d, 0x0a, 0x0e, 0x73,
	0x74, 0x61, 0x74, 0x69, 0x63, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76,
	0x31, 0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x53, 0x74, 0x61, 0x74,
	0x69, 0x63, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x48, 0x00, 0x52, 0x0d, 0x73, 0x74, 0x61,
	0x74, 0x69, 0x63, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x5d, 0x0a, 0x0e, 0x6c, 0x69,
	0x6e, 0x65, 0x61, 0x72, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x34, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61,
	0x72, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x48, 0x00, 0x52, 0x0d, 0x6c, 0x69, 0x6e, 0x65,
	0x61, 0x72, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x6c, 0x0a, 0x13, 0x65, 0x78, 0x70,
	0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x39, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72,
	0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x45,
	0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74,
	0x73, 0x48, 0x00, 0x52, 0x12, 0x65, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c,
	0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x7c, 0x0a, 0x19, 0x65, 0x78, 0x70, 0x6f, 0x6e,
	0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x5f, 0x72,
	0x61, 0x6e, 0x67, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3e, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x6c, 0x75, 0x78, 0x4d, 0x65, 0x74,
	0x65, 0x72, 0x2e, 0x45, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75,
	0x63, 0x6b, 0x65, 0x74, 0x73, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x48, 0x00, 0x52, 0x17, 0x65, 0x78,
	0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73,
	0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75,
	0x74, 0x65, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x61, 0x74,
	0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x4b, 0x65, 0x79, 0x12, 0x43, 0x0a, 0x09, 0x73, 0x65,
	0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x6c, 0x65,
	0x63, 0x74, 0x6f, 0x72, 0x52, 0x09, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x1a,
	0x29, 0x0a, 0x0d, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73,
	0x12, 0x18, 0x0a, 0x07, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
	0x01, 0x52, 0x07, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x1a, 0x51, 0x0a, 0x0d, 0x4c, 0x69,
	0x6e, 0x65, 0x61, 0x72, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x73,
	0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72,
	0x74, 0x12, 0x14, 0x0a, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01,
	0x52, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x1a, 0x58, 0x0a,
	0x12, 0x45, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75, 0x63, 0x6b,
	0x65, 0x74, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x01, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x61, 0x63,
	0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x06, 0x66, 0x61, 0x63, 0x74, 0x6f,
	0x72, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x1a, 0x53, 0x0a, 0x17, 0x45, 0x78, 0x70, 0x6f, 0x6e,
	0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x52, 0x61, 0x6e,
	0x67, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x69, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52,
	0x03, 0x6d, 0x69, 0x6e, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x61, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x01, 0x52, 0x03, 0x6d, 0x61, 0x78, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x42, 0x13, 0x0a, 0x11,
	0x68, 0x69, 0x73, 0x74, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74,
	0x73, 0x22, 0xaf, 0x02, 0x0a, 0x0a, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x69, 0x66, 0x69, 0x65, 0x72,
	0x12, 0x48, 0x0a, 0x05, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x32, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6c,
	0x61, 0x73, 0x73, 0x69, 0x66, 0x69, 0x65, 0x72, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x52, 0x05, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x35, 0x0a, 0x04, 0x72, 0x65,
	0x67, 0x6f, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74,
	0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75,
	0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x6f, 0x52, 0x04, 0x72, 0x65, 0x67,
	0x6f, 0x12, 0x43, 0x0a, 0x09, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x18, 0x04,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x09, 0x73, 0x65, 0x6c,
	0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x1a, 0x5b, 0x0a, 0x0a, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x45,
	0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x37, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a,
	0x02, 0x38, 0x01, 0x22, 0x76, 0x0a, 0x04, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x46, 0x0a, 0x09, 0x65,
	0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26,
	0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x74,
	0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x09, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63,
	0x74, 0x6f, 0x72, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72,
	0x79, 0x42, 0x08, 0x0a, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x22, 0x84, 0x02, 0x0a, 0x04,
	0x52, 0x65, 0x67, 0x6f, 0x12, 0x45, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x6f, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x52, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x6d,
	0x6f, 0x64, 0x75, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6d, 0x6f, 0x64,
	0x75, 0x6c, 0x65, 0x1a, 0x2f, 0x0a, 0x0f, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x50, 0x72, 0x6f, 0x70,
	0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65,
	0x74, 0x72, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x74, 0x65, 0x6c, 0x65, 0x6d,
	0x65, 0x74, 0x72, 0x79, 0x1a, 0x6c, 0x0a, 0x0b, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x47, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x6f, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x50, 0x72, 0x6f,
	0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02,
	0x38, 0x01, 0x22, 0xd3, 0x02, 0x0a, 0x09, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72,
	0x12, 0x14, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00,
	0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x40, 0x0a, 0x04, 0x6a, 0x73, 0x6f, 0x6e, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72,
	0x48, 0x00, 0x52, 0x04, 0x6a, 0x73, 0x6f, 0x6e, 0x12, 0x49, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x61, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45,
	0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x12, 0x3d, 0x0a, 0x03, 0x6a, 0x77, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4a,
	0x57, 0x54, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x03, 0x6a,
	0x77, 0x74, 0x12, 0x59, 0x0a, 0x0e, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x74, 0x65, 0x6d, 0x70, 0x6c,
	0x61, 0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x74, 0x68, 0x54, 0x65, 0x6d,
	0x70, 0x6c, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x48, 0x00, 0x52, 0x0d,
	0x70, 0x61, 0x74, 0x68, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x73, 0x42, 0x09, 0x0a,
	0x07, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x22, 0x3d, 0x0a, 0x0d, 0x4a, 0x53, 0x4f, 0x4e,
	0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x72, 0x6f,
	0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x18, 0x0a,
	0x07, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
	0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x22, 0x26, 0x0a, 0x10, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x66,
	0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x22,
	0x45, 0x0a, 0x0c, 0x4a, 0x57, 0x54, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12,
	0x12, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66,
	0x72, 0x6f, 0x6d, 0x12, 0x21, 0x0a, 0x0c, 0x6a, 0x73, 0x6f, 0x6e, 0x5f, 0x70, 0x6f, 0x69, 0x6e,
	0x74, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6a, 0x73, 0x6f, 0x6e, 0x50,
	0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x22, 0xc7, 0x01, 0x0a, 0x13, 0x50, 0x61, 0x74, 0x68, 0x54,
	0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x12, 0x6d,
	0x0a, 0x0f, 0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x44, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x74, 0x68, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61,
	0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61,
	0x74, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0e, 0x74,
	0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x1a, 0x41, 0x0a,
	0x13, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x45,
	0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01,
	0x22, 0xba, 0x01, 0x0a, 0x08, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a,
	0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x50, 0x6f, 0x69,
	0x6e, 0x74, 0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x5f, 0x67, 0x72, 0x6f, 0x75,
	0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x47, 0x72,
	0x6f, 0x75, 0x70, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x4e, 0x0a,
	0x0d, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2e,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x52,
	0x0c, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x42, 0xb0, 0x02,
	0x0a, 0x33, 0x63, 0x6f, 0x6d, 0x2e, 0x66, 0x6c, 0x75, 0x78, 0x6e, 0x69, 0x6e, 0x6a, 0x61, 0x2e,
	0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x2e, 0x61, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x2e, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x2e, 0x76, 0x31, 0x42, 0x10, 0x46, 0x6c, 0x6f, 0x77, 0x63, 0x6f, 0x6e, 0x74, 0x72,
	0x6f, 0x6c, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x58, 0x67, 0x69, 0x74, 0x68, 0x75,
	0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x6c, 0x75, 0x78, 0x6e, 0x69, 0x6e, 0x6a, 0x61, 0x2f,
	0x61, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x76, 0x32, 0x2f, 0x61, 0x70, 0x69, 0x2f,
	0x67, 0x65, 0x6e, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x2f, 0x61, 0x70, 0x65,
	0x72, 0x74, 0x75, 0x72, 0x65, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2f, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x2f, 0x76, 0x31, 0x3b, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x76, 0x31, 0xa2, 0x02, 0x03, 0x41, 0x50, 0x4c, 0xaa, 0x02, 0x1b, 0x41, 0x70, 0x65, 0x72,
	0x74, 0x75, 0x72, 0x65, 0x2e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x4c, 0x61, 0x6e, 0x67,
	0x75, 0x61, 0x67, 0x65, 0x2e, 0x56, 0x31, 0xca, 0x02, 0x1b, 0x41, 0x70, 0x65, 0x72, 0x74, 0x75,
	0x72, 0x65, 0x5c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x5c, 0x4c, 0x61, 0x6e, 0x67, 0x75, 0x61,
	0x67, 0x65, 0x5c, 0x56, 0x31, 0xe2, 0x02, 0x27, 0x41, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65,
	0x5c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x5c, 0x4c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
	0x5c, 0x56, 0x31, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0xea,
	0x02, 0x1e, 0x41, 0x70, 0x65, 0x72, 0x74, 0x75, 0x72, 0x65, 0x3a, 0x3a, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x3a, 0x3a, 0x4c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x3a, 0x3a, 0x56, 0x31,
	0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_aperture_policy_language_v1_flowcontrol_proto_rawDescOnce sync.Once
	file_aperture_policy_language_v1_flowcontrol_proto_rawDescData = file_aperture_policy_language_v1_flowcontrol_proto_rawDesc
)

func file_aperture_policy_language_v1_flowcontrol_proto_rawDescGZIP() []byte {
	file_aperture_policy_language_v1_flowcontrol_proto_rawDescOnce.Do(func() {
		file_aperture_policy_language_v1_flowcontrol_proto_rawDescData = protoimpl.X.CompressGZIP(file_aperture_policy_language_v1_flowcontrol_proto_rawDescData)
	})
	return file_aperture_policy_language_v1_flowcontrol_proto_rawDescData
}

var file_aperture_policy_language_v1_flowcontrol_proto_msgTypes = make([]protoimpl.MessageInfo, 49)
var file_aperture_policy_language_v1_flowcontrol_proto_goTypes = []interface{}{
	(*FlowControlResources)(nil),              // 0: aperture.policy.language.v1.FlowControlResources
	(*FlowControl)(nil),                       // 1: aperture.policy.language.v1.FlowControl
	(*QuotaScheduler)(nil),                    // 2: aperture.policy.language.v1.QuotaScheduler
	(*RateLimiter)(nil),                       // 3: aperture.policy.language.v1.RateLimiter
	(*LoadScheduler)(nil),                     // 4: aperture.policy.language.v1.LoadScheduler
	(*Scheduler)(nil),                         // 5: aperture.policy.language.v1.Scheduler
	(*AdaptiveLoadScheduler)(nil),             // 6: aperture.policy.language.v1.AdaptiveLoadScheduler
	(*Regulator)(nil),                         // 7: aperture.policy.language.v1.Regulator
	(*LoadRamp)(nil),                          // 8: aperture.policy.language.v1.LoadRamp
	(*LoadRampSeries)(nil),                    // 9: aperture.policy.language.v1.LoadRampSeries
	(*FluxMeter)(nil),                         // 10: aperture.policy.language.v1.FluxMeter
	(*Classifier)(nil),                        // 11: aperture.policy.language.v1.Classifier
	(*Rule)(nil),                              // 12: aperture.policy.language.v1.Rule
	(*Rego)(nil),                              // 13: aperture.policy.language.v1.Rego
	(*Extractor)(nil),                         // 14: aperture.policy.language.v1.Extractor
	(*JSONExtractor)(nil),                     // 15: aperture.policy.language.v1.JSONExtractor
	(*AddressExtractor)(nil),                  // 16: aperture.policy.language.v1.AddressExtractor
	(*JWTExtractor)(nil),                      // 17: aperture.policy.language.v1.JWTExtractor
	(*PathTemplateMatcher)(nil),               // 18: aperture.policy.language.v1.PathTemplateMatcher
	(*Selector)(nil),                          // 19: aperture.policy.language.v1.Selector
	nil,                                       // 20: aperture.policy.language.v1.FlowControlResources.FluxMetersEntry
	(*RateLimiter_Parameters)(nil),            // 21: aperture.policy.language.v1.RateLimiter.Parameters
	(*RateLimiter_Ins)(nil),                   // 22: aperture.policy.language.v1.RateLimiter.Ins
	(*RateLimiter_Parameters_LazySync)(nil),   // 23: aperture.policy.language.v1.RateLimiter.Parameters.LazySync
	(*LoadScheduler_Parameters)(nil),          // 24: aperture.policy.language.v1.LoadScheduler.Parameters
	(*LoadScheduler_Ins)(nil),                 // 25: aperture.policy.language.v1.LoadScheduler.Ins
	(*LoadScheduler_Outs)(nil),                // 26: aperture.policy.language.v1.LoadScheduler.Outs
	(*Scheduler_Workload)(nil),                // 27: aperture.policy.language.v1.Scheduler.Workload
	(*Scheduler_Workload_Parameters)(nil),     // 28: aperture.policy.language.v1.Scheduler.Workload.Parameters
	(*AdaptiveLoadScheduler_Parameters)(nil),  // 29: aperture.policy.language.v1.AdaptiveLoadScheduler.Parameters
	(*AdaptiveLoadScheduler_Ins)(nil),         // 30: aperture.policy.language.v1.AdaptiveLoadScheduler.Ins
	(*AdaptiveLoadScheduler_Outs)(nil),        // 31: aperture.policy.language.v1.AdaptiveLoadScheduler.Outs
	(*Regulator_Parameters)(nil),              // 32: aperture.policy.language.v1.Regulator.Parameters
	(*Regulator_Ins)(nil),                     // 33: aperture.policy.language.v1.Regulator.Ins
	(*LoadRamp_Parameters)(nil),               // 34: aperture.policy.language.v1.LoadRamp.Parameters
	(*LoadRamp_Ins)(nil),                      // 35: aperture.policy.language.v1.LoadRamp.Ins
	(*LoadRamp_Outs)(nil),                     // 36: aperture.policy.language.v1.LoadRamp.Outs
	(*LoadRamp_Parameters_Step)(nil),          // 37: aperture.policy.language.v1.LoadRamp.Parameters.Step
	(*LoadRampSeries_LoadRampInstance)(nil),   // 38: aperture.policy.language.v1.LoadRampSeries.LoadRampInstance
	(*LoadRampSeries_Parameters)(nil),         // 39: aperture.policy.language.v1.LoadRampSeries.Parameters
	(*LoadRampSeries_Ins)(nil),                // 40: aperture.policy.language.v1.LoadRampSeries.Ins
	(*FluxMeter_StaticBuckets)(nil),           // 41: aperture.policy.language.v1.FluxMeter.StaticBuckets
	(*FluxMeter_LinearBuckets)(nil),           // 42: aperture.policy.language.v1.FluxMeter.LinearBuckets
	(*FluxMeter_ExponentialBuckets)(nil),      // 43: aperture.policy.language.v1.FluxMeter.ExponentialBuckets
	(*FluxMeter_ExponentialBucketsRange)(nil), // 44: aperture.policy.language.v1.FluxMeter.ExponentialBucketsRange
	nil,                                   // 45: aperture.policy.language.v1.Classifier.RulesEntry
	(*Rego_LabelProperties)(nil),          // 46: aperture.policy.language.v1.Rego.LabelProperties
	nil,                                   // 47: aperture.policy.language.v1.Rego.LabelsEntry
	nil,                                   // 48: aperture.policy.language.v1.PathTemplateMatcher.TemplateValuesEntry
	(*anypb.Any)(nil),                     // 49: google.protobuf.Any
	(*durationpb.Duration)(nil),           // 50: google.protobuf.Duration
	(*LabelMatcher)(nil),                  // 51: aperture.policy.language.v1.LabelMatcher
	(*InPort)(nil),                        // 52: aperture.policy.language.v1.InPort
	(*OutPort)(nil),                       // 53: aperture.policy.language.v1.OutPort
	(*GradientController_Parameters)(nil), // 54: aperture.policy.language.v1.GradientController.Parameters
	(*Alerter_Parameters)(nil),            // 55: aperture.policy.language.v1.Alerter.Parameters
}
var file_aperture_policy_language_v1_flowcontrol_proto_depIdxs = []int32{
	20, // 0: aperture.policy.language.v1.FlowControlResources.flux_meters:type_name -> aperture.policy.language.v1.FlowControlResources.FluxMetersEntry
	11, // 1: aperture.policy.language.v1.FlowControlResources.classifiers:type_name -> aperture.policy.language.v1.Classifier
	2,  // 2: aperture.policy.language.v1.FlowControl.quota_scheduler:type_name -> aperture.policy.language.v1.QuotaScheduler
	3,  // 3: aperture.policy.language.v1.FlowControl.rate_limiter:type_name -> aperture.policy.language.v1.RateLimiter
	4,  // 4: aperture.policy.language.v1.FlowControl.load_scheduler:type_name -> aperture.policy.language.v1.LoadScheduler
	6,  // 5: aperture.policy.language.v1.FlowControl.adaptive_load_scheduler:type_name -> aperture.policy.language.v1.AdaptiveLoadScheduler
	7,  // 6: aperture.policy.language.v1.FlowControl.regulator:type_name -> aperture.policy.language.v1.Regulator
	8,  // 7: aperture.policy.language.v1.FlowControl.load_ramp:type_name -> aperture.policy.language.v1.LoadRamp
	9,  // 8: aperture.policy.language.v1.FlowControl.load_ramp_series:type_name -> aperture.policy.language.v1.LoadRampSeries
	49, // 9: aperture.policy.language.v1.FlowControl.private:type_name -> google.protobuf.Any
	22, // 10: aperture.policy.language.v1.QuotaScheduler.in_ports:type_name -> aperture.policy.language.v1.RateLimiter.Ins
	19, // 11: aperture.policy.language.v1.QuotaScheduler.selectors:type_name -> aperture.policy.language.v1.Selector
	21, // 12: aperture.policy.language.v1.QuotaScheduler.rate_limiter:type_name -> aperture.policy.language.v1.RateLimiter.Parameters
	5,  // 13: aperture.policy.language.v1.QuotaScheduler.scheduler:type_name -> aperture.policy.language.v1.Scheduler
	22, // 14: aperture.policy.language.v1.RateLimiter.in_ports:type_name -> aperture.policy.language.v1.RateLimiter.Ins
	21, // 15: aperture.policy.language.v1.RateLimiter.parameters:type_name -> aperture.policy.language.v1.RateLimiter.Parameters
	19, // 16: aperture.policy.language.v1.RateLimiter.selectors:type_name -> aperture.policy.language.v1.Selector
	25, // 17: aperture.policy.language.v1.LoadScheduler.in_ports:type_name -> aperture.policy.language.v1.LoadScheduler.Ins
	26, // 18: aperture.policy.language.v1.LoadScheduler.out_ports:type_name -> aperture.policy.language.v1.LoadScheduler.Outs
	24, // 19: aperture.policy.language.v1.LoadScheduler.parameters:type_name -> aperture.policy.language.v1.LoadScheduler.Parameters
	27, // 20: aperture.policy.language.v1.Scheduler.workloads:type_name -> aperture.policy.language.v1.Scheduler.Workload
	28, // 21: aperture.policy.language.v1.Scheduler.default_workload_parameters:type_name -> aperture.policy.language.v1.Scheduler.Workload.Parameters
	50, // 22: aperture.policy.language.v1.Scheduler.decision_deadline_margin:type_name -> google.protobuf.Duration
	30, // 23: aperture.policy.language.v1.AdaptiveLoadScheduler.in_ports:type_name -> aperture.policy.language.v1.AdaptiveLoadScheduler.Ins
	31, // 24: aperture.policy.language.v1.AdaptiveLoadScheduler.out_ports:type_name -> aperture.policy.language.v1.AdaptiveLoadScheduler.Outs
	29, // 25: aperture.policy.language.v1.AdaptiveLoadScheduler.parameters:type_name -> aperture.policy.language.v1.AdaptiveLoadScheduler.Parameters
	33, // 26: aperture.policy.language.v1.Regulator.in_ports:type_name -> aperture.policy.language.v1.Regulator.Ins
	32, // 27: aperture.policy.language.v1.Regulator.parameters:type_name -> aperture.policy.language.v1.Regulator.Parameters
	35, // 28: aperture.policy.language.v1.LoadRamp.in_ports:type_name -> aperture.policy.language.v1.LoadRamp.Ins
	36, // 29: aperture.policy.language.v1.LoadRamp.out_ports:type_name -> aperture.policy.language.v1.LoadRamp.Outs
	34, // 30: aperture.policy.language.v1.LoadRamp.parameters:type_name -> aperture.policy.language.v1.LoadRamp.Parameters
	40, // 31: aperture.policy.language.v1.LoadRampSeries.in_ports:type_name -> aperture.policy.language.v1.LoadRampSeries.Ins
	39, // 32: aperture.policy.language.v1.LoadRampSeries.parameters:type_name -> aperture.policy.language.v1.LoadRampSeries.Parameters
	41, // 33: aperture.policy.language.v1.FluxMeter.static_buckets:type_name -> aperture.policy.language.v1.FluxMeter.StaticBuckets
	42, // 34: aperture.policy.language.v1.FluxMeter.linear_buckets:type_name -> aperture.policy.language.v1.FluxMeter.LinearBuckets
	43, // 35: aperture.policy.language.v1.FluxMeter.exponential_buckets:type_name -> aperture.policy.language.v1.FluxMeter.ExponentialBuckets
	44, // 36: aperture.policy.language.v1.FluxMeter.exponential_buckets_range:type_name -> aperture.policy.language.v1.FluxMeter.ExponentialBucketsRange
	19, // 37: aperture.policy.language.v1.FluxMeter.selectors:type_name -> aperture.policy.language.v1.Selector
	45, // 38: aperture.policy.language.v1.Classifier.rules:type_name -> aperture.policy.language.v1.Classifier.RulesEntry
	13, // 39: aperture.policy.language.v1.Classifier.rego:type_name -> aperture.policy.language.v1.Rego
	19, // 40: aperture.policy.language.v1.Classifier.selectors:type_name -> aperture.policy.language.v1.Selector
	14, // 41: aperture.policy.language.v1.Rule.extractor:type_name -> aperture.policy.language.v1.Extractor
	47, // 42: aperture.policy.language.v1.Rego.labels:type_name -> aperture.policy.language.v1.Rego.LabelsEntry
	15, // 43: aperture.policy.language.v1.Extractor.json:type_name -> aperture.policy.language.v1.JSONExtractor
	16, // 44: aperture.policy.language.v1.Extractor.address:type_name -> aperture.policy.language.v1.AddressExtractor
	17, // 45: aperture.policy.language.v1.Extractor.jwt:type_name -> aperture.policy.language.v1.JWTExtractor
	18, // 46: aperture.policy.language.v1.Extractor.path_templates:type_name -> aperture.policy.language.v1.PathTemplateMatcher
	48, // 47: aperture.policy.language.v1.PathTemplateMatcher.template_values:type_name -> aperture.policy.language.v1.PathTemplateMatcher.TemplateValuesEntry
	51, // 48: aperture.policy.language.v1.Selector.label_matcher:type_name -> aperture.policy.language.v1.LabelMatcher
	10, // 49: aperture.policy.language.v1.FlowControlResources.FluxMetersEntry.value:type_name -> aperture.policy.language.v1.FluxMeter
	50, // 50: aperture.policy.language.v1.RateLimiter.Parameters.interval:type_name -> google.protobuf.Duration
	50, // 51: aperture.policy.language.v1.RateLimiter.Parameters.max_idle_time:type_name -> google.protobuf.Duration
	23, // 52: aperture.policy.language.v1.RateLimiter.Parameters.lazy_sync:type_name -> aperture.policy.language.v1.RateLimiter.Parameters.LazySync
	52, // 53: aperture.policy.language.v1.RateLimiter.Ins.bucket_capacity:type_name -> aperture.policy.language.v1.InPort
	52, // 54: aperture.policy.language.v1.RateLimiter.Ins.fill_amount:type_name -> aperture.policy.language.v1.InPort
	52, // 55: aperture.policy.language.v1.RateLimiter.Ins.pass_through:type_name -> aperture.policy.language.v1.InPort
	5,  // 56: aperture.policy.language.v1.LoadScheduler.Parameters.scheduler:type_name -> aperture.policy.language.v1.Scheduler
	19, // 57: aperture.policy.language.v1.LoadScheduler.Parameters.selectors:type_name -> aperture.policy.language.v1.Selector
	52, // 58: aperture.policy.language.v1.LoadScheduler.Ins.load_multiplier:type_name -> aperture.policy.language.v1.InPort
	53, // 59: aperture.policy.language.v1.LoadScheduler.Outs.observed_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	28, // 60: aperture.policy.language.v1.Scheduler.Workload.parameters:type_name -> aperture.policy.language.v1.Scheduler.Workload.Parameters
	51, // 61: aperture.policy.language.v1.Scheduler.Workload.label_matcher:type_name -> aperture.policy.language.v1.LabelMatcher
	24, // 62: aperture.policy.language.v1.AdaptiveLoadScheduler.Parameters.load_scheduler:type_name -> aperture.policy.language.v1.LoadScheduler.Parameters
	54, // 63: aperture.policy.language.v1.AdaptiveLoadScheduler.Parameters.gradient:type_name -> aperture.policy.language.v1.GradientController.Parameters
	55, // 64: aperture.policy.language.v1.AdaptiveLoadScheduler.Parameters.alerter:type_name -> aperture.policy.language.v1.Alerter.Parameters
	52, // 65: aperture.policy.language.v1.AdaptiveLoadScheduler.Ins.signal:type_name -> aperture.policy.language.v1.InPort
	52, // 66: aperture.policy.language.v1.AdaptiveLoadScheduler.Ins.setpoint:type_name -> aperture.policy.language.v1.InPort
	52, // 67: aperture.policy.language.v1.AdaptiveLoadScheduler.Ins.overload_confirmation:type_name -> aperture.policy.language.v1.InPort
	53, // 68: aperture.policy.language.v1.AdaptiveLoadScheduler.Outs.is_overload:type_name -> aperture.policy.language.v1.OutPort
	53, // 69: aperture.policy.language.v1.AdaptiveLoadScheduler.Outs.desired_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	53, // 70: aperture.policy.language.v1.AdaptiveLoadScheduler.Outs.observed_load_multiplier:type_name -> aperture.policy.language.v1.OutPort
	19, // 71: aperture.policy.language.v1.Regulator.Parameters.selectors:type_name -> aperture.policy.language.v1.Selector
	52, // 72: aperture.policy.language.v1.Regulator.Ins.accept_percentage:type_name -> aperture.policy.language.v1.InPort
	32, // 73: aperture.policy.language.v1.LoadRamp.Parameters.regulator:type_name -> aperture.policy.language.v1.Regulator.Parameters
	37, // 74: aperture.policy.language.v1.LoadRamp.Parameters.steps:type_name -> aperture.policy.language.v1.LoadRamp.Parameters.Step
	52, // 75: aperture.policy.language.v1.LoadRamp.Ins.forward:type_name -> aperture.policy.language.v1.InPort
	52, // 76: aperture.policy.language.v1.LoadRamp.Ins.backward:type_name -> aperture.policy.language.v1.InPort
	52, // 77: aperture.policy.language.v1.LoadRamp.Ins.reset:type_name -> aperture.policy.language.v1.InPort
	53, // 78: aperture.policy.language.v1.LoadRamp.Outs.accept_percentage:type_name -> aperture.policy.language.v1.OutPort
	53, // 79: aperture.policy.language.v1.LoadRamp.Outs.at_start:type_name -> aperture.policy.language.v1.OutPort
	53, // 80: aperture.policy.language.v1.LoadRamp.Outs.at_end:type_name -> aperture.policy.language.v1.OutPort
	50, // 81: aperture.policy.language.v1.LoadRamp.Parameters.Step.duration:type_name -> google.protobuf.Duration
	34, // 82: aperture.policy.language.v1.LoadRampSeries.LoadRampInstance.load_ramp:type_name -> aperture.policy.language.v1.LoadRamp.Parameters
	36, // 83: aperture.policy.language.v1.LoadRampSeries.LoadRampInstance.out_ports:type_name -> aperture.policy.language.v1.LoadRamp.Outs
	38, // 84: aperture.policy.language.v1.LoadRampSeries.Parameters.load_ramps:type_name -> aperture.policy.language.v1.LoadRampSeries.LoadRampInstance
	52, // 85: aperture.policy.language.v1.LoadRampSeries.Ins.forward:type_name -> aperture.policy.language.v1.InPort
	52, // 86: aperture.policy.language.v1.LoadRampSeries.Ins.backward:type_name -> aperture.policy.language.v1.InPort
	52, // 87: aperture.policy.language.v1.LoadRampSeries.Ins.reset:type_name -> aperture.policy.language.v1.InPort
	12, // 88: aperture.policy.language.v1.Classifier.RulesEntry.value:type_name -> aperture.policy.language.v1.Rule
	46, // 89: aperture.policy.language.v1.Rego.LabelsEntry.value:type_name -> aperture.policy.language.v1.Rego.LabelProperties
	90, // [90:90] is the sub-list for method output_type
	90, // [90:90] is the sub-list for method input_type
	90, // [90:90] is the sub-list for extension type_name
	90, // [90:90] is the sub-list for extension extendee
	0,  // [0:90] is the sub-list for field type_name
}

func init() { file_aperture_policy_language_v1_flowcontrol_proto_init() }
func file_aperture_policy_language_v1_flowcontrol_proto_init() {
	if File_aperture_policy_language_v1_flowcontrol_proto != nil {
		return
	}
	file_aperture_policy_language_v1_label_matcher_proto_init()
	file_aperture_policy_language_v1_ports_proto_init()
	file_aperture_policy_language_v1_std_components_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FlowControlResources); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FlowControl); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QuotaScheduler); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadScheduler); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AdaptiveLoadScheduler); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Regulator); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadRamp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadRampSeries); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Classifier); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Rule); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Rego); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Extractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*JSONExtractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddressExtractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*JWTExtractor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PathTemplateMatcher); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Selector); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RateLimiter_Parameters_LazySync); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadScheduler_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadScheduler_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadScheduler_Outs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler_Workload); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Scheduler_Workload_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AdaptiveLoadScheduler_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AdaptiveLoadScheduler_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AdaptiveLoadScheduler_Outs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Regulator_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Regulator_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadRamp_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadRamp_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadRamp_Outs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[37].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadRamp_Parameters_Step); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[38].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadRampSeries_LoadRampInstance); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[39].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadRampSeries_Parameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[40].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoadRampSeries_Ins); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[41].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_StaticBuckets); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[42].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_LinearBuckets); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[43].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_ExponentialBuckets); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[44].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FluxMeter_ExponentialBucketsRange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[46].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Rego_LabelProperties); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[1].OneofWrappers = []interface{}{
		(*FlowControl_QuotaScheduler)(nil),
		(*FlowControl_RateLimiter)(nil),
		(*FlowControl_LoadScheduler)(nil),
		(*FlowControl_AdaptiveLoadScheduler)(nil),
		(*FlowControl_Regulator)(nil),
		(*FlowControl_LoadRamp)(nil),
		(*FlowControl_LoadRampSeries)(nil),
		(*FlowControl_Private)(nil),
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[10].OneofWrappers = []interface{}{
		(*FluxMeter_StaticBuckets_)(nil),
		(*FluxMeter_LinearBuckets_)(nil),
		(*FluxMeter_ExponentialBuckets_)(nil),
		(*FluxMeter_ExponentialBucketsRange_)(nil),
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[12].OneofWrappers = []interface{}{
		(*Rule_Extractor)(nil),
	}
	file_aperture_policy_language_v1_flowcontrol_proto_msgTypes[14].OneofWrappers = []interface{}{
		(*Extractor_From)(nil),
		(*Extractor_Json)(nil),
		(*Extractor_Address)(nil),
		(*Extractor_Jwt)(nil),
		(*Extractor_PathTemplates)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_aperture_policy_language_v1_flowcontrol_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   49,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_aperture_policy_language_v1_flowcontrol_proto_goTypes,
		DependencyIndexes: file_aperture_policy_language_v1_flowcontrol_proto_depIdxs,
		MessageInfos:      file_aperture_policy_language_v1_flowcontrol_proto_msgTypes,
	}.Build()
	File_aperture_policy_language_v1_flowcontrol_proto = out.File
	file_aperture_policy_language_v1_flowcontrol_proto_rawDesc = nil
	file_aperture_policy_language_v1_flowcontrol_proto_goTypes = nil
	file_aperture_policy_language_v1_flowcontrol_proto_depIdxs = nil
}
