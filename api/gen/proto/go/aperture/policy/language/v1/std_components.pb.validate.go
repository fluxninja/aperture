// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: aperture/policy/language/v1/std_components.proto

package languagev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GradientController with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GradientController) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GradientController with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GradientControllerMultiError, or nil if none found.
func (m *GradientController) ValidateAll() error {
	return m.validate(true)
}

func (m *GradientController) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GradientControllerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GradientControllerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GradientControllerValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GradientControllerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GradientControllerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GradientControllerValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GradientControllerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GradientControllerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GradientControllerValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DynamicConfigKey

	if all {
		switch v := interface{}(m.GetDefaultConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GradientControllerValidationError{
					field:  "DefaultConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GradientControllerValidationError{
					field:  "DefaultConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GradientControllerValidationError{
				field:  "DefaultConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GradientControllerMultiError(errors)
	}

	return nil
}

// GradientControllerMultiError is an error wrapping multiple validation errors
// returned by GradientController.ValidateAll() if the designated constraints
// aren't met.
type GradientControllerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GradientControllerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GradientControllerMultiError) AllErrors() []error { return m }

// GradientControllerValidationError is the validation error returned by
// GradientController.Validate if the designated constraints aren't met.
type GradientControllerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GradientControllerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GradientControllerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GradientControllerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GradientControllerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GradientControllerValidationError) ErrorName() string {
	return "GradientControllerValidationError"
}

// Error satisfies the builtin error interface
func (e GradientControllerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGradientController.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GradientControllerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GradientControllerValidationError{}

// Validate checks the field values on EMA with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *EMA) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EMA with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EMAMultiError, or nil if none found.
func (m *EMA) ValidateAll() error {
	return m.validate(true)
}

func (m *EMA) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EMAValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EMAValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EMAValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EMAValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EMAValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EMAValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EMAValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EMAValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EMAValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EMAMultiError(errors)
	}

	return nil
}

// EMAMultiError is an error wrapping multiple validation errors returned by
// EMA.ValidateAll() if the designated constraints aren't met.
type EMAMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EMAMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EMAMultiError) AllErrors() []error { return m }

// EMAValidationError is the validation error returned by EMA.Validate if the
// designated constraints aren't met.
type EMAValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EMAValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EMAValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EMAValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EMAValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EMAValidationError) ErrorName() string { return "EMAValidationError" }

// Error satisfies the builtin error interface
func (e EMAValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEMA.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EMAValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EMAValidationError{}

// Validate checks the field values on SMA with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *SMA) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SMA with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SMAMultiError, or nil if none found.
func (m *SMA) ValidateAll() error {
	return m.validate(true)
}

func (m *SMA) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SMAValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SMAValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SMAValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SMAValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SMAValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SMAValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SMAValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SMAValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SMAValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SMAMultiError(errors)
	}

	return nil
}

// SMAMultiError is an error wrapping multiple validation errors returned by
// SMA.ValidateAll() if the designated constraints aren't met.
type SMAMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SMAMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SMAMultiError) AllErrors() []error { return m }

// SMAValidationError is the validation error returned by SMA.Validate if the
// designated constraints aren't met.
type SMAValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SMAValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SMAValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SMAValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SMAValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SMAValidationError) ErrorName() string { return "SMAValidationError" }

// Error satisfies the builtin error interface
func (e SMAValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSMA.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SMAValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SMAValidationError{}

// Validate checks the field values on ArithmeticCombinator with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ArithmeticCombinator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArithmeticCombinator with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ArithmeticCombinatorMultiError, or nil if none found.
func (m *ArithmeticCombinator) ValidateAll() error {
	return m.validate(true)
}

func (m *ArithmeticCombinator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ArithmeticCombinatorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ArithmeticCombinatorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ArithmeticCombinatorValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ArithmeticCombinatorValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ArithmeticCombinatorValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ArithmeticCombinatorValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return ArithmeticCombinatorMultiError(errors)
	}

	return nil
}

// ArithmeticCombinatorMultiError is an error wrapping multiple validation
// errors returned by ArithmeticCombinator.ValidateAll() if the designated
// constraints aren't met.
type ArithmeticCombinatorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArithmeticCombinatorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArithmeticCombinatorMultiError) AllErrors() []error { return m }

// ArithmeticCombinatorValidationError is the validation error returned by
// ArithmeticCombinator.Validate if the designated constraints aren't met.
type ArithmeticCombinatorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArithmeticCombinatorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArithmeticCombinatorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArithmeticCombinatorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArithmeticCombinatorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArithmeticCombinatorValidationError) ErrorName() string {
	return "ArithmeticCombinatorValidationError"
}

// Error satisfies the builtin error interface
func (e ArithmeticCombinatorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArithmeticCombinator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArithmeticCombinatorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArithmeticCombinatorValidationError{}

// Validate checks the field values on Decider with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Decider) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Decider with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DeciderMultiError, or nil if none found.
func (m *Decider) ValidateAll() error {
	return m.validate(true)
}

func (m *Decider) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeciderValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeciderValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeciderValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeciderValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeciderValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeciderValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Operator

	if all {
		switch v := interface{}(m.GetTrueFor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeciderValidationError{
					field:  "TrueFor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeciderValidationError{
					field:  "TrueFor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTrueFor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeciderValidationError{
				field:  "TrueFor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFalseFor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeciderValidationError{
					field:  "FalseFor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeciderValidationError{
					field:  "FalseFor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFalseFor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeciderValidationError{
				field:  "FalseFor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeciderMultiError(errors)
	}

	return nil
}

// DeciderMultiError is an error wrapping multiple validation errors returned
// by Decider.ValidateAll() if the designated constraints aren't met.
type DeciderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeciderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeciderMultiError) AllErrors() []error { return m }

// DeciderValidationError is the validation error returned by Decider.Validate
// if the designated constraints aren't met.
type DeciderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeciderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeciderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeciderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeciderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeciderValidationError) ErrorName() string { return "DeciderValidationError" }

// Error satisfies the builtin error interface
func (e DeciderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDecider.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeciderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeciderValidationError{}

// Validate checks the field values on Switcher with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Switcher) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Switcher with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SwitcherMultiError, or nil
// if none found.
func (m *Switcher) ValidateAll() error {
	return m.validate(true)
}

func (m *Switcher) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SwitcherValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SwitcherValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SwitcherValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SwitcherValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SwitcherValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SwitcherValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SwitcherMultiError(errors)
	}

	return nil
}

// SwitcherMultiError is an error wrapping multiple validation errors returned
// by Switcher.ValidateAll() if the designated constraints aren't met.
type SwitcherMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SwitcherMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SwitcherMultiError) AllErrors() []error { return m }

// SwitcherValidationError is the validation error returned by
// Switcher.Validate if the designated constraints aren't met.
type SwitcherValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SwitcherValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SwitcherValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SwitcherValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SwitcherValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SwitcherValidationError) ErrorName() string { return "SwitcherValidationError" }

// Error satisfies the builtin error interface
func (e SwitcherValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSwitcher.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SwitcherValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SwitcherValidationError{}

// Validate checks the field values on Variable with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Variable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Variable with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VariableMultiError, or nil
// if none found.
func (m *Variable) ValidateAll() error {
	return m.validate(true)
}

func (m *Variable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VariableValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VariableValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VariableValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DynamicConfigKey

	if all {
		switch v := interface{}(m.GetDefaultConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VariableValidationError{
					field:  "DefaultConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VariableValidationError{
					field:  "DefaultConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VariableValidationError{
				field:  "DefaultConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VariableMultiError(errors)
	}

	return nil
}

// VariableMultiError is an error wrapping multiple validation errors returned
// by Variable.ValidateAll() if the designated constraints aren't met.
type VariableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VariableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VariableMultiError) AllErrors() []error { return m }

// VariableValidationError is the validation error returned by
// Variable.Validate if the designated constraints aren't met.
type VariableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VariableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VariableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VariableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VariableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VariableValidationError) ErrorName() string { return "VariableValidationError" }

// Error satisfies the builtin error interface
func (e VariableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVariable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VariableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VariableValidationError{}

// Validate checks the field values on UnaryOperator with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UnaryOperator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnaryOperator with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UnaryOperatorMultiError, or
// nil if none found.
func (m *UnaryOperator) ValidateAll() error {
	return m.validate(true)
}

func (m *UnaryOperator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnaryOperatorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnaryOperatorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnaryOperatorValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnaryOperatorValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnaryOperatorValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnaryOperatorValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return UnaryOperatorMultiError(errors)
	}

	return nil
}

// UnaryOperatorMultiError is an error wrapping multiple validation errors
// returned by UnaryOperator.ValidateAll() if the designated constraints
// aren't met.
type UnaryOperatorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnaryOperatorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnaryOperatorMultiError) AllErrors() []error { return m }

// UnaryOperatorValidationError is the validation error returned by
// UnaryOperator.Validate if the designated constraints aren't met.
type UnaryOperatorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnaryOperatorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnaryOperatorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnaryOperatorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnaryOperatorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnaryOperatorValidationError) ErrorName() string { return "UnaryOperatorValidationError" }

// Error satisfies the builtin error interface
func (e UnaryOperatorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnaryOperator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnaryOperatorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnaryOperatorValidationError{}

// Validate checks the field values on Extrapolator with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Extrapolator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Extrapolator with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExtrapolatorMultiError, or
// nil if none found.
func (m *Extrapolator) ValidateAll() error {
	return m.validate(true)
}

func (m *Extrapolator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtrapolatorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtrapolatorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtrapolatorValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtrapolatorValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtrapolatorValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtrapolatorValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtrapolatorValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtrapolatorValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtrapolatorValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExtrapolatorMultiError(errors)
	}

	return nil
}

// ExtrapolatorMultiError is an error wrapping multiple validation errors
// returned by Extrapolator.ValidateAll() if the designated constraints aren't met.
type ExtrapolatorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtrapolatorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtrapolatorMultiError) AllErrors() []error { return m }

// ExtrapolatorValidationError is the validation error returned by
// Extrapolator.Validate if the designated constraints aren't met.
type ExtrapolatorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtrapolatorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtrapolatorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtrapolatorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtrapolatorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtrapolatorValidationError) ErrorName() string { return "ExtrapolatorValidationError" }

// Error satisfies the builtin error interface
func (e ExtrapolatorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtrapolator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtrapolatorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtrapolatorValidationError{}

// Validate checks the field values on Max with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Max) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Max with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MaxMultiError, or nil if none found.
func (m *Max) ValidateAll() error {
	return m.validate(true)
}

func (m *Max) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MaxValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MaxValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MaxValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MaxValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MaxValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MaxValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MaxMultiError(errors)
	}

	return nil
}

// MaxMultiError is an error wrapping multiple validation errors returned by
// Max.ValidateAll() if the designated constraints aren't met.
type MaxMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxMultiError) AllErrors() []error { return m }

// MaxValidationError is the validation error returned by Max.Validate if the
// designated constraints aren't met.
type MaxValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxValidationError) ErrorName() string { return "MaxValidationError" }

// Error satisfies the builtin error interface
func (e MaxValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMax.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxValidationError{}

// Validate checks the field values on Min with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Min) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Min with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MinMultiError, or nil if none found.
func (m *Min) ValidateAll() error {
	return m.validate(true)
}

func (m *Min) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MinValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MinValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MinValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MinValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MinValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MinValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MinMultiError(errors)
	}

	return nil
}

// MinMultiError is an error wrapping multiple validation errors returned by
// Min.ValidateAll() if the designated constraints aren't met.
type MinMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MinMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MinMultiError) AllErrors() []error { return m }

// MinValidationError is the validation error returned by Min.Validate if the
// designated constraints aren't met.
type MinValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MinValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MinValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MinValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MinValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MinValidationError) ErrorName() string { return "MinValidationError" }

// Error satisfies the builtin error interface
func (e MinValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MinValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MinValidationError{}

// Validate checks the field values on And with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *And) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on And with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AndMultiError, or nil if none found.
func (m *And) ValidateAll() error {
	return m.validate(true)
}

func (m *And) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AndValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AndValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AndValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AndValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AndValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AndValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AndMultiError(errors)
	}

	return nil
}

// AndMultiError is an error wrapping multiple validation errors returned by
// And.ValidateAll() if the designated constraints aren't met.
type AndMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AndMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AndMultiError) AllErrors() []error { return m }

// AndValidationError is the validation error returned by And.Validate if the
// designated constraints aren't met.
type AndValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AndValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AndValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AndValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AndValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AndValidationError) ErrorName() string { return "AndValidationError" }

// Error satisfies the builtin error interface
func (e AndValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AndValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AndValidationError{}

// Validate checks the field values on Or with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Or) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Or with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OrMultiError, or nil if none found.
func (m *Or) ValidateAll() error {
	return m.validate(true)
}

func (m *Or) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OrMultiError(errors)
	}

	return nil
}

// OrMultiError is an error wrapping multiple validation errors returned by
// Or.ValidateAll() if the designated constraints aren't met.
type OrMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrMultiError) AllErrors() []error { return m }

// OrValidationError is the validation error returned by Or.Validate if the
// designated constraints aren't met.
type OrValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrValidationError) ErrorName() string { return "OrValidationError" }

// Error satisfies the builtin error interface
func (e OrValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrValidationError{}

// Validate checks the field values on Inverter with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Inverter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Inverter with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InverterMultiError, or nil
// if none found.
func (m *Inverter) ValidateAll() error {
	return m.validate(true)
}

func (m *Inverter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InverterValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InverterValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InverterValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InverterValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InverterValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InverterValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InverterMultiError(errors)
	}

	return nil
}

// InverterMultiError is an error wrapping multiple validation errors returned
// by Inverter.ValidateAll() if the designated constraints aren't met.
type InverterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InverterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InverterMultiError) AllErrors() []error { return m }

// InverterValidationError is the validation error returned by
// Inverter.Validate if the designated constraints aren't met.
type InverterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InverterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InverterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InverterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InverterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InverterValidationError) ErrorName() string { return "InverterValidationError" }

// Error satisfies the builtin error interface
func (e InverterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInverter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InverterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InverterValidationError{}

// Validate checks the field values on FirstValid with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FirstValid) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FirstValid with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FirstValidMultiError, or
// nil if none found.
func (m *FirstValid) ValidateAll() error {
	return m.validate(true)
}

func (m *FirstValid) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FirstValidValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FirstValidValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FirstValidValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FirstValidValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FirstValidValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FirstValidValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FirstValidMultiError(errors)
	}

	return nil
}

// FirstValidMultiError is an error wrapping multiple validation errors
// returned by FirstValid.ValidateAll() if the designated constraints aren't met.
type FirstValidMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FirstValidMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FirstValidMultiError) AllErrors() []error { return m }

// FirstValidValidationError is the validation error returned by
// FirstValid.Validate if the designated constraints aren't met.
type FirstValidValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FirstValidValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FirstValidValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FirstValidValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FirstValidValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FirstValidValidationError) ErrorName() string { return "FirstValidValidationError" }

// Error satisfies the builtin error interface
func (e FirstValidValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFirstValid.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FirstValidValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FirstValidValidationError{}

// Validate checks the field values on Alerter with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Alerter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Alerter with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AlerterMultiError, or nil if none found.
func (m *Alerter) ValidateAll() error {
	return m.validate(true)
}

func (m *Alerter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlerterValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlerterValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlerterValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlerterValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlerterValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlerterValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AlerterMultiError(errors)
	}

	return nil
}

// AlerterMultiError is an error wrapping multiple validation errors returned
// by Alerter.ValidateAll() if the designated constraints aren't met.
type AlerterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AlerterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AlerterMultiError) AllErrors() []error { return m }

// AlerterValidationError is the validation error returned by Alerter.Validate
// if the designated constraints aren't met.
type AlerterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AlerterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AlerterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AlerterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AlerterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AlerterValidationError) ErrorName() string { return "AlerterValidationError" }

// Error satisfies the builtin error interface
func (e AlerterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlerter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AlerterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AlerterValidationError{}

// Validate checks the field values on Integrator with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Integrator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Integrator with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IntegratorMultiError, or
// nil if none found.
func (m *Integrator) ValidateAll() error {
	return m.validate(true)
}

func (m *Integrator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IntegratorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IntegratorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IntegratorValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IntegratorValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IntegratorValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IntegratorValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InitialValue

	if len(errors) > 0 {
		return IntegratorMultiError(errors)
	}

	return nil
}

// IntegratorMultiError is an error wrapping multiple validation errors
// returned by Integrator.ValidateAll() if the designated constraints aren't met.
type IntegratorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IntegratorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IntegratorMultiError) AllErrors() []error { return m }

// IntegratorValidationError is the validation error returned by
// Integrator.Validate if the designated constraints aren't met.
type IntegratorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IntegratorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IntegratorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IntegratorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IntegratorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IntegratorValidationError) ErrorName() string { return "IntegratorValidationError" }

// Error satisfies the builtin error interface
func (e IntegratorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIntegrator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IntegratorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IntegratorValidationError{}

// Validate checks the field values on Differentiator with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Differentiator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Differentiator with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DifferentiatorMultiError,
// or nil if none found.
func (m *Differentiator) ValidateAll() error {
	return m.validate(true)
}

func (m *Differentiator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DifferentiatorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DifferentiatorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DifferentiatorValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DifferentiatorValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DifferentiatorValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DifferentiatorValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWindow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DifferentiatorValidationError{
					field:  "Window",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DifferentiatorValidationError{
					field:  "Window",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWindow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DifferentiatorValidationError{
				field:  "Window",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DifferentiatorMultiError(errors)
	}

	return nil
}

// DifferentiatorMultiError is an error wrapping multiple validation errors
// returned by Differentiator.ValidateAll() if the designated constraints
// aren't met.
type DifferentiatorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DifferentiatorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DifferentiatorMultiError) AllErrors() []error { return m }

// DifferentiatorValidationError is the validation error returned by
// Differentiator.Validate if the designated constraints aren't met.
type DifferentiatorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DifferentiatorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DifferentiatorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DifferentiatorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DifferentiatorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DifferentiatorValidationError) ErrorName() string { return "DifferentiatorValidationError" }

// Error satisfies the builtin error interface
func (e DifferentiatorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDifferentiator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DifferentiatorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DifferentiatorValidationError{}

// Validate checks the field values on PulseGenerator with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PulseGenerator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PulseGenerator with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PulseGeneratorMultiError,
// or nil if none found.
func (m *PulseGenerator) ValidateAll() error {
	return m.validate(true)
}

func (m *PulseGenerator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PulseGeneratorValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PulseGeneratorValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PulseGeneratorValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTrueFor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PulseGeneratorValidationError{
					field:  "TrueFor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PulseGeneratorValidationError{
					field:  "TrueFor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTrueFor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PulseGeneratorValidationError{
				field:  "TrueFor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFalseFor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PulseGeneratorValidationError{
					field:  "FalseFor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PulseGeneratorValidationError{
					field:  "FalseFor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFalseFor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PulseGeneratorValidationError{
				field:  "FalseFor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PulseGeneratorMultiError(errors)
	}

	return nil
}

// PulseGeneratorMultiError is an error wrapping multiple validation errors
// returned by PulseGenerator.ValidateAll() if the designated constraints
// aren't met.
type PulseGeneratorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PulseGeneratorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PulseGeneratorMultiError) AllErrors() []error { return m }

// PulseGeneratorValidationError is the validation error returned by
// PulseGenerator.Validate if the designated constraints aren't met.
type PulseGeneratorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PulseGeneratorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PulseGeneratorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PulseGeneratorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PulseGeneratorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PulseGeneratorValidationError) ErrorName() string { return "PulseGeneratorValidationError" }

// Error satisfies the builtin error interface
func (e PulseGeneratorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPulseGenerator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PulseGeneratorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PulseGeneratorValidationError{}

// Validate checks the field values on Holder with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Holder) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Holder with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in HolderMultiError, or nil if none found.
func (m *Holder) ValidateAll() error {
	return m.validate(true)
}

func (m *Holder) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HolderValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HolderValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HolderValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HolderValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HolderValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HolderValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetHoldFor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HolderValidationError{
					field:  "HoldFor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HolderValidationError{
					field:  "HoldFor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHoldFor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HolderValidationError{
				field:  "HoldFor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HolderMultiError(errors)
	}

	return nil
}

// HolderMultiError is an error wrapping multiple validation errors returned by
// Holder.ValidateAll() if the designated constraints aren't met.
type HolderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HolderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HolderMultiError) AllErrors() []error { return m }

// HolderValidationError is the validation error returned by Holder.Validate if
// the designated constraints aren't met.
type HolderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HolderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HolderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HolderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HolderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HolderValidationError) ErrorName() string { return "HolderValidationError" }

// Error satisfies the builtin error interface
func (e HolderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHolder.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HolderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HolderValidationError{}

// Validate checks the field values on NestedSignalIngress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NestedSignalIngress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NestedSignalIngress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NestedSignalIngressMultiError, or nil if none found.
func (m *NestedSignalIngress) ValidateAll() error {
	return m.validate(true)
}

func (m *NestedSignalIngress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NestedSignalIngressValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NestedSignalIngressValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NestedSignalIngressValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PortName

	if len(errors) > 0 {
		return NestedSignalIngressMultiError(errors)
	}

	return nil
}

// NestedSignalIngressMultiError is an error wrapping multiple validation
// errors returned by NestedSignalIngress.ValidateAll() if the designated
// constraints aren't met.
type NestedSignalIngressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NestedSignalIngressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NestedSignalIngressMultiError) AllErrors() []error { return m }

// NestedSignalIngressValidationError is the validation error returned by
// NestedSignalIngress.Validate if the designated constraints aren't met.
type NestedSignalIngressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NestedSignalIngressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NestedSignalIngressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NestedSignalIngressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NestedSignalIngressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NestedSignalIngressValidationError) ErrorName() string {
	return "NestedSignalIngressValidationError"
}

// Error satisfies the builtin error interface
func (e NestedSignalIngressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNestedSignalIngress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NestedSignalIngressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NestedSignalIngressValidationError{}

// Validate checks the field values on NestedSignalEgress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NestedSignalEgress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NestedSignalEgress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NestedSignalEgressMultiError, or nil if none found.
func (m *NestedSignalEgress) ValidateAll() error {
	return m.validate(true)
}

func (m *NestedSignalEgress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NestedSignalEgressValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NestedSignalEgressValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NestedSignalEgressValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PortName

	if len(errors) > 0 {
		return NestedSignalEgressMultiError(errors)
	}

	return nil
}

// NestedSignalEgressMultiError is an error wrapping multiple validation errors
// returned by NestedSignalEgress.ValidateAll() if the designated constraints
// aren't met.
type NestedSignalEgressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NestedSignalEgressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NestedSignalEgressMultiError) AllErrors() []error { return m }

// NestedSignalEgressValidationError is the validation error returned by
// NestedSignalEgress.Validate if the designated constraints aren't met.
type NestedSignalEgressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NestedSignalEgressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NestedSignalEgressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NestedSignalEgressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NestedSignalEgressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NestedSignalEgressValidationError) ErrorName() string {
	return "NestedSignalEgressValidationError"
}

// Error satisfies the builtin error interface
func (e NestedSignalEgressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNestedSignalEgress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NestedSignalEgressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NestedSignalEgressValidationError{}

// Validate checks the field values on SignalGenerator with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignalGenerator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalGenerator with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalGeneratorMultiError, or nil if none found.
func (m *SignalGenerator) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalGenerator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalGeneratorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalGeneratorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalGeneratorValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalGeneratorValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalGeneratorValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalGeneratorValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalGeneratorValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalGeneratorValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalGeneratorValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SignalGeneratorMultiError(errors)
	}

	return nil
}

// SignalGeneratorMultiError is an error wrapping multiple validation errors
// returned by SignalGenerator.ValidateAll() if the designated constraints
// aren't met.
type SignalGeneratorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalGeneratorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalGeneratorMultiError) AllErrors() []error { return m }

// SignalGeneratorValidationError is the validation error returned by
// SignalGenerator.Validate if the designated constraints aren't met.
type SignalGeneratorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalGeneratorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalGeneratorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalGeneratorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalGeneratorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalGeneratorValidationError) ErrorName() string { return "SignalGeneratorValidationError" }

// Error satisfies the builtin error interface
func (e SignalGeneratorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalGenerator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalGeneratorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalGeneratorValidationError{}

// Validate checks the field values on GradientController_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GradientController_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GradientController_Parameters with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GradientController_ParametersMultiError, or nil if none found.
func (m *GradientController_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *GradientController_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Slope

	// no validation rules for MinGradient

	// no validation rules for MaxGradient

	if len(errors) > 0 {
		return GradientController_ParametersMultiError(errors)
	}

	return nil
}

// GradientController_ParametersMultiError is an error wrapping multiple
// validation errors returned by GradientController_Parameters.ValidateAll()
// if the designated constraints aren't met.
type GradientController_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GradientController_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GradientController_ParametersMultiError) AllErrors() []error { return m }

// GradientController_ParametersValidationError is the validation error
// returned by GradientController_Parameters.Validate if the designated
// constraints aren't met.
type GradientController_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GradientController_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GradientController_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GradientController_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GradientController_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GradientController_ParametersValidationError) ErrorName() string {
	return "GradientController_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e GradientController_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGradientController_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GradientController_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GradientController_ParametersValidationError{}

// Validate checks the field values on GradientController_DynamicConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GradientController_DynamicConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GradientController_DynamicConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GradientController_DynamicConfigMultiError, or nil if none found.
func (m *GradientController_DynamicConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *GradientController_DynamicConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ManualMode

	if len(errors) > 0 {
		return GradientController_DynamicConfigMultiError(errors)
	}

	return nil
}

// GradientController_DynamicConfigMultiError is an error wrapping multiple
// validation errors returned by
// GradientController_DynamicConfig.ValidateAll() if the designated
// constraints aren't met.
type GradientController_DynamicConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GradientController_DynamicConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GradientController_DynamicConfigMultiError) AllErrors() []error { return m }

// GradientController_DynamicConfigValidationError is the validation error
// returned by GradientController_DynamicConfig.Validate if the designated
// constraints aren't met.
type GradientController_DynamicConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GradientController_DynamicConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GradientController_DynamicConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GradientController_DynamicConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GradientController_DynamicConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GradientController_DynamicConfigValidationError) ErrorName() string {
	return "GradientController_DynamicConfigValidationError"
}

// Error satisfies the builtin error interface
func (e GradientController_DynamicConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGradientController_DynamicConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GradientController_DynamicConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GradientController_DynamicConfigValidationError{}

// Validate checks the field values on GradientController_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GradientController_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GradientController_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GradientController_InsMultiError, or nil if none found.
func (m *GradientController_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *GradientController_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSignal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GradientController_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GradientController_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GradientController_InsValidationError{
				field:  "Signal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSetpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GradientController_InsValidationError{
					field:  "Setpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GradientController_InsValidationError{
					field:  "Setpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSetpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GradientController_InsValidationError{
				field:  "Setpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOptimize()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GradientController_InsValidationError{
					field:  "Optimize",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GradientController_InsValidationError{
					field:  "Optimize",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptimize()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GradientController_InsValidationError{
				field:  "Optimize",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMax()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GradientController_InsValidationError{
					field:  "Max",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GradientController_InsValidationError{
					field:  "Max",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMax()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GradientController_InsValidationError{
				field:  "Max",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GradientController_InsValidationError{
					field:  "Min",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GradientController_InsValidationError{
					field:  "Min",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GradientController_InsValidationError{
				field:  "Min",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetControlVariable()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GradientController_InsValidationError{
					field:  "ControlVariable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GradientController_InsValidationError{
					field:  "ControlVariable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetControlVariable()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GradientController_InsValidationError{
				field:  "ControlVariable",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GradientController_InsMultiError(errors)
	}

	return nil
}

// GradientController_InsMultiError is an error wrapping multiple validation
// errors returned by GradientController_Ins.ValidateAll() if the designated
// constraints aren't met.
type GradientController_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GradientController_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GradientController_InsMultiError) AllErrors() []error { return m }

// GradientController_InsValidationError is the validation error returned by
// GradientController_Ins.Validate if the designated constraints aren't met.
type GradientController_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GradientController_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GradientController_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GradientController_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GradientController_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GradientController_InsValidationError) ErrorName() string {
	return "GradientController_InsValidationError"
}

// Error satisfies the builtin error interface
func (e GradientController_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGradientController_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GradientController_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GradientController_InsValidationError{}

// Validate checks the field values on GradientController_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GradientController_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GradientController_Outs with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GradientController_OutsMultiError, or nil if none found.
func (m *GradientController_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *GradientController_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GradientController_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GradientController_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GradientController_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GradientController_OutsMultiError(errors)
	}

	return nil
}

// GradientController_OutsMultiError is an error wrapping multiple validation
// errors returned by GradientController_Outs.ValidateAll() if the designated
// constraints aren't met.
type GradientController_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GradientController_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GradientController_OutsMultiError) AllErrors() []error { return m }

// GradientController_OutsValidationError is the validation error returned by
// GradientController_Outs.Validate if the designated constraints aren't met.
type GradientController_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GradientController_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GradientController_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GradientController_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GradientController_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GradientController_OutsValidationError) ErrorName() string {
	return "GradientController_OutsValidationError"
}

// Error satisfies the builtin error interface
func (e GradientController_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGradientController_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GradientController_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GradientController_OutsValidationError{}

// Validate checks the field values on EMA_Ins with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EMA_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EMA_Ins with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EMA_InsMultiError, or nil if none found.
func (m *EMA_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *EMA_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EMA_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EMA_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EMA_InsValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMaxEnvelope()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EMA_InsValidationError{
					field:  "MaxEnvelope",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EMA_InsValidationError{
					field:  "MaxEnvelope",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxEnvelope()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EMA_InsValidationError{
				field:  "MaxEnvelope",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMinEnvelope()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EMA_InsValidationError{
					field:  "MinEnvelope",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EMA_InsValidationError{
					field:  "MinEnvelope",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinEnvelope()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EMA_InsValidationError{
				field:  "MinEnvelope",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EMA_InsMultiError(errors)
	}

	return nil
}

// EMA_InsMultiError is an error wrapping multiple validation errors returned
// by EMA_Ins.ValidateAll() if the designated constraints aren't met.
type EMA_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EMA_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EMA_InsMultiError) AllErrors() []error { return m }

// EMA_InsValidationError is the validation error returned by EMA_Ins.Validate
// if the designated constraints aren't met.
type EMA_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EMA_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EMA_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EMA_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EMA_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EMA_InsValidationError) ErrorName() string { return "EMA_InsValidationError" }

// Error satisfies the builtin error interface
func (e EMA_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEMA_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EMA_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EMA_InsValidationError{}

// Validate checks the field values on EMA_Outs with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EMA_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EMA_Outs with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EMA_OutsMultiError, or nil
// if none found.
func (m *EMA_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *EMA_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EMA_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EMA_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EMA_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EMA_OutsMultiError(errors)
	}

	return nil
}

// EMA_OutsMultiError is an error wrapping multiple validation errors returned
// by EMA_Outs.ValidateAll() if the designated constraints aren't met.
type EMA_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EMA_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EMA_OutsMultiError) AllErrors() []error { return m }

// EMA_OutsValidationError is the validation error returned by
// EMA_Outs.Validate if the designated constraints aren't met.
type EMA_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EMA_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EMA_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EMA_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EMA_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EMA_OutsValidationError) ErrorName() string { return "EMA_OutsValidationError" }

// Error satisfies the builtin error interface
func (e EMA_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEMA_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EMA_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EMA_OutsValidationError{}

// Validate checks the field values on EMA_Parameters with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EMA_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EMA_Parameters with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EMA_ParametersMultiError,
// or nil if none found.
func (m *EMA_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *EMA_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEmaWindow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EMA_ParametersValidationError{
					field:  "EmaWindow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EMA_ParametersValidationError{
					field:  "EmaWindow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEmaWindow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EMA_ParametersValidationError{
				field:  "EmaWindow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWarmupWindow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EMA_ParametersValidationError{
					field:  "WarmupWindow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EMA_ParametersValidationError{
					field:  "WarmupWindow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWarmupWindow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EMA_ParametersValidationError{
				field:  "WarmupWindow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CorrectionFactorOnMinEnvelopeViolation

	// no validation rules for CorrectionFactorOnMaxEnvelopeViolation

	// no validation rules for ValidDuringWarmup

	if len(errors) > 0 {
		return EMA_ParametersMultiError(errors)
	}

	return nil
}

// EMA_ParametersMultiError is an error wrapping multiple validation errors
// returned by EMA_Parameters.ValidateAll() if the designated constraints
// aren't met.
type EMA_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EMA_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EMA_ParametersMultiError) AllErrors() []error { return m }

// EMA_ParametersValidationError is the validation error returned by
// EMA_Parameters.Validate if the designated constraints aren't met.
type EMA_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EMA_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EMA_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EMA_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EMA_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EMA_ParametersValidationError) ErrorName() string { return "EMA_ParametersValidationError" }

// Error satisfies the builtin error interface
func (e EMA_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEMA_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EMA_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EMA_ParametersValidationError{}

// Validate checks the field values on SMA_Ins with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SMA_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SMA_Ins with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SMA_InsMultiError, or nil if none found.
func (m *SMA_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *SMA_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SMA_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SMA_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SMA_InsValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SMA_InsMultiError(errors)
	}

	return nil
}

// SMA_InsMultiError is an error wrapping multiple validation errors returned
// by SMA_Ins.ValidateAll() if the designated constraints aren't met.
type SMA_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SMA_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SMA_InsMultiError) AllErrors() []error { return m }

// SMA_InsValidationError is the validation error returned by SMA_Ins.Validate
// if the designated constraints aren't met.
type SMA_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SMA_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SMA_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SMA_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SMA_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SMA_InsValidationError) ErrorName() string { return "SMA_InsValidationError" }

// Error satisfies the builtin error interface
func (e SMA_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSMA_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SMA_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SMA_InsValidationError{}

// Validate checks the field values on SMA_Outs with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SMA_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SMA_Outs with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SMA_OutsMultiError, or nil
// if none found.
func (m *SMA_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *SMA_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SMA_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SMA_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SMA_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SMA_OutsMultiError(errors)
	}

	return nil
}

// SMA_OutsMultiError is an error wrapping multiple validation errors returned
// by SMA_Outs.ValidateAll() if the designated constraints aren't met.
type SMA_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SMA_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SMA_OutsMultiError) AllErrors() []error { return m }

// SMA_OutsValidationError is the validation error returned by
// SMA_Outs.Validate if the designated constraints aren't met.
type SMA_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SMA_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SMA_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SMA_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SMA_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SMA_OutsValidationError) ErrorName() string { return "SMA_OutsValidationError" }

// Error satisfies the builtin error interface
func (e SMA_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSMA_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SMA_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SMA_OutsValidationError{}

// Validate checks the field values on SMA_Parameters with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SMA_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SMA_Parameters with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SMA_ParametersMultiError,
// or nil if none found.
func (m *SMA_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *SMA_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSmaWindow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SMA_ParametersValidationError{
					field:  "SmaWindow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SMA_ParametersValidationError{
					field:  "SmaWindow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSmaWindow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SMA_ParametersValidationError{
				field:  "SmaWindow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ValidDuringWarmup

	if len(errors) > 0 {
		return SMA_ParametersMultiError(errors)
	}

	return nil
}

// SMA_ParametersMultiError is an error wrapping multiple validation errors
// returned by SMA_Parameters.ValidateAll() if the designated constraints
// aren't met.
type SMA_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SMA_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SMA_ParametersMultiError) AllErrors() []error { return m }

// SMA_ParametersValidationError is the validation error returned by
// SMA_Parameters.Validate if the designated constraints aren't met.
type SMA_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SMA_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SMA_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SMA_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SMA_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SMA_ParametersValidationError) ErrorName() string { return "SMA_ParametersValidationError" }

// Error satisfies the builtin error interface
func (e SMA_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSMA_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SMA_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SMA_ParametersValidationError{}

// Validate checks the field values on ArithmeticCombinator_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ArithmeticCombinator_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArithmeticCombinator_Ins with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ArithmeticCombinator_InsMultiError, or nil if none found.
func (m *ArithmeticCombinator_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *ArithmeticCombinator_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLhs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ArithmeticCombinator_InsValidationError{
					field:  "Lhs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ArithmeticCombinator_InsValidationError{
					field:  "Lhs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLhs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ArithmeticCombinator_InsValidationError{
				field:  "Lhs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRhs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ArithmeticCombinator_InsValidationError{
					field:  "Rhs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ArithmeticCombinator_InsValidationError{
					field:  "Rhs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRhs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ArithmeticCombinator_InsValidationError{
				field:  "Rhs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ArithmeticCombinator_InsMultiError(errors)
	}

	return nil
}

// ArithmeticCombinator_InsMultiError is an error wrapping multiple validation
// errors returned by ArithmeticCombinator_Ins.ValidateAll() if the designated
// constraints aren't met.
type ArithmeticCombinator_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArithmeticCombinator_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArithmeticCombinator_InsMultiError) AllErrors() []error { return m }

// ArithmeticCombinator_InsValidationError is the validation error returned by
// ArithmeticCombinator_Ins.Validate if the designated constraints aren't met.
type ArithmeticCombinator_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArithmeticCombinator_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArithmeticCombinator_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArithmeticCombinator_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArithmeticCombinator_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArithmeticCombinator_InsValidationError) ErrorName() string {
	return "ArithmeticCombinator_InsValidationError"
}

// Error satisfies the builtin error interface
func (e ArithmeticCombinator_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArithmeticCombinator_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArithmeticCombinator_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArithmeticCombinator_InsValidationError{}

// Validate checks the field values on ArithmeticCombinator_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ArithmeticCombinator_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArithmeticCombinator_Outs with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ArithmeticCombinator_OutsMultiError, or nil if none found.
func (m *ArithmeticCombinator_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *ArithmeticCombinator_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ArithmeticCombinator_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ArithmeticCombinator_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ArithmeticCombinator_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ArithmeticCombinator_OutsMultiError(errors)
	}

	return nil
}

// ArithmeticCombinator_OutsMultiError is an error wrapping multiple validation
// errors returned by ArithmeticCombinator_Outs.ValidateAll() if the
// designated constraints aren't met.
type ArithmeticCombinator_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArithmeticCombinator_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArithmeticCombinator_OutsMultiError) AllErrors() []error { return m }

// ArithmeticCombinator_OutsValidationError is the validation error returned by
// ArithmeticCombinator_Outs.Validate if the designated constraints aren't met.
type ArithmeticCombinator_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArithmeticCombinator_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArithmeticCombinator_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArithmeticCombinator_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArithmeticCombinator_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArithmeticCombinator_OutsValidationError) ErrorName() string {
	return "ArithmeticCombinator_OutsValidationError"
}

// Error satisfies the builtin error interface
func (e ArithmeticCombinator_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArithmeticCombinator_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArithmeticCombinator_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArithmeticCombinator_OutsValidationError{}

// Validate checks the field values on Decider_Ins with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Decider_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Decider_Ins with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Decider_InsMultiError, or
// nil if none found.
func (m *Decider_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *Decider_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLhs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Decider_InsValidationError{
					field:  "Lhs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Decider_InsValidationError{
					field:  "Lhs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLhs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Decider_InsValidationError{
				field:  "Lhs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRhs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Decider_InsValidationError{
					field:  "Rhs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Decider_InsValidationError{
					field:  "Rhs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRhs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Decider_InsValidationError{
				field:  "Rhs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Decider_InsMultiError(errors)
	}

	return nil
}

// Decider_InsMultiError is an error wrapping multiple validation errors
// returned by Decider_Ins.ValidateAll() if the designated constraints aren't met.
type Decider_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Decider_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Decider_InsMultiError) AllErrors() []error { return m }

// Decider_InsValidationError is the validation error returned by
// Decider_Ins.Validate if the designated constraints aren't met.
type Decider_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Decider_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Decider_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Decider_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Decider_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Decider_InsValidationError) ErrorName() string { return "Decider_InsValidationError" }

// Error satisfies the builtin error interface
func (e Decider_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDecider_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Decider_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Decider_InsValidationError{}

// Validate checks the field values on Decider_Outs with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Decider_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Decider_Outs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Decider_OutsMultiError, or
// nil if none found.
func (m *Decider_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *Decider_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Decider_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Decider_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Decider_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Decider_OutsMultiError(errors)
	}

	return nil
}

// Decider_OutsMultiError is an error wrapping multiple validation errors
// returned by Decider_Outs.ValidateAll() if the designated constraints aren't met.
type Decider_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Decider_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Decider_OutsMultiError) AllErrors() []error { return m }

// Decider_OutsValidationError is the validation error returned by
// Decider_Outs.Validate if the designated constraints aren't met.
type Decider_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Decider_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Decider_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Decider_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Decider_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Decider_OutsValidationError) ErrorName() string { return "Decider_OutsValidationError" }

// Error satisfies the builtin error interface
func (e Decider_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDecider_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Decider_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Decider_OutsValidationError{}

// Validate checks the field values on Switcher_Ins with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Switcher_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Switcher_Ins with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Switcher_InsMultiError, or
// nil if none found.
func (m *Switcher_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *Switcher_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOnSignal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Switcher_InsValidationError{
					field:  "OnSignal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Switcher_InsValidationError{
					field:  "OnSignal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOnSignal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Switcher_InsValidationError{
				field:  "OnSignal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOffSignal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Switcher_InsValidationError{
					field:  "OffSignal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Switcher_InsValidationError{
					field:  "OffSignal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOffSignal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Switcher_InsValidationError{
				field:  "OffSignal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSwitch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Switcher_InsValidationError{
					field:  "Switch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Switcher_InsValidationError{
					field:  "Switch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSwitch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Switcher_InsValidationError{
				field:  "Switch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Switcher_InsMultiError(errors)
	}

	return nil
}

// Switcher_InsMultiError is an error wrapping multiple validation errors
// returned by Switcher_Ins.ValidateAll() if the designated constraints aren't met.
type Switcher_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Switcher_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Switcher_InsMultiError) AllErrors() []error { return m }

// Switcher_InsValidationError is the validation error returned by
// Switcher_Ins.Validate if the designated constraints aren't met.
type Switcher_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Switcher_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Switcher_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Switcher_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Switcher_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Switcher_InsValidationError) ErrorName() string { return "Switcher_InsValidationError" }

// Error satisfies the builtin error interface
func (e Switcher_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSwitcher_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Switcher_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Switcher_InsValidationError{}

// Validate checks the field values on Switcher_Outs with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Switcher_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Switcher_Outs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Switcher_OutsMultiError, or
// nil if none found.
func (m *Switcher_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *Switcher_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Switcher_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Switcher_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Switcher_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Switcher_OutsMultiError(errors)
	}

	return nil
}

// Switcher_OutsMultiError is an error wrapping multiple validation errors
// returned by Switcher_Outs.ValidateAll() if the designated constraints
// aren't met.
type Switcher_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Switcher_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Switcher_OutsMultiError) AllErrors() []error { return m }

// Switcher_OutsValidationError is the validation error returned by
// Switcher_Outs.Validate if the designated constraints aren't met.
type Switcher_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Switcher_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Switcher_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Switcher_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Switcher_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Switcher_OutsValidationError) ErrorName() string { return "Switcher_OutsValidationError" }

// Error satisfies the builtin error interface
func (e Switcher_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSwitcher_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Switcher_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Switcher_OutsValidationError{}

// Validate checks the field values on Variable_DynamicConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Variable_DynamicConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Variable_DynamicConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Variable_DynamicConfigMultiError, or nil if none found.
func (m *Variable_DynamicConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *Variable_DynamicConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConstantSignal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Variable_DynamicConfigValidationError{
					field:  "ConstantSignal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Variable_DynamicConfigValidationError{
					field:  "ConstantSignal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConstantSignal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Variable_DynamicConfigValidationError{
				field:  "ConstantSignal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Variable_DynamicConfigMultiError(errors)
	}

	return nil
}

// Variable_DynamicConfigMultiError is an error wrapping multiple validation
// errors returned by Variable_DynamicConfig.ValidateAll() if the designated
// constraints aren't met.
type Variable_DynamicConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Variable_DynamicConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Variable_DynamicConfigMultiError) AllErrors() []error { return m }

// Variable_DynamicConfigValidationError is the validation error returned by
// Variable_DynamicConfig.Validate if the designated constraints aren't met.
type Variable_DynamicConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Variable_DynamicConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Variable_DynamicConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Variable_DynamicConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Variable_DynamicConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Variable_DynamicConfigValidationError) ErrorName() string {
	return "Variable_DynamicConfigValidationError"
}

// Error satisfies the builtin error interface
func (e Variable_DynamicConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVariable_DynamicConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Variable_DynamicConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Variable_DynamicConfigValidationError{}

// Validate checks the field values on Variable_Outs with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Variable_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Variable_Outs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Variable_OutsMultiError, or
// nil if none found.
func (m *Variable_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *Variable_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Variable_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Variable_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Variable_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Variable_OutsMultiError(errors)
	}

	return nil
}

// Variable_OutsMultiError is an error wrapping multiple validation errors
// returned by Variable_Outs.ValidateAll() if the designated constraints
// aren't met.
type Variable_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Variable_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Variable_OutsMultiError) AllErrors() []error { return m }

// Variable_OutsValidationError is the validation error returned by
// Variable_Outs.Validate if the designated constraints aren't met.
type Variable_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Variable_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Variable_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Variable_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Variable_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Variable_OutsValidationError) ErrorName() string { return "Variable_OutsValidationError" }

// Error satisfies the builtin error interface
func (e Variable_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVariable_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Variable_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Variable_OutsValidationError{}

// Validate checks the field values on UnaryOperator_Ins with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UnaryOperator_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnaryOperator_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnaryOperator_InsMultiError, or nil if none found.
func (m *UnaryOperator_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *UnaryOperator_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnaryOperator_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnaryOperator_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnaryOperator_InsValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UnaryOperator_InsMultiError(errors)
	}

	return nil
}

// UnaryOperator_InsMultiError is an error wrapping multiple validation errors
// returned by UnaryOperator_Ins.ValidateAll() if the designated constraints
// aren't met.
type UnaryOperator_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnaryOperator_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnaryOperator_InsMultiError) AllErrors() []error { return m }

// UnaryOperator_InsValidationError is the validation error returned by
// UnaryOperator_Ins.Validate if the designated constraints aren't met.
type UnaryOperator_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnaryOperator_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnaryOperator_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnaryOperator_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnaryOperator_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnaryOperator_InsValidationError) ErrorName() string {
	return "UnaryOperator_InsValidationError"
}

// Error satisfies the builtin error interface
func (e UnaryOperator_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnaryOperator_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnaryOperator_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnaryOperator_InsValidationError{}

// Validate checks the field values on UnaryOperator_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnaryOperator_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnaryOperator_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnaryOperator_OutsMultiError, or nil if none found.
func (m *UnaryOperator_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *UnaryOperator_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnaryOperator_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnaryOperator_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnaryOperator_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UnaryOperator_OutsMultiError(errors)
	}

	return nil
}

// UnaryOperator_OutsMultiError is an error wrapping multiple validation errors
// returned by UnaryOperator_Outs.ValidateAll() if the designated constraints
// aren't met.
type UnaryOperator_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnaryOperator_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnaryOperator_OutsMultiError) AllErrors() []error { return m }

// UnaryOperator_OutsValidationError is the validation error returned by
// UnaryOperator_Outs.Validate if the designated constraints aren't met.
type UnaryOperator_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnaryOperator_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnaryOperator_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnaryOperator_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnaryOperator_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnaryOperator_OutsValidationError) ErrorName() string {
	return "UnaryOperator_OutsValidationError"
}

// Error satisfies the builtin error interface
func (e UnaryOperator_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnaryOperator_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnaryOperator_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnaryOperator_OutsValidationError{}

// Validate checks the field values on Extrapolator_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Extrapolator_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Extrapolator_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Extrapolator_ParametersMultiError, or nil if none found.
func (m *Extrapolator_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *Extrapolator_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMaxExtrapolationInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Extrapolator_ParametersValidationError{
					field:  "MaxExtrapolationInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Extrapolator_ParametersValidationError{
					field:  "MaxExtrapolationInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxExtrapolationInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Extrapolator_ParametersValidationError{
				field:  "MaxExtrapolationInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Extrapolator_ParametersMultiError(errors)
	}

	return nil
}

// Extrapolator_ParametersMultiError is an error wrapping multiple validation
// errors returned by Extrapolator_Parameters.ValidateAll() if the designated
// constraints aren't met.
type Extrapolator_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Extrapolator_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Extrapolator_ParametersMultiError) AllErrors() []error { return m }

// Extrapolator_ParametersValidationError is the validation error returned by
// Extrapolator_Parameters.Validate if the designated constraints aren't met.
type Extrapolator_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Extrapolator_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Extrapolator_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Extrapolator_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Extrapolator_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Extrapolator_ParametersValidationError) ErrorName() string {
	return "Extrapolator_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e Extrapolator_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtrapolator_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Extrapolator_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Extrapolator_ParametersValidationError{}

// Validate checks the field values on Extrapolator_Ins with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Extrapolator_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Extrapolator_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Extrapolator_InsMultiError, or nil if none found.
func (m *Extrapolator_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *Extrapolator_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Extrapolator_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Extrapolator_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Extrapolator_InsValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Extrapolator_InsMultiError(errors)
	}

	return nil
}

// Extrapolator_InsMultiError is an error wrapping multiple validation errors
// returned by Extrapolator_Ins.ValidateAll() if the designated constraints
// aren't met.
type Extrapolator_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Extrapolator_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Extrapolator_InsMultiError) AllErrors() []error { return m }

// Extrapolator_InsValidationError is the validation error returned by
// Extrapolator_Ins.Validate if the designated constraints aren't met.
type Extrapolator_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Extrapolator_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Extrapolator_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Extrapolator_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Extrapolator_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Extrapolator_InsValidationError) ErrorName() string { return "Extrapolator_InsValidationError" }

// Error satisfies the builtin error interface
func (e Extrapolator_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtrapolator_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Extrapolator_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Extrapolator_InsValidationError{}

// Validate checks the field values on Extrapolator_Outs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Extrapolator_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Extrapolator_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Extrapolator_OutsMultiError, or nil if none found.
func (m *Extrapolator_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *Extrapolator_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Extrapolator_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Extrapolator_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Extrapolator_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Extrapolator_OutsMultiError(errors)
	}

	return nil
}

// Extrapolator_OutsMultiError is an error wrapping multiple validation errors
// returned by Extrapolator_Outs.ValidateAll() if the designated constraints
// aren't met.
type Extrapolator_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Extrapolator_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Extrapolator_OutsMultiError) AllErrors() []error { return m }

// Extrapolator_OutsValidationError is the validation error returned by
// Extrapolator_Outs.Validate if the designated constraints aren't met.
type Extrapolator_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Extrapolator_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Extrapolator_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Extrapolator_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Extrapolator_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Extrapolator_OutsValidationError) ErrorName() string {
	return "Extrapolator_OutsValidationError"
}

// Error satisfies the builtin error interface
func (e Extrapolator_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtrapolator_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Extrapolator_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Extrapolator_OutsValidationError{}

// Validate checks the field values on Max_Ins with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Max_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Max_Ins with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in Max_InsMultiError, or nil if none found.
func (m *Max_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *Max_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Max_InsValidationError{
						field:  fmt.Sprintf("Inputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Max_InsValidationError{
						field:  fmt.Sprintf("Inputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Max_InsValidationError{
					field:  fmt.Sprintf("Inputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Max_InsMultiError(errors)
	}

	return nil
}

// Max_InsMultiError is an error wrapping multiple validation errors returned
// by Max_Ins.ValidateAll() if the designated constraints aren't met.
type Max_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Max_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Max_InsMultiError) AllErrors() []error { return m }

// Max_InsValidationError is the validation error returned by Max_Ins.Validate
// if the designated constraints aren't met.
type Max_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Max_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Max_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Max_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Max_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Max_InsValidationError) ErrorName() string { return "Max_InsValidationError" }

// Error satisfies the builtin error interface
func (e Max_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMax_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Max_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Max_InsValidationError{}

// Validate checks the field values on Max_Outs with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Max_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Max_Outs with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Max_OutsMultiError, or nil
// if none found.
func (m *Max_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *Max_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Max_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Max_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Max_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Max_OutsMultiError(errors)
	}

	return nil
}

// Max_OutsMultiError is an error wrapping multiple validation errors returned
// by Max_Outs.ValidateAll() if the designated constraints aren't met.
type Max_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Max_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Max_OutsMultiError) AllErrors() []error { return m }

// Max_OutsValidationError is the validation error returned by
// Max_Outs.Validate if the designated constraints aren't met.
type Max_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Max_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Max_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Max_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Max_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Max_OutsValidationError) ErrorName() string { return "Max_OutsValidationError" }

// Error satisfies the builtin error interface
func (e Max_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMax_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Max_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Max_OutsValidationError{}

// Validate checks the field values on Min_Ins with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Min_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Min_Ins with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in Min_InsMultiError, or nil if none found.
func (m *Min_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *Min_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Min_InsValidationError{
						field:  fmt.Sprintf("Inputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Min_InsValidationError{
						field:  fmt.Sprintf("Inputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Min_InsValidationError{
					field:  fmt.Sprintf("Inputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Min_InsMultiError(errors)
	}

	return nil
}

// Min_InsMultiError is an error wrapping multiple validation errors returned
// by Min_Ins.ValidateAll() if the designated constraints aren't met.
type Min_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Min_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Min_InsMultiError) AllErrors() []error { return m }

// Min_InsValidationError is the validation error returned by Min_Ins.Validate
// if the designated constraints aren't met.
type Min_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Min_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Min_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Min_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Min_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Min_InsValidationError) ErrorName() string { return "Min_InsValidationError" }

// Error satisfies the builtin error interface
func (e Min_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMin_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Min_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Min_InsValidationError{}

// Validate checks the field values on Min_Outs with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Min_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Min_Outs with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Min_OutsMultiError, or nil
// if none found.
func (m *Min_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *Min_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Min_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Min_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Min_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Min_OutsMultiError(errors)
	}

	return nil
}

// Min_OutsMultiError is an error wrapping multiple validation errors returned
// by Min_Outs.ValidateAll() if the designated constraints aren't met.
type Min_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Min_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Min_OutsMultiError) AllErrors() []error { return m }

// Min_OutsValidationError is the validation error returned by
// Min_Outs.Validate if the designated constraints aren't met.
type Min_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Min_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Min_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Min_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Min_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Min_OutsValidationError) ErrorName() string { return "Min_OutsValidationError" }

// Error satisfies the builtin error interface
func (e Min_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMin_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Min_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Min_OutsValidationError{}

// Validate checks the field values on And_Ins with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *And_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on And_Ins with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in And_InsMultiError, or nil if none found.
func (m *And_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *And_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, And_InsValidationError{
						field:  fmt.Sprintf("Inputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, And_InsValidationError{
						field:  fmt.Sprintf("Inputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return And_InsValidationError{
					field:  fmt.Sprintf("Inputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return And_InsMultiError(errors)
	}

	return nil
}

// And_InsMultiError is an error wrapping multiple validation errors returned
// by And_Ins.ValidateAll() if the designated constraints aren't met.
type And_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m And_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m And_InsMultiError) AllErrors() []error { return m }

// And_InsValidationError is the validation error returned by And_Ins.Validate
// if the designated constraints aren't met.
type And_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e And_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e And_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e And_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e And_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e And_InsValidationError) ErrorName() string { return "And_InsValidationError" }

// Error satisfies the builtin error interface
func (e And_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnd_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = And_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = And_InsValidationError{}

// Validate checks the field values on And_Outs with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *And_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on And_Outs with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in And_OutsMultiError, or nil
// if none found.
func (m *And_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *And_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, And_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, And_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return And_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return And_OutsMultiError(errors)
	}

	return nil
}

// And_OutsMultiError is an error wrapping multiple validation errors returned
// by And_Outs.ValidateAll() if the designated constraints aren't met.
type And_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m And_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m And_OutsMultiError) AllErrors() []error { return m }

// And_OutsValidationError is the validation error returned by
// And_Outs.Validate if the designated constraints aren't met.
type And_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e And_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e And_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e And_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e And_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e And_OutsValidationError) ErrorName() string { return "And_OutsValidationError" }

// Error satisfies the builtin error interface
func (e And_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnd_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = And_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = And_OutsValidationError{}

// Validate checks the field values on Or_Ins with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Or_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Or_Ins with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in Or_InsMultiError, or nil if none found.
func (m *Or_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *Or_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Or_InsValidationError{
						field:  fmt.Sprintf("Inputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Or_InsValidationError{
						field:  fmt.Sprintf("Inputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Or_InsValidationError{
					field:  fmt.Sprintf("Inputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Or_InsMultiError(errors)
	}

	return nil
}

// Or_InsMultiError is an error wrapping multiple validation errors returned by
// Or_Ins.ValidateAll() if the designated constraints aren't met.
type Or_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Or_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Or_InsMultiError) AllErrors() []error { return m }

// Or_InsValidationError is the validation error returned by Or_Ins.Validate if
// the designated constraints aren't met.
type Or_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Or_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Or_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Or_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Or_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Or_InsValidationError) ErrorName() string { return "Or_InsValidationError" }

// Error satisfies the builtin error interface
func (e Or_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOr_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Or_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Or_InsValidationError{}

// Validate checks the field values on Or_Outs with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Or_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Or_Outs with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in Or_OutsMultiError, or nil if none found.
func (m *Or_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *Or_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Or_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Or_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Or_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Or_OutsMultiError(errors)
	}

	return nil
}

// Or_OutsMultiError is an error wrapping multiple validation errors returned
// by Or_Outs.ValidateAll() if the designated constraints aren't met.
type Or_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Or_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Or_OutsMultiError) AllErrors() []error { return m }

// Or_OutsValidationError is the validation error returned by Or_Outs.Validate
// if the designated constraints aren't met.
type Or_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Or_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Or_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Or_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Or_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Or_OutsValidationError) ErrorName() string { return "Or_OutsValidationError" }

// Error satisfies the builtin error interface
func (e Or_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOr_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Or_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Or_OutsValidationError{}

// Validate checks the field values on Inverter_Ins with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Inverter_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Inverter_Ins with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Inverter_InsMultiError, or
// nil if none found.
func (m *Inverter_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *Inverter_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Inverter_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Inverter_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Inverter_InsValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Inverter_InsMultiError(errors)
	}

	return nil
}

// Inverter_InsMultiError is an error wrapping multiple validation errors
// returned by Inverter_Ins.ValidateAll() if the designated constraints aren't met.
type Inverter_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Inverter_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Inverter_InsMultiError) AllErrors() []error { return m }

// Inverter_InsValidationError is the validation error returned by
// Inverter_Ins.Validate if the designated constraints aren't met.
type Inverter_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Inverter_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Inverter_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Inverter_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Inverter_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Inverter_InsValidationError) ErrorName() string { return "Inverter_InsValidationError" }

// Error satisfies the builtin error interface
func (e Inverter_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInverter_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Inverter_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Inverter_InsValidationError{}

// Validate checks the field values on Inverter_Outs with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Inverter_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Inverter_Outs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Inverter_OutsMultiError, or
// nil if none found.
func (m *Inverter_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *Inverter_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Inverter_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Inverter_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Inverter_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Inverter_OutsMultiError(errors)
	}

	return nil
}

// Inverter_OutsMultiError is an error wrapping multiple validation errors
// returned by Inverter_Outs.ValidateAll() if the designated constraints
// aren't met.
type Inverter_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Inverter_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Inverter_OutsMultiError) AllErrors() []error { return m }

// Inverter_OutsValidationError is the validation error returned by
// Inverter_Outs.Validate if the designated constraints aren't met.
type Inverter_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Inverter_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Inverter_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Inverter_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Inverter_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Inverter_OutsValidationError) ErrorName() string { return "Inverter_OutsValidationError" }

// Error satisfies the builtin error interface
func (e Inverter_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInverter_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Inverter_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Inverter_OutsValidationError{}

// Validate checks the field values on FirstValid_Ins with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FirstValid_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FirstValid_Ins with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FirstValid_InsMultiError,
// or nil if none found.
func (m *FirstValid_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *FirstValid_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FirstValid_InsValidationError{
						field:  fmt.Sprintf("Inputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FirstValid_InsValidationError{
						field:  fmt.Sprintf("Inputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FirstValid_InsValidationError{
					field:  fmt.Sprintf("Inputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FirstValid_InsMultiError(errors)
	}

	return nil
}

// FirstValid_InsMultiError is an error wrapping multiple validation errors
// returned by FirstValid_Ins.ValidateAll() if the designated constraints
// aren't met.
type FirstValid_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FirstValid_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FirstValid_InsMultiError) AllErrors() []error { return m }

// FirstValid_InsValidationError is the validation error returned by
// FirstValid_Ins.Validate if the designated constraints aren't met.
type FirstValid_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FirstValid_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FirstValid_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FirstValid_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FirstValid_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FirstValid_InsValidationError) ErrorName() string { return "FirstValid_InsValidationError" }

// Error satisfies the builtin error interface
func (e FirstValid_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFirstValid_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FirstValid_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FirstValid_InsValidationError{}

// Validate checks the field values on FirstValid_Outs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FirstValid_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FirstValid_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FirstValid_OutsMultiError, or nil if none found.
func (m *FirstValid_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *FirstValid_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FirstValid_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FirstValid_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FirstValid_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FirstValid_OutsMultiError(errors)
	}

	return nil
}

// FirstValid_OutsMultiError is an error wrapping multiple validation errors
// returned by FirstValid_Outs.ValidateAll() if the designated constraints
// aren't met.
type FirstValid_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FirstValid_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FirstValid_OutsMultiError) AllErrors() []error { return m }

// FirstValid_OutsValidationError is the validation error returned by
// FirstValid_Outs.Validate if the designated constraints aren't met.
type FirstValid_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FirstValid_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FirstValid_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FirstValid_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FirstValid_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FirstValid_OutsValidationError) ErrorName() string { return "FirstValid_OutsValidationError" }

// Error satisfies the builtin error interface
func (e FirstValid_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFirstValid_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FirstValid_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FirstValid_OutsValidationError{}

// Validate checks the field values on Alerter_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Alerter_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Alerter_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Alerter_ParametersMultiError, or nil if none found.
func (m *Alerter_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *Alerter_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AlertName

	// no validation rules for Severity

	if all {
		switch v := interface{}(m.GetResolveTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Alerter_ParametersValidationError{
					field:  "ResolveTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Alerter_ParametersValidationError{
					field:  "ResolveTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResolveTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Alerter_ParametersValidationError{
				field:  "ResolveTimeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Labels

	if len(errors) > 0 {
		return Alerter_ParametersMultiError(errors)
	}

	return nil
}

// Alerter_ParametersMultiError is an error wrapping multiple validation errors
// returned by Alerter_Parameters.ValidateAll() if the designated constraints
// aren't met.
type Alerter_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Alerter_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Alerter_ParametersMultiError) AllErrors() []error { return m }

// Alerter_ParametersValidationError is the validation error returned by
// Alerter_Parameters.Validate if the designated constraints aren't met.
type Alerter_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Alerter_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Alerter_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Alerter_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Alerter_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Alerter_ParametersValidationError) ErrorName() string {
	return "Alerter_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e Alerter_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlerter_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Alerter_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Alerter_ParametersValidationError{}

// Validate checks the field values on Alerter_Ins with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Alerter_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Alerter_Ins with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Alerter_InsMultiError, or
// nil if none found.
func (m *Alerter_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *Alerter_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSignal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Alerter_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Alerter_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Alerter_InsValidationError{
				field:  "Signal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Alerter_InsMultiError(errors)
	}

	return nil
}

// Alerter_InsMultiError is an error wrapping multiple validation errors
// returned by Alerter_Ins.ValidateAll() if the designated constraints aren't met.
type Alerter_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Alerter_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Alerter_InsMultiError) AllErrors() []error { return m }

// Alerter_InsValidationError is the validation error returned by
// Alerter_Ins.Validate if the designated constraints aren't met.
type Alerter_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Alerter_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Alerter_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Alerter_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Alerter_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Alerter_InsValidationError) ErrorName() string { return "Alerter_InsValidationError" }

// Error satisfies the builtin error interface
func (e Alerter_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlerter_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Alerter_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Alerter_InsValidationError{}

// Validate checks the field values on Integrator_Ins with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Integrator_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Integrator_Ins with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Integrator_InsMultiError,
// or nil if none found.
func (m *Integrator_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *Integrator_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Integrator_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Integrator_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Integrator_InsValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReset_()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Integrator_InsValidationError{
					field:  "Reset_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Integrator_InsValidationError{
					field:  "Reset_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReset_()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Integrator_InsValidationError{
				field:  "Reset_",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMax()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Integrator_InsValidationError{
					field:  "Max",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Integrator_InsValidationError{
					field:  "Max",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMax()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Integrator_InsValidationError{
				field:  "Max",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Integrator_InsValidationError{
					field:  "Min",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Integrator_InsValidationError{
					field:  "Min",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Integrator_InsValidationError{
				field:  "Min",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Integrator_InsMultiError(errors)
	}

	return nil
}

// Integrator_InsMultiError is an error wrapping multiple validation errors
// returned by Integrator_Ins.ValidateAll() if the designated constraints
// aren't met.
type Integrator_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Integrator_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Integrator_InsMultiError) AllErrors() []error { return m }

// Integrator_InsValidationError is the validation error returned by
// Integrator_Ins.Validate if the designated constraints aren't met.
type Integrator_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Integrator_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Integrator_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Integrator_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Integrator_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Integrator_InsValidationError) ErrorName() string { return "Integrator_InsValidationError" }

// Error satisfies the builtin error interface
func (e Integrator_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIntegrator_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Integrator_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Integrator_InsValidationError{}

// Validate checks the field values on Integrator_Outs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Integrator_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Integrator_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Integrator_OutsMultiError, or nil if none found.
func (m *Integrator_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *Integrator_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Integrator_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Integrator_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Integrator_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Integrator_OutsMultiError(errors)
	}

	return nil
}

// Integrator_OutsMultiError is an error wrapping multiple validation errors
// returned by Integrator_Outs.ValidateAll() if the designated constraints
// aren't met.
type Integrator_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Integrator_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Integrator_OutsMultiError) AllErrors() []error { return m }

// Integrator_OutsValidationError is the validation error returned by
// Integrator_Outs.Validate if the designated constraints aren't met.
type Integrator_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Integrator_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Integrator_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Integrator_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Integrator_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Integrator_OutsValidationError) ErrorName() string { return "Integrator_OutsValidationError" }

// Error satisfies the builtin error interface
func (e Integrator_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIntegrator_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Integrator_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Integrator_OutsValidationError{}

// Validate checks the field values on Differentiator_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Differentiator_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Differentiator_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Differentiator_InsMultiError, or nil if none found.
func (m *Differentiator_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *Differentiator_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Differentiator_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Differentiator_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Differentiator_InsValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Differentiator_InsMultiError(errors)
	}

	return nil
}

// Differentiator_InsMultiError is an error wrapping multiple validation errors
// returned by Differentiator_Ins.ValidateAll() if the designated constraints
// aren't met.
type Differentiator_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Differentiator_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Differentiator_InsMultiError) AllErrors() []error { return m }

// Differentiator_InsValidationError is the validation error returned by
// Differentiator_Ins.Validate if the designated constraints aren't met.
type Differentiator_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Differentiator_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Differentiator_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Differentiator_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Differentiator_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Differentiator_InsValidationError) ErrorName() string {
	return "Differentiator_InsValidationError"
}

// Error satisfies the builtin error interface
func (e Differentiator_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDifferentiator_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Differentiator_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Differentiator_InsValidationError{}

// Validate checks the field values on Differentiator_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Differentiator_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Differentiator_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Differentiator_OutsMultiError, or nil if none found.
func (m *Differentiator_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *Differentiator_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Differentiator_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Differentiator_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Differentiator_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Differentiator_OutsMultiError(errors)
	}

	return nil
}

// Differentiator_OutsMultiError is an error wrapping multiple validation
// errors returned by Differentiator_Outs.ValidateAll() if the designated
// constraints aren't met.
type Differentiator_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Differentiator_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Differentiator_OutsMultiError) AllErrors() []error { return m }

// Differentiator_OutsValidationError is the validation error returned by
// Differentiator_Outs.Validate if the designated constraints aren't met.
type Differentiator_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Differentiator_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Differentiator_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Differentiator_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Differentiator_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Differentiator_OutsValidationError) ErrorName() string {
	return "Differentiator_OutsValidationError"
}

// Error satisfies the builtin error interface
func (e Differentiator_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDifferentiator_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Differentiator_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Differentiator_OutsValidationError{}

// Validate checks the field values on PulseGenerator_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PulseGenerator_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PulseGenerator_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PulseGenerator_OutsMultiError, or nil if none found.
func (m *PulseGenerator_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *PulseGenerator_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PulseGenerator_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PulseGenerator_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PulseGenerator_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PulseGenerator_OutsMultiError(errors)
	}

	return nil
}

// PulseGenerator_OutsMultiError is an error wrapping multiple validation
// errors returned by PulseGenerator_Outs.ValidateAll() if the designated
// constraints aren't met.
type PulseGenerator_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PulseGenerator_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PulseGenerator_OutsMultiError) AllErrors() []error { return m }

// PulseGenerator_OutsValidationError is the validation error returned by
// PulseGenerator_Outs.Validate if the designated constraints aren't met.
type PulseGenerator_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PulseGenerator_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PulseGenerator_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PulseGenerator_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PulseGenerator_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PulseGenerator_OutsValidationError) ErrorName() string {
	return "PulseGenerator_OutsValidationError"
}

// Error satisfies the builtin error interface
func (e PulseGenerator_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPulseGenerator_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PulseGenerator_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PulseGenerator_OutsValidationError{}

// Validate checks the field values on Holder_Ins with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Holder_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Holder_Ins with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Holder_InsMultiError, or
// nil if none found.
func (m *Holder_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *Holder_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Holder_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Holder_InsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Holder_InsValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReset_()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Holder_InsValidationError{
					field:  "Reset_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Holder_InsValidationError{
					field:  "Reset_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReset_()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Holder_InsValidationError{
				field:  "Reset_",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Holder_InsMultiError(errors)
	}

	return nil
}

// Holder_InsMultiError is an error wrapping multiple validation errors
// returned by Holder_Ins.ValidateAll() if the designated constraints aren't met.
type Holder_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Holder_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Holder_InsMultiError) AllErrors() []error { return m }

// Holder_InsValidationError is the validation error returned by
// Holder_Ins.Validate if the designated constraints aren't met.
type Holder_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Holder_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Holder_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Holder_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Holder_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Holder_InsValidationError) ErrorName() string { return "Holder_InsValidationError" }

// Error satisfies the builtin error interface
func (e Holder_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHolder_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Holder_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Holder_InsValidationError{}

// Validate checks the field values on Holder_Outs with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Holder_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Holder_Outs with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Holder_OutsMultiError, or
// nil if none found.
func (m *Holder_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *Holder_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Holder_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Holder_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Holder_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Holder_OutsMultiError(errors)
	}

	return nil
}

// Holder_OutsMultiError is an error wrapping multiple validation errors
// returned by Holder_Outs.ValidateAll() if the designated constraints aren't met.
type Holder_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Holder_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Holder_OutsMultiError) AllErrors() []error { return m }

// Holder_OutsValidationError is the validation error returned by
// Holder_Outs.Validate if the designated constraints aren't met.
type Holder_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Holder_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Holder_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Holder_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Holder_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Holder_OutsValidationError) ErrorName() string { return "Holder_OutsValidationError" }

// Error satisfies the builtin error interface
func (e Holder_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHolder_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Holder_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Holder_OutsValidationError{}

// Validate checks the field values on NestedSignalIngress_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NestedSignalIngress_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NestedSignalIngress_Outs with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NestedSignalIngress_OutsMultiError, or nil if none found.
func (m *NestedSignalIngress_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *NestedSignalIngress_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSignal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NestedSignalIngress_OutsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NestedSignalIngress_OutsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NestedSignalIngress_OutsValidationError{
				field:  "Signal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NestedSignalIngress_OutsMultiError(errors)
	}

	return nil
}

// NestedSignalIngress_OutsMultiError is an error wrapping multiple validation
// errors returned by NestedSignalIngress_Outs.ValidateAll() if the designated
// constraints aren't met.
type NestedSignalIngress_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NestedSignalIngress_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NestedSignalIngress_OutsMultiError) AllErrors() []error { return m }

// NestedSignalIngress_OutsValidationError is the validation error returned by
// NestedSignalIngress_Outs.Validate if the designated constraints aren't met.
type NestedSignalIngress_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NestedSignalIngress_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NestedSignalIngress_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NestedSignalIngress_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NestedSignalIngress_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NestedSignalIngress_OutsValidationError) ErrorName() string {
	return "NestedSignalIngress_OutsValidationError"
}

// Error satisfies the builtin error interface
func (e NestedSignalIngress_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNestedSignalIngress_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NestedSignalIngress_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NestedSignalIngress_OutsValidationError{}

// Validate checks the field values on NestedSignalEgress_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NestedSignalEgress_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NestedSignalEgress_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NestedSignalEgress_InsMultiError, or nil if none found.
func (m *NestedSignalEgress_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *NestedSignalEgress_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSignal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NestedSignalEgress_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NestedSignalEgress_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NestedSignalEgress_InsValidationError{
				field:  "Signal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NestedSignalEgress_InsMultiError(errors)
	}

	return nil
}

// NestedSignalEgress_InsMultiError is an error wrapping multiple validation
// errors returned by NestedSignalEgress_Ins.ValidateAll() if the designated
// constraints aren't met.
type NestedSignalEgress_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NestedSignalEgress_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NestedSignalEgress_InsMultiError) AllErrors() []error { return m }

// NestedSignalEgress_InsValidationError is the validation error returned by
// NestedSignalEgress_Ins.Validate if the designated constraints aren't met.
type NestedSignalEgress_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NestedSignalEgress_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NestedSignalEgress_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NestedSignalEgress_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NestedSignalEgress_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NestedSignalEgress_InsValidationError) ErrorName() string {
	return "NestedSignalEgress_InsValidationError"
}

// Error satisfies the builtin error interface
func (e NestedSignalEgress_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNestedSignalEgress_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NestedSignalEgress_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NestedSignalEgress_InsValidationError{}

// Validate checks the field values on SignalGenerator_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalGenerator_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalGenerator_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalGenerator_ParametersMultiError, or nil if none found.
func (m *SignalGenerator_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalGenerator_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSteps() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalGenerator_ParametersValidationError{
						field:  fmt.Sprintf("Steps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalGenerator_ParametersValidationError{
						field:  fmt.Sprintf("Steps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalGenerator_ParametersValidationError{
					field:  fmt.Sprintf("Steps[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SignalGenerator_ParametersMultiError(errors)
	}

	return nil
}

// SignalGenerator_ParametersMultiError is an error wrapping multiple
// validation errors returned by SignalGenerator_Parameters.ValidateAll() if
// the designated constraints aren't met.
type SignalGenerator_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalGenerator_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalGenerator_ParametersMultiError) AllErrors() []error { return m }

// SignalGenerator_ParametersValidationError is the validation error returned
// by SignalGenerator_Parameters.Validate if the designated constraints aren't met.
type SignalGenerator_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalGenerator_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalGenerator_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalGenerator_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalGenerator_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalGenerator_ParametersValidationError) ErrorName() string {
	return "SignalGenerator_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e SignalGenerator_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalGenerator_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalGenerator_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalGenerator_ParametersValidationError{}

// Validate checks the field values on SignalGenerator_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalGenerator_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalGenerator_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalGenerator_InsMultiError, or nil if none found.
func (m *SignalGenerator_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalGenerator_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetForward()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalGenerator_InsValidationError{
					field:  "Forward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalGenerator_InsValidationError{
					field:  "Forward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetForward()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalGenerator_InsValidationError{
				field:  "Forward",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBackward()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalGenerator_InsValidationError{
					field:  "Backward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalGenerator_InsValidationError{
					field:  "Backward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBackward()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalGenerator_InsValidationError{
				field:  "Backward",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReset_()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalGenerator_InsValidationError{
					field:  "Reset_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalGenerator_InsValidationError{
					field:  "Reset_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReset_()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalGenerator_InsValidationError{
				field:  "Reset_",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SignalGenerator_InsMultiError(errors)
	}

	return nil
}

// SignalGenerator_InsMultiError is an error wrapping multiple validation
// errors returned by SignalGenerator_Ins.ValidateAll() if the designated
// constraints aren't met.
type SignalGenerator_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalGenerator_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalGenerator_InsMultiError) AllErrors() []error { return m }

// SignalGenerator_InsValidationError is the validation error returned by
// SignalGenerator_Ins.Validate if the designated constraints aren't met.
type SignalGenerator_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalGenerator_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalGenerator_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalGenerator_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalGenerator_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalGenerator_InsValidationError) ErrorName() string {
	return "SignalGenerator_InsValidationError"
}

// Error satisfies the builtin error interface
func (e SignalGenerator_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalGenerator_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalGenerator_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalGenerator_InsValidationError{}

// Validate checks the field values on SignalGenerator_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalGenerator_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalGenerator_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalGenerator_OutsMultiError, or nil if none found.
func (m *SignalGenerator_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalGenerator_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalGenerator_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalGenerator_OutsValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalGenerator_OutsValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAtStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalGenerator_OutsValidationError{
					field:  "AtStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalGenerator_OutsValidationError{
					field:  "AtStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAtStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalGenerator_OutsValidationError{
				field:  "AtStart",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAtEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalGenerator_OutsValidationError{
					field:  "AtEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalGenerator_OutsValidationError{
					field:  "AtEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAtEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalGenerator_OutsValidationError{
				field:  "AtEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SignalGenerator_OutsMultiError(errors)
	}

	return nil
}

// SignalGenerator_OutsMultiError is an error wrapping multiple validation
// errors returned by SignalGenerator_Outs.ValidateAll() if the designated
// constraints aren't met.
type SignalGenerator_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalGenerator_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalGenerator_OutsMultiError) AllErrors() []error { return m }

// SignalGenerator_OutsValidationError is the validation error returned by
// SignalGenerator_Outs.Validate if the designated constraints aren't met.
type SignalGenerator_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalGenerator_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalGenerator_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalGenerator_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalGenerator_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalGenerator_OutsValidationError) ErrorName() string {
	return "SignalGenerator_OutsValidationError"
}

// Error satisfies the builtin error interface
func (e SignalGenerator_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalGenerator_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalGenerator_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalGenerator_OutsValidationError{}

// Validate checks the field values on SignalGenerator_Parameters_Step with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalGenerator_Parameters_Step) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalGenerator_Parameters_Step with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SignalGenerator_Parameters_StepMultiError, or nil if none found.
func (m *SignalGenerator_Parameters_Step) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalGenerator_Parameters_Step) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTargetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalGenerator_Parameters_StepValidationError{
					field:  "TargetOutput",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalGenerator_Parameters_StepValidationError{
					field:  "TargetOutput",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalGenerator_Parameters_StepValidationError{
				field:  "TargetOutput",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDuration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalGenerator_Parameters_StepValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalGenerator_Parameters_StepValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDuration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalGenerator_Parameters_StepValidationError{
				field:  "Duration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SignalGenerator_Parameters_StepMultiError(errors)
	}

	return nil
}

// SignalGenerator_Parameters_StepMultiError is an error wrapping multiple
// validation errors returned by SignalGenerator_Parameters_Step.ValidateAll()
// if the designated constraints aren't met.
type SignalGenerator_Parameters_StepMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalGenerator_Parameters_StepMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalGenerator_Parameters_StepMultiError) AllErrors() []error { return m }

// SignalGenerator_Parameters_StepValidationError is the validation error
// returned by SignalGenerator_Parameters_Step.Validate if the designated
// constraints aren't met.
type SignalGenerator_Parameters_StepValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalGenerator_Parameters_StepValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalGenerator_Parameters_StepValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalGenerator_Parameters_StepValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalGenerator_Parameters_StepValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalGenerator_Parameters_StepValidationError) ErrorName() string {
	return "SignalGenerator_Parameters_StepValidationError"
}

// Error satisfies the builtin error interface
func (e SignalGenerator_Parameters_StepValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalGenerator_Parameters_Step.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalGenerator_Parameters_StepValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalGenerator_Parameters_StepValidationError{}
