// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: aperture/policy/language/v1/flowcontrol.proto

package languagev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	checkv1 "github.com/fluxninja/aperture/v2/api/gen/proto/go/aperture/flowcontrol/check/v1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = checkv1.StatusCode(0)
)

// Validate checks the field values on FlowControlResources with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FlowControlResources) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlowControlResources with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FlowControlResourcesMultiError, or nil if none found.
func (m *FlowControlResources) ValidateAll() error {
	return m.validate(true)
}

func (m *FlowControlResources) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetFluxMeters()))
		i := 0
		for key := range m.GetFluxMeters() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetFluxMeters()[key]
			_ = val

			// no validation rules for FluxMeters[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, FlowControlResourcesValidationError{
							field:  fmt.Sprintf("FluxMeters[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, FlowControlResourcesValidationError{
							field:  fmt.Sprintf("FluxMeters[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return FlowControlResourcesValidationError{
						field:  fmt.Sprintf("FluxMeters[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetClassifiers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlResourcesValidationError{
						field:  fmt.Sprintf("Classifiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlResourcesValidationError{
						field:  fmt.Sprintf("Classifiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlResourcesValidationError{
					field:  fmt.Sprintf("Classifiers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FlowControlResourcesMultiError(errors)
	}

	return nil
}

// FlowControlResourcesMultiError is an error wrapping multiple validation
// errors returned by FlowControlResources.ValidateAll() if the designated
// constraints aren't met.
type FlowControlResourcesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlowControlResourcesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlowControlResourcesMultiError) AllErrors() []error { return m }

// FlowControlResourcesValidationError is the validation error returned by
// FlowControlResources.Validate if the designated constraints aren't met.
type FlowControlResourcesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowControlResourcesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowControlResourcesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowControlResourcesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowControlResourcesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowControlResourcesValidationError) ErrorName() string {
	return "FlowControlResourcesValidationError"
}

// Error satisfies the builtin error interface
func (e FlowControlResourcesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlowControlResources.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowControlResourcesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowControlResourcesValidationError{}

// Validate checks the field values on FlowControl with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FlowControl) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlowControl with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FlowControlMultiError, or
// nil if none found.
func (m *FlowControl) ValidateAll() error {
	return m.validate(true)
}

func (m *FlowControl) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Component.(type) {
	case *FlowControl_QuotaScheduler:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetQuotaScheduler()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "QuotaScheduler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "QuotaScheduler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetQuotaScheduler()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "QuotaScheduler",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FlowControl_RateLimiter:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRateLimiter()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "RateLimiter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "RateLimiter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRateLimiter()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "RateLimiter",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FlowControl_LoadScheduler:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoadScheduler()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "LoadScheduler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "LoadScheduler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoadScheduler()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "LoadScheduler",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FlowControl_AdaptiveLoadScheduler:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAdaptiveLoadScheduler()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "AdaptiveLoadScheduler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "AdaptiveLoadScheduler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAdaptiveLoadScheduler()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "AdaptiveLoadScheduler",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FlowControl_Sampler:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSampler()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "Sampler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "Sampler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSampler()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "Sampler",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FlowControl_LoadRamp:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoadRamp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "LoadRamp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "LoadRamp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoadRamp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "LoadRamp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FlowControl_AimdLoadScheduler:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAimdLoadScheduler()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "AimdLoadScheduler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "AimdLoadScheduler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAimdLoadScheduler()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "AimdLoadScheduler",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FlowControl_RangeDrivenLoadScheduler:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRangeDrivenLoadScheduler()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "RangeDrivenLoadScheduler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "RangeDrivenLoadScheduler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRangeDrivenLoadScheduler()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "RangeDrivenLoadScheduler",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FlowControl_AiadLoadScheduler:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAiadLoadScheduler()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "AiadLoadScheduler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "AiadLoadScheduler",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAiadLoadScheduler()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "AiadLoadScheduler",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FlowControl_Private:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPrivate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "Private",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "Private",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPrivate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "Private",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return FlowControlMultiError(errors)
	}

	return nil
}

// FlowControlMultiError is an error wrapping multiple validation errors
// returned by FlowControl.ValidateAll() if the designated constraints aren't met.
type FlowControlMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlowControlMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlowControlMultiError) AllErrors() []error { return m }

// FlowControlValidationError is the validation error returned by
// FlowControl.Validate if the designated constraints aren't met.
type FlowControlValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowControlValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowControlValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowControlValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowControlValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowControlValidationError) ErrorName() string { return "FlowControlValidationError" }

// Error satisfies the builtin error interface
func (e FlowControlValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlowControl.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowControlValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowControlValidationError{}

// Validate checks the field values on QuotaScheduler with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QuotaScheduler) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QuotaScheduler with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QuotaSchedulerMultiError,
// or nil if none found.
func (m *QuotaScheduler) ValidateAll() error {
	return m.validate(true)
}

func (m *QuotaScheduler) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuotaSchedulerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuotaSchedulerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuotaSchedulerValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSelectors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QuotaSchedulerValidationError{
						field:  fmt.Sprintf("Selectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QuotaSchedulerValidationError{
						field:  fmt.Sprintf("Selectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QuotaSchedulerValidationError{
					field:  fmt.Sprintf("Selectors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRateLimiter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuotaSchedulerValidationError{
					field:  "RateLimiter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuotaSchedulerValidationError{
					field:  "RateLimiter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRateLimiter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuotaSchedulerValidationError{
				field:  "RateLimiter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScheduler()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuotaSchedulerValidationError{
					field:  "Scheduler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuotaSchedulerValidationError{
					field:  "Scheduler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScheduler()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuotaSchedulerValidationError{
				field:  "Scheduler",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuotaSchedulerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuotaSchedulerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuotaSchedulerValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QuotaSchedulerMultiError(errors)
	}

	return nil
}

// QuotaSchedulerMultiError is an error wrapping multiple validation errors
// returned by QuotaScheduler.ValidateAll() if the designated constraints
// aren't met.
type QuotaSchedulerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuotaSchedulerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuotaSchedulerMultiError) AllErrors() []error { return m }

// QuotaSchedulerValidationError is the validation error returned by
// QuotaScheduler.Validate if the designated constraints aren't met.
type QuotaSchedulerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuotaSchedulerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuotaSchedulerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuotaSchedulerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuotaSchedulerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuotaSchedulerValidationError) ErrorName() string { return "QuotaSchedulerValidationError" }

// Error satisfies the builtin error interface
func (e QuotaSchedulerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuotaScheduler.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuotaSchedulerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuotaSchedulerValidationError{}

// Validate checks the field values on RateLimiter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RateLimiter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimiter with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RateLimiterMultiError, or
// nil if none found.
func (m *RateLimiter) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimiter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiterValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiterValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSelectors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RateLimiterValidationError{
						field:  fmt.Sprintf("Selectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RateLimiterValidationError{
						field:  fmt.Sprintf("Selectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RateLimiterValidationError{
					field:  fmt.Sprintf("Selectors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRequestParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "RequestParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "RequestParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiterValidationError{
				field:  "RequestParameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiterValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RateLimiterMultiError(errors)
	}

	return nil
}

// RateLimiterMultiError is an error wrapping multiple validation errors
// returned by RateLimiter.ValidateAll() if the designated constraints aren't met.
type RateLimiterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimiterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimiterMultiError) AllErrors() []error { return m }

// RateLimiterValidationError is the validation error returned by
// RateLimiter.Validate if the designated constraints aren't met.
type RateLimiterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimiterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimiterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimiterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimiterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimiterValidationError) ErrorName() string { return "RateLimiterValidationError" }

// Error satisfies the builtin error interface
func (e RateLimiterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimiter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimiterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimiterValidationError{}

// Validate checks the field values on LoadScheduler with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoadScheduler) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadScheduler with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoadSchedulerMultiError, or
// nil if none found.
func (m *LoadScheduler) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadScheduler) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadSchedulerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadSchedulerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadSchedulerValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadSchedulerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadSchedulerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadSchedulerValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadSchedulerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadSchedulerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadSchedulerValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DryRun

	// no validation rules for DryRunConfigKey

	if len(errors) > 0 {
		return LoadSchedulerMultiError(errors)
	}

	return nil
}

// LoadSchedulerMultiError is an error wrapping multiple validation errors
// returned by LoadScheduler.ValidateAll() if the designated constraints
// aren't met.
type LoadSchedulerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadSchedulerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadSchedulerMultiError) AllErrors() []error { return m }

// LoadSchedulerValidationError is the validation error returned by
// LoadScheduler.Validate if the designated constraints aren't met.
type LoadSchedulerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadSchedulerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadSchedulerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadSchedulerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadSchedulerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadSchedulerValidationError) ErrorName() string { return "LoadSchedulerValidationError" }

// Error satisfies the builtin error interface
func (e LoadSchedulerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadScheduler.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadSchedulerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadSchedulerValidationError{}

// Validate checks the field values on Scheduler with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Scheduler) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Scheduler with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SchedulerMultiError, or nil
// if none found.
func (m *Scheduler) ValidateAll() error {
	return m.validate(true)
}

func (m *Scheduler) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWorkloads() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SchedulerValidationError{
						field:  fmt.Sprintf("Workloads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SchedulerValidationError{
						field:  fmt.Sprintf("Workloads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SchedulerValidationError{
					field:  fmt.Sprintf("Workloads[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetDefaultWorkloadParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchedulerValidationError{
					field:  "DefaultWorkloadParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchedulerValidationError{
					field:  "DefaultWorkloadParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultWorkloadParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchedulerValidationError{
				field:  "DefaultWorkloadParameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDecisionDeadlineMargin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchedulerValidationError{
					field:  "DecisionDeadlineMargin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchedulerValidationError{
					field:  "DecisionDeadlineMargin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDecisionDeadlineMargin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchedulerValidationError{
				field:  "DecisionDeadlineMargin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TokensLabelKey

	// no validation rules for PriorityLabelKey

	// no validation rules for DeniedResponseStatusCode

	if len(errors) > 0 {
		return SchedulerMultiError(errors)
	}

	return nil
}

// SchedulerMultiError is an error wrapping multiple validation errors returned
// by Scheduler.ValidateAll() if the designated constraints aren't met.
type SchedulerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SchedulerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SchedulerMultiError) AllErrors() []error { return m }

// SchedulerValidationError is the validation error returned by
// Scheduler.Validate if the designated constraints aren't met.
type SchedulerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SchedulerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SchedulerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SchedulerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SchedulerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SchedulerValidationError) ErrorName() string { return "SchedulerValidationError" }

// Error satisfies the builtin error interface
func (e SchedulerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduler.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SchedulerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SchedulerValidationError{}

// Validate checks the field values on AIMDLoadScheduler with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AIMDLoadScheduler) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AIMDLoadScheduler with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AIMDLoadSchedulerMultiError, or nil if none found.
func (m *AIMDLoadScheduler) ValidateAll() error {
	return m.validate(true)
}

func (m *AIMDLoadScheduler) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDLoadSchedulerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDLoadSchedulerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDLoadSchedulerValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDLoadSchedulerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDLoadSchedulerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDLoadSchedulerValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDLoadSchedulerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDLoadSchedulerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDLoadSchedulerValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DryRun

	// no validation rules for DryRunConfigKey

	if len(errors) > 0 {
		return AIMDLoadSchedulerMultiError(errors)
	}

	return nil
}

// AIMDLoadSchedulerMultiError is an error wrapping multiple validation errors
// returned by AIMDLoadScheduler.ValidateAll() if the designated constraints
// aren't met.
type AIMDLoadSchedulerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AIMDLoadSchedulerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AIMDLoadSchedulerMultiError) AllErrors() []error { return m }

// AIMDLoadSchedulerValidationError is the validation error returned by
// AIMDLoadScheduler.Validate if the designated constraints aren't met.
type AIMDLoadSchedulerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AIMDLoadSchedulerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AIMDLoadSchedulerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AIMDLoadSchedulerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AIMDLoadSchedulerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AIMDLoadSchedulerValidationError) ErrorName() string {
	return "AIMDLoadSchedulerValidationError"
}

// Error satisfies the builtin error interface
func (e AIMDLoadSchedulerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAIMDLoadScheduler.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AIMDLoadSchedulerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AIMDLoadSchedulerValidationError{}

// Validate checks the field values on RangeDrivenLoadScheduler with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RangeDrivenLoadScheduler) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RangeDrivenLoadScheduler with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RangeDrivenLoadSchedulerMultiError, or nil if none found.
func (m *RangeDrivenLoadScheduler) ValidateAll() error {
	return m.validate(true)
}

func (m *RangeDrivenLoadScheduler) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RangeDrivenLoadSchedulerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RangeDrivenLoadSchedulerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RangeDrivenLoadSchedulerValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RangeDrivenLoadSchedulerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RangeDrivenLoadSchedulerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RangeDrivenLoadSchedulerValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RangeDrivenLoadSchedulerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RangeDrivenLoadSchedulerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RangeDrivenLoadSchedulerValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DryRun

	// no validation rules for DryRunConfigKey

	if len(errors) > 0 {
		return RangeDrivenLoadSchedulerMultiError(errors)
	}

	return nil
}

// RangeDrivenLoadSchedulerMultiError is an error wrapping multiple validation
// errors returned by RangeDrivenLoadScheduler.ValidateAll() if the designated
// constraints aren't met.
type RangeDrivenLoadSchedulerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RangeDrivenLoadSchedulerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RangeDrivenLoadSchedulerMultiError) AllErrors() []error { return m }

// RangeDrivenLoadSchedulerValidationError is the validation error returned by
// RangeDrivenLoadScheduler.Validate if the designated constraints aren't met.
type RangeDrivenLoadSchedulerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RangeDrivenLoadSchedulerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RangeDrivenLoadSchedulerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RangeDrivenLoadSchedulerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RangeDrivenLoadSchedulerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RangeDrivenLoadSchedulerValidationError) ErrorName() string {
	return "RangeDrivenLoadSchedulerValidationError"
}

// Error satisfies the builtin error interface
func (e RangeDrivenLoadSchedulerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRangeDrivenLoadScheduler.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RangeDrivenLoadSchedulerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RangeDrivenLoadSchedulerValidationError{}

// Validate checks the field values on AIADLoadScheduler with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AIADLoadScheduler) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AIADLoadScheduler with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AIADLoadSchedulerMultiError, or nil if none found.
func (m *AIADLoadScheduler) ValidateAll() error {
	return m.validate(true)
}

func (m *AIADLoadScheduler) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIADLoadSchedulerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIADLoadSchedulerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIADLoadSchedulerValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIADLoadSchedulerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIADLoadSchedulerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIADLoadSchedulerValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIADLoadSchedulerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIADLoadSchedulerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIADLoadSchedulerValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DryRun

	// no validation rules for DryRunConfigKey

	// no validation rules for OverloadCondition

	if len(errors) > 0 {
		return AIADLoadSchedulerMultiError(errors)
	}

	return nil
}

// AIADLoadSchedulerMultiError is an error wrapping multiple validation errors
// returned by AIADLoadScheduler.ValidateAll() if the designated constraints
// aren't met.
type AIADLoadSchedulerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AIADLoadSchedulerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AIADLoadSchedulerMultiError) AllErrors() []error { return m }

// AIADLoadSchedulerValidationError is the validation error returned by
// AIADLoadScheduler.Validate if the designated constraints aren't met.
type AIADLoadSchedulerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AIADLoadSchedulerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AIADLoadSchedulerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AIADLoadSchedulerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AIADLoadSchedulerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AIADLoadSchedulerValidationError) ErrorName() string {
	return "AIADLoadSchedulerValidationError"
}

// Error satisfies the builtin error interface
func (e AIADLoadSchedulerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAIADLoadScheduler.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AIADLoadSchedulerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AIADLoadSchedulerValidationError{}

// Validate checks the field values on AdaptiveLoadScheduler with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdaptiveLoadScheduler) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdaptiveLoadScheduler with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AdaptiveLoadSchedulerMultiError, or nil if none found.
func (m *AdaptiveLoadScheduler) ValidateAll() error {
	return m.validate(true)
}

func (m *AdaptiveLoadScheduler) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdaptiveLoadSchedulerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdaptiveLoadSchedulerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdaptiveLoadSchedulerValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdaptiveLoadSchedulerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdaptiveLoadSchedulerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdaptiveLoadSchedulerValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdaptiveLoadSchedulerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdaptiveLoadSchedulerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdaptiveLoadSchedulerValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DryRun

	// no validation rules for DryRunConfigKey

	if len(errors) > 0 {
		return AdaptiveLoadSchedulerMultiError(errors)
	}

	return nil
}

// AdaptiveLoadSchedulerMultiError is an error wrapping multiple validation
// errors returned by AdaptiveLoadScheduler.ValidateAll() if the designated
// constraints aren't met.
type AdaptiveLoadSchedulerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdaptiveLoadSchedulerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdaptiveLoadSchedulerMultiError) AllErrors() []error { return m }

// AdaptiveLoadSchedulerValidationError is the validation error returned by
// AdaptiveLoadScheduler.Validate if the designated constraints aren't met.
type AdaptiveLoadSchedulerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdaptiveLoadSchedulerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdaptiveLoadSchedulerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdaptiveLoadSchedulerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdaptiveLoadSchedulerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdaptiveLoadSchedulerValidationError) ErrorName() string {
	return "AdaptiveLoadSchedulerValidationError"
}

// Error satisfies the builtin error interface
func (e AdaptiveLoadSchedulerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdaptiveLoadScheduler.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdaptiveLoadSchedulerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdaptiveLoadSchedulerValidationError{}

// Validate checks the field values on Sampler with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Sampler) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Sampler with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SamplerMultiError, or nil if none found.
func (m *Sampler) ValidateAll() error {
	return m.validate(true)
}

func (m *Sampler) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SamplerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SamplerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SamplerValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SamplerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SamplerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SamplerValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PassThroughLabelValuesConfigKey

	if len(errors) > 0 {
		return SamplerMultiError(errors)
	}

	return nil
}

// SamplerMultiError is an error wrapping multiple validation errors returned
// by Sampler.ValidateAll() if the designated constraints aren't met.
type SamplerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SamplerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SamplerMultiError) AllErrors() []error { return m }

// SamplerValidationError is the validation error returned by Sampler.Validate
// if the designated constraints aren't met.
type SamplerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SamplerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SamplerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SamplerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SamplerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SamplerValidationError) ErrorName() string { return "SamplerValidationError" }

// Error satisfies the builtin error interface
func (e SamplerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSampler.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SamplerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SamplerValidationError{}

// Validate checks the field values on LoadRamp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoadRamp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadRamp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoadRampMultiError, or nil
// if none found.
func (m *LoadRamp) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadRamp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadRampValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadRampValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadRampValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadRampValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadRampValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadRampValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadRampValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadRampValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadRampValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PassThroughLabelValuesConfigKey

	if len(errors) > 0 {
		return LoadRampMultiError(errors)
	}

	return nil
}

// LoadRampMultiError is an error wrapping multiple validation errors returned
// by LoadRamp.ValidateAll() if the designated constraints aren't met.
type LoadRampMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadRampMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadRampMultiError) AllErrors() []error { return m }

// LoadRampValidationError is the validation error returned by
// LoadRamp.Validate if the designated constraints aren't met.
type LoadRampValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadRampValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadRampValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadRampValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadRampValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadRampValidationError) ErrorName() string { return "LoadRampValidationError" }

// Error satisfies the builtin error interface
func (e LoadRampValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadRamp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadRampValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadRampValidationError{}

// Validate checks the field values on FluxMeter with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FluxMeter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FluxMeter with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FluxMeterMultiError, or nil
// if none found.
func (m *FluxMeter) ValidateAll() error {
	return m.validate(true)
}

func (m *FluxMeter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AttributeKey

	for idx, item := range m.GetSelectors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  fmt.Sprintf("Selectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  fmt.Sprintf("Selectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FluxMeterValidationError{
					field:  fmt.Sprintf("Selectors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.HistogramBuckets.(type) {
	case *FluxMeter_StaticBuckets_:
		if v == nil {
			err := FluxMeterValidationError{
				field:  "HistogramBuckets",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStaticBuckets()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "StaticBuckets",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "StaticBuckets",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStaticBuckets()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FluxMeterValidationError{
					field:  "StaticBuckets",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FluxMeter_LinearBuckets_:
		if v == nil {
			err := FluxMeterValidationError{
				field:  "HistogramBuckets",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLinearBuckets()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "LinearBuckets",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "LinearBuckets",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLinearBuckets()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FluxMeterValidationError{
					field:  "LinearBuckets",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FluxMeter_ExponentialBuckets_:
		if v == nil {
			err := FluxMeterValidationError{
				field:  "HistogramBuckets",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExponentialBuckets()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "ExponentialBuckets",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "ExponentialBuckets",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExponentialBuckets()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FluxMeterValidationError{
					field:  "ExponentialBuckets",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FluxMeter_ExponentialBucketsRange_:
		if v == nil {
			err := FluxMeterValidationError{
				field:  "HistogramBuckets",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExponentialBucketsRange()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "ExponentialBucketsRange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "ExponentialBucketsRange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExponentialBucketsRange()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FluxMeterValidationError{
					field:  "ExponentialBucketsRange",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return FluxMeterMultiError(errors)
	}

	return nil
}

// FluxMeterMultiError is an error wrapping multiple validation errors returned
// by FluxMeter.ValidateAll() if the designated constraints aren't met.
type FluxMeterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FluxMeterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FluxMeterMultiError) AllErrors() []error { return m }

// FluxMeterValidationError is the validation error returned by
// FluxMeter.Validate if the designated constraints aren't met.
type FluxMeterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FluxMeterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FluxMeterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FluxMeterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FluxMeterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FluxMeterValidationError) ErrorName() string { return "FluxMeterValidationError" }

// Error satisfies the builtin error interface
func (e FluxMeterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFluxMeter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FluxMeterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FluxMeterValidationError{}

// Validate checks the field values on Classifier with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Classifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Classifier with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClassifierMultiError, or
// nil if none found.
func (m *Classifier) ValidateAll() error {
	return m.validate(true)
}

func (m *Classifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetRules()))
		i := 0
		for key := range m.GetRules() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetRules()[key]
			_ = val

			// no validation rules for Rules[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ClassifierValidationError{
							field:  fmt.Sprintf("Rules[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ClassifierValidationError{
							field:  fmt.Sprintf("Rules[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ClassifierValidationError{
						field:  fmt.Sprintf("Rules[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetRego()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClassifierValidationError{
					field:  "Rego",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClassifierValidationError{
					field:  "Rego",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRego()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClassifierValidationError{
				field:  "Rego",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSelectors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClassifierValidationError{
						field:  fmt.Sprintf("Selectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClassifierValidationError{
						field:  fmt.Sprintf("Selectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClassifierValidationError{
					field:  fmt.Sprintf("Selectors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ClassifierMultiError(errors)
	}

	return nil
}

// ClassifierMultiError is an error wrapping multiple validation errors
// returned by Classifier.ValidateAll() if the designated constraints aren't met.
type ClassifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClassifierMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClassifierMultiError) AllErrors() []error { return m }

// ClassifierValidationError is the validation error returned by
// Classifier.Validate if the designated constraints aren't met.
type ClassifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClassifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClassifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClassifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClassifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClassifierValidationError) ErrorName() string { return "ClassifierValidationError" }

// Error satisfies the builtin error interface
func (e ClassifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClassifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClassifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClassifierValidationError{}

// Validate checks the field values on Rule with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Rule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Rule with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RuleMultiError, or nil if none found.
func (m *Rule) ValidateAll() error {
	return m.validate(true)
}

func (m *Rule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Telemetry

	switch v := m.Source.(type) {
	case *Rule_Extractor:
		if v == nil {
			err := RuleValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExtractor()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuleValidationError{
						field:  "Extractor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuleValidationError{
						field:  "Extractor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExtractor()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuleValidationError{
					field:  "Extractor",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RuleMultiError(errors)
	}

	return nil
}

// RuleMultiError is an error wrapping multiple validation errors returned by
// Rule.ValidateAll() if the designated constraints aren't met.
type RuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuleMultiError) AllErrors() []error { return m }

// RuleValidationError is the validation error returned by Rule.Validate if the
// designated constraints aren't met.
type RuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuleValidationError) ErrorName() string { return "RuleValidationError" }

// Error satisfies the builtin error interface
func (e RuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuleValidationError{}

// Validate checks the field values on Rego with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Rego) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Rego with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RegoMultiError, or nil if none found.
func (m *Rego) ValidateAll() error {
	return m.validate(true)
}

func (m *Rego) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetLabels()))
		i := 0
		for key := range m.GetLabels() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetLabels()[key]
			_ = val

			// no validation rules for Labels[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, RegoValidationError{
							field:  fmt.Sprintf("Labels[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, RegoValidationError{
							field:  fmt.Sprintf("Labels[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return RegoValidationError{
						field:  fmt.Sprintf("Labels[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Module

	if len(errors) > 0 {
		return RegoMultiError(errors)
	}

	return nil
}

// RegoMultiError is an error wrapping multiple validation errors returned by
// Rego.ValidateAll() if the designated constraints aren't met.
type RegoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegoMultiError) AllErrors() []error { return m }

// RegoValidationError is the validation error returned by Rego.Validate if the
// designated constraints aren't met.
type RegoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegoValidationError) ErrorName() string { return "RegoValidationError" }

// Error satisfies the builtin error interface
func (e RegoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRego.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegoValidationError{}

// Validate checks the field values on Extractor with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Extractor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Extractor with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExtractorMultiError, or nil
// if none found.
func (m *Extractor) ValidateAll() error {
	return m.validate(true)
}

func (m *Extractor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Variant.(type) {
	case *Extractor_From:
		if v == nil {
			err := ExtractorValidationError{
				field:  "Variant",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for From
	case *Extractor_Json:
		if v == nil {
			err := ExtractorValidationError{
				field:  "Variant",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetJson()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "Json",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "Json",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJson()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExtractorValidationError{
					field:  "Json",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Extractor_Address:
		if v == nil {
			err := ExtractorValidationError{
				field:  "Variant",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAddress()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "Address",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "Address",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAddress()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExtractorValidationError{
					field:  "Address",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Extractor_Jwt:
		if v == nil {
			err := ExtractorValidationError{
				field:  "Variant",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetJwt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJwt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExtractorValidationError{
					field:  "Jwt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Extractor_PathTemplates:
		if v == nil {
			err := ExtractorValidationError{
				field:  "Variant",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPathTemplates()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "PathTemplates",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "PathTemplates",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPathTemplates()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExtractorValidationError{
					field:  "PathTemplates",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ExtractorMultiError(errors)
	}

	return nil
}

// ExtractorMultiError is an error wrapping multiple validation errors returned
// by Extractor.ValidateAll() if the designated constraints aren't met.
type ExtractorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtractorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtractorMultiError) AllErrors() []error { return m }

// ExtractorValidationError is the validation error returned by
// Extractor.Validate if the designated constraints aren't met.
type ExtractorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtractorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtractorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtractorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtractorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtractorValidationError) ErrorName() string { return "ExtractorValidationError" }

// Error satisfies the builtin error interface
func (e ExtractorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtractor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtractorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtractorValidationError{}

// Validate checks the field values on JSONExtractor with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JSONExtractor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JSONExtractor with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JSONExtractorMultiError, or
// nil if none found.
func (m *JSONExtractor) ValidateAll() error {
	return m.validate(true)
}

func (m *JSONExtractor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	// no validation rules for Pointer

	if len(errors) > 0 {
		return JSONExtractorMultiError(errors)
	}

	return nil
}

// JSONExtractorMultiError is an error wrapping multiple validation errors
// returned by JSONExtractor.ValidateAll() if the designated constraints
// aren't met.
type JSONExtractorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JSONExtractorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JSONExtractorMultiError) AllErrors() []error { return m }

// JSONExtractorValidationError is the validation error returned by
// JSONExtractor.Validate if the designated constraints aren't met.
type JSONExtractorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JSONExtractorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JSONExtractorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JSONExtractorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JSONExtractorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JSONExtractorValidationError) ErrorName() string { return "JSONExtractorValidationError" }

// Error satisfies the builtin error interface
func (e JSONExtractorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJSONExtractor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JSONExtractorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JSONExtractorValidationError{}

// Validate checks the field values on AddressExtractor with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddressExtractor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddressExtractor with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddressExtractorMultiError, or nil if none found.
func (m *AddressExtractor) ValidateAll() error {
	return m.validate(true)
}

func (m *AddressExtractor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	if len(errors) > 0 {
		return AddressExtractorMultiError(errors)
	}

	return nil
}

// AddressExtractorMultiError is an error wrapping multiple validation errors
// returned by AddressExtractor.ValidateAll() if the designated constraints
// aren't met.
type AddressExtractorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressExtractorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressExtractorMultiError) AllErrors() []error { return m }

// AddressExtractorValidationError is the validation error returned by
// AddressExtractor.Validate if the designated constraints aren't met.
type AddressExtractorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressExtractorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressExtractorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressExtractorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressExtractorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressExtractorValidationError) ErrorName() string { return "AddressExtractorValidationError" }

// Error satisfies the builtin error interface
func (e AddressExtractorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddressExtractor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressExtractorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressExtractorValidationError{}

// Validate checks the field values on JWTExtractor with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JWTExtractor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JWTExtractor with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JWTExtractorMultiError, or
// nil if none found.
func (m *JWTExtractor) ValidateAll() error {
	return m.validate(true)
}

func (m *JWTExtractor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	// no validation rules for JsonPointer

	if len(errors) > 0 {
		return JWTExtractorMultiError(errors)
	}

	return nil
}

// JWTExtractorMultiError is an error wrapping multiple validation errors
// returned by JWTExtractor.ValidateAll() if the designated constraints aren't met.
type JWTExtractorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JWTExtractorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JWTExtractorMultiError) AllErrors() []error { return m }

// JWTExtractorValidationError is the validation error returned by
// JWTExtractor.Validate if the designated constraints aren't met.
type JWTExtractorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JWTExtractorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JWTExtractorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JWTExtractorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JWTExtractorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JWTExtractorValidationError) ErrorName() string { return "JWTExtractorValidationError" }

// Error satisfies the builtin error interface
func (e JWTExtractorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJWTExtractor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JWTExtractorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JWTExtractorValidationError{}

// Validate checks the field values on PathTemplateMatcher with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PathTemplateMatcher) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PathTemplateMatcher with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PathTemplateMatcherMultiError, or nil if none found.
func (m *PathTemplateMatcher) ValidateAll() error {
	return m.validate(true)
}

func (m *PathTemplateMatcher) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TemplateValues

	if len(errors) > 0 {
		return PathTemplateMatcherMultiError(errors)
	}

	return nil
}

// PathTemplateMatcherMultiError is an error wrapping multiple validation
// errors returned by PathTemplateMatcher.ValidateAll() if the designated
// constraints aren't met.
type PathTemplateMatcherMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PathTemplateMatcherMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PathTemplateMatcherMultiError) AllErrors() []error { return m }

// PathTemplateMatcherValidationError is the validation error returned by
// PathTemplateMatcher.Validate if the designated constraints aren't met.
type PathTemplateMatcherValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PathTemplateMatcherValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PathTemplateMatcherValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PathTemplateMatcherValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PathTemplateMatcherValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PathTemplateMatcherValidationError) ErrorName() string {
	return "PathTemplateMatcherValidationError"
}

// Error satisfies the builtin error interface
func (e PathTemplateMatcherValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPathTemplateMatcher.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PathTemplateMatcherValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PathTemplateMatcherValidationError{}

// Validate checks the field values on Selector with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Selector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Selector with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SelectorMultiError, or nil
// if none found.
func (m *Selector) ValidateAll() error {
	return m.validate(true)
}

func (m *Selector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ControlPoint

	// no validation rules for AgentGroup

	// no validation rules for Service

	if all {
		switch v := interface{}(m.GetLabelMatcher()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SelectorValidationError{
					field:  "LabelMatcher",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SelectorValidationError{
					field:  "LabelMatcher",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLabelMatcher()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SelectorValidationError{
				field:  "LabelMatcher",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SelectorMultiError(errors)
	}

	return nil
}

// SelectorMultiError is an error wrapping multiple validation errors returned
// by Selector.ValidateAll() if the designated constraints aren't met.
type SelectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SelectorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SelectorMultiError) AllErrors() []error { return m }

// SelectorValidationError is the validation error returned by
// Selector.Validate if the designated constraints aren't met.
type SelectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SelectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SelectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SelectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SelectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SelectorValidationError) ErrorName() string { return "SelectorValidationError" }

// Error satisfies the builtin error interface
func (e SelectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSelector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SelectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SelectorValidationError{}

// Validate checks the field values on QuotaScheduler_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QuotaScheduler_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QuotaScheduler_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QuotaScheduler_OutsMultiError, or nil if none found.
func (m *QuotaScheduler_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *QuotaScheduler_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAcceptPercentage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuotaScheduler_OutsValidationError{
					field:  "AcceptPercentage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuotaScheduler_OutsValidationError{
					field:  "AcceptPercentage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAcceptPercentage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuotaScheduler_OutsValidationError{
				field:  "AcceptPercentage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QuotaScheduler_OutsMultiError(errors)
	}

	return nil
}

// QuotaScheduler_OutsMultiError is an error wrapping multiple validation
// errors returned by QuotaScheduler_Outs.ValidateAll() if the designated
// constraints aren't met.
type QuotaScheduler_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuotaScheduler_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuotaScheduler_OutsMultiError) AllErrors() []error { return m }

// QuotaScheduler_OutsValidationError is the validation error returned by
// QuotaScheduler_Outs.Validate if the designated constraints aren't met.
type QuotaScheduler_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuotaScheduler_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuotaScheduler_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuotaScheduler_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuotaScheduler_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuotaScheduler_OutsValidationError) ErrorName() string {
	return "QuotaScheduler_OutsValidationError"
}

// Error satisfies the builtin error interface
func (e QuotaScheduler_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuotaScheduler_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuotaScheduler_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuotaScheduler_OutsValidationError{}

// Validate checks the field values on RateLimiter_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RateLimiter_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimiter_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RateLimiter_ParametersMultiError, or nil if none found.
func (m *RateLimiter_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimiter_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LabelKey

	if all {
		switch v := interface{}(m.GetInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiter_ParametersValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiter_ParametersValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiter_ParametersValidationError{
				field:  "Interval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ContinuousFill

	if all {
		switch v := interface{}(m.GetMaxIdleTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiter_ParametersValidationError{
					field:  "MaxIdleTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiter_ParametersValidationError{
					field:  "MaxIdleTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxIdleTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiter_ParametersValidationError{
				field:  "MaxIdleTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLazySync()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiter_ParametersValidationError{
					field:  "LazySync",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiter_ParametersValidationError{
					field:  "LazySync",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLazySync()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiter_ParametersValidationError{
				field:  "LazySync",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DelayInitialFill

	if len(errors) > 0 {
		return RateLimiter_ParametersMultiError(errors)
	}

	return nil
}

// RateLimiter_ParametersMultiError is an error wrapping multiple validation
// errors returned by RateLimiter_Parameters.ValidateAll() if the designated
// constraints aren't met.
type RateLimiter_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimiter_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimiter_ParametersMultiError) AllErrors() []error { return m }

// RateLimiter_ParametersValidationError is the validation error returned by
// RateLimiter_Parameters.Validate if the designated constraints aren't met.
type RateLimiter_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimiter_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimiter_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimiter_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimiter_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimiter_ParametersValidationError) ErrorName() string {
	return "RateLimiter_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e RateLimiter_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimiter_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimiter_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimiter_ParametersValidationError{}

// Validate checks the field values on RateLimiter_RequestParameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RateLimiter_RequestParameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimiter_RequestParameters with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// RateLimiter_RequestParametersMultiError, or nil if none found.
func (m *RateLimiter_RequestParameters) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimiter_RequestParameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TokensLabelKey

	// no validation rules for DeniedResponseStatusCode

	if len(errors) > 0 {
		return RateLimiter_RequestParametersMultiError(errors)
	}

	return nil
}

// RateLimiter_RequestParametersMultiError is an error wrapping multiple
// validation errors returned by RateLimiter_RequestParameters.ValidateAll()
// if the designated constraints aren't met.
type RateLimiter_RequestParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimiter_RequestParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimiter_RequestParametersMultiError) AllErrors() []error { return m }

// RateLimiter_RequestParametersValidationError is the validation error
// returned by RateLimiter_RequestParameters.Validate if the designated
// constraints aren't met.
type RateLimiter_RequestParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimiter_RequestParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimiter_RequestParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimiter_RequestParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimiter_RequestParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimiter_RequestParametersValidationError) ErrorName() string {
	return "RateLimiter_RequestParametersValidationError"
}

// Error satisfies the builtin error interface
func (e RateLimiter_RequestParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimiter_RequestParameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimiter_RequestParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimiter_RequestParametersValidationError{}

// Validate checks the field values on RateLimiter_Ins with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RateLimiter_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimiter_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RateLimiter_InsMultiError, or nil if none found.
func (m *RateLimiter_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimiter_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBucketCapacity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiter_InsValidationError{
					field:  "BucketCapacity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiter_InsValidationError{
					field:  "BucketCapacity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBucketCapacity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiter_InsValidationError{
				field:  "BucketCapacity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFillAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiter_InsValidationError{
					field:  "FillAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiter_InsValidationError{
					field:  "FillAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFillAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiter_InsValidationError{
				field:  "FillAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPassThrough()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiter_InsValidationError{
					field:  "PassThrough",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiter_InsValidationError{
					field:  "PassThrough",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPassThrough()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiter_InsValidationError{
				field:  "PassThrough",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RateLimiter_InsMultiError(errors)
	}

	return nil
}

// RateLimiter_InsMultiError is an error wrapping multiple validation errors
// returned by RateLimiter_Ins.ValidateAll() if the designated constraints
// aren't met.
type RateLimiter_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimiter_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimiter_InsMultiError) AllErrors() []error { return m }

// RateLimiter_InsValidationError is the validation error returned by
// RateLimiter_Ins.Validate if the designated constraints aren't met.
type RateLimiter_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimiter_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimiter_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimiter_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimiter_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimiter_InsValidationError) ErrorName() string { return "RateLimiter_InsValidationError" }

// Error satisfies the builtin error interface
func (e RateLimiter_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimiter_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimiter_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimiter_InsValidationError{}

// Validate checks the field values on RateLimiter_Outs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RateLimiter_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimiter_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RateLimiter_OutsMultiError, or nil if none found.
func (m *RateLimiter_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimiter_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAcceptPercentage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiter_OutsValidationError{
					field:  "AcceptPercentage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiter_OutsValidationError{
					field:  "AcceptPercentage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAcceptPercentage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiter_OutsValidationError{
				field:  "AcceptPercentage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RateLimiter_OutsMultiError(errors)
	}

	return nil
}

// RateLimiter_OutsMultiError is an error wrapping multiple validation errors
// returned by RateLimiter_Outs.ValidateAll() if the designated constraints
// aren't met.
type RateLimiter_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimiter_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimiter_OutsMultiError) AllErrors() []error { return m }

// RateLimiter_OutsValidationError is the validation error returned by
// RateLimiter_Outs.Validate if the designated constraints aren't met.
type RateLimiter_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimiter_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimiter_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimiter_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimiter_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimiter_OutsValidationError) ErrorName() string { return "RateLimiter_OutsValidationError" }

// Error satisfies the builtin error interface
func (e RateLimiter_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimiter_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimiter_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimiter_OutsValidationError{}

// Validate checks the field values on RateLimiter_Parameters_LazySync with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RateLimiter_Parameters_LazySync) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimiter_Parameters_LazySync with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// RateLimiter_Parameters_LazySyncMultiError, or nil if none found.
func (m *RateLimiter_Parameters_LazySync) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimiter_Parameters_LazySync) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	// no validation rules for NumSync

	if len(errors) > 0 {
		return RateLimiter_Parameters_LazySyncMultiError(errors)
	}

	return nil
}

// RateLimiter_Parameters_LazySyncMultiError is an error wrapping multiple
// validation errors returned by RateLimiter_Parameters_LazySync.ValidateAll()
// if the designated constraints aren't met.
type RateLimiter_Parameters_LazySyncMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimiter_Parameters_LazySyncMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimiter_Parameters_LazySyncMultiError) AllErrors() []error { return m }

// RateLimiter_Parameters_LazySyncValidationError is the validation error
// returned by RateLimiter_Parameters_LazySync.Validate if the designated
// constraints aren't met.
type RateLimiter_Parameters_LazySyncValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimiter_Parameters_LazySyncValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimiter_Parameters_LazySyncValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimiter_Parameters_LazySyncValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimiter_Parameters_LazySyncValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimiter_Parameters_LazySyncValidationError) ErrorName() string {
	return "RateLimiter_Parameters_LazySyncValidationError"
}

// Error satisfies the builtin error interface
func (e RateLimiter_Parameters_LazySyncValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimiter_Parameters_LazySync.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimiter_Parameters_LazySyncValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimiter_Parameters_LazySyncValidationError{}

// Validate checks the field values on LoadScheduler_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoadScheduler_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadScheduler_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoadScheduler_ParametersMultiError, or nil if none found.
func (m *LoadScheduler_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadScheduler_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WorkloadLatencyBasedTokens

	if all {
		switch v := interface{}(m.GetScheduler()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadScheduler_ParametersValidationError{
					field:  "Scheduler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadScheduler_ParametersValidationError{
					field:  "Scheduler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScheduler()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadScheduler_ParametersValidationError{
				field:  "Scheduler",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSelectors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoadScheduler_ParametersValidationError{
						field:  fmt.Sprintf("Selectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoadScheduler_ParametersValidationError{
						field:  fmt.Sprintf("Selectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoadScheduler_ParametersValidationError{
					field:  fmt.Sprintf("Selectors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LoadScheduler_ParametersMultiError(errors)
	}

	return nil
}

// LoadScheduler_ParametersMultiError is an error wrapping multiple validation
// errors returned by LoadScheduler_Parameters.ValidateAll() if the designated
// constraints aren't met.
type LoadScheduler_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadScheduler_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadScheduler_ParametersMultiError) AllErrors() []error { return m }

// LoadScheduler_ParametersValidationError is the validation error returned by
// LoadScheduler_Parameters.Validate if the designated constraints aren't met.
type LoadScheduler_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadScheduler_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadScheduler_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadScheduler_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadScheduler_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadScheduler_ParametersValidationError) ErrorName() string {
	return "LoadScheduler_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e LoadScheduler_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadScheduler_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadScheduler_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadScheduler_ParametersValidationError{}

// Validate checks the field values on LoadScheduler_Ins with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LoadScheduler_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadScheduler_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoadScheduler_InsMultiError, or nil if none found.
func (m *LoadScheduler_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadScheduler_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLoadMultiplier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadScheduler_InsValidationError{
					field:  "LoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadScheduler_InsValidationError{
					field:  "LoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLoadMultiplier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadScheduler_InsValidationError{
				field:  "LoadMultiplier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoadScheduler_InsMultiError(errors)
	}

	return nil
}

// LoadScheduler_InsMultiError is an error wrapping multiple validation errors
// returned by LoadScheduler_Ins.ValidateAll() if the designated constraints
// aren't met.
type LoadScheduler_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadScheduler_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadScheduler_InsMultiError) AllErrors() []error { return m }

// LoadScheduler_InsValidationError is the validation error returned by
// LoadScheduler_Ins.Validate if the designated constraints aren't met.
type LoadScheduler_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadScheduler_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadScheduler_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadScheduler_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadScheduler_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadScheduler_InsValidationError) ErrorName() string {
	return "LoadScheduler_InsValidationError"
}

// Error satisfies the builtin error interface
func (e LoadScheduler_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadScheduler_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadScheduler_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadScheduler_InsValidationError{}

// Validate checks the field values on LoadScheduler_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoadScheduler_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadScheduler_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoadScheduler_OutsMultiError, or nil if none found.
func (m *LoadScheduler_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadScheduler_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetObservedLoadMultiplier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadScheduler_OutsValidationError{
					field:  "ObservedLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadScheduler_OutsValidationError{
					field:  "ObservedLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObservedLoadMultiplier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadScheduler_OutsValidationError{
				field:  "ObservedLoadMultiplier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoadScheduler_OutsMultiError(errors)
	}

	return nil
}

// LoadScheduler_OutsMultiError is an error wrapping multiple validation errors
// returned by LoadScheduler_Outs.ValidateAll() if the designated constraints
// aren't met.
type LoadScheduler_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadScheduler_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadScheduler_OutsMultiError) AllErrors() []error { return m }

// LoadScheduler_OutsValidationError is the validation error returned by
// LoadScheduler_Outs.Validate if the designated constraints aren't met.
type LoadScheduler_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadScheduler_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadScheduler_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadScheduler_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadScheduler_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadScheduler_OutsValidationError) ErrorName() string {
	return "LoadScheduler_OutsValidationError"
}

// Error satisfies the builtin error interface
func (e LoadScheduler_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadScheduler_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadScheduler_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadScheduler_OutsValidationError{}

// Validate checks the field values on Scheduler_Workload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Scheduler_Workload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Scheduler_Workload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Scheduler_WorkloadMultiError, or nil if none found.
func (m *Scheduler_Workload) ValidateAll() error {
	return m.validate(true)
}

func (m *Scheduler_Workload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Scheduler_WorkloadValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Scheduler_WorkloadValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Scheduler_WorkloadValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLabelMatcher()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Scheduler_WorkloadValidationError{
					field:  "LabelMatcher",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Scheduler_WorkloadValidationError{
					field:  "LabelMatcher",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLabelMatcher()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Scheduler_WorkloadValidationError{
				field:  "LabelMatcher",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	if len(errors) > 0 {
		return Scheduler_WorkloadMultiError(errors)
	}

	return nil
}

// Scheduler_WorkloadMultiError is an error wrapping multiple validation errors
// returned by Scheduler_Workload.ValidateAll() if the designated constraints
// aren't met.
type Scheduler_WorkloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Scheduler_WorkloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Scheduler_WorkloadMultiError) AllErrors() []error { return m }

// Scheduler_WorkloadValidationError is the validation error returned by
// Scheduler_Workload.Validate if the designated constraints aren't met.
type Scheduler_WorkloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Scheduler_WorkloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Scheduler_WorkloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Scheduler_WorkloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Scheduler_WorkloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Scheduler_WorkloadValidationError) ErrorName() string {
	return "Scheduler_WorkloadValidationError"
}

// Error satisfies the builtin error interface
func (e Scheduler_WorkloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduler_Workload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Scheduler_WorkloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Scheduler_WorkloadValidationError{}

// Validate checks the field values on Scheduler_Workload_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Scheduler_Workload_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Scheduler_Workload_Parameters with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Scheduler_Workload_ParametersMultiError, or nil if none found.
func (m *Scheduler_Workload_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *Scheduler_Workload_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Priority

	// no validation rules for Tokens

	if all {
		switch v := interface{}(m.GetQueueTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Scheduler_Workload_ParametersValidationError{
					field:  "QueueTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Scheduler_Workload_ParametersValidationError{
					field:  "QueueTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Scheduler_Workload_ParametersValidationError{
				field:  "QueueTimeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Scheduler_Workload_ParametersMultiError(errors)
	}

	return nil
}

// Scheduler_Workload_ParametersMultiError is an error wrapping multiple
// validation errors returned by Scheduler_Workload_Parameters.ValidateAll()
// if the designated constraints aren't met.
type Scheduler_Workload_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Scheduler_Workload_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Scheduler_Workload_ParametersMultiError) AllErrors() []error { return m }

// Scheduler_Workload_ParametersValidationError is the validation error
// returned by Scheduler_Workload_Parameters.Validate if the designated
// constraints aren't met.
type Scheduler_Workload_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Scheduler_Workload_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Scheduler_Workload_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Scheduler_Workload_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Scheduler_Workload_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Scheduler_Workload_ParametersValidationError) ErrorName() string {
	return "Scheduler_Workload_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e Scheduler_Workload_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduler_Workload_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Scheduler_Workload_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Scheduler_Workload_ParametersValidationError{}

// Validate checks the field values on AIMDLoadScheduler_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AIMDLoadScheduler_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AIMDLoadScheduler_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AIMDLoadScheduler_InsMultiError, or nil if none found.
func (m *AIMDLoadScheduler_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *AIMDLoadScheduler_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSignal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDLoadScheduler_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDLoadScheduler_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDLoadScheduler_InsValidationError{
				field:  "Signal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSetpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDLoadScheduler_InsValidationError{
					field:  "Setpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDLoadScheduler_InsValidationError{
					field:  "Setpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSetpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDLoadScheduler_InsValidationError{
				field:  "Setpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOverloadConfirmation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDLoadScheduler_InsValidationError{
					field:  "OverloadConfirmation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDLoadScheduler_InsValidationError{
					field:  "OverloadConfirmation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOverloadConfirmation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDLoadScheduler_InsValidationError{
				field:  "OverloadConfirmation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AIMDLoadScheduler_InsMultiError(errors)
	}

	return nil
}

// AIMDLoadScheduler_InsMultiError is an error wrapping multiple validation
// errors returned by AIMDLoadScheduler_Ins.ValidateAll() if the designated
// constraints aren't met.
type AIMDLoadScheduler_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AIMDLoadScheduler_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AIMDLoadScheduler_InsMultiError) AllErrors() []error { return m }

// AIMDLoadScheduler_InsValidationError is the validation error returned by
// AIMDLoadScheduler_Ins.Validate if the designated constraints aren't met.
type AIMDLoadScheduler_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AIMDLoadScheduler_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AIMDLoadScheduler_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AIMDLoadScheduler_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AIMDLoadScheduler_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AIMDLoadScheduler_InsValidationError) ErrorName() string {
	return "AIMDLoadScheduler_InsValidationError"
}

// Error satisfies the builtin error interface
func (e AIMDLoadScheduler_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAIMDLoadScheduler_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AIMDLoadScheduler_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AIMDLoadScheduler_InsValidationError{}

// Validate checks the field values on AIMDLoadScheduler_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AIMDLoadScheduler_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AIMDLoadScheduler_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AIMDLoadScheduler_OutsMultiError, or nil if none found.
func (m *AIMDLoadScheduler_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *AIMDLoadScheduler_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIsOverload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDLoadScheduler_OutsValidationError{
					field:  "IsOverload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDLoadScheduler_OutsValidationError{
					field:  "IsOverload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsOverload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDLoadScheduler_OutsValidationError{
				field:  "IsOverload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDesiredLoadMultiplier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDLoadScheduler_OutsValidationError{
					field:  "DesiredLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDLoadScheduler_OutsValidationError{
					field:  "DesiredLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDesiredLoadMultiplier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDLoadScheduler_OutsValidationError{
				field:  "DesiredLoadMultiplier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetObservedLoadMultiplier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDLoadScheduler_OutsValidationError{
					field:  "ObservedLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDLoadScheduler_OutsValidationError{
					field:  "ObservedLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObservedLoadMultiplier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDLoadScheduler_OutsValidationError{
				field:  "ObservedLoadMultiplier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AIMDLoadScheduler_OutsMultiError(errors)
	}

	return nil
}

// AIMDLoadScheduler_OutsMultiError is an error wrapping multiple validation
// errors returned by AIMDLoadScheduler_Outs.ValidateAll() if the designated
// constraints aren't met.
type AIMDLoadScheduler_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AIMDLoadScheduler_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AIMDLoadScheduler_OutsMultiError) AllErrors() []error { return m }

// AIMDLoadScheduler_OutsValidationError is the validation error returned by
// AIMDLoadScheduler_Outs.Validate if the designated constraints aren't met.
type AIMDLoadScheduler_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AIMDLoadScheduler_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AIMDLoadScheduler_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AIMDLoadScheduler_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AIMDLoadScheduler_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AIMDLoadScheduler_OutsValidationError) ErrorName() string {
	return "AIMDLoadScheduler_OutsValidationError"
}

// Error satisfies the builtin error interface
func (e AIMDLoadScheduler_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAIMDLoadScheduler_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AIMDLoadScheduler_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AIMDLoadScheduler_OutsValidationError{}

// Validate checks the field values on AIMDLoadScheduler_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AIMDLoadScheduler_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AIMDLoadScheduler_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AIMDLoadScheduler_ParametersMultiError, or nil if none found.
func (m *AIMDLoadScheduler_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *AIMDLoadScheduler_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLoadScheduler()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDLoadScheduler_ParametersValidationError{
					field:  "LoadScheduler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDLoadScheduler_ParametersValidationError{
					field:  "LoadScheduler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLoadScheduler()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDLoadScheduler_ParametersValidationError{
				field:  "LoadScheduler",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGradient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDLoadScheduler_ParametersValidationError{
					field:  "Gradient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDLoadScheduler_ParametersValidationError{
					field:  "Gradient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGradient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDLoadScheduler_ParametersValidationError{
				field:  "Gradient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MaxLoadMultiplier

	// no validation rules for LoadMultiplierLinearIncrement

	if all {
		switch v := interface{}(m.GetAlerter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDLoadScheduler_ParametersValidationError{
					field:  "Alerter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDLoadScheduler_ParametersValidationError{
					field:  "Alerter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAlerter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDLoadScheduler_ParametersValidationError{
				field:  "Alerter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AIMDLoadScheduler_ParametersMultiError(errors)
	}

	return nil
}

// AIMDLoadScheduler_ParametersMultiError is an error wrapping multiple
// validation errors returned by AIMDLoadScheduler_Parameters.ValidateAll() if
// the designated constraints aren't met.
type AIMDLoadScheduler_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AIMDLoadScheduler_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AIMDLoadScheduler_ParametersMultiError) AllErrors() []error { return m }

// AIMDLoadScheduler_ParametersValidationError is the validation error returned
// by AIMDLoadScheduler_Parameters.Validate if the designated constraints
// aren't met.
type AIMDLoadScheduler_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AIMDLoadScheduler_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AIMDLoadScheduler_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AIMDLoadScheduler_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AIMDLoadScheduler_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AIMDLoadScheduler_ParametersValidationError) ErrorName() string {
	return "AIMDLoadScheduler_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e AIMDLoadScheduler_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAIMDLoadScheduler_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AIMDLoadScheduler_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AIMDLoadScheduler_ParametersValidationError{}

// Validate checks the field values on RangeDrivenLoadScheduler_Ins with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RangeDrivenLoadScheduler_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RangeDrivenLoadScheduler_Ins with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RangeDrivenLoadScheduler_InsMultiError, or nil if none found.
func (m *RangeDrivenLoadScheduler_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *RangeDrivenLoadScheduler_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSignal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RangeDrivenLoadScheduler_InsValidationError{
				field:  "Signal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOverloadConfirmation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_InsValidationError{
					field:  "OverloadConfirmation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_InsValidationError{
					field:  "OverloadConfirmation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOverloadConfirmation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RangeDrivenLoadScheduler_InsValidationError{
				field:  "OverloadConfirmation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RangeDrivenLoadScheduler_InsMultiError(errors)
	}

	return nil
}

// RangeDrivenLoadScheduler_InsMultiError is an error wrapping multiple
// validation errors returned by RangeDrivenLoadScheduler_Ins.ValidateAll() if
// the designated constraints aren't met.
type RangeDrivenLoadScheduler_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RangeDrivenLoadScheduler_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RangeDrivenLoadScheduler_InsMultiError) AllErrors() []error { return m }

// RangeDrivenLoadScheduler_InsValidationError is the validation error returned
// by RangeDrivenLoadScheduler_Ins.Validate if the designated constraints
// aren't met.
type RangeDrivenLoadScheduler_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RangeDrivenLoadScheduler_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RangeDrivenLoadScheduler_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RangeDrivenLoadScheduler_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RangeDrivenLoadScheduler_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RangeDrivenLoadScheduler_InsValidationError) ErrorName() string {
	return "RangeDrivenLoadScheduler_InsValidationError"
}

// Error satisfies the builtin error interface
func (e RangeDrivenLoadScheduler_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRangeDrivenLoadScheduler_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RangeDrivenLoadScheduler_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RangeDrivenLoadScheduler_InsValidationError{}

// Validate checks the field values on RangeDrivenLoadScheduler_Outs with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RangeDrivenLoadScheduler_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RangeDrivenLoadScheduler_Outs with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// RangeDrivenLoadScheduler_OutsMultiError, or nil if none found.
func (m *RangeDrivenLoadScheduler_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *RangeDrivenLoadScheduler_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIsOverload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_OutsValidationError{
					field:  "IsOverload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_OutsValidationError{
					field:  "IsOverload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsOverload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RangeDrivenLoadScheduler_OutsValidationError{
				field:  "IsOverload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDesiredLoadMultiplier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_OutsValidationError{
					field:  "DesiredLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_OutsValidationError{
					field:  "DesiredLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDesiredLoadMultiplier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RangeDrivenLoadScheduler_OutsValidationError{
				field:  "DesiredLoadMultiplier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetObservedLoadMultiplier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_OutsValidationError{
					field:  "ObservedLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_OutsValidationError{
					field:  "ObservedLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObservedLoadMultiplier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RangeDrivenLoadScheduler_OutsValidationError{
				field:  "ObservedLoadMultiplier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RangeDrivenLoadScheduler_OutsMultiError(errors)
	}

	return nil
}

// RangeDrivenLoadScheduler_OutsMultiError is an error wrapping multiple
// validation errors returned by RangeDrivenLoadScheduler_Outs.ValidateAll()
// if the designated constraints aren't met.
type RangeDrivenLoadScheduler_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RangeDrivenLoadScheduler_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RangeDrivenLoadScheduler_OutsMultiError) AllErrors() []error { return m }

// RangeDrivenLoadScheduler_OutsValidationError is the validation error
// returned by RangeDrivenLoadScheduler_Outs.Validate if the designated
// constraints aren't met.
type RangeDrivenLoadScheduler_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RangeDrivenLoadScheduler_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RangeDrivenLoadScheduler_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RangeDrivenLoadScheduler_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RangeDrivenLoadScheduler_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RangeDrivenLoadScheduler_OutsValidationError) ErrorName() string {
	return "RangeDrivenLoadScheduler_OutsValidationError"
}

// Error satisfies the builtin error interface
func (e RangeDrivenLoadScheduler_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRangeDrivenLoadScheduler_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RangeDrivenLoadScheduler_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RangeDrivenLoadScheduler_OutsValidationError{}

// Validate checks the field values on RangeDrivenLoadScheduler_Datapoint with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *RangeDrivenLoadScheduler_Datapoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RangeDrivenLoadScheduler_Datapoint
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// RangeDrivenLoadScheduler_DatapointMultiError, or nil if none found.
func (m *RangeDrivenLoadScheduler_Datapoint) ValidateAll() error {
	return m.validate(true)
}

func (m *RangeDrivenLoadScheduler_Datapoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SignalValue

	// no validation rules for LoadMultiplier

	if len(errors) > 0 {
		return RangeDrivenLoadScheduler_DatapointMultiError(errors)
	}

	return nil
}

// RangeDrivenLoadScheduler_DatapointMultiError is an error wrapping multiple
// validation errors returned by
// RangeDrivenLoadScheduler_Datapoint.ValidateAll() if the designated
// constraints aren't met.
type RangeDrivenLoadScheduler_DatapointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RangeDrivenLoadScheduler_DatapointMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RangeDrivenLoadScheduler_DatapointMultiError) AllErrors() []error { return m }

// RangeDrivenLoadScheduler_DatapointValidationError is the validation error
// returned by RangeDrivenLoadScheduler_Datapoint.Validate if the designated
// constraints aren't met.
type RangeDrivenLoadScheduler_DatapointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RangeDrivenLoadScheduler_DatapointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RangeDrivenLoadScheduler_DatapointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RangeDrivenLoadScheduler_DatapointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RangeDrivenLoadScheduler_DatapointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RangeDrivenLoadScheduler_DatapointValidationError) ErrorName() string {
	return "RangeDrivenLoadScheduler_DatapointValidationError"
}

// Error satisfies the builtin error interface
func (e RangeDrivenLoadScheduler_DatapointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRangeDrivenLoadScheduler_Datapoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RangeDrivenLoadScheduler_DatapointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RangeDrivenLoadScheduler_DatapointValidationError{}

// Validate checks the field values on RangeDrivenLoadScheduler_Parameters with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *RangeDrivenLoadScheduler_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RangeDrivenLoadScheduler_Parameters
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// RangeDrivenLoadScheduler_ParametersMultiError, or nil if none found.
func (m *RangeDrivenLoadScheduler_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *RangeDrivenLoadScheduler_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLoadScheduler()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_ParametersValidationError{
					field:  "LoadScheduler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_ParametersValidationError{
					field:  "LoadScheduler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLoadScheduler()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RangeDrivenLoadScheduler_ParametersValidationError{
				field:  "LoadScheduler",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLowThrottleThreshold()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_ParametersValidationError{
					field:  "LowThrottleThreshold",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_ParametersValidationError{
					field:  "LowThrottleThreshold",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLowThrottleThreshold()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RangeDrivenLoadScheduler_ParametersValidationError{
				field:  "LowThrottleThreshold",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetHighThrottleThreshold()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_ParametersValidationError{
					field:  "HighThrottleThreshold",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_ParametersValidationError{
					field:  "HighThrottleThreshold",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHighThrottleThreshold()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RangeDrivenLoadScheduler_ParametersValidationError{
				field:  "HighThrottleThreshold",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Degree

	if all {
		switch v := interface{}(m.GetAlerter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_ParametersValidationError{
					field:  "Alerter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RangeDrivenLoadScheduler_ParametersValidationError{
					field:  "Alerter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAlerter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RangeDrivenLoadScheduler_ParametersValidationError{
				field:  "Alerter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RangeDrivenLoadScheduler_ParametersMultiError(errors)
	}

	return nil
}

// RangeDrivenLoadScheduler_ParametersMultiError is an error wrapping multiple
// validation errors returned by
// RangeDrivenLoadScheduler_Parameters.ValidateAll() if the designated
// constraints aren't met.
type RangeDrivenLoadScheduler_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RangeDrivenLoadScheduler_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RangeDrivenLoadScheduler_ParametersMultiError) AllErrors() []error { return m }

// RangeDrivenLoadScheduler_ParametersValidationError is the validation error
// returned by RangeDrivenLoadScheduler_Parameters.Validate if the designated
// constraints aren't met.
type RangeDrivenLoadScheduler_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RangeDrivenLoadScheduler_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RangeDrivenLoadScheduler_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RangeDrivenLoadScheduler_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RangeDrivenLoadScheduler_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RangeDrivenLoadScheduler_ParametersValidationError) ErrorName() string {
	return "RangeDrivenLoadScheduler_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e RangeDrivenLoadScheduler_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRangeDrivenLoadScheduler_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RangeDrivenLoadScheduler_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RangeDrivenLoadScheduler_ParametersValidationError{}

// Validate checks the field values on AIADLoadScheduler_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AIADLoadScheduler_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AIADLoadScheduler_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AIADLoadScheduler_InsMultiError, or nil if none found.
func (m *AIADLoadScheduler_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *AIADLoadScheduler_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSignal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIADLoadScheduler_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIADLoadScheduler_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIADLoadScheduler_InsValidationError{
				field:  "Signal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSetpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIADLoadScheduler_InsValidationError{
					field:  "Setpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIADLoadScheduler_InsValidationError{
					field:  "Setpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSetpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIADLoadScheduler_InsValidationError{
				field:  "Setpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOverloadConfirmation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIADLoadScheduler_InsValidationError{
					field:  "OverloadConfirmation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIADLoadScheduler_InsValidationError{
					field:  "OverloadConfirmation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOverloadConfirmation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIADLoadScheduler_InsValidationError{
				field:  "OverloadConfirmation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AIADLoadScheduler_InsMultiError(errors)
	}

	return nil
}

// AIADLoadScheduler_InsMultiError is an error wrapping multiple validation
// errors returned by AIADLoadScheduler_Ins.ValidateAll() if the designated
// constraints aren't met.
type AIADLoadScheduler_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AIADLoadScheduler_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AIADLoadScheduler_InsMultiError) AllErrors() []error { return m }

// AIADLoadScheduler_InsValidationError is the validation error returned by
// AIADLoadScheduler_Ins.Validate if the designated constraints aren't met.
type AIADLoadScheduler_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AIADLoadScheduler_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AIADLoadScheduler_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AIADLoadScheduler_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AIADLoadScheduler_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AIADLoadScheduler_InsValidationError) ErrorName() string {
	return "AIADLoadScheduler_InsValidationError"
}

// Error satisfies the builtin error interface
func (e AIADLoadScheduler_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAIADLoadScheduler_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AIADLoadScheduler_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AIADLoadScheduler_InsValidationError{}

// Validate checks the field values on AIADLoadScheduler_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AIADLoadScheduler_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AIADLoadScheduler_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AIADLoadScheduler_OutsMultiError, or nil if none found.
func (m *AIADLoadScheduler_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *AIADLoadScheduler_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIsOverload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIADLoadScheduler_OutsValidationError{
					field:  "IsOverload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIADLoadScheduler_OutsValidationError{
					field:  "IsOverload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsOverload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIADLoadScheduler_OutsValidationError{
				field:  "IsOverload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDesiredLoadMultiplier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIADLoadScheduler_OutsValidationError{
					field:  "DesiredLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIADLoadScheduler_OutsValidationError{
					field:  "DesiredLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDesiredLoadMultiplier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIADLoadScheduler_OutsValidationError{
				field:  "DesiredLoadMultiplier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetObservedLoadMultiplier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIADLoadScheduler_OutsValidationError{
					field:  "ObservedLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIADLoadScheduler_OutsValidationError{
					field:  "ObservedLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObservedLoadMultiplier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIADLoadScheduler_OutsValidationError{
				field:  "ObservedLoadMultiplier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AIADLoadScheduler_OutsMultiError(errors)
	}

	return nil
}

// AIADLoadScheduler_OutsMultiError is an error wrapping multiple validation
// errors returned by AIADLoadScheduler_Outs.ValidateAll() if the designated
// constraints aren't met.
type AIADLoadScheduler_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AIADLoadScheduler_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AIADLoadScheduler_OutsMultiError) AllErrors() []error { return m }

// AIADLoadScheduler_OutsValidationError is the validation error returned by
// AIADLoadScheduler_Outs.Validate if the designated constraints aren't met.
type AIADLoadScheduler_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AIADLoadScheduler_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AIADLoadScheduler_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AIADLoadScheduler_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AIADLoadScheduler_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AIADLoadScheduler_OutsValidationError) ErrorName() string {
	return "AIADLoadScheduler_OutsValidationError"
}

// Error satisfies the builtin error interface
func (e AIADLoadScheduler_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAIADLoadScheduler_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AIADLoadScheduler_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AIADLoadScheduler_OutsValidationError{}

// Validate checks the field values on AIADLoadScheduler_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AIADLoadScheduler_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AIADLoadScheduler_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AIADLoadScheduler_ParametersMultiError, or nil if none found.
func (m *AIADLoadScheduler_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *AIADLoadScheduler_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLoadScheduler()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIADLoadScheduler_ParametersValidationError{
					field:  "LoadScheduler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIADLoadScheduler_ParametersValidationError{
					field:  "LoadScheduler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLoadScheduler()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIADLoadScheduler_ParametersValidationError{
				field:  "LoadScheduler",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MinLoadMultiplier

	// no validation rules for LoadMultiplierLinearDecrement

	// no validation rules for MaxLoadMultiplier

	// no validation rules for LoadMultiplierLinearIncrement

	if all {
		switch v := interface{}(m.GetAlerter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIADLoadScheduler_ParametersValidationError{
					field:  "Alerter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIADLoadScheduler_ParametersValidationError{
					field:  "Alerter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAlerter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIADLoadScheduler_ParametersValidationError{
				field:  "Alerter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AIADLoadScheduler_ParametersMultiError(errors)
	}

	return nil
}

// AIADLoadScheduler_ParametersMultiError is an error wrapping multiple
// validation errors returned by AIADLoadScheduler_Parameters.ValidateAll() if
// the designated constraints aren't met.
type AIADLoadScheduler_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AIADLoadScheduler_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AIADLoadScheduler_ParametersMultiError) AllErrors() []error { return m }

// AIADLoadScheduler_ParametersValidationError is the validation error returned
// by AIADLoadScheduler_Parameters.Validate if the designated constraints
// aren't met.
type AIADLoadScheduler_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AIADLoadScheduler_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AIADLoadScheduler_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AIADLoadScheduler_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AIADLoadScheduler_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AIADLoadScheduler_ParametersValidationError) ErrorName() string {
	return "AIADLoadScheduler_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e AIADLoadScheduler_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAIADLoadScheduler_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AIADLoadScheduler_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AIADLoadScheduler_ParametersValidationError{}

// Validate checks the field values on AdaptiveLoadScheduler_Parameters with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *AdaptiveLoadScheduler_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdaptiveLoadScheduler_Parameters with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// AdaptiveLoadScheduler_ParametersMultiError, or nil if none found.
func (m *AdaptiveLoadScheduler_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *AdaptiveLoadScheduler_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLoadScheduler()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_ParametersValidationError{
					field:  "LoadScheduler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_ParametersValidationError{
					field:  "LoadScheduler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLoadScheduler()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdaptiveLoadScheduler_ParametersValidationError{
				field:  "LoadScheduler",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGradient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_ParametersValidationError{
					field:  "Gradient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_ParametersValidationError{
					field:  "Gradient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGradient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdaptiveLoadScheduler_ParametersValidationError{
				field:  "Gradient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MaxLoadMultiplier

	// no validation rules for LoadMultiplierLinearIncrement

	if all {
		switch v := interface{}(m.GetAlerter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_ParametersValidationError{
					field:  "Alerter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_ParametersValidationError{
					field:  "Alerter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAlerter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdaptiveLoadScheduler_ParametersValidationError{
				field:  "Alerter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AdaptiveLoadScheduler_ParametersMultiError(errors)
	}

	return nil
}

// AdaptiveLoadScheduler_ParametersMultiError is an error wrapping multiple
// validation errors returned by
// AdaptiveLoadScheduler_Parameters.ValidateAll() if the designated
// constraints aren't met.
type AdaptiveLoadScheduler_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdaptiveLoadScheduler_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdaptiveLoadScheduler_ParametersMultiError) AllErrors() []error { return m }

// AdaptiveLoadScheduler_ParametersValidationError is the validation error
// returned by AdaptiveLoadScheduler_Parameters.Validate if the designated
// constraints aren't met.
type AdaptiveLoadScheduler_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdaptiveLoadScheduler_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdaptiveLoadScheduler_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdaptiveLoadScheduler_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdaptiveLoadScheduler_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdaptiveLoadScheduler_ParametersValidationError) ErrorName() string {
	return "AdaptiveLoadScheduler_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e AdaptiveLoadScheduler_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdaptiveLoadScheduler_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdaptiveLoadScheduler_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdaptiveLoadScheduler_ParametersValidationError{}

// Validate checks the field values on AdaptiveLoadScheduler_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdaptiveLoadScheduler_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdaptiveLoadScheduler_Ins with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AdaptiveLoadScheduler_InsMultiError, or nil if none found.
func (m *AdaptiveLoadScheduler_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *AdaptiveLoadScheduler_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSignal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdaptiveLoadScheduler_InsValidationError{
				field:  "Signal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSetpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_InsValidationError{
					field:  "Setpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_InsValidationError{
					field:  "Setpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSetpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdaptiveLoadScheduler_InsValidationError{
				field:  "Setpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOverloadConfirmation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_InsValidationError{
					field:  "OverloadConfirmation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_InsValidationError{
					field:  "OverloadConfirmation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOverloadConfirmation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdaptiveLoadScheduler_InsValidationError{
				field:  "OverloadConfirmation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AdaptiveLoadScheduler_InsMultiError(errors)
	}

	return nil
}

// AdaptiveLoadScheduler_InsMultiError is an error wrapping multiple validation
// errors returned by AdaptiveLoadScheduler_Ins.ValidateAll() if the
// designated constraints aren't met.
type AdaptiveLoadScheduler_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdaptiveLoadScheduler_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdaptiveLoadScheduler_InsMultiError) AllErrors() []error { return m }

// AdaptiveLoadScheduler_InsValidationError is the validation error returned by
// AdaptiveLoadScheduler_Ins.Validate if the designated constraints aren't met.
type AdaptiveLoadScheduler_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdaptiveLoadScheduler_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdaptiveLoadScheduler_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdaptiveLoadScheduler_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdaptiveLoadScheduler_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdaptiveLoadScheduler_InsValidationError) ErrorName() string {
	return "AdaptiveLoadScheduler_InsValidationError"
}

// Error satisfies the builtin error interface
func (e AdaptiveLoadScheduler_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdaptiveLoadScheduler_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdaptiveLoadScheduler_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdaptiveLoadScheduler_InsValidationError{}

// Validate checks the field values on AdaptiveLoadScheduler_Outs with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdaptiveLoadScheduler_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdaptiveLoadScheduler_Outs with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AdaptiveLoadScheduler_OutsMultiError, or nil if none found.
func (m *AdaptiveLoadScheduler_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *AdaptiveLoadScheduler_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIsOverload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_OutsValidationError{
					field:  "IsOverload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_OutsValidationError{
					field:  "IsOverload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsOverload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdaptiveLoadScheduler_OutsValidationError{
				field:  "IsOverload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDesiredLoadMultiplier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_OutsValidationError{
					field:  "DesiredLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_OutsValidationError{
					field:  "DesiredLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDesiredLoadMultiplier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdaptiveLoadScheduler_OutsValidationError{
				field:  "DesiredLoadMultiplier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetObservedLoadMultiplier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_OutsValidationError{
					field:  "ObservedLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdaptiveLoadScheduler_OutsValidationError{
					field:  "ObservedLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObservedLoadMultiplier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdaptiveLoadScheduler_OutsValidationError{
				field:  "ObservedLoadMultiplier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AdaptiveLoadScheduler_OutsMultiError(errors)
	}

	return nil
}

// AdaptiveLoadScheduler_OutsMultiError is an error wrapping multiple
// validation errors returned by AdaptiveLoadScheduler_Outs.ValidateAll() if
// the designated constraints aren't met.
type AdaptiveLoadScheduler_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdaptiveLoadScheduler_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdaptiveLoadScheduler_OutsMultiError) AllErrors() []error { return m }

// AdaptiveLoadScheduler_OutsValidationError is the validation error returned
// by AdaptiveLoadScheduler_Outs.Validate if the designated constraints aren't met.
type AdaptiveLoadScheduler_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdaptiveLoadScheduler_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdaptiveLoadScheduler_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdaptiveLoadScheduler_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdaptiveLoadScheduler_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdaptiveLoadScheduler_OutsValidationError) ErrorName() string {
	return "AdaptiveLoadScheduler_OutsValidationError"
}

// Error satisfies the builtin error interface
func (e AdaptiveLoadScheduler_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdaptiveLoadScheduler_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdaptiveLoadScheduler_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdaptiveLoadScheduler_OutsValidationError{}

// Validate checks the field values on Sampler_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Sampler_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Sampler_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Sampler_ParametersMultiError, or nil if none found.
func (m *Sampler_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *Sampler_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LabelKey

	for idx, item := range m.GetSelectors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Sampler_ParametersValidationError{
						field:  fmt.Sprintf("Selectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Sampler_ParametersValidationError{
						field:  fmt.Sprintf("Selectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Sampler_ParametersValidationError{
					field:  fmt.Sprintf("Selectors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DeniedResponseStatusCode

	// no validation rules for RampMode

	if len(errors) > 0 {
		return Sampler_ParametersMultiError(errors)
	}

	return nil
}

// Sampler_ParametersMultiError is an error wrapping multiple validation errors
// returned by Sampler_Parameters.ValidateAll() if the designated constraints
// aren't met.
type Sampler_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Sampler_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Sampler_ParametersMultiError) AllErrors() []error { return m }

// Sampler_ParametersValidationError is the validation error returned by
// Sampler_Parameters.Validate if the designated constraints aren't met.
type Sampler_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Sampler_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Sampler_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Sampler_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Sampler_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Sampler_ParametersValidationError) ErrorName() string {
	return "Sampler_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e Sampler_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSampler_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Sampler_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Sampler_ParametersValidationError{}

// Validate checks the field values on Sampler_Ins with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Sampler_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Sampler_Ins with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Sampler_InsMultiError, or
// nil if none found.
func (m *Sampler_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *Sampler_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAcceptPercentage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Sampler_InsValidationError{
					field:  "AcceptPercentage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Sampler_InsValidationError{
					field:  "AcceptPercentage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAcceptPercentage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Sampler_InsValidationError{
				field:  "AcceptPercentage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Sampler_InsMultiError(errors)
	}

	return nil
}

// Sampler_InsMultiError is an error wrapping multiple validation errors
// returned by Sampler_Ins.ValidateAll() if the designated constraints aren't met.
type Sampler_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Sampler_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Sampler_InsMultiError) AllErrors() []error { return m }

// Sampler_InsValidationError is the validation error returned by
// Sampler_Ins.Validate if the designated constraints aren't met.
type Sampler_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Sampler_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Sampler_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Sampler_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Sampler_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Sampler_InsValidationError) ErrorName() string { return "Sampler_InsValidationError" }

// Error satisfies the builtin error interface
func (e Sampler_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSampler_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Sampler_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Sampler_InsValidationError{}

// Validate checks the field values on LoadRamp_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoadRamp_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadRamp_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoadRamp_ParametersMultiError, or nil if none found.
func (m *LoadRamp_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadRamp_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSampler()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadRamp_ParametersValidationError{
					field:  "Sampler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadRamp_ParametersValidationError{
					field:  "Sampler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSampler()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadRamp_ParametersValidationError{
				field:  "Sampler",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSteps() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoadRamp_ParametersValidationError{
						field:  fmt.Sprintf("Steps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoadRamp_ParametersValidationError{
						field:  fmt.Sprintf("Steps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoadRamp_ParametersValidationError{
					field:  fmt.Sprintf("Steps[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LoadRamp_ParametersMultiError(errors)
	}

	return nil
}

// LoadRamp_ParametersMultiError is an error wrapping multiple validation
// errors returned by LoadRamp_Parameters.ValidateAll() if the designated
// constraints aren't met.
type LoadRamp_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadRamp_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadRamp_ParametersMultiError) AllErrors() []error { return m }

// LoadRamp_ParametersValidationError is the validation error returned by
// LoadRamp_Parameters.Validate if the designated constraints aren't met.
type LoadRamp_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadRamp_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadRamp_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadRamp_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadRamp_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadRamp_ParametersValidationError) ErrorName() string {
	return "LoadRamp_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e LoadRamp_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadRamp_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadRamp_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadRamp_ParametersValidationError{}

// Validate checks the field values on LoadRamp_Ins with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoadRamp_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadRamp_Ins with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoadRamp_InsMultiError, or
// nil if none found.
func (m *LoadRamp_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadRamp_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetForward()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadRamp_InsValidationError{
					field:  "Forward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadRamp_InsValidationError{
					field:  "Forward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetForward()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadRamp_InsValidationError{
				field:  "Forward",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBackward()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadRamp_InsValidationError{
					field:  "Backward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadRamp_InsValidationError{
					field:  "Backward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBackward()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadRamp_InsValidationError{
				field:  "Backward",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReset_()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadRamp_InsValidationError{
					field:  "Reset_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadRamp_InsValidationError{
					field:  "Reset_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReset_()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadRamp_InsValidationError{
				field:  "Reset_",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoadRamp_InsMultiError(errors)
	}

	return nil
}

// LoadRamp_InsMultiError is an error wrapping multiple validation errors
// returned by LoadRamp_Ins.ValidateAll() if the designated constraints aren't met.
type LoadRamp_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadRamp_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadRamp_InsMultiError) AllErrors() []error { return m }

// LoadRamp_InsValidationError is the validation error returned by
// LoadRamp_Ins.Validate if the designated constraints aren't met.
type LoadRamp_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadRamp_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadRamp_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadRamp_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadRamp_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadRamp_InsValidationError) ErrorName() string { return "LoadRamp_InsValidationError" }

// Error satisfies the builtin error interface
func (e LoadRamp_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadRamp_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadRamp_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadRamp_InsValidationError{}

// Validate checks the field values on LoadRamp_Outs with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoadRamp_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadRamp_Outs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoadRamp_OutsMultiError, or
// nil if none found.
func (m *LoadRamp_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadRamp_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAcceptPercentage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadRamp_OutsValidationError{
					field:  "AcceptPercentage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadRamp_OutsValidationError{
					field:  "AcceptPercentage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAcceptPercentage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadRamp_OutsValidationError{
				field:  "AcceptPercentage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAtStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadRamp_OutsValidationError{
					field:  "AtStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadRamp_OutsValidationError{
					field:  "AtStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAtStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadRamp_OutsValidationError{
				field:  "AtStart",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAtEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadRamp_OutsValidationError{
					field:  "AtEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadRamp_OutsValidationError{
					field:  "AtEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAtEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadRamp_OutsValidationError{
				field:  "AtEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoadRamp_OutsMultiError(errors)
	}

	return nil
}

// LoadRamp_OutsMultiError is an error wrapping multiple validation errors
// returned by LoadRamp_Outs.ValidateAll() if the designated constraints
// aren't met.
type LoadRamp_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadRamp_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadRamp_OutsMultiError) AllErrors() []error { return m }

// LoadRamp_OutsValidationError is the validation error returned by
// LoadRamp_Outs.Validate if the designated constraints aren't met.
type LoadRamp_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadRamp_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadRamp_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadRamp_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadRamp_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadRamp_OutsValidationError) ErrorName() string { return "LoadRamp_OutsValidationError" }

// Error satisfies the builtin error interface
func (e LoadRamp_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadRamp_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadRamp_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadRamp_OutsValidationError{}

// Validate checks the field values on LoadRamp_Parameters_Step with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoadRamp_Parameters_Step) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadRamp_Parameters_Step with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoadRamp_Parameters_StepMultiError, or nil if none found.
func (m *LoadRamp_Parameters_Step) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadRamp_Parameters_Step) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetAcceptPercentage

	if all {
		switch v := interface{}(m.GetDuration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadRamp_Parameters_StepValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadRamp_Parameters_StepValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDuration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadRamp_Parameters_StepValidationError{
				field:  "Duration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DeniedResponseStatusCode

	if len(errors) > 0 {
		return LoadRamp_Parameters_StepMultiError(errors)
	}

	return nil
}

// LoadRamp_Parameters_StepMultiError is an error wrapping multiple validation
// errors returned by LoadRamp_Parameters_Step.ValidateAll() if the designated
// constraints aren't met.
type LoadRamp_Parameters_StepMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadRamp_Parameters_StepMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadRamp_Parameters_StepMultiError) AllErrors() []error { return m }

// LoadRamp_Parameters_StepValidationError is the validation error returned by
// LoadRamp_Parameters_Step.Validate if the designated constraints aren't met.
type LoadRamp_Parameters_StepValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadRamp_Parameters_StepValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadRamp_Parameters_StepValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadRamp_Parameters_StepValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadRamp_Parameters_StepValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadRamp_Parameters_StepValidationError) ErrorName() string {
	return "LoadRamp_Parameters_StepValidationError"
}

// Error satisfies the builtin error interface
func (e LoadRamp_Parameters_StepValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadRamp_Parameters_Step.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadRamp_Parameters_StepValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadRamp_Parameters_StepValidationError{}

// Validate checks the field values on FluxMeter_StaticBuckets with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FluxMeter_StaticBuckets) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FluxMeter_StaticBuckets with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FluxMeter_StaticBucketsMultiError, or nil if none found.
func (m *FluxMeter_StaticBuckets) ValidateAll() error {
	return m.validate(true)
}

func (m *FluxMeter_StaticBuckets) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FluxMeter_StaticBucketsMultiError(errors)
	}

	return nil
}

// FluxMeter_StaticBucketsMultiError is an error wrapping multiple validation
// errors returned by FluxMeter_StaticBuckets.ValidateAll() if the designated
// constraints aren't met.
type FluxMeter_StaticBucketsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FluxMeter_StaticBucketsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FluxMeter_StaticBucketsMultiError) AllErrors() []error { return m }

// FluxMeter_StaticBucketsValidationError is the validation error returned by
// FluxMeter_StaticBuckets.Validate if the designated constraints aren't met.
type FluxMeter_StaticBucketsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FluxMeter_StaticBucketsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FluxMeter_StaticBucketsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FluxMeter_StaticBucketsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FluxMeter_StaticBucketsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FluxMeter_StaticBucketsValidationError) ErrorName() string {
	return "FluxMeter_StaticBucketsValidationError"
}

// Error satisfies the builtin error interface
func (e FluxMeter_StaticBucketsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFluxMeter_StaticBuckets.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FluxMeter_StaticBucketsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FluxMeter_StaticBucketsValidationError{}

// Validate checks the field values on FluxMeter_LinearBuckets with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FluxMeter_LinearBuckets) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FluxMeter_LinearBuckets with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FluxMeter_LinearBucketsMultiError, or nil if none found.
func (m *FluxMeter_LinearBuckets) ValidateAll() error {
	return m.validate(true)
}

func (m *FluxMeter_LinearBuckets) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for Width

	// no validation rules for Count

	if len(errors) > 0 {
		return FluxMeter_LinearBucketsMultiError(errors)
	}

	return nil
}

// FluxMeter_LinearBucketsMultiError is an error wrapping multiple validation
// errors returned by FluxMeter_LinearBuckets.ValidateAll() if the designated
// constraints aren't met.
type FluxMeter_LinearBucketsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FluxMeter_LinearBucketsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FluxMeter_LinearBucketsMultiError) AllErrors() []error { return m }

// FluxMeter_LinearBucketsValidationError is the validation error returned by
// FluxMeter_LinearBuckets.Validate if the designated constraints aren't met.
type FluxMeter_LinearBucketsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FluxMeter_LinearBucketsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FluxMeter_LinearBucketsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FluxMeter_LinearBucketsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FluxMeter_LinearBucketsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FluxMeter_LinearBucketsValidationError) ErrorName() string {
	return "FluxMeter_LinearBucketsValidationError"
}

// Error satisfies the builtin error interface
func (e FluxMeter_LinearBucketsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFluxMeter_LinearBuckets.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FluxMeter_LinearBucketsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FluxMeter_LinearBucketsValidationError{}

// Validate checks the field values on FluxMeter_ExponentialBuckets with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FluxMeter_ExponentialBuckets) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FluxMeter_ExponentialBuckets with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FluxMeter_ExponentialBucketsMultiError, or nil if none found.
func (m *FluxMeter_ExponentialBuckets) ValidateAll() error {
	return m.validate(true)
}

func (m *FluxMeter_ExponentialBuckets) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for Factor

	// no validation rules for Count

	if len(errors) > 0 {
		return FluxMeter_ExponentialBucketsMultiError(errors)
	}

	return nil
}

// FluxMeter_ExponentialBucketsMultiError is an error wrapping multiple
// validation errors returned by FluxMeter_ExponentialBuckets.ValidateAll() if
// the designated constraints aren't met.
type FluxMeter_ExponentialBucketsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FluxMeter_ExponentialBucketsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FluxMeter_ExponentialBucketsMultiError) AllErrors() []error { return m }

// FluxMeter_ExponentialBucketsValidationError is the validation error returned
// by FluxMeter_ExponentialBuckets.Validate if the designated constraints
// aren't met.
type FluxMeter_ExponentialBucketsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FluxMeter_ExponentialBucketsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FluxMeter_ExponentialBucketsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FluxMeter_ExponentialBucketsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FluxMeter_ExponentialBucketsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FluxMeter_ExponentialBucketsValidationError) ErrorName() string {
	return "FluxMeter_ExponentialBucketsValidationError"
}

// Error satisfies the builtin error interface
func (e FluxMeter_ExponentialBucketsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFluxMeter_ExponentialBuckets.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FluxMeter_ExponentialBucketsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FluxMeter_ExponentialBucketsValidationError{}

// Validate checks the field values on FluxMeter_ExponentialBucketsRange with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *FluxMeter_ExponentialBucketsRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FluxMeter_ExponentialBucketsRange
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// FluxMeter_ExponentialBucketsRangeMultiError, or nil if none found.
func (m *FluxMeter_ExponentialBucketsRange) ValidateAll() error {
	return m.validate(true)
}

func (m *FluxMeter_ExponentialBucketsRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	// no validation rules for Count

	if len(errors) > 0 {
		return FluxMeter_ExponentialBucketsRangeMultiError(errors)
	}

	return nil
}

// FluxMeter_ExponentialBucketsRangeMultiError is an error wrapping multiple
// validation errors returned by
// FluxMeter_ExponentialBucketsRange.ValidateAll() if the designated
// constraints aren't met.
type FluxMeter_ExponentialBucketsRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FluxMeter_ExponentialBucketsRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FluxMeter_ExponentialBucketsRangeMultiError) AllErrors() []error { return m }

// FluxMeter_ExponentialBucketsRangeValidationError is the validation error
// returned by FluxMeter_ExponentialBucketsRange.Validate if the designated
// constraints aren't met.
type FluxMeter_ExponentialBucketsRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FluxMeter_ExponentialBucketsRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FluxMeter_ExponentialBucketsRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FluxMeter_ExponentialBucketsRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FluxMeter_ExponentialBucketsRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FluxMeter_ExponentialBucketsRangeValidationError) ErrorName() string {
	return "FluxMeter_ExponentialBucketsRangeValidationError"
}

// Error satisfies the builtin error interface
func (e FluxMeter_ExponentialBucketsRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFluxMeter_ExponentialBucketsRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FluxMeter_ExponentialBucketsRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FluxMeter_ExponentialBucketsRangeValidationError{}

// Validate checks the field values on Rego_LabelProperties with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Rego_LabelProperties) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Rego_LabelProperties with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Rego_LabelPropertiesMultiError, or nil if none found.
func (m *Rego_LabelProperties) ValidateAll() error {
	return m.validate(true)
}

func (m *Rego_LabelProperties) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Telemetry

	if len(errors) > 0 {
		return Rego_LabelPropertiesMultiError(errors)
	}

	return nil
}

// Rego_LabelPropertiesMultiError is an error wrapping multiple validation
// errors returned by Rego_LabelProperties.ValidateAll() if the designated
// constraints aren't met.
type Rego_LabelPropertiesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Rego_LabelPropertiesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Rego_LabelPropertiesMultiError) AllErrors() []error { return m }

// Rego_LabelPropertiesValidationError is the validation error returned by
// Rego_LabelProperties.Validate if the designated constraints aren't met.
type Rego_LabelPropertiesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Rego_LabelPropertiesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Rego_LabelPropertiesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Rego_LabelPropertiesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Rego_LabelPropertiesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Rego_LabelPropertiesValidationError) ErrorName() string {
	return "Rego_LabelPropertiesValidationError"
}

// Error satisfies the builtin error interface
func (e Rego_LabelPropertiesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRego_LabelProperties.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Rego_LabelPropertiesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Rego_LabelPropertiesValidationError{}
