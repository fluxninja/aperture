// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: aperture/policy/language/v1/flowcontrol.proto

package languagev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on FlowSelector with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FlowSelector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlowSelector with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FlowSelectorMultiError, or
// nil if none found.
func (m *FlowSelector) ValidateAll() error {
	return m.validate(true)
}

func (m *FlowSelector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetServiceSelector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlowSelectorValidationError{
					field:  "ServiceSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlowSelectorValidationError{
					field:  "ServiceSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServiceSelector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowSelectorValidationError{
				field:  "ServiceSelector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFlowMatcher()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlowSelectorValidationError{
					field:  "FlowMatcher",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlowSelectorValidationError{
					field:  "FlowMatcher",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFlowMatcher()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowSelectorValidationError{
				field:  "FlowMatcher",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FlowSelectorMultiError(errors)
	}

	return nil
}

// FlowSelectorMultiError is an error wrapping multiple validation errors
// returned by FlowSelector.ValidateAll() if the designated constraints aren't met.
type FlowSelectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlowSelectorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlowSelectorMultiError) AllErrors() []error { return m }

// FlowSelectorValidationError is the validation error returned by
// FlowSelector.Validate if the designated constraints aren't met.
type FlowSelectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowSelectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowSelectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowSelectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowSelectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowSelectorValidationError) ErrorName() string { return "FlowSelectorValidationError" }

// Error satisfies the builtin error interface
func (e FlowSelectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlowSelector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowSelectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowSelectorValidationError{}

// Validate checks the field values on ServiceSelector with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ServiceSelector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceSelector with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceSelectorMultiError, or nil if none found.
func (m *ServiceSelector) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceSelector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AgentGroup

	// no validation rules for Service

	if len(errors) > 0 {
		return ServiceSelectorMultiError(errors)
	}

	return nil
}

// ServiceSelectorMultiError is an error wrapping multiple validation errors
// returned by ServiceSelector.ValidateAll() if the designated constraints
// aren't met.
type ServiceSelectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceSelectorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceSelectorMultiError) AllErrors() []error { return m }

// ServiceSelectorValidationError is the validation error returned by
// ServiceSelector.Validate if the designated constraints aren't met.
type ServiceSelectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceSelectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceSelectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceSelectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceSelectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceSelectorValidationError) ErrorName() string { return "ServiceSelectorValidationError" }

// Error satisfies the builtin error interface
func (e ServiceSelectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceSelector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceSelectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceSelectorValidationError{}

// Validate checks the field values on FlowMatcher with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FlowMatcher) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlowMatcher with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FlowMatcherMultiError, or
// nil if none found.
func (m *FlowMatcher) ValidateAll() error {
	return m.validate(true)
}

func (m *FlowMatcher) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ControlPoint

	if all {
		switch v := interface{}(m.GetLabelMatcher()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlowMatcherValidationError{
					field:  "LabelMatcher",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlowMatcherValidationError{
					field:  "LabelMatcher",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLabelMatcher()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowMatcherValidationError{
				field:  "LabelMatcher",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FlowMatcherMultiError(errors)
	}

	return nil
}

// FlowMatcherMultiError is an error wrapping multiple validation errors
// returned by FlowMatcher.ValidateAll() if the designated constraints aren't met.
type FlowMatcherMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlowMatcherMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlowMatcherMultiError) AllErrors() []error { return m }

// FlowMatcherValidationError is the validation error returned by
// FlowMatcher.Validate if the designated constraints aren't met.
type FlowMatcherValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowMatcherValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowMatcherValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowMatcherValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowMatcherValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowMatcherValidationError) ErrorName() string { return "FlowMatcherValidationError" }

// Error satisfies the builtin error interface
func (e FlowMatcherValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlowMatcher.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowMatcherValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowMatcherValidationError{}

// Validate checks the field values on FlowControlResources with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FlowControlResources) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlowControlResources with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FlowControlResourcesMultiError, or nil if none found.
func (m *FlowControlResources) ValidateAll() error {
	return m.validate(true)
}

func (m *FlowControlResources) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetFluxMeters()))
		i := 0
		for key := range m.GetFluxMeters() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetFluxMeters()[key]
			_ = val

			// no validation rules for FluxMeters[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, FlowControlResourcesValidationError{
							field:  fmt.Sprintf("FluxMeters[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, FlowControlResourcesValidationError{
							field:  fmt.Sprintf("FluxMeters[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return FlowControlResourcesValidationError{
						field:  fmt.Sprintf("FluxMeters[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetClassifiers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlResourcesValidationError{
						field:  fmt.Sprintf("Classifiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlResourcesValidationError{
						field:  fmt.Sprintf("Classifiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlResourcesValidationError{
					field:  fmt.Sprintf("Classifiers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FlowControlResourcesMultiError(errors)
	}

	return nil
}

// FlowControlResourcesMultiError is an error wrapping multiple validation
// errors returned by FlowControlResources.ValidateAll() if the designated
// constraints aren't met.
type FlowControlResourcesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlowControlResourcesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlowControlResourcesMultiError) AllErrors() []error { return m }

// FlowControlResourcesValidationError is the validation error returned by
// FlowControlResources.Validate if the designated constraints aren't met.
type FlowControlResourcesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowControlResourcesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowControlResourcesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowControlResourcesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowControlResourcesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowControlResourcesValidationError) ErrorName() string {
	return "FlowControlResourcesValidationError"
}

// Error satisfies the builtin error interface
func (e FlowControlResourcesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlowControlResources.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowControlResourcesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowControlResourcesValidationError{}

// Validate checks the field values on FluxMeter with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FluxMeter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FluxMeter with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FluxMeterMultiError, or nil
// if none found.
func (m *FluxMeter) ValidateAll() error {
	return m.validate(true)
}

func (m *FluxMeter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFlowSelector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FluxMeterValidationError{
					field:  "FlowSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FluxMeterValidationError{
					field:  "FlowSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFlowSelector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FluxMeterValidationError{
				field:  "FlowSelector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AttributeKey

	switch v := m.HistogramBuckets.(type) {
	case *FluxMeter_StaticBuckets_:
		if v == nil {
			err := FluxMeterValidationError{
				field:  "HistogramBuckets",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStaticBuckets()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "StaticBuckets",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "StaticBuckets",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStaticBuckets()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FluxMeterValidationError{
					field:  "StaticBuckets",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FluxMeter_LinearBuckets_:
		if v == nil {
			err := FluxMeterValidationError{
				field:  "HistogramBuckets",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLinearBuckets()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "LinearBuckets",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "LinearBuckets",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLinearBuckets()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FluxMeterValidationError{
					field:  "LinearBuckets",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FluxMeter_ExponentialBuckets_:
		if v == nil {
			err := FluxMeterValidationError{
				field:  "HistogramBuckets",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExponentialBuckets()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "ExponentialBuckets",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "ExponentialBuckets",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExponentialBuckets()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FluxMeterValidationError{
					field:  "ExponentialBuckets",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FluxMeter_ExponentialBucketsRange_:
		if v == nil {
			err := FluxMeterValidationError{
				field:  "HistogramBuckets",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExponentialBucketsRange()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "ExponentialBucketsRange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FluxMeterValidationError{
						field:  "ExponentialBucketsRange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExponentialBucketsRange()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FluxMeterValidationError{
					field:  "ExponentialBucketsRange",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return FluxMeterMultiError(errors)
	}

	return nil
}

// FluxMeterMultiError is an error wrapping multiple validation errors returned
// by FluxMeter.ValidateAll() if the designated constraints aren't met.
type FluxMeterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FluxMeterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FluxMeterMultiError) AllErrors() []error { return m }

// FluxMeterValidationError is the validation error returned by
// FluxMeter.Validate if the designated constraints aren't met.
type FluxMeterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FluxMeterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FluxMeterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FluxMeterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FluxMeterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FluxMeterValidationError) ErrorName() string { return "FluxMeterValidationError" }

// Error satisfies the builtin error interface
func (e FluxMeterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFluxMeter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FluxMeterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FluxMeterValidationError{}

// Validate checks the field values on Classifier with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Classifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Classifier with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClassifierMultiError, or
// nil if none found.
func (m *Classifier) ValidateAll() error {
	return m.validate(true)
}

func (m *Classifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFlowSelector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClassifierValidationError{
					field:  "FlowSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClassifierValidationError{
					field:  "FlowSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFlowSelector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClassifierValidationError{
				field:  "FlowSelector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetRules()))
		i := 0
		for key := range m.GetRules() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetRules()[key]
			_ = val

			// no validation rules for Rules[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ClassifierValidationError{
							field:  fmt.Sprintf("Rules[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ClassifierValidationError{
							field:  fmt.Sprintf("Rules[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ClassifierValidationError{
						field:  fmt.Sprintf("Rules[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetRego()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClassifierValidationError{
					field:  "Rego",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClassifierValidationError{
					field:  "Rego",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRego()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClassifierValidationError{
				field:  "Rego",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClassifierMultiError(errors)
	}

	return nil
}

// ClassifierMultiError is an error wrapping multiple validation errors
// returned by Classifier.ValidateAll() if the designated constraints aren't met.
type ClassifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClassifierMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClassifierMultiError) AllErrors() []error { return m }

// ClassifierValidationError is the validation error returned by
// Classifier.Validate if the designated constraints aren't met.
type ClassifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClassifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClassifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClassifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClassifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClassifierValidationError) ErrorName() string { return "ClassifierValidationError" }

// Error satisfies the builtin error interface
func (e ClassifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClassifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClassifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClassifierValidationError{}

// Validate checks the field values on Rule with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Rule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Rule with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RuleMultiError, or nil if none found.
func (m *Rule) ValidateAll() error {
	return m.validate(true)
}

func (m *Rule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Telemetry

	switch v := m.Source.(type) {
	case *Rule_Extractor:
		if v == nil {
			err := RuleValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExtractor()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuleValidationError{
						field:  "Extractor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuleValidationError{
						field:  "Extractor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExtractor()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuleValidationError{
					field:  "Extractor",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Rule_Rego_:
		if v == nil {
			err := RuleValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRego()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuleValidationError{
						field:  "Rego",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuleValidationError{
						field:  "Rego",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRego()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuleValidationError{
					field:  "Rego",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RuleMultiError(errors)
	}

	return nil
}

// RuleMultiError is an error wrapping multiple validation errors returned by
// Rule.ValidateAll() if the designated constraints aren't met.
type RuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuleMultiError) AllErrors() []error { return m }

// RuleValidationError is the validation error returned by Rule.Validate if the
// designated constraints aren't met.
type RuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuleValidationError) ErrorName() string { return "RuleValidationError" }

// Error satisfies the builtin error interface
func (e RuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuleValidationError{}

// Validate checks the field values on Rego with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Rego) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Rego with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RegoMultiError, or nil if none found.
func (m *Rego) ValidateAll() error {
	return m.validate(true)
}

func (m *Rego) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetLabels()))
		i := 0
		for key := range m.GetLabels() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetLabels()[key]
			_ = val

			// no validation rules for Labels[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, RegoValidationError{
							field:  fmt.Sprintf("Labels[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, RegoValidationError{
							field:  fmt.Sprintf("Labels[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return RegoValidationError{
						field:  fmt.Sprintf("Labels[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Module

	if len(errors) > 0 {
		return RegoMultiError(errors)
	}

	return nil
}

// RegoMultiError is an error wrapping multiple validation errors returned by
// Rego.ValidateAll() if the designated constraints aren't met.
type RegoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegoMultiError) AllErrors() []error { return m }

// RegoValidationError is the validation error returned by Rego.Validate if the
// designated constraints aren't met.
type RegoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegoValidationError) ErrorName() string { return "RegoValidationError" }

// Error satisfies the builtin error interface
func (e RegoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRego.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegoValidationError{}

// Validate checks the field values on Extractor with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Extractor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Extractor with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExtractorMultiError, or nil
// if none found.
func (m *Extractor) ValidateAll() error {
	return m.validate(true)
}

func (m *Extractor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Variant.(type) {
	case *Extractor_From:
		if v == nil {
			err := ExtractorValidationError{
				field:  "Variant",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for From
	case *Extractor_Json:
		if v == nil {
			err := ExtractorValidationError{
				field:  "Variant",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetJson()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "Json",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "Json",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJson()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExtractorValidationError{
					field:  "Json",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Extractor_Address:
		if v == nil {
			err := ExtractorValidationError{
				field:  "Variant",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAddress()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "Address",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "Address",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAddress()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExtractorValidationError{
					field:  "Address",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Extractor_Jwt:
		if v == nil {
			err := ExtractorValidationError{
				field:  "Variant",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetJwt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJwt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExtractorValidationError{
					field:  "Jwt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Extractor_PathTemplates:
		if v == nil {
			err := ExtractorValidationError{
				field:  "Variant",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPathTemplates()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "PathTemplates",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExtractorValidationError{
						field:  "PathTemplates",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPathTemplates()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExtractorValidationError{
					field:  "PathTemplates",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ExtractorMultiError(errors)
	}

	return nil
}

// ExtractorMultiError is an error wrapping multiple validation errors returned
// by Extractor.ValidateAll() if the designated constraints aren't met.
type ExtractorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtractorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtractorMultiError) AllErrors() []error { return m }

// ExtractorValidationError is the validation error returned by
// Extractor.Validate if the designated constraints aren't met.
type ExtractorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtractorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtractorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtractorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtractorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtractorValidationError) ErrorName() string { return "ExtractorValidationError" }

// Error satisfies the builtin error interface
func (e ExtractorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtractor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtractorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtractorValidationError{}

// Validate checks the field values on JSONExtractor with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JSONExtractor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JSONExtractor with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JSONExtractorMultiError, or
// nil if none found.
func (m *JSONExtractor) ValidateAll() error {
	return m.validate(true)
}

func (m *JSONExtractor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	// no validation rules for Pointer

	if len(errors) > 0 {
		return JSONExtractorMultiError(errors)
	}

	return nil
}

// JSONExtractorMultiError is an error wrapping multiple validation errors
// returned by JSONExtractor.ValidateAll() if the designated constraints
// aren't met.
type JSONExtractorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JSONExtractorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JSONExtractorMultiError) AllErrors() []error { return m }

// JSONExtractorValidationError is the validation error returned by
// JSONExtractor.Validate if the designated constraints aren't met.
type JSONExtractorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JSONExtractorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JSONExtractorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JSONExtractorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JSONExtractorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JSONExtractorValidationError) ErrorName() string { return "JSONExtractorValidationError" }

// Error satisfies the builtin error interface
func (e JSONExtractorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJSONExtractor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JSONExtractorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JSONExtractorValidationError{}

// Validate checks the field values on AddressExtractor with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddressExtractor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddressExtractor with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddressExtractorMultiError, or nil if none found.
func (m *AddressExtractor) ValidateAll() error {
	return m.validate(true)
}

func (m *AddressExtractor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	if len(errors) > 0 {
		return AddressExtractorMultiError(errors)
	}

	return nil
}

// AddressExtractorMultiError is an error wrapping multiple validation errors
// returned by AddressExtractor.ValidateAll() if the designated constraints
// aren't met.
type AddressExtractorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressExtractorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressExtractorMultiError) AllErrors() []error { return m }

// AddressExtractorValidationError is the validation error returned by
// AddressExtractor.Validate if the designated constraints aren't met.
type AddressExtractorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressExtractorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressExtractorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressExtractorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressExtractorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressExtractorValidationError) ErrorName() string { return "AddressExtractorValidationError" }

// Error satisfies the builtin error interface
func (e AddressExtractorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddressExtractor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressExtractorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressExtractorValidationError{}

// Validate checks the field values on JWTExtractor with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JWTExtractor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JWTExtractor with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JWTExtractorMultiError, or
// nil if none found.
func (m *JWTExtractor) ValidateAll() error {
	return m.validate(true)
}

func (m *JWTExtractor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	// no validation rules for JsonPointer

	if len(errors) > 0 {
		return JWTExtractorMultiError(errors)
	}

	return nil
}

// JWTExtractorMultiError is an error wrapping multiple validation errors
// returned by JWTExtractor.ValidateAll() if the designated constraints aren't met.
type JWTExtractorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JWTExtractorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JWTExtractorMultiError) AllErrors() []error { return m }

// JWTExtractorValidationError is the validation error returned by
// JWTExtractor.Validate if the designated constraints aren't met.
type JWTExtractorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JWTExtractorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JWTExtractorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JWTExtractorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JWTExtractorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JWTExtractorValidationError) ErrorName() string { return "JWTExtractorValidationError" }

// Error satisfies the builtin error interface
func (e JWTExtractorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJWTExtractor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JWTExtractorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JWTExtractorValidationError{}

// Validate checks the field values on PathTemplateMatcher with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PathTemplateMatcher) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PathTemplateMatcher with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PathTemplateMatcherMultiError, or nil if none found.
func (m *PathTemplateMatcher) ValidateAll() error {
	return m.validate(true)
}

func (m *PathTemplateMatcher) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TemplateValues

	if len(errors) > 0 {
		return PathTemplateMatcherMultiError(errors)
	}

	return nil
}

// PathTemplateMatcherMultiError is an error wrapping multiple validation
// errors returned by PathTemplateMatcher.ValidateAll() if the designated
// constraints aren't met.
type PathTemplateMatcherMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PathTemplateMatcherMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PathTemplateMatcherMultiError) AllErrors() []error { return m }

// PathTemplateMatcherValidationError is the validation error returned by
// PathTemplateMatcher.Validate if the designated constraints aren't met.
type PathTemplateMatcherValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PathTemplateMatcherValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PathTemplateMatcherValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PathTemplateMatcherValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PathTemplateMatcherValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PathTemplateMatcherValidationError) ErrorName() string {
	return "PathTemplateMatcherValidationError"
}

// Error satisfies the builtin error interface
func (e PathTemplateMatcherValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPathTemplateMatcher.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PathTemplateMatcherValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PathTemplateMatcherValidationError{}

// Validate checks the field values on FlowControl with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FlowControl) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlowControl with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FlowControlMultiError, or
// nil if none found.
func (m *FlowControl) ValidateAll() error {
	return m.validate(true)
}

func (m *FlowControl) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Component.(type) {
	case *FlowControl_RateLimiter:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRateLimiter()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "RateLimiter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "RateLimiter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRateLimiter()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "RateLimiter",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FlowControl_ConcurrencyLimiter:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConcurrencyLimiter()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "ConcurrencyLimiter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "ConcurrencyLimiter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConcurrencyLimiter()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "ConcurrencyLimiter",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FlowControl_AimdConcurrencyController:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAimdConcurrencyController()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "AimdConcurrencyController",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "AimdConcurrencyController",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAimdConcurrencyController()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "AimdConcurrencyController",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FlowControl_FlowRegulator:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFlowRegulator()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "FlowRegulator",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "FlowRegulator",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFlowRegulator()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "FlowRegulator",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FlowControl_LoadShaper:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoadShaper()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "LoadShaper",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "LoadShaper",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoadShaper()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "LoadShaper",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FlowControl_LoadShaperSeries:
		if v == nil {
			err := FlowControlValidationError{
				field:  "Component",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoadShaperSeries()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "LoadShaperSeries",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FlowControlValidationError{
						field:  "LoadShaperSeries",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoadShaperSeries()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowControlValidationError{
					field:  "LoadShaperSeries",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return FlowControlMultiError(errors)
	}

	return nil
}

// FlowControlMultiError is an error wrapping multiple validation errors
// returned by FlowControl.ValidateAll() if the designated constraints aren't met.
type FlowControlMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlowControlMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlowControlMultiError) AllErrors() []error { return m }

// FlowControlValidationError is the validation error returned by
// FlowControl.Validate if the designated constraints aren't met.
type FlowControlValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowControlValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowControlValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowControlValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowControlValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowControlValidationError) ErrorName() string { return "FlowControlValidationError" }

// Error satisfies the builtin error interface
func (e FlowControlValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlowControl.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowControlValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowControlValidationError{}

// Validate checks the field values on RateLimiter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RateLimiter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimiter with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RateLimiterMultiError, or
// nil if none found.
func (m *RateLimiter) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimiter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiterValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFlowSelector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "FlowSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "FlowSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFlowSelector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiterValidationError{
				field:  "FlowSelector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiterValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DynamicConfigKey

	if all {
		switch v := interface{}(m.GetDefaultConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "DefaultConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiterValidationError{
					field:  "DefaultConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiterValidationError{
				field:  "DefaultConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RateLimiterMultiError(errors)
	}

	return nil
}

// RateLimiterMultiError is an error wrapping multiple validation errors
// returned by RateLimiter.ValidateAll() if the designated constraints aren't met.
type RateLimiterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimiterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimiterMultiError) AllErrors() []error { return m }

// RateLimiterValidationError is the validation error returned by
// RateLimiter.Validate if the designated constraints aren't met.
type RateLimiterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimiterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimiterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimiterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimiterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimiterValidationError) ErrorName() string { return "RateLimiterValidationError" }

// Error satisfies the builtin error interface
func (e RateLimiterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimiter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimiterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimiterValidationError{}

// Validate checks the field values on ConcurrencyLimiter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConcurrencyLimiter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConcurrencyLimiter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConcurrencyLimiterMultiError, or nil if none found.
func (m *ConcurrencyLimiter) ValidateAll() error {
	return m.validate(true)
}

func (m *ConcurrencyLimiter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFlowSelector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConcurrencyLimiterValidationError{
					field:  "FlowSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConcurrencyLimiterValidationError{
					field:  "FlowSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFlowSelector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConcurrencyLimiterValidationError{
				field:  "FlowSelector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScheduler()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConcurrencyLimiterValidationError{
					field:  "Scheduler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConcurrencyLimiterValidationError{
					field:  "Scheduler",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScheduler()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConcurrencyLimiterValidationError{
				field:  "Scheduler",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.ActuationStrategy.(type) {
	case *ConcurrencyLimiter_LoadActuator:
		if v == nil {
			err := ConcurrencyLimiterValidationError{
				field:  "ActuationStrategy",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoadActuator()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConcurrencyLimiterValidationError{
						field:  "LoadActuator",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConcurrencyLimiterValidationError{
						field:  "LoadActuator",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoadActuator()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConcurrencyLimiterValidationError{
					field:  "LoadActuator",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ConcurrencyLimiterMultiError(errors)
	}

	return nil
}

// ConcurrencyLimiterMultiError is an error wrapping multiple validation errors
// returned by ConcurrencyLimiter.ValidateAll() if the designated constraints
// aren't met.
type ConcurrencyLimiterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConcurrencyLimiterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConcurrencyLimiterMultiError) AllErrors() []error { return m }

// ConcurrencyLimiterValidationError is the validation error returned by
// ConcurrencyLimiter.Validate if the designated constraints aren't met.
type ConcurrencyLimiterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConcurrencyLimiterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConcurrencyLimiterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConcurrencyLimiterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConcurrencyLimiterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConcurrencyLimiterValidationError) ErrorName() string {
	return "ConcurrencyLimiterValidationError"
}

// Error satisfies the builtin error interface
func (e ConcurrencyLimiterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConcurrencyLimiter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConcurrencyLimiterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConcurrencyLimiterValidationError{}

// Validate checks the field values on Scheduler with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Scheduler) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Scheduler with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SchedulerMultiError, or nil
// if none found.
func (m *Scheduler) ValidateAll() error {
	return m.validate(true)
}

func (m *Scheduler) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchedulerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchedulerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchedulerValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchedulerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchedulerValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchedulerValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SchedulerMultiError(errors)
	}

	return nil
}

// SchedulerMultiError is an error wrapping multiple validation errors returned
// by Scheduler.ValidateAll() if the designated constraints aren't met.
type SchedulerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SchedulerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SchedulerMultiError) AllErrors() []error { return m }

// SchedulerValidationError is the validation error returned by
// Scheduler.Validate if the designated constraints aren't met.
type SchedulerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SchedulerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SchedulerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SchedulerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SchedulerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SchedulerValidationError) ErrorName() string { return "SchedulerValidationError" }

// Error satisfies the builtin error interface
func (e SchedulerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduler.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SchedulerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SchedulerValidationError{}

// Validate checks the field values on LoadActuator with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoadActuator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadActuator with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoadActuatorMultiError, or
// nil if none found.
func (m *LoadActuator) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadActuator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadActuatorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadActuatorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadActuatorValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DynamicConfigKey

	if all {
		switch v := interface{}(m.GetDefaultConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadActuatorValidationError{
					field:  "DefaultConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadActuatorValidationError{
					field:  "DefaultConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadActuatorValidationError{
				field:  "DefaultConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoadActuatorMultiError(errors)
	}

	return nil
}

// LoadActuatorMultiError is an error wrapping multiple validation errors
// returned by LoadActuator.ValidateAll() if the designated constraints aren't met.
type LoadActuatorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadActuatorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadActuatorMultiError) AllErrors() []error { return m }

// LoadActuatorValidationError is the validation error returned by
// LoadActuator.Validate if the designated constraints aren't met.
type LoadActuatorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadActuatorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadActuatorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadActuatorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadActuatorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadActuatorValidationError) ErrorName() string { return "LoadActuatorValidationError" }

// Error satisfies the builtin error interface
func (e LoadActuatorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadActuator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadActuatorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadActuatorValidationError{}

// Validate checks the field values on AIMDConcurrencyController with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AIMDConcurrencyController) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AIMDConcurrencyController with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AIMDConcurrencyControllerMultiError, or nil if none found.
func (m *AIMDConcurrencyController) ValidateAll() error {
	return m.validate(true)
}

func (m *AIMDConcurrencyController) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDConcurrencyControllerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDConcurrencyControllerValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDConcurrencyControllerValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDConcurrencyControllerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDConcurrencyControllerValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDConcurrencyControllerValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFlowSelector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDConcurrencyControllerValidationError{
					field:  "FlowSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDConcurrencyControllerValidationError{
					field:  "FlowSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFlowSelector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDConcurrencyControllerValidationError{
				field:  "FlowSelector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSchedulerParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDConcurrencyControllerValidationError{
					field:  "SchedulerParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDConcurrencyControllerValidationError{
					field:  "SchedulerParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchedulerParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDConcurrencyControllerValidationError{
				field:  "SchedulerParameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGradientParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDConcurrencyControllerValidationError{
					field:  "GradientParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDConcurrencyControllerValidationError{
					field:  "GradientParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGradientParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDConcurrencyControllerValidationError{
				field:  "GradientParameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MaxLoadMultiplier

	// no validation rules for LoadMultiplierLinearIncrement

	if all {
		switch v := interface{}(m.GetAlerterParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDConcurrencyControllerValidationError{
					field:  "AlerterParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDConcurrencyControllerValidationError{
					field:  "AlerterParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAlerterParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDConcurrencyControllerValidationError{
				field:  "AlerterParameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DynamicConfigKey

	if all {
		switch v := interface{}(m.GetDefaultConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDConcurrencyControllerValidationError{
					field:  "DefaultConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDConcurrencyControllerValidationError{
					field:  "DefaultConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDConcurrencyControllerValidationError{
				field:  "DefaultConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AIMDConcurrencyControllerMultiError(errors)
	}

	return nil
}

// AIMDConcurrencyControllerMultiError is an error wrapping multiple validation
// errors returned by AIMDConcurrencyController.ValidateAll() if the
// designated constraints aren't met.
type AIMDConcurrencyControllerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AIMDConcurrencyControllerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AIMDConcurrencyControllerMultiError) AllErrors() []error { return m }

// AIMDConcurrencyControllerValidationError is the validation error returned by
// AIMDConcurrencyController.Validate if the designated constraints aren't met.
type AIMDConcurrencyControllerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AIMDConcurrencyControllerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AIMDConcurrencyControllerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AIMDConcurrencyControllerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AIMDConcurrencyControllerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AIMDConcurrencyControllerValidationError) ErrorName() string {
	return "AIMDConcurrencyControllerValidationError"
}

// Error satisfies the builtin error interface
func (e AIMDConcurrencyControllerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAIMDConcurrencyController.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AIMDConcurrencyControllerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AIMDConcurrencyControllerValidationError{}

// Validate checks the field values on FlowRegulator with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FlowRegulator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlowRegulator with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FlowRegulatorMultiError, or
// nil if none found.
func (m *FlowRegulator) ValidateAll() error {
	return m.validate(true)
}

func (m *FlowRegulator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlowRegulatorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlowRegulatorValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowRegulatorValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlowRegulatorValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlowRegulatorValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowRegulatorValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DynamicConfigKey

	if all {
		switch v := interface{}(m.GetDefaultConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlowRegulatorValidationError{
					field:  "DefaultConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlowRegulatorValidationError{
					field:  "DefaultConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowRegulatorValidationError{
				field:  "DefaultConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FlowRegulatorMultiError(errors)
	}

	return nil
}

// FlowRegulatorMultiError is an error wrapping multiple validation errors
// returned by FlowRegulator.ValidateAll() if the designated constraints
// aren't met.
type FlowRegulatorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlowRegulatorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlowRegulatorMultiError) AllErrors() []error { return m }

// FlowRegulatorValidationError is the validation error returned by
// FlowRegulator.Validate if the designated constraints aren't met.
type FlowRegulatorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowRegulatorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowRegulatorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowRegulatorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowRegulatorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowRegulatorValidationError) ErrorName() string { return "FlowRegulatorValidationError" }

// Error satisfies the builtin error interface
func (e FlowRegulatorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlowRegulator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowRegulatorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowRegulatorValidationError{}

// Validate checks the field values on LoadShaper with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoadShaper) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadShaper with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoadShaperMultiError, or
// nil if none found.
func (m *LoadShaper) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadShaper) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaperValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaperValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaperValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaperValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaperValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaperValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaperValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaperValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaperValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DynamicConfigKey

	if all {
		switch v := interface{}(m.GetDefaultConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaperValidationError{
					field:  "DefaultConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaperValidationError{
					field:  "DefaultConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaperValidationError{
				field:  "DefaultConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoadShaperMultiError(errors)
	}

	return nil
}

// LoadShaperMultiError is an error wrapping multiple validation errors
// returned by LoadShaper.ValidateAll() if the designated constraints aren't met.
type LoadShaperMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadShaperMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadShaperMultiError) AllErrors() []error { return m }

// LoadShaperValidationError is the validation error returned by
// LoadShaper.Validate if the designated constraints aren't met.
type LoadShaperValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadShaperValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadShaperValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadShaperValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadShaperValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadShaperValidationError) ErrorName() string { return "LoadShaperValidationError" }

// Error satisfies the builtin error interface
func (e LoadShaperValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadShaper.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadShaperValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadShaperValidationError{}

// Validate checks the field values on LoadShaperSeries with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LoadShaperSeries) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadShaperSeries with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoadShaperSeriesMultiError, or nil if none found.
func (m *LoadShaperSeries) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadShaperSeries) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaperSeriesValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaperSeriesValidationError{
					field:  "InPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaperSeriesValidationError{
				field:  "InPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaperSeriesValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaperSeriesValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaperSeriesValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoadShaperSeriesMultiError(errors)
	}

	return nil
}

// LoadShaperSeriesMultiError is an error wrapping multiple validation errors
// returned by LoadShaperSeries.ValidateAll() if the designated constraints
// aren't met.
type LoadShaperSeriesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadShaperSeriesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadShaperSeriesMultiError) AllErrors() []error { return m }

// LoadShaperSeriesValidationError is the validation error returned by
// LoadShaperSeries.Validate if the designated constraints aren't met.
type LoadShaperSeriesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadShaperSeriesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadShaperSeriesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadShaperSeriesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadShaperSeriesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadShaperSeriesValidationError) ErrorName() string { return "LoadShaperSeriesValidationError" }

// Error satisfies the builtin error interface
func (e LoadShaperSeriesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadShaperSeries.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadShaperSeriesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadShaperSeriesValidationError{}

// Validate checks the field values on FluxMeter_StaticBuckets with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FluxMeter_StaticBuckets) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FluxMeter_StaticBuckets with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FluxMeter_StaticBucketsMultiError, or nil if none found.
func (m *FluxMeter_StaticBuckets) ValidateAll() error {
	return m.validate(true)
}

func (m *FluxMeter_StaticBuckets) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FluxMeter_StaticBucketsMultiError(errors)
	}

	return nil
}

// FluxMeter_StaticBucketsMultiError is an error wrapping multiple validation
// errors returned by FluxMeter_StaticBuckets.ValidateAll() if the designated
// constraints aren't met.
type FluxMeter_StaticBucketsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FluxMeter_StaticBucketsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FluxMeter_StaticBucketsMultiError) AllErrors() []error { return m }

// FluxMeter_StaticBucketsValidationError is the validation error returned by
// FluxMeter_StaticBuckets.Validate if the designated constraints aren't met.
type FluxMeter_StaticBucketsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FluxMeter_StaticBucketsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FluxMeter_StaticBucketsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FluxMeter_StaticBucketsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FluxMeter_StaticBucketsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FluxMeter_StaticBucketsValidationError) ErrorName() string {
	return "FluxMeter_StaticBucketsValidationError"
}

// Error satisfies the builtin error interface
func (e FluxMeter_StaticBucketsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFluxMeter_StaticBuckets.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FluxMeter_StaticBucketsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FluxMeter_StaticBucketsValidationError{}

// Validate checks the field values on FluxMeter_LinearBuckets with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FluxMeter_LinearBuckets) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FluxMeter_LinearBuckets with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FluxMeter_LinearBucketsMultiError, or nil if none found.
func (m *FluxMeter_LinearBuckets) ValidateAll() error {
	return m.validate(true)
}

func (m *FluxMeter_LinearBuckets) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for Width

	// no validation rules for Count

	if len(errors) > 0 {
		return FluxMeter_LinearBucketsMultiError(errors)
	}

	return nil
}

// FluxMeter_LinearBucketsMultiError is an error wrapping multiple validation
// errors returned by FluxMeter_LinearBuckets.ValidateAll() if the designated
// constraints aren't met.
type FluxMeter_LinearBucketsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FluxMeter_LinearBucketsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FluxMeter_LinearBucketsMultiError) AllErrors() []error { return m }

// FluxMeter_LinearBucketsValidationError is the validation error returned by
// FluxMeter_LinearBuckets.Validate if the designated constraints aren't met.
type FluxMeter_LinearBucketsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FluxMeter_LinearBucketsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FluxMeter_LinearBucketsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FluxMeter_LinearBucketsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FluxMeter_LinearBucketsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FluxMeter_LinearBucketsValidationError) ErrorName() string {
	return "FluxMeter_LinearBucketsValidationError"
}

// Error satisfies the builtin error interface
func (e FluxMeter_LinearBucketsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFluxMeter_LinearBuckets.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FluxMeter_LinearBucketsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FluxMeter_LinearBucketsValidationError{}

// Validate checks the field values on FluxMeter_ExponentialBuckets with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FluxMeter_ExponentialBuckets) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FluxMeter_ExponentialBuckets with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FluxMeter_ExponentialBucketsMultiError, or nil if none found.
func (m *FluxMeter_ExponentialBuckets) ValidateAll() error {
	return m.validate(true)
}

func (m *FluxMeter_ExponentialBuckets) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for Factor

	// no validation rules for Count

	if len(errors) > 0 {
		return FluxMeter_ExponentialBucketsMultiError(errors)
	}

	return nil
}

// FluxMeter_ExponentialBucketsMultiError is an error wrapping multiple
// validation errors returned by FluxMeter_ExponentialBuckets.ValidateAll() if
// the designated constraints aren't met.
type FluxMeter_ExponentialBucketsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FluxMeter_ExponentialBucketsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FluxMeter_ExponentialBucketsMultiError) AllErrors() []error { return m }

// FluxMeter_ExponentialBucketsValidationError is the validation error returned
// by FluxMeter_ExponentialBuckets.Validate if the designated constraints
// aren't met.
type FluxMeter_ExponentialBucketsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FluxMeter_ExponentialBucketsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FluxMeter_ExponentialBucketsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FluxMeter_ExponentialBucketsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FluxMeter_ExponentialBucketsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FluxMeter_ExponentialBucketsValidationError) ErrorName() string {
	return "FluxMeter_ExponentialBucketsValidationError"
}

// Error satisfies the builtin error interface
func (e FluxMeter_ExponentialBucketsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFluxMeter_ExponentialBuckets.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FluxMeter_ExponentialBucketsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FluxMeter_ExponentialBucketsValidationError{}

// Validate checks the field values on FluxMeter_ExponentialBucketsRange with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *FluxMeter_ExponentialBucketsRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FluxMeter_ExponentialBucketsRange
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// FluxMeter_ExponentialBucketsRangeMultiError, or nil if none found.
func (m *FluxMeter_ExponentialBucketsRange) ValidateAll() error {
	return m.validate(true)
}

func (m *FluxMeter_ExponentialBucketsRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	// no validation rules for Count

	if len(errors) > 0 {
		return FluxMeter_ExponentialBucketsRangeMultiError(errors)
	}

	return nil
}

// FluxMeter_ExponentialBucketsRangeMultiError is an error wrapping multiple
// validation errors returned by
// FluxMeter_ExponentialBucketsRange.ValidateAll() if the designated
// constraints aren't met.
type FluxMeter_ExponentialBucketsRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FluxMeter_ExponentialBucketsRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FluxMeter_ExponentialBucketsRangeMultiError) AllErrors() []error { return m }

// FluxMeter_ExponentialBucketsRangeValidationError is the validation error
// returned by FluxMeter_ExponentialBucketsRange.Validate if the designated
// constraints aren't met.
type FluxMeter_ExponentialBucketsRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FluxMeter_ExponentialBucketsRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FluxMeter_ExponentialBucketsRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FluxMeter_ExponentialBucketsRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FluxMeter_ExponentialBucketsRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FluxMeter_ExponentialBucketsRangeValidationError) ErrorName() string {
	return "FluxMeter_ExponentialBucketsRangeValidationError"
}

// Error satisfies the builtin error interface
func (e FluxMeter_ExponentialBucketsRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFluxMeter_ExponentialBucketsRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FluxMeter_ExponentialBucketsRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FluxMeter_ExponentialBucketsRangeValidationError{}

// Validate checks the field values on Rule_Rego with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Rule_Rego) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Rule_Rego with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Rule_RegoMultiError, or nil
// if none found.
func (m *Rule_Rego) ValidateAll() error {
	return m.validate(true)
}

func (m *Rule_Rego) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Source

	// no validation rules for Query

	if len(errors) > 0 {
		return Rule_RegoMultiError(errors)
	}

	return nil
}

// Rule_RegoMultiError is an error wrapping multiple validation errors returned
// by Rule_Rego.ValidateAll() if the designated constraints aren't met.
type Rule_RegoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Rule_RegoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Rule_RegoMultiError) AllErrors() []error { return m }

// Rule_RegoValidationError is the validation error returned by
// Rule_Rego.Validate if the designated constraints aren't met.
type Rule_RegoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Rule_RegoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Rule_RegoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Rule_RegoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Rule_RegoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Rule_RegoValidationError) ErrorName() string { return "Rule_RegoValidationError" }

// Error satisfies the builtin error interface
func (e Rule_RegoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRule_Rego.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Rule_RegoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Rule_RegoValidationError{}

// Validate checks the field values on Rego_LabelProperties with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Rego_LabelProperties) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Rego_LabelProperties with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Rego_LabelPropertiesMultiError, or nil if none found.
func (m *Rego_LabelProperties) ValidateAll() error {
	return m.validate(true)
}

func (m *Rego_LabelProperties) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Telemetry

	if len(errors) > 0 {
		return Rego_LabelPropertiesMultiError(errors)
	}

	return nil
}

// Rego_LabelPropertiesMultiError is an error wrapping multiple validation
// errors returned by Rego_LabelProperties.ValidateAll() if the designated
// constraints aren't met.
type Rego_LabelPropertiesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Rego_LabelPropertiesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Rego_LabelPropertiesMultiError) AllErrors() []error { return m }

// Rego_LabelPropertiesValidationError is the validation error returned by
// Rego_LabelProperties.Validate if the designated constraints aren't met.
type Rego_LabelPropertiesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Rego_LabelPropertiesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Rego_LabelPropertiesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Rego_LabelPropertiesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Rego_LabelPropertiesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Rego_LabelPropertiesValidationError) ErrorName() string {
	return "Rego_LabelPropertiesValidationError"
}

// Error satisfies the builtin error interface
func (e Rego_LabelPropertiesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRego_LabelProperties.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Rego_LabelPropertiesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Rego_LabelPropertiesValidationError{}

// Validate checks the field values on RateLimiter_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RateLimiter_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimiter_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RateLimiter_ParametersMultiError, or nil if none found.
func (m *RateLimiter_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimiter_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLimitResetInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiter_ParametersValidationError{
					field:  "LimitResetInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiter_ParametersValidationError{
					field:  "LimitResetInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLimitResetInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiter_ParametersValidationError{
				field:  "LimitResetInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LabelKey

	if all {
		switch v := interface{}(m.GetLazySync()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiter_ParametersValidationError{
					field:  "LazySync",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiter_ParametersValidationError{
					field:  "LazySync",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLazySync()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiter_ParametersValidationError{
				field:  "LazySync",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RateLimiter_ParametersMultiError(errors)
	}

	return nil
}

// RateLimiter_ParametersMultiError is an error wrapping multiple validation
// errors returned by RateLimiter_Parameters.ValidateAll() if the designated
// constraints aren't met.
type RateLimiter_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimiter_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimiter_ParametersMultiError) AllErrors() []error { return m }

// RateLimiter_ParametersValidationError is the validation error returned by
// RateLimiter_Parameters.Validate if the designated constraints aren't met.
type RateLimiter_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimiter_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimiter_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimiter_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimiter_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimiter_ParametersValidationError) ErrorName() string {
	return "RateLimiter_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e RateLimiter_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimiter_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimiter_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimiter_ParametersValidationError{}

// Validate checks the field values on RateLimiter_Override with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RateLimiter_Override) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimiter_Override with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RateLimiter_OverrideMultiError, or nil if none found.
func (m *RateLimiter_Override) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimiter_Override) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LabelValue

	// no validation rules for LimitScaleFactor

	if len(errors) > 0 {
		return RateLimiter_OverrideMultiError(errors)
	}

	return nil
}

// RateLimiter_OverrideMultiError is an error wrapping multiple validation
// errors returned by RateLimiter_Override.ValidateAll() if the designated
// constraints aren't met.
type RateLimiter_OverrideMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimiter_OverrideMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimiter_OverrideMultiError) AllErrors() []error { return m }

// RateLimiter_OverrideValidationError is the validation error returned by
// RateLimiter_Override.Validate if the designated constraints aren't met.
type RateLimiter_OverrideValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimiter_OverrideValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimiter_OverrideValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimiter_OverrideValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimiter_OverrideValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimiter_OverrideValidationError) ErrorName() string {
	return "RateLimiter_OverrideValidationError"
}

// Error satisfies the builtin error interface
func (e RateLimiter_OverrideValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimiter_Override.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimiter_OverrideValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimiter_OverrideValidationError{}

// Validate checks the field values on RateLimiter_DynamicConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RateLimiter_DynamicConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimiter_DynamicConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RateLimiter_DynamicConfigMultiError, or nil if none found.
func (m *RateLimiter_DynamicConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimiter_DynamicConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOverrides() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RateLimiter_DynamicConfigValidationError{
						field:  fmt.Sprintf("Overrides[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RateLimiter_DynamicConfigValidationError{
						field:  fmt.Sprintf("Overrides[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RateLimiter_DynamicConfigValidationError{
					field:  fmt.Sprintf("Overrides[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RateLimiter_DynamicConfigMultiError(errors)
	}

	return nil
}

// RateLimiter_DynamicConfigMultiError is an error wrapping multiple validation
// errors returned by RateLimiter_DynamicConfig.ValidateAll() if the
// designated constraints aren't met.
type RateLimiter_DynamicConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimiter_DynamicConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimiter_DynamicConfigMultiError) AllErrors() []error { return m }

// RateLimiter_DynamicConfigValidationError is the validation error returned by
// RateLimiter_DynamicConfig.Validate if the designated constraints aren't met.
type RateLimiter_DynamicConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimiter_DynamicConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimiter_DynamicConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimiter_DynamicConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimiter_DynamicConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimiter_DynamicConfigValidationError) ErrorName() string {
	return "RateLimiter_DynamicConfigValidationError"
}

// Error satisfies the builtin error interface
func (e RateLimiter_DynamicConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimiter_DynamicConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimiter_DynamicConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimiter_DynamicConfigValidationError{}

// Validate checks the field values on RateLimiter_Ins with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RateLimiter_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimiter_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RateLimiter_InsMultiError, or nil if none found.
func (m *RateLimiter_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimiter_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLimit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimiter_InsValidationError{
					field:  "Limit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimiter_InsValidationError{
					field:  "Limit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLimit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimiter_InsValidationError{
				field:  "Limit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RateLimiter_InsMultiError(errors)
	}

	return nil
}

// RateLimiter_InsMultiError is an error wrapping multiple validation errors
// returned by RateLimiter_Ins.ValidateAll() if the designated constraints
// aren't met.
type RateLimiter_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimiter_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimiter_InsMultiError) AllErrors() []error { return m }

// RateLimiter_InsValidationError is the validation error returned by
// RateLimiter_Ins.Validate if the designated constraints aren't met.
type RateLimiter_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimiter_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimiter_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimiter_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimiter_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimiter_InsValidationError) ErrorName() string { return "RateLimiter_InsValidationError" }

// Error satisfies the builtin error interface
func (e RateLimiter_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimiter_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimiter_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimiter_InsValidationError{}

// Validate checks the field values on RateLimiter_Parameters_LazySync with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RateLimiter_Parameters_LazySync) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimiter_Parameters_LazySync with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// RateLimiter_Parameters_LazySyncMultiError, or nil if none found.
func (m *RateLimiter_Parameters_LazySync) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimiter_Parameters_LazySync) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	// no validation rules for NumSync

	if len(errors) > 0 {
		return RateLimiter_Parameters_LazySyncMultiError(errors)
	}

	return nil
}

// RateLimiter_Parameters_LazySyncMultiError is an error wrapping multiple
// validation errors returned by RateLimiter_Parameters_LazySync.ValidateAll()
// if the designated constraints aren't met.
type RateLimiter_Parameters_LazySyncMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimiter_Parameters_LazySyncMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimiter_Parameters_LazySyncMultiError) AllErrors() []error { return m }

// RateLimiter_Parameters_LazySyncValidationError is the validation error
// returned by RateLimiter_Parameters_LazySync.Validate if the designated
// constraints aren't met.
type RateLimiter_Parameters_LazySyncValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimiter_Parameters_LazySyncValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimiter_Parameters_LazySyncValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimiter_Parameters_LazySyncValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimiter_Parameters_LazySyncValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimiter_Parameters_LazySyncValidationError) ErrorName() string {
	return "RateLimiter_Parameters_LazySyncValidationError"
}

// Error satisfies the builtin error interface
func (e RateLimiter_Parameters_LazySyncValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimiter_Parameters_LazySync.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimiter_Parameters_LazySyncValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimiter_Parameters_LazySyncValidationError{}

// Validate checks the field values on Scheduler_Workload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Scheduler_Workload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Scheduler_Workload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Scheduler_WorkloadMultiError, or nil if none found.
func (m *Scheduler_Workload) ValidateAll() error {
	return m.validate(true)
}

func (m *Scheduler_Workload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Scheduler_WorkloadValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Scheduler_WorkloadValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Scheduler_WorkloadValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLabelMatcher()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Scheduler_WorkloadValidationError{
					field:  "LabelMatcher",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Scheduler_WorkloadValidationError{
					field:  "LabelMatcher",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLabelMatcher()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Scheduler_WorkloadValidationError{
				field:  "LabelMatcher",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Scheduler_WorkloadMultiError(errors)
	}

	return nil
}

// Scheduler_WorkloadMultiError is an error wrapping multiple validation errors
// returned by Scheduler_Workload.ValidateAll() if the designated constraints
// aren't met.
type Scheduler_WorkloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Scheduler_WorkloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Scheduler_WorkloadMultiError) AllErrors() []error { return m }

// Scheduler_WorkloadValidationError is the validation error returned by
// Scheduler_Workload.Validate if the designated constraints aren't met.
type Scheduler_WorkloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Scheduler_WorkloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Scheduler_WorkloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Scheduler_WorkloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Scheduler_WorkloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Scheduler_WorkloadValidationError) ErrorName() string {
	return "Scheduler_WorkloadValidationError"
}

// Error satisfies the builtin error interface
func (e Scheduler_WorkloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduler_Workload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Scheduler_WorkloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Scheduler_WorkloadValidationError{}

// Validate checks the field values on Scheduler_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Scheduler_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Scheduler_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Scheduler_ParametersMultiError, or nil if none found.
func (m *Scheduler_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *Scheduler_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWorkloads() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Scheduler_ParametersValidationError{
						field:  fmt.Sprintf("Workloads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Scheduler_ParametersValidationError{
						field:  fmt.Sprintf("Workloads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Scheduler_ParametersValidationError{
					field:  fmt.Sprintf("Workloads[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetDefaultWorkloadParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Scheduler_ParametersValidationError{
					field:  "DefaultWorkloadParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Scheduler_ParametersValidationError{
					field:  "DefaultWorkloadParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultWorkloadParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Scheduler_ParametersValidationError{
				field:  "DefaultWorkloadParameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AutoTokens

	// no validation rules for TimeoutFactor

	if all {
		switch v := interface{}(m.GetMaxTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Scheduler_ParametersValidationError{
					field:  "MaxTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Scheduler_ParametersValidationError{
					field:  "MaxTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Scheduler_ParametersValidationError{
				field:  "MaxTimeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Scheduler_ParametersMultiError(errors)
	}

	return nil
}

// Scheduler_ParametersMultiError is an error wrapping multiple validation
// errors returned by Scheduler_Parameters.ValidateAll() if the designated
// constraints aren't met.
type Scheduler_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Scheduler_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Scheduler_ParametersMultiError) AllErrors() []error { return m }

// Scheduler_ParametersValidationError is the validation error returned by
// Scheduler_Parameters.Validate if the designated constraints aren't met.
type Scheduler_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Scheduler_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Scheduler_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Scheduler_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Scheduler_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Scheduler_ParametersValidationError) ErrorName() string {
	return "Scheduler_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e Scheduler_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduler_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Scheduler_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Scheduler_ParametersValidationError{}

// Validate checks the field values on Scheduler_Outs with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Scheduler_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Scheduler_Outs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Scheduler_OutsMultiError,
// or nil if none found.
func (m *Scheduler_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *Scheduler_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAcceptedConcurrency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Scheduler_OutsValidationError{
					field:  "AcceptedConcurrency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Scheduler_OutsValidationError{
					field:  "AcceptedConcurrency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAcceptedConcurrency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Scheduler_OutsValidationError{
				field:  "AcceptedConcurrency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIncomingConcurrency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Scheduler_OutsValidationError{
					field:  "IncomingConcurrency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Scheduler_OutsValidationError{
					field:  "IncomingConcurrency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIncomingConcurrency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Scheduler_OutsValidationError{
				field:  "IncomingConcurrency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Scheduler_OutsMultiError(errors)
	}

	return nil
}

// Scheduler_OutsMultiError is an error wrapping multiple validation errors
// returned by Scheduler_Outs.ValidateAll() if the designated constraints
// aren't met.
type Scheduler_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Scheduler_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Scheduler_OutsMultiError) AllErrors() []error { return m }

// Scheduler_OutsValidationError is the validation error returned by
// Scheduler_Outs.Validate if the designated constraints aren't met.
type Scheduler_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Scheduler_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Scheduler_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Scheduler_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Scheduler_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Scheduler_OutsValidationError) ErrorName() string { return "Scheduler_OutsValidationError" }

// Error satisfies the builtin error interface
func (e Scheduler_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduler_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Scheduler_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Scheduler_OutsValidationError{}

// Validate checks the field values on Scheduler_Workload_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Scheduler_Workload_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Scheduler_Workload_Parameters with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Scheduler_Workload_ParametersMultiError, or nil if none found.
func (m *Scheduler_Workload_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *Scheduler_Workload_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Priority

	// no validation rules for Tokens

	// no validation rules for FairnessKey

	if len(errors) > 0 {
		return Scheduler_Workload_ParametersMultiError(errors)
	}

	return nil
}

// Scheduler_Workload_ParametersMultiError is an error wrapping multiple
// validation errors returned by Scheduler_Workload_Parameters.ValidateAll()
// if the designated constraints aren't met.
type Scheduler_Workload_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Scheduler_Workload_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Scheduler_Workload_ParametersMultiError) AllErrors() []error { return m }

// Scheduler_Workload_ParametersValidationError is the validation error
// returned by Scheduler_Workload_Parameters.Validate if the designated
// constraints aren't met.
type Scheduler_Workload_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Scheduler_Workload_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Scheduler_Workload_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Scheduler_Workload_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Scheduler_Workload_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Scheduler_Workload_ParametersValidationError) ErrorName() string {
	return "Scheduler_Workload_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e Scheduler_Workload_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduler_Workload_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Scheduler_Workload_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Scheduler_Workload_ParametersValidationError{}

// Validate checks the field values on LoadActuator_DynamicConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoadActuator_DynamicConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadActuator_DynamicConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoadActuator_DynamicConfigMultiError, or nil if none found.
func (m *LoadActuator_DynamicConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadActuator_DynamicConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DryRun

	if len(errors) > 0 {
		return LoadActuator_DynamicConfigMultiError(errors)
	}

	return nil
}

// LoadActuator_DynamicConfigMultiError is an error wrapping multiple
// validation errors returned by LoadActuator_DynamicConfig.ValidateAll() if
// the designated constraints aren't met.
type LoadActuator_DynamicConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadActuator_DynamicConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadActuator_DynamicConfigMultiError) AllErrors() []error { return m }

// LoadActuator_DynamicConfigValidationError is the validation error returned
// by LoadActuator_DynamicConfig.Validate if the designated constraints aren't met.
type LoadActuator_DynamicConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadActuator_DynamicConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadActuator_DynamicConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadActuator_DynamicConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadActuator_DynamicConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadActuator_DynamicConfigValidationError) ErrorName() string {
	return "LoadActuator_DynamicConfigValidationError"
}

// Error satisfies the builtin error interface
func (e LoadActuator_DynamicConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadActuator_DynamicConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadActuator_DynamicConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadActuator_DynamicConfigValidationError{}

// Validate checks the field values on LoadActuator_Ins with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LoadActuator_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadActuator_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoadActuator_InsMultiError, or nil if none found.
func (m *LoadActuator_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadActuator_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLoadMultiplier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadActuator_InsValidationError{
					field:  "LoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadActuator_InsValidationError{
					field:  "LoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLoadMultiplier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadActuator_InsValidationError{
				field:  "LoadMultiplier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoadActuator_InsMultiError(errors)
	}

	return nil
}

// LoadActuator_InsMultiError is an error wrapping multiple validation errors
// returned by LoadActuator_Ins.ValidateAll() if the designated constraints
// aren't met.
type LoadActuator_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadActuator_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadActuator_InsMultiError) AllErrors() []error { return m }

// LoadActuator_InsValidationError is the validation error returned by
// LoadActuator_Ins.Validate if the designated constraints aren't met.
type LoadActuator_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadActuator_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadActuator_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadActuator_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadActuator_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadActuator_InsValidationError) ErrorName() string { return "LoadActuator_InsValidationError" }

// Error satisfies the builtin error interface
func (e LoadActuator_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadActuator_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadActuator_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadActuator_InsValidationError{}

// Validate checks the field values on AIMDConcurrencyController_Ins with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AIMDConcurrencyController_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AIMDConcurrencyController_Ins with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// AIMDConcurrencyController_InsMultiError, or nil if none found.
func (m *AIMDConcurrencyController_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *AIMDConcurrencyController_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSignal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDConcurrencyController_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDConcurrencyController_InsValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDConcurrencyController_InsValidationError{
				field:  "Signal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSetpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDConcurrencyController_InsValidationError{
					field:  "Setpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDConcurrencyController_InsValidationError{
					field:  "Setpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSetpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDConcurrencyController_InsValidationError{
				field:  "Setpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AIMDConcurrencyController_InsMultiError(errors)
	}

	return nil
}

// AIMDConcurrencyController_InsMultiError is an error wrapping multiple
// validation errors returned by AIMDConcurrencyController_Ins.ValidateAll()
// if the designated constraints aren't met.
type AIMDConcurrencyController_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AIMDConcurrencyController_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AIMDConcurrencyController_InsMultiError) AllErrors() []error { return m }

// AIMDConcurrencyController_InsValidationError is the validation error
// returned by AIMDConcurrencyController_Ins.Validate if the designated
// constraints aren't met.
type AIMDConcurrencyController_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AIMDConcurrencyController_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AIMDConcurrencyController_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AIMDConcurrencyController_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AIMDConcurrencyController_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AIMDConcurrencyController_InsValidationError) ErrorName() string {
	return "AIMDConcurrencyController_InsValidationError"
}

// Error satisfies the builtin error interface
func (e AIMDConcurrencyController_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAIMDConcurrencyController_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AIMDConcurrencyController_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AIMDConcurrencyController_InsValidationError{}

// Validate checks the field values on AIMDConcurrencyController_Outs with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AIMDConcurrencyController_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AIMDConcurrencyController_Outs with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// AIMDConcurrencyController_OutsMultiError, or nil if none found.
func (m *AIMDConcurrencyController_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *AIMDConcurrencyController_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIsOverload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDConcurrencyController_OutsValidationError{
					field:  "IsOverload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDConcurrencyController_OutsValidationError{
					field:  "IsOverload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsOverload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDConcurrencyController_OutsValidationError{
				field:  "IsOverload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDesiredLoadMultiplier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDConcurrencyController_OutsValidationError{
					field:  "DesiredLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDConcurrencyController_OutsValidationError{
					field:  "DesiredLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDesiredLoadMultiplier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDConcurrencyController_OutsValidationError{
				field:  "DesiredLoadMultiplier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetObservedLoadMultiplier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDConcurrencyController_OutsValidationError{
					field:  "ObservedLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDConcurrencyController_OutsValidationError{
					field:  "ObservedLoadMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObservedLoadMultiplier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDConcurrencyController_OutsValidationError{
				field:  "ObservedLoadMultiplier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAcceptedConcurrency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDConcurrencyController_OutsValidationError{
					field:  "AcceptedConcurrency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDConcurrencyController_OutsValidationError{
					field:  "AcceptedConcurrency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAcceptedConcurrency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDConcurrencyController_OutsValidationError{
				field:  "AcceptedConcurrency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIncomingConcurrency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIMDConcurrencyController_OutsValidationError{
					field:  "IncomingConcurrency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIMDConcurrencyController_OutsValidationError{
					field:  "IncomingConcurrency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIncomingConcurrency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIMDConcurrencyController_OutsValidationError{
				field:  "IncomingConcurrency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AIMDConcurrencyController_OutsMultiError(errors)
	}

	return nil
}

// AIMDConcurrencyController_OutsMultiError is an error wrapping multiple
// validation errors returned by AIMDConcurrencyController_Outs.ValidateAll()
// if the designated constraints aren't met.
type AIMDConcurrencyController_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AIMDConcurrencyController_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AIMDConcurrencyController_OutsMultiError) AllErrors() []error { return m }

// AIMDConcurrencyController_OutsValidationError is the validation error
// returned by AIMDConcurrencyController_Outs.Validate if the designated
// constraints aren't met.
type AIMDConcurrencyController_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AIMDConcurrencyController_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AIMDConcurrencyController_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AIMDConcurrencyController_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AIMDConcurrencyController_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AIMDConcurrencyController_OutsValidationError) ErrorName() string {
	return "AIMDConcurrencyController_OutsValidationError"
}

// Error satisfies the builtin error interface
func (e AIMDConcurrencyController_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAIMDConcurrencyController_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AIMDConcurrencyController_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AIMDConcurrencyController_OutsValidationError{}

// Validate checks the field values on FlowRegulator_DynamicConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FlowRegulator_DynamicConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlowRegulator_DynamicConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FlowRegulator_DynamicConfigMultiError, or nil if none found.
func (m *FlowRegulator_DynamicConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *FlowRegulator_DynamicConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FlowRegulator_DynamicConfigMultiError(errors)
	}

	return nil
}

// FlowRegulator_DynamicConfigMultiError is an error wrapping multiple
// validation errors returned by FlowRegulator_DynamicConfig.ValidateAll() if
// the designated constraints aren't met.
type FlowRegulator_DynamicConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlowRegulator_DynamicConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlowRegulator_DynamicConfigMultiError) AllErrors() []error { return m }

// FlowRegulator_DynamicConfigValidationError is the validation error returned
// by FlowRegulator_DynamicConfig.Validate if the designated constraints
// aren't met.
type FlowRegulator_DynamicConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowRegulator_DynamicConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowRegulator_DynamicConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowRegulator_DynamicConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowRegulator_DynamicConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowRegulator_DynamicConfigValidationError) ErrorName() string {
	return "FlowRegulator_DynamicConfigValidationError"
}

// Error satisfies the builtin error interface
func (e FlowRegulator_DynamicConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlowRegulator_DynamicConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowRegulator_DynamicConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowRegulator_DynamicConfigValidationError{}

// Validate checks the field values on FlowRegulator_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FlowRegulator_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlowRegulator_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FlowRegulator_ParametersMultiError, or nil if none found.
func (m *FlowRegulator_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *FlowRegulator_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFlowSelector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlowRegulator_ParametersValidationError{
					field:  "FlowSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlowRegulator_ParametersValidationError{
					field:  "FlowSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFlowSelector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowRegulator_ParametersValidationError{
				field:  "FlowSelector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LabelKey

	if len(errors) > 0 {
		return FlowRegulator_ParametersMultiError(errors)
	}

	return nil
}

// FlowRegulator_ParametersMultiError is an error wrapping multiple validation
// errors returned by FlowRegulator_Parameters.ValidateAll() if the designated
// constraints aren't met.
type FlowRegulator_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlowRegulator_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlowRegulator_ParametersMultiError) AllErrors() []error { return m }

// FlowRegulator_ParametersValidationError is the validation error returned by
// FlowRegulator_Parameters.Validate if the designated constraints aren't met.
type FlowRegulator_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowRegulator_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowRegulator_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowRegulator_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowRegulator_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowRegulator_ParametersValidationError) ErrorName() string {
	return "FlowRegulator_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e FlowRegulator_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlowRegulator_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowRegulator_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowRegulator_ParametersValidationError{}

// Validate checks the field values on FlowRegulator_Ins with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FlowRegulator_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlowRegulator_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FlowRegulator_InsMultiError, or nil if none found.
func (m *FlowRegulator_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *FlowRegulator_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAcceptPercentage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlowRegulator_InsValidationError{
					field:  "AcceptPercentage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlowRegulator_InsValidationError{
					field:  "AcceptPercentage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAcceptPercentage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowRegulator_InsValidationError{
				field:  "AcceptPercentage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FlowRegulator_InsMultiError(errors)
	}

	return nil
}

// FlowRegulator_InsMultiError is an error wrapping multiple validation errors
// returned by FlowRegulator_Ins.ValidateAll() if the designated constraints
// aren't met.
type FlowRegulator_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlowRegulator_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlowRegulator_InsMultiError) AllErrors() []error { return m }

// FlowRegulator_InsValidationError is the validation error returned by
// FlowRegulator_Ins.Validate if the designated constraints aren't met.
type FlowRegulator_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowRegulator_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowRegulator_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowRegulator_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowRegulator_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowRegulator_InsValidationError) ErrorName() string {
	return "FlowRegulator_InsValidationError"
}

// Error satisfies the builtin error interface
func (e FlowRegulator_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlowRegulator_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowRegulator_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowRegulator_InsValidationError{}

// Validate checks the field values on LoadShaper_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoadShaper_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadShaper_Parameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoadShaper_ParametersMultiError, or nil if none found.
func (m *LoadShaper_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadShaper_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFlowRegulatorParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaper_ParametersValidationError{
					field:  "FlowRegulatorParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaper_ParametersValidationError{
					field:  "FlowRegulatorParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFlowRegulatorParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaper_ParametersValidationError{
				field:  "FlowRegulatorParameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSteps() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoadShaper_ParametersValidationError{
						field:  fmt.Sprintf("Steps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoadShaper_ParametersValidationError{
						field:  fmt.Sprintf("Steps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoadShaper_ParametersValidationError{
					field:  fmt.Sprintf("Steps[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LoadShaper_ParametersMultiError(errors)
	}

	return nil
}

// LoadShaper_ParametersMultiError is an error wrapping multiple validation
// errors returned by LoadShaper_Parameters.ValidateAll() if the designated
// constraints aren't met.
type LoadShaper_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadShaper_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadShaper_ParametersMultiError) AllErrors() []error { return m }

// LoadShaper_ParametersValidationError is the validation error returned by
// LoadShaper_Parameters.Validate if the designated constraints aren't met.
type LoadShaper_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadShaper_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadShaper_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadShaper_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadShaper_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadShaper_ParametersValidationError) ErrorName() string {
	return "LoadShaper_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e LoadShaper_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadShaper_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadShaper_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadShaper_ParametersValidationError{}

// Validate checks the field values on LoadShaper_Ins with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoadShaper_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadShaper_Ins with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoadShaper_InsMultiError,
// or nil if none found.
func (m *LoadShaper_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadShaper_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetForward()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaper_InsValidationError{
					field:  "Forward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaper_InsValidationError{
					field:  "Forward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetForward()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaper_InsValidationError{
				field:  "Forward",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBackward()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaper_InsValidationError{
					field:  "Backward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaper_InsValidationError{
					field:  "Backward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBackward()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaper_InsValidationError{
				field:  "Backward",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReset_()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaper_InsValidationError{
					field:  "Reset_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaper_InsValidationError{
					field:  "Reset_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReset_()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaper_InsValidationError{
				field:  "Reset_",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoadShaper_InsMultiError(errors)
	}

	return nil
}

// LoadShaper_InsMultiError is an error wrapping multiple validation errors
// returned by LoadShaper_Ins.ValidateAll() if the designated constraints
// aren't met.
type LoadShaper_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadShaper_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadShaper_InsMultiError) AllErrors() []error { return m }

// LoadShaper_InsValidationError is the validation error returned by
// LoadShaper_Ins.Validate if the designated constraints aren't met.
type LoadShaper_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadShaper_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadShaper_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadShaper_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadShaper_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadShaper_InsValidationError) ErrorName() string { return "LoadShaper_InsValidationError" }

// Error satisfies the builtin error interface
func (e LoadShaper_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadShaper_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadShaper_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadShaper_InsValidationError{}

// Validate checks the field values on LoadShaper_Outs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LoadShaper_Outs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadShaper_Outs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoadShaper_OutsMultiError, or nil if none found.
func (m *LoadShaper_Outs) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadShaper_Outs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAcceptPercentage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaper_OutsValidationError{
					field:  "AcceptPercentage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaper_OutsValidationError{
					field:  "AcceptPercentage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAcceptPercentage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaper_OutsValidationError{
				field:  "AcceptPercentage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAtStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaper_OutsValidationError{
					field:  "AtStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaper_OutsValidationError{
					field:  "AtStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAtStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaper_OutsValidationError{
				field:  "AtStart",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAtEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaper_OutsValidationError{
					field:  "AtEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaper_OutsValidationError{
					field:  "AtEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAtEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaper_OutsValidationError{
				field:  "AtEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoadShaper_OutsMultiError(errors)
	}

	return nil
}

// LoadShaper_OutsMultiError is an error wrapping multiple validation errors
// returned by LoadShaper_Outs.ValidateAll() if the designated constraints
// aren't met.
type LoadShaper_OutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadShaper_OutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadShaper_OutsMultiError) AllErrors() []error { return m }

// LoadShaper_OutsValidationError is the validation error returned by
// LoadShaper_Outs.Validate if the designated constraints aren't met.
type LoadShaper_OutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadShaper_OutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadShaper_OutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadShaper_OutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadShaper_OutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadShaper_OutsValidationError) ErrorName() string { return "LoadShaper_OutsValidationError" }

// Error satisfies the builtin error interface
func (e LoadShaper_OutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadShaper_Outs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadShaper_OutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadShaper_OutsValidationError{}

// Validate checks the field values on LoadShaper_Parameters_Step with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoadShaper_Parameters_Step) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadShaper_Parameters_Step with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoadShaper_Parameters_StepMultiError, or nil if none found.
func (m *LoadShaper_Parameters_Step) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadShaper_Parameters_Step) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetAcceptPercentage

	if all {
		switch v := interface{}(m.GetDuration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaper_Parameters_StepValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaper_Parameters_StepValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDuration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaper_Parameters_StepValidationError{
				field:  "Duration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoadShaper_Parameters_StepMultiError(errors)
	}

	return nil
}

// LoadShaper_Parameters_StepMultiError is an error wrapping multiple
// validation errors returned by LoadShaper_Parameters_Step.ValidateAll() if
// the designated constraints aren't met.
type LoadShaper_Parameters_StepMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadShaper_Parameters_StepMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadShaper_Parameters_StepMultiError) AllErrors() []error { return m }

// LoadShaper_Parameters_StepValidationError is the validation error returned
// by LoadShaper_Parameters_Step.Validate if the designated constraints aren't met.
type LoadShaper_Parameters_StepValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadShaper_Parameters_StepValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadShaper_Parameters_StepValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadShaper_Parameters_StepValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadShaper_Parameters_StepValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadShaper_Parameters_StepValidationError) ErrorName() string {
	return "LoadShaper_Parameters_StepValidationError"
}

// Error satisfies the builtin error interface
func (e LoadShaper_Parameters_StepValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadShaper_Parameters_Step.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadShaper_Parameters_StepValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadShaper_Parameters_StepValidationError{}

// Validate checks the field values on LoadShaperSeries_LoadShaperInstance with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *LoadShaperSeries_LoadShaperInstance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadShaperSeries_LoadShaperInstance
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// LoadShaperSeries_LoadShaperInstanceMultiError, or nil if none found.
func (m *LoadShaperSeries_LoadShaperInstance) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadShaperSeries_LoadShaperInstance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLoadShaper()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaperSeries_LoadShaperInstanceValidationError{
					field:  "LoadShaper",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaperSeries_LoadShaperInstanceValidationError{
					field:  "LoadShaper",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLoadShaper()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaperSeries_LoadShaperInstanceValidationError{
				field:  "LoadShaper",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutPorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaperSeries_LoadShaperInstanceValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaperSeries_LoadShaperInstanceValidationError{
					field:  "OutPorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaperSeries_LoadShaperInstanceValidationError{
				field:  "OutPorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoadShaperSeries_LoadShaperInstanceMultiError(errors)
	}

	return nil
}

// LoadShaperSeries_LoadShaperInstanceMultiError is an error wrapping multiple
// validation errors returned by
// LoadShaperSeries_LoadShaperInstance.ValidateAll() if the designated
// constraints aren't met.
type LoadShaperSeries_LoadShaperInstanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadShaperSeries_LoadShaperInstanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadShaperSeries_LoadShaperInstanceMultiError) AllErrors() []error { return m }

// LoadShaperSeries_LoadShaperInstanceValidationError is the validation error
// returned by LoadShaperSeries_LoadShaperInstance.Validate if the designated
// constraints aren't met.
type LoadShaperSeries_LoadShaperInstanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadShaperSeries_LoadShaperInstanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadShaperSeries_LoadShaperInstanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadShaperSeries_LoadShaperInstanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadShaperSeries_LoadShaperInstanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadShaperSeries_LoadShaperInstanceValidationError) ErrorName() string {
	return "LoadShaperSeries_LoadShaperInstanceValidationError"
}

// Error satisfies the builtin error interface
func (e LoadShaperSeries_LoadShaperInstanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadShaperSeries_LoadShaperInstance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadShaperSeries_LoadShaperInstanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadShaperSeries_LoadShaperInstanceValidationError{}

// Validate checks the field values on LoadShaperSeries_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoadShaperSeries_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadShaperSeries_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoadShaperSeries_ParametersMultiError, or nil if none found.
func (m *LoadShaperSeries_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadShaperSeries_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLoadShapers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoadShaperSeries_ParametersValidationError{
						field:  fmt.Sprintf("LoadShapers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoadShaperSeries_ParametersValidationError{
						field:  fmt.Sprintf("LoadShapers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoadShaperSeries_ParametersValidationError{
					field:  fmt.Sprintf("LoadShapers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LoadShaperSeries_ParametersMultiError(errors)
	}

	return nil
}

// LoadShaperSeries_ParametersMultiError is an error wrapping multiple
// validation errors returned by LoadShaperSeries_Parameters.ValidateAll() if
// the designated constraints aren't met.
type LoadShaperSeries_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadShaperSeries_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadShaperSeries_ParametersMultiError) AllErrors() []error { return m }

// LoadShaperSeries_ParametersValidationError is the validation error returned
// by LoadShaperSeries_Parameters.Validate if the designated constraints
// aren't met.
type LoadShaperSeries_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadShaperSeries_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadShaperSeries_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadShaperSeries_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadShaperSeries_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadShaperSeries_ParametersValidationError) ErrorName() string {
	return "LoadShaperSeries_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e LoadShaperSeries_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadShaperSeries_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadShaperSeries_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadShaperSeries_ParametersValidationError{}

// Validate checks the field values on LoadShaperSeries_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoadShaperSeries_Ins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadShaperSeries_Ins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoadShaperSeries_InsMultiError, or nil if none found.
func (m *LoadShaperSeries_Ins) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadShaperSeries_Ins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetForward()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaperSeries_InsValidationError{
					field:  "Forward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaperSeries_InsValidationError{
					field:  "Forward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetForward()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaperSeries_InsValidationError{
				field:  "Forward",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBackward()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaperSeries_InsValidationError{
					field:  "Backward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaperSeries_InsValidationError{
					field:  "Backward",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBackward()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaperSeries_InsValidationError{
				field:  "Backward",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReset_()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadShaperSeries_InsValidationError{
					field:  "Reset_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadShaperSeries_InsValidationError{
					field:  "Reset_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReset_()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadShaperSeries_InsValidationError{
				field:  "Reset_",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoadShaperSeries_InsMultiError(errors)
	}

	return nil
}

// LoadShaperSeries_InsMultiError is an error wrapping multiple validation
// errors returned by LoadShaperSeries_Ins.ValidateAll() if the designated
// constraints aren't met.
type LoadShaperSeries_InsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadShaperSeries_InsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadShaperSeries_InsMultiError) AllErrors() []error { return m }

// LoadShaperSeries_InsValidationError is the validation error returned by
// LoadShaperSeries_Ins.Validate if the designated constraints aren't met.
type LoadShaperSeries_InsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadShaperSeries_InsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadShaperSeries_InsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadShaperSeries_InsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadShaperSeries_InsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadShaperSeries_InsValidationError) ErrorName() string {
	return "LoadShaperSeries_InsValidationError"
}

// Error satisfies the builtin error interface
func (e LoadShaperSeries_InsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadShaperSeries_Ins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadShaperSeries_InsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadShaperSeries_InsValidationError{}
