// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: aperture/policy/language/v1/policy.proto

package com.fluxninja.generated.aperture.policy.language.v1;

public interface CircuitOrBuilder extends
    // @@protoc_insertion_point(interface_extends:aperture.policy.language.v1.Circuit)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Evaluation interval (tick) is the time period between consecutive runs of the policy circuit.
   * This interval is typically aligned with how often the corrective action (actuation) needs to be taken.
   * </pre>
   *
   * <code>.google.protobuf.Duration evaluation_interval = 1 [json_name = "evaluationInterval", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = { ... }</code>
   * @return Whether the evaluationInterval field is set.
   */
  boolean hasEvaluationInterval();
  /**
   * <pre>
   * Evaluation interval (tick) is the time period between consecutive runs of the policy circuit.
   * This interval is typically aligned with how often the corrective action (actuation) needs to be taken.
   * </pre>
   *
   * <code>.google.protobuf.Duration evaluation_interval = 1 [json_name = "evaluationInterval", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = { ... }</code>
   * @return The evaluationInterval.
   */
  com.google.protobuf.Duration getEvaluationInterval();
  /**
   * <pre>
   * Evaluation interval (tick) is the time period between consecutive runs of the policy circuit.
   * This interval is typically aligned with how often the corrective action (actuation) needs to be taken.
   * </pre>
   *
   * <code>.google.protobuf.Duration evaluation_interval = 1 [json_name = "evaluationInterval", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getEvaluationIntervalOrBuilder();

  /**
   * <pre>
   * Defines a signal processing graph as a list of components.
   * </pre>
   *
   * <code>repeated .aperture.policy.language.v1.Component components = 2 [json_name = "components"];</code>
   */
  java.util.List<com.fluxninja.generated.aperture.policy.language.v1.Component> 
      getComponentsList();
  /**
   * <pre>
   * Defines a signal processing graph as a list of components.
   * </pre>
   *
   * <code>repeated .aperture.policy.language.v1.Component components = 2 [json_name = "components"];</code>
   */
  com.fluxninja.generated.aperture.policy.language.v1.Component getComponents(int index);
  /**
   * <pre>
   * Defines a signal processing graph as a list of components.
   * </pre>
   *
   * <code>repeated .aperture.policy.language.v1.Component components = 2 [json_name = "components"];</code>
   */
  int getComponentsCount();
  /**
   * <pre>
   * Defines a signal processing graph as a list of components.
   * </pre>
   *
   * <code>repeated .aperture.policy.language.v1.Component components = 2 [json_name = "components"];</code>
   */
  java.util.List<? extends com.fluxninja.generated.aperture.policy.language.v1.ComponentOrBuilder> 
      getComponentsOrBuilderList();
  /**
   * <pre>
   * Defines a signal processing graph as a list of components.
   * </pre>
   *
   * <code>repeated .aperture.policy.language.v1.Component components = 2 [json_name = "components"];</code>
   */
  com.fluxninja.generated.aperture.policy.language.v1.ComponentOrBuilder getComponentsOrBuilder(
      int index);
}
