// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: aperture/policy/language/v1/flowcontrol.proto

package com.fluxninja.generated.aperture.policy.language.v1;

/**
 * <pre>
 * Weighted Fair Queuing-based workload scheduler
 * :::note
 * Each Agent instantiates an independent copy of the scheduler, but output
 * signals for accepted and incoming concurrency are aggregated across all agents.
 * :::
 * See [ConcurrencyLimiter](#concurrency-limiter) for more context.
 * </pre>
 *
 * Protobuf type {@code aperture.policy.language.v1.Scheduler}
 */
public final class Scheduler extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:aperture.policy.language.v1.Scheduler)
    SchedulerOrBuilder {
private static final long serialVersionUID = 0L;
  // Use Scheduler.newBuilder() to construct.
  private Scheduler(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private Scheduler() {
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(
      UnusedPrivateParameter unused) {
    return new Scheduler();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private Scheduler(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 10: {
            com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.Builder subBuilder = null;
            if (outPorts_ != null) {
              subBuilder = outPorts_.toBuilder();
            }
            outPorts_ = input.readMessage(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(outPorts_);
              outPorts_ = subBuilder.buildPartial();
            }

            break;
          }
          case 18: {
            com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.Builder subBuilder = null;
            if (parameters_ != null) {
              subBuilder = parameters_.toBuilder();
            }
            parameters_ = input.readMessage(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(parameters_);
              parameters_ = subBuilder.buildPartial();
            }

            break;
          }
          default: {
            if (!parseUnknownField(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (com.google.protobuf.UninitializedMessageException e) {
      throw e.asInvalidProtocolBufferException().setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.fluxninja.generated.aperture.policy.language.v1.Scheduler.class, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Builder.class);
  }

  public interface WorkloadOrBuilder extends
      // @@protoc_insertion_point(interface_extends:aperture.policy.language.v1.Scheduler.Workload)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Parameters associated with flows matching the label matcher.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters = 1 [json_name = "parameters"];</code>
     * @return Whether the parameters field is set.
     */
    boolean hasParameters();
    /**
     * <pre>
     * Parameters associated with flows matching the label matcher.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters = 1 [json_name = "parameters"];</code>
     * @return The parameters.
     */
    com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters getParameters();
    /**
     * <pre>
     * Parameters associated with flows matching the label matcher.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters = 1 [json_name = "parameters"];</code>
     */
    com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.ParametersOrBuilder getParametersOrBuilder();

    /**
     * <pre>
     * Label Matcher to select a Workload based on
     * [flow labels](/concepts/flow-control/flow-label.md).
     * </pre>
     *
     * <code>.aperture.policy.language.v1.LabelMatcher label_matcher = 2 [json_name = "labelMatcher"];</code>
     * @return Whether the labelMatcher field is set.
     */
    boolean hasLabelMatcher();
    /**
     * <pre>
     * Label Matcher to select a Workload based on
     * [flow labels](/concepts/flow-control/flow-label.md).
     * </pre>
     *
     * <code>.aperture.policy.language.v1.LabelMatcher label_matcher = 2 [json_name = "labelMatcher"];</code>
     * @return The labelMatcher.
     */
    com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher getLabelMatcher();
    /**
     * <pre>
     * Label Matcher to select a Workload based on
     * [flow labels](/concepts/flow-control/flow-label.md).
     * </pre>
     *
     * <code>.aperture.policy.language.v1.LabelMatcher label_matcher = 2 [json_name = "labelMatcher"];</code>
     */
    com.fluxninja.generated.aperture.policy.language.v1.LabelMatcherOrBuilder getLabelMatcherOrBuilder();
  }
  /**
   * <pre>
   * Workload defines a class of requests that preferably have similar properties such as response latency or desired priority.
   * </pre>
   *
   * Protobuf type {@code aperture.policy.language.v1.Scheduler.Workload}
   */
  public static final class Workload extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:aperture.policy.language.v1.Scheduler.Workload)
      WorkloadOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Workload.newBuilder() to construct.
    private Workload(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Workload() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Workload();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Workload(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.Builder subBuilder = null;
              if (parameters_ != null) {
                subBuilder = parameters_.toBuilder();
              }
              parameters_ = input.readMessage(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(parameters_);
                parameters_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher.Builder subBuilder = null;
              if (labelMatcher_ != null) {
                subBuilder = labelMatcher_.toBuilder();
              }
              labelMatcher_ = input.readMessage(com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(labelMatcher_);
                labelMatcher_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (com.google.protobuf.UninitializedMessageException e) {
        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Workload_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Workload_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.class, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Builder.class);
    }

    public interface ParametersOrBuilder extends
        // @@protoc_insertion_point(interface_extends:aperture.policy.language.v1.Scheduler.Workload.Parameters)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Describes priority level of the requests within the workload.
       * Priority level ranges from 0 to 255.
       * Higher numbers means higher priority level.
       * Priority levels have non-linear effect on the workload scheduling. The following formula is used to determine the position of a request in the queue based on virtual finish time:
       * $$
       * &#92;text{virtual&#92;_finish&#92;_time} = &#92;text{virtual&#92;_time} + &#92;left(&#92;text{tokens} &#92;cdot &#92;left(&#92;text{256} - &#92;text{priority}&#92;right)&#92;right)
       * $$
       * </pre>
       *
       * <code>uint32 priority = 1 [json_name = "priority"];</code>
       * @return The priority.
       */
      int getPriority();

      /**
       * <pre>
       * Tokens determines the cost of admitting a single request the workload, which is typically defined as milliseconds of response latency.
       * This override is applicable only if tokens for the request are not specified in the request.
       * </pre>
       *
       * <code>uint64 tokens = 2 [json_name = "tokens"];</code>
       * @return The tokens.
       */
      long getTokens();

      /**
       * <pre>
       * Fairness key is a label key that can be used to provide fairness within a workload.
       * Any [flow label](/concepts/flow-control/flow-label.md) can be used here. Eg. if
       * you have a classifier that sets `user` flow label, you might want to set
       * `fairness_key = "user"`.
       * </pre>
       *
       * <code>string fairness_key = 3 [json_name = "fairnessKey"];</code>
       * @return The fairnessKey.
       */
      java.lang.String getFairnessKey();
      /**
       * <pre>
       * Fairness key is a label key that can be used to provide fairness within a workload.
       * Any [flow label](/concepts/flow-control/flow-label.md) can be used here. Eg. if
       * you have a classifier that sets `user` flow label, you might want to set
       * `fairness_key = "user"`.
       * </pre>
       *
       * <code>string fairness_key = 3 [json_name = "fairnessKey"];</code>
       * @return The bytes for fairnessKey.
       */
      com.google.protobuf.ByteString
          getFairnessKeyBytes();
    }
    /**
     * <pre>
     * Parameters defines parameters such as priority, tokens and fairness key that are applicable to flows within a workload.
     * </pre>
     *
     * Protobuf type {@code aperture.policy.language.v1.Scheduler.Workload.Parameters}
     */
    public static final class Parameters extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:aperture.policy.language.v1.Scheduler.Workload.Parameters)
        ParametersOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Parameters.newBuilder() to construct.
      private Parameters(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Parameters() {
        fairnessKey_ = "";
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new Parameters();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private Parameters(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {

                priority_ = input.readUInt32();
                break;
              }
              case 16: {

                tokens_ = input.readUInt64();
                break;
              }
              case 26: {
                java.lang.String s = input.readStringRequireUtf8();

                fairnessKey_ = s;
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Workload_Parameters_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Workload_Parameters_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.class, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.Builder.class);
      }

      public static final int PRIORITY_FIELD_NUMBER = 1;
      private int priority_;
      /**
       * <pre>
       * Describes priority level of the requests within the workload.
       * Priority level ranges from 0 to 255.
       * Higher numbers means higher priority level.
       * Priority levels have non-linear effect on the workload scheduling. The following formula is used to determine the position of a request in the queue based on virtual finish time:
       * $$
       * &#92;text{virtual&#92;_finish&#92;_time} = &#92;text{virtual&#92;_time} + &#92;left(&#92;text{tokens} &#92;cdot &#92;left(&#92;text{256} - &#92;text{priority}&#92;right)&#92;right)
       * $$
       * </pre>
       *
       * <code>uint32 priority = 1 [json_name = "priority"];</code>
       * @return The priority.
       */
      @java.lang.Override
      public int getPriority() {
        return priority_;
      }

      public static final int TOKENS_FIELD_NUMBER = 2;
      private long tokens_;
      /**
       * <pre>
       * Tokens determines the cost of admitting a single request the workload, which is typically defined as milliseconds of response latency.
       * This override is applicable only if tokens for the request are not specified in the request.
       * </pre>
       *
       * <code>uint64 tokens = 2 [json_name = "tokens"];</code>
       * @return The tokens.
       */
      @java.lang.Override
      public long getTokens() {
        return tokens_;
      }

      public static final int FAIRNESS_KEY_FIELD_NUMBER = 3;
      private volatile java.lang.Object fairnessKey_;
      /**
       * <pre>
       * Fairness key is a label key that can be used to provide fairness within a workload.
       * Any [flow label](/concepts/flow-control/flow-label.md) can be used here. Eg. if
       * you have a classifier that sets `user` flow label, you might want to set
       * `fairness_key = "user"`.
       * </pre>
       *
       * <code>string fairness_key = 3 [json_name = "fairnessKey"];</code>
       * @return The fairnessKey.
       */
      @java.lang.Override
      public java.lang.String getFairnessKey() {
        java.lang.Object ref = fairnessKey_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          fairnessKey_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * Fairness key is a label key that can be used to provide fairness within a workload.
       * Any [flow label](/concepts/flow-control/flow-label.md) can be used here. Eg. if
       * you have a classifier that sets `user` flow label, you might want to set
       * `fairness_key = "user"`.
       * </pre>
       *
       * <code>string fairness_key = 3 [json_name = "fairnessKey"];</code>
       * @return The bytes for fairnessKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getFairnessKeyBytes() {
        java.lang.Object ref = fairnessKey_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fairnessKey_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (priority_ != 0) {
          output.writeUInt32(1, priority_);
        }
        if (tokens_ != 0L) {
          output.writeUInt64(2, tokens_);
        }
        if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(fairnessKey_)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 3, fairnessKey_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (priority_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(1, priority_);
        }
        if (tokens_ != 0L) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(2, tokens_);
        }
        if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(fairnessKey_)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, fairnessKey_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters)) {
          return super.equals(obj);
        }
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters other = (com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters) obj;

        if (getPriority()
            != other.getPriority()) return false;
        if (getTokens()
            != other.getTokens()) return false;
        if (!getFairnessKey()
            .equals(other.getFairnessKey())) return false;
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + PRIORITY_FIELD_NUMBER;
        hash = (53 * hash) + getPriority();
        hash = (37 * hash) + TOKENS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getTokens());
        hash = (37 * hash) + FAIRNESS_KEY_FIELD_NUMBER;
        hash = (53 * hash) + getFairnessKey().hashCode();
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Parameters defines parameters such as priority, tokens and fairness key that are applicable to flows within a workload.
       * </pre>
       *
       * Protobuf type {@code aperture.policy.language.v1.Scheduler.Workload.Parameters}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:aperture.policy.language.v1.Scheduler.Workload.Parameters)
          com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.ParametersOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Workload_Parameters_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Workload_Parameters_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.class, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.Builder.class);
        }

        // Construct using com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          priority_ = 0;

          tokens_ = 0L;

          fairnessKey_ = "";

          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Workload_Parameters_descriptor;
        }

        @java.lang.Override
        public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters getDefaultInstanceForType() {
          return com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.getDefaultInstance();
        }

        @java.lang.Override
        public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters build() {
          com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters buildPartial() {
          com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters result = new com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters(this);
          result.priority_ = priority_;
          result.tokens_ = tokens_;
          result.fairnessKey_ = fairnessKey_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters) {
            return mergeFrom((com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters other) {
          if (other == com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.getDefaultInstance()) return this;
          if (other.getPriority() != 0) {
            setPriority(other.getPriority());
          }
          if (other.getTokens() != 0L) {
            setTokens(other.getTokens());
          }
          if (!other.getFairnessKey().isEmpty()) {
            fairnessKey_ = other.fairnessKey_;
            onChanged();
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private int priority_ ;
        /**
         * <pre>
         * Describes priority level of the requests within the workload.
         * Priority level ranges from 0 to 255.
         * Higher numbers means higher priority level.
         * Priority levels have non-linear effect on the workload scheduling. The following formula is used to determine the position of a request in the queue based on virtual finish time:
         * $$
         * &#92;text{virtual&#92;_finish&#92;_time} = &#92;text{virtual&#92;_time} + &#92;left(&#92;text{tokens} &#92;cdot &#92;left(&#92;text{256} - &#92;text{priority}&#92;right)&#92;right)
         * $$
         * </pre>
         *
         * <code>uint32 priority = 1 [json_name = "priority"];</code>
         * @return The priority.
         */
        @java.lang.Override
        public int getPriority() {
          return priority_;
        }
        /**
         * <pre>
         * Describes priority level of the requests within the workload.
         * Priority level ranges from 0 to 255.
         * Higher numbers means higher priority level.
         * Priority levels have non-linear effect on the workload scheduling. The following formula is used to determine the position of a request in the queue based on virtual finish time:
         * $$
         * &#92;text{virtual&#92;_finish&#92;_time} = &#92;text{virtual&#92;_time} + &#92;left(&#92;text{tokens} &#92;cdot &#92;left(&#92;text{256} - &#92;text{priority}&#92;right)&#92;right)
         * $$
         * </pre>
         *
         * <code>uint32 priority = 1 [json_name = "priority"];</code>
         * @param value The priority to set.
         * @return This builder for chaining.
         */
        public Builder setPriority(int value) {
          
          priority_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Describes priority level of the requests within the workload.
         * Priority level ranges from 0 to 255.
         * Higher numbers means higher priority level.
         * Priority levels have non-linear effect on the workload scheduling. The following formula is used to determine the position of a request in the queue based on virtual finish time:
         * $$
         * &#92;text{virtual&#92;_finish&#92;_time} = &#92;text{virtual&#92;_time} + &#92;left(&#92;text{tokens} &#92;cdot &#92;left(&#92;text{256} - &#92;text{priority}&#92;right)&#92;right)
         * $$
         * </pre>
         *
         * <code>uint32 priority = 1 [json_name = "priority"];</code>
         * @return This builder for chaining.
         */
        public Builder clearPriority() {
          
          priority_ = 0;
          onChanged();
          return this;
        }

        private long tokens_ ;
        /**
         * <pre>
         * Tokens determines the cost of admitting a single request the workload, which is typically defined as milliseconds of response latency.
         * This override is applicable only if tokens for the request are not specified in the request.
         * </pre>
         *
         * <code>uint64 tokens = 2 [json_name = "tokens"];</code>
         * @return The tokens.
         */
        @java.lang.Override
        public long getTokens() {
          return tokens_;
        }
        /**
         * <pre>
         * Tokens determines the cost of admitting a single request the workload, which is typically defined as milliseconds of response latency.
         * This override is applicable only if tokens for the request are not specified in the request.
         * </pre>
         *
         * <code>uint64 tokens = 2 [json_name = "tokens"];</code>
         * @param value The tokens to set.
         * @return This builder for chaining.
         */
        public Builder setTokens(long value) {
          
          tokens_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Tokens determines the cost of admitting a single request the workload, which is typically defined as milliseconds of response latency.
         * This override is applicable only if tokens for the request are not specified in the request.
         * </pre>
         *
         * <code>uint64 tokens = 2 [json_name = "tokens"];</code>
         * @return This builder for chaining.
         */
        public Builder clearTokens() {
          
          tokens_ = 0L;
          onChanged();
          return this;
        }

        private java.lang.Object fairnessKey_ = "";
        /**
         * <pre>
         * Fairness key is a label key that can be used to provide fairness within a workload.
         * Any [flow label](/concepts/flow-control/flow-label.md) can be used here. Eg. if
         * you have a classifier that sets `user` flow label, you might want to set
         * `fairness_key = "user"`.
         * </pre>
         *
         * <code>string fairness_key = 3 [json_name = "fairnessKey"];</code>
         * @return The fairnessKey.
         */
        public java.lang.String getFairnessKey() {
          java.lang.Object ref = fairnessKey_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            fairnessKey_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * Fairness key is a label key that can be used to provide fairness within a workload.
         * Any [flow label](/concepts/flow-control/flow-label.md) can be used here. Eg. if
         * you have a classifier that sets `user` flow label, you might want to set
         * `fairness_key = "user"`.
         * </pre>
         *
         * <code>string fairness_key = 3 [json_name = "fairnessKey"];</code>
         * @return The bytes for fairnessKey.
         */
        public com.google.protobuf.ByteString
            getFairnessKeyBytes() {
          java.lang.Object ref = fairnessKey_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            fairnessKey_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * Fairness key is a label key that can be used to provide fairness within a workload.
         * Any [flow label](/concepts/flow-control/flow-label.md) can be used here. Eg. if
         * you have a classifier that sets `user` flow label, you might want to set
         * `fairness_key = "user"`.
         * </pre>
         *
         * <code>string fairness_key = 3 [json_name = "fairnessKey"];</code>
         * @param value The fairnessKey to set.
         * @return This builder for chaining.
         */
        public Builder setFairnessKey(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  
          fairnessKey_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Fairness key is a label key that can be used to provide fairness within a workload.
         * Any [flow label](/concepts/flow-control/flow-label.md) can be used here. Eg. if
         * you have a classifier that sets `user` flow label, you might want to set
         * `fairness_key = "user"`.
         * </pre>
         *
         * <code>string fairness_key = 3 [json_name = "fairnessKey"];</code>
         * @return This builder for chaining.
         */
        public Builder clearFairnessKey() {
          
          fairnessKey_ = getDefaultInstance().getFairnessKey();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Fairness key is a label key that can be used to provide fairness within a workload.
         * Any [flow label](/concepts/flow-control/flow-label.md) can be used here. Eg. if
         * you have a classifier that sets `user` flow label, you might want to set
         * `fairness_key = "user"`.
         * </pre>
         *
         * <code>string fairness_key = 3 [json_name = "fairnessKey"];</code>
         * @param value The bytes for fairnessKey to set.
         * @return This builder for chaining.
         */
        public Builder setFairnessKeyBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          
          fairnessKey_ = value;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:aperture.policy.language.v1.Scheduler.Workload.Parameters)
      }

      // @@protoc_insertion_point(class_scope:aperture.policy.language.v1.Scheduler.Workload.Parameters)
      private static final com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters();
      }

      public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Parameters>
          PARSER = new com.google.protobuf.AbstractParser<Parameters>() {
        @java.lang.Override
        public Parameters parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new Parameters(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<Parameters> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Parameters> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public static final int PARAMETERS_FIELD_NUMBER = 1;
    private com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters_;
    /**
     * <pre>
     * Parameters associated with flows matching the label matcher.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters = 1 [json_name = "parameters"];</code>
     * @return Whether the parameters field is set.
     */
    @java.lang.Override
    public boolean hasParameters() {
      return parameters_ != null;
    }
    /**
     * <pre>
     * Parameters associated with flows matching the label matcher.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters = 1 [json_name = "parameters"];</code>
     * @return The parameters.
     */
    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters getParameters() {
      return parameters_ == null ? com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.getDefaultInstance() : parameters_;
    }
    /**
     * <pre>
     * Parameters associated with flows matching the label matcher.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters = 1 [json_name = "parameters"];</code>
     */
    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.ParametersOrBuilder getParametersOrBuilder() {
      return getParameters();
    }

    public static final int LABEL_MATCHER_FIELD_NUMBER = 2;
    private com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher labelMatcher_;
    /**
     * <pre>
     * Label Matcher to select a Workload based on
     * [flow labels](/concepts/flow-control/flow-label.md).
     * </pre>
     *
     * <code>.aperture.policy.language.v1.LabelMatcher label_matcher = 2 [json_name = "labelMatcher"];</code>
     * @return Whether the labelMatcher field is set.
     */
    @java.lang.Override
    public boolean hasLabelMatcher() {
      return labelMatcher_ != null;
    }
    /**
     * <pre>
     * Label Matcher to select a Workload based on
     * [flow labels](/concepts/flow-control/flow-label.md).
     * </pre>
     *
     * <code>.aperture.policy.language.v1.LabelMatcher label_matcher = 2 [json_name = "labelMatcher"];</code>
     * @return The labelMatcher.
     */
    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher getLabelMatcher() {
      return labelMatcher_ == null ? com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher.getDefaultInstance() : labelMatcher_;
    }
    /**
     * <pre>
     * Label Matcher to select a Workload based on
     * [flow labels](/concepts/flow-control/flow-label.md).
     * </pre>
     *
     * <code>.aperture.policy.language.v1.LabelMatcher label_matcher = 2 [json_name = "labelMatcher"];</code>
     */
    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.LabelMatcherOrBuilder getLabelMatcherOrBuilder() {
      return getLabelMatcher();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (parameters_ != null) {
        output.writeMessage(1, getParameters());
      }
      if (labelMatcher_ != null) {
        output.writeMessage(2, getLabelMatcher());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (parameters_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getParameters());
      }
      if (labelMatcher_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getLabelMatcher());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload)) {
        return super.equals(obj);
      }
      com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload other = (com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload) obj;

      if (hasParameters() != other.hasParameters()) return false;
      if (hasParameters()) {
        if (!getParameters()
            .equals(other.getParameters())) return false;
      }
      if (hasLabelMatcher() != other.hasLabelMatcher()) return false;
      if (hasLabelMatcher()) {
        if (!getLabelMatcher()
            .equals(other.getLabelMatcher())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasParameters()) {
        hash = (37 * hash) + PARAMETERS_FIELD_NUMBER;
        hash = (53 * hash) + getParameters().hashCode();
      }
      if (hasLabelMatcher()) {
        hash = (37 * hash) + LABEL_MATCHER_FIELD_NUMBER;
        hash = (53 * hash) + getLabelMatcher().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Workload defines a class of requests that preferably have similar properties such as response latency or desired priority.
     * </pre>
     *
     * Protobuf type {@code aperture.policy.language.v1.Scheduler.Workload}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:aperture.policy.language.v1.Scheduler.Workload)
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.WorkloadOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Workload_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Workload_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.class, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Builder.class);
      }

      // Construct using com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (parametersBuilder_ == null) {
          parameters_ = null;
        } else {
          parameters_ = null;
          parametersBuilder_ = null;
        }
        if (labelMatcherBuilder_ == null) {
          labelMatcher_ = null;
        } else {
          labelMatcher_ = null;
          labelMatcherBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Workload_descriptor;
      }

      @java.lang.Override
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload getDefaultInstanceForType() {
        return com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.getDefaultInstance();
      }

      @java.lang.Override
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload build() {
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload buildPartial() {
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload result = new com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload(this);
        if (parametersBuilder_ == null) {
          result.parameters_ = parameters_;
        } else {
          result.parameters_ = parametersBuilder_.build();
        }
        if (labelMatcherBuilder_ == null) {
          result.labelMatcher_ = labelMatcher_;
        } else {
          result.labelMatcher_ = labelMatcherBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload) {
          return mergeFrom((com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload other) {
        if (other == com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.getDefaultInstance()) return this;
        if (other.hasParameters()) {
          mergeParameters(other.getParameters());
        }
        if (other.hasLabelMatcher()) {
          mergeLabelMatcher(other.getLabelMatcher());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.Builder, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.ParametersOrBuilder> parametersBuilder_;
      /**
       * <pre>
       * Parameters associated with flows matching the label matcher.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters = 1 [json_name = "parameters"];</code>
       * @return Whether the parameters field is set.
       */
      public boolean hasParameters() {
        return parametersBuilder_ != null || parameters_ != null;
      }
      /**
       * <pre>
       * Parameters associated with flows matching the label matcher.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters = 1 [json_name = "parameters"];</code>
       * @return The parameters.
       */
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters getParameters() {
        if (parametersBuilder_ == null) {
          return parameters_ == null ? com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.getDefaultInstance() : parameters_;
        } else {
          return parametersBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Parameters associated with flows matching the label matcher.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters = 1 [json_name = "parameters"];</code>
       */
      public Builder setParameters(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters value) {
        if (parametersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          parameters_ = value;
          onChanged();
        } else {
          parametersBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Parameters associated with flows matching the label matcher.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters = 1 [json_name = "parameters"];</code>
       */
      public Builder setParameters(
          com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.Builder builderForValue) {
        if (parametersBuilder_ == null) {
          parameters_ = builderForValue.build();
          onChanged();
        } else {
          parametersBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Parameters associated with flows matching the label matcher.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters = 1 [json_name = "parameters"];</code>
       */
      public Builder mergeParameters(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters value) {
        if (parametersBuilder_ == null) {
          if (parameters_ != null) {
            parameters_ =
              com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.newBuilder(parameters_).mergeFrom(value).buildPartial();
          } else {
            parameters_ = value;
          }
          onChanged();
        } else {
          parametersBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Parameters associated with flows matching the label matcher.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters = 1 [json_name = "parameters"];</code>
       */
      public Builder clearParameters() {
        if (parametersBuilder_ == null) {
          parameters_ = null;
          onChanged();
        } else {
          parameters_ = null;
          parametersBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Parameters associated with flows matching the label matcher.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters = 1 [json_name = "parameters"];</code>
       */
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.Builder getParametersBuilder() {
        
        onChanged();
        return getParametersFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Parameters associated with flows matching the label matcher.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters = 1 [json_name = "parameters"];</code>
       */
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.ParametersOrBuilder getParametersOrBuilder() {
        if (parametersBuilder_ != null) {
          return parametersBuilder_.getMessageOrBuilder();
        } else {
          return parameters_ == null ?
              com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.getDefaultInstance() : parameters_;
        }
      }
      /**
       * <pre>
       * Parameters associated with flows matching the label matcher.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters parameters = 1 [json_name = "parameters"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.Builder, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.ParametersOrBuilder> 
          getParametersFieldBuilder() {
        if (parametersBuilder_ == null) {
          parametersBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.Builder, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.ParametersOrBuilder>(
                  getParameters(),
                  getParentForChildren(),
                  isClean());
          parameters_ = null;
        }
        return parametersBuilder_;
      }

      private com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher labelMatcher_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher, com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher.Builder, com.fluxninja.generated.aperture.policy.language.v1.LabelMatcherOrBuilder> labelMatcherBuilder_;
      /**
       * <pre>
       * Label Matcher to select a Workload based on
       * [flow labels](/concepts/flow-control/flow-label.md).
       * </pre>
       *
       * <code>.aperture.policy.language.v1.LabelMatcher label_matcher = 2 [json_name = "labelMatcher"];</code>
       * @return Whether the labelMatcher field is set.
       */
      public boolean hasLabelMatcher() {
        return labelMatcherBuilder_ != null || labelMatcher_ != null;
      }
      /**
       * <pre>
       * Label Matcher to select a Workload based on
       * [flow labels](/concepts/flow-control/flow-label.md).
       * </pre>
       *
       * <code>.aperture.policy.language.v1.LabelMatcher label_matcher = 2 [json_name = "labelMatcher"];</code>
       * @return The labelMatcher.
       */
      public com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher getLabelMatcher() {
        if (labelMatcherBuilder_ == null) {
          return labelMatcher_ == null ? com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher.getDefaultInstance() : labelMatcher_;
        } else {
          return labelMatcherBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Label Matcher to select a Workload based on
       * [flow labels](/concepts/flow-control/flow-label.md).
       * </pre>
       *
       * <code>.aperture.policy.language.v1.LabelMatcher label_matcher = 2 [json_name = "labelMatcher"];</code>
       */
      public Builder setLabelMatcher(com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher value) {
        if (labelMatcherBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          labelMatcher_ = value;
          onChanged();
        } else {
          labelMatcherBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Label Matcher to select a Workload based on
       * [flow labels](/concepts/flow-control/flow-label.md).
       * </pre>
       *
       * <code>.aperture.policy.language.v1.LabelMatcher label_matcher = 2 [json_name = "labelMatcher"];</code>
       */
      public Builder setLabelMatcher(
          com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher.Builder builderForValue) {
        if (labelMatcherBuilder_ == null) {
          labelMatcher_ = builderForValue.build();
          onChanged();
        } else {
          labelMatcherBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Label Matcher to select a Workload based on
       * [flow labels](/concepts/flow-control/flow-label.md).
       * </pre>
       *
       * <code>.aperture.policy.language.v1.LabelMatcher label_matcher = 2 [json_name = "labelMatcher"];</code>
       */
      public Builder mergeLabelMatcher(com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher value) {
        if (labelMatcherBuilder_ == null) {
          if (labelMatcher_ != null) {
            labelMatcher_ =
              com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher.newBuilder(labelMatcher_).mergeFrom(value).buildPartial();
          } else {
            labelMatcher_ = value;
          }
          onChanged();
        } else {
          labelMatcherBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Label Matcher to select a Workload based on
       * [flow labels](/concepts/flow-control/flow-label.md).
       * </pre>
       *
       * <code>.aperture.policy.language.v1.LabelMatcher label_matcher = 2 [json_name = "labelMatcher"];</code>
       */
      public Builder clearLabelMatcher() {
        if (labelMatcherBuilder_ == null) {
          labelMatcher_ = null;
          onChanged();
        } else {
          labelMatcher_ = null;
          labelMatcherBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Label Matcher to select a Workload based on
       * [flow labels](/concepts/flow-control/flow-label.md).
       * </pre>
       *
       * <code>.aperture.policy.language.v1.LabelMatcher label_matcher = 2 [json_name = "labelMatcher"];</code>
       */
      public com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher.Builder getLabelMatcherBuilder() {
        
        onChanged();
        return getLabelMatcherFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Label Matcher to select a Workload based on
       * [flow labels](/concepts/flow-control/flow-label.md).
       * </pre>
       *
       * <code>.aperture.policy.language.v1.LabelMatcher label_matcher = 2 [json_name = "labelMatcher"];</code>
       */
      public com.fluxninja.generated.aperture.policy.language.v1.LabelMatcherOrBuilder getLabelMatcherOrBuilder() {
        if (labelMatcherBuilder_ != null) {
          return labelMatcherBuilder_.getMessageOrBuilder();
        } else {
          return labelMatcher_ == null ?
              com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher.getDefaultInstance() : labelMatcher_;
        }
      }
      /**
       * <pre>
       * Label Matcher to select a Workload based on
       * [flow labels](/concepts/flow-control/flow-label.md).
       * </pre>
       *
       * <code>.aperture.policy.language.v1.LabelMatcher label_matcher = 2 [json_name = "labelMatcher"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher, com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher.Builder, com.fluxninja.generated.aperture.policy.language.v1.LabelMatcherOrBuilder> 
          getLabelMatcherFieldBuilder() {
        if (labelMatcherBuilder_ == null) {
          labelMatcherBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher, com.fluxninja.generated.aperture.policy.language.v1.LabelMatcher.Builder, com.fluxninja.generated.aperture.policy.language.v1.LabelMatcherOrBuilder>(
                  getLabelMatcher(),
                  getParentForChildren(),
                  isClean());
          labelMatcher_ = null;
        }
        return labelMatcherBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:aperture.policy.language.v1.Scheduler.Workload)
    }

    // @@protoc_insertion_point(class_scope:aperture.policy.language.v1.Scheduler.Workload)
    private static final com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload();
    }

    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Workload>
        PARSER = new com.google.protobuf.AbstractParser<Workload>() {
      @java.lang.Override
      public Workload parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Workload(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Workload> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Workload> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ParametersOrBuilder extends
      // @@protoc_insertion_point(interface_extends:aperture.policy.language.v1.Scheduler.Parameters)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * List of workloads to be used in scheduler.
     * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
     * allows for load-shedding to be "smarter" than just "randomly deny 50% of
     * requests". There are two aspects of this "smartness":
     * * Scheduler can more precisely calculate concurrency if it understands
     *   that flows belonging to different classes have different weights (eg.
     *   inserts vs lookups).
     * * Setting different priorities to different workloads lets the scheduler
     *   avoid dropping important traffic during overload.
     * Each workload in this list specifies also a matcher that's used to
     * determine which flow will be categorized into which workload.
     * In case of multiple matching workloads, the first matching one will be used.
     * If none of workloads match, `default_workload` will be used.
     * :::info
     * See also [workload definition in the concepts
     * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
     * :::
     * </pre>
     *
     * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
     */
    java.util.List<com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload> 
        getWorkloadsList();
    /**
     * <pre>
     * List of workloads to be used in scheduler.
     * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
     * allows for load-shedding to be "smarter" than just "randomly deny 50% of
     * requests". There are two aspects of this "smartness":
     * * Scheduler can more precisely calculate concurrency if it understands
     *   that flows belonging to different classes have different weights (eg.
     *   inserts vs lookups).
     * * Setting different priorities to different workloads lets the scheduler
     *   avoid dropping important traffic during overload.
     * Each workload in this list specifies also a matcher that's used to
     * determine which flow will be categorized into which workload.
     * In case of multiple matching workloads, the first matching one will be used.
     * If none of workloads match, `default_workload` will be used.
     * :::info
     * See also [workload definition in the concepts
     * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
     * :::
     * </pre>
     *
     * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
     */
    com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload getWorkloads(int index);
    /**
     * <pre>
     * List of workloads to be used in scheduler.
     * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
     * allows for load-shedding to be "smarter" than just "randomly deny 50% of
     * requests". There are two aspects of this "smartness":
     * * Scheduler can more precisely calculate concurrency if it understands
     *   that flows belonging to different classes have different weights (eg.
     *   inserts vs lookups).
     * * Setting different priorities to different workloads lets the scheduler
     *   avoid dropping important traffic during overload.
     * Each workload in this list specifies also a matcher that's used to
     * determine which flow will be categorized into which workload.
     * In case of multiple matching workloads, the first matching one will be used.
     * If none of workloads match, `default_workload` will be used.
     * :::info
     * See also [workload definition in the concepts
     * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
     * :::
     * </pre>
     *
     * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
     */
    int getWorkloadsCount();
    /**
     * <pre>
     * List of workloads to be used in scheduler.
     * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
     * allows for load-shedding to be "smarter" than just "randomly deny 50% of
     * requests". There are two aspects of this "smartness":
     * * Scheduler can more precisely calculate concurrency if it understands
     *   that flows belonging to different classes have different weights (eg.
     *   inserts vs lookups).
     * * Setting different priorities to different workloads lets the scheduler
     *   avoid dropping important traffic during overload.
     * Each workload in this list specifies also a matcher that's used to
     * determine which flow will be categorized into which workload.
     * In case of multiple matching workloads, the first matching one will be used.
     * If none of workloads match, `default_workload` will be used.
     * :::info
     * See also [workload definition in the concepts
     * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
     * :::
     * </pre>
     *
     * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
     */
    java.util.List<? extends com.fluxninja.generated.aperture.policy.language.v1.Scheduler.WorkloadOrBuilder> 
        getWorkloadsOrBuilderList();
    /**
     * <pre>
     * List of workloads to be used in scheduler.
     * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
     * allows for load-shedding to be "smarter" than just "randomly deny 50% of
     * requests". There are two aspects of this "smartness":
     * * Scheduler can more precisely calculate concurrency if it understands
     *   that flows belonging to different classes have different weights (eg.
     *   inserts vs lookups).
     * * Setting different priorities to different workloads lets the scheduler
     *   avoid dropping important traffic during overload.
     * Each workload in this list specifies also a matcher that's used to
     * determine which flow will be categorized into which workload.
     * In case of multiple matching workloads, the first matching one will be used.
     * If none of workloads match, `default_workload` will be used.
     * :::info
     * See also [workload definition in the concepts
     * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
     * :::
     * </pre>
     *
     * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
     */
    com.fluxninja.generated.aperture.policy.language.v1.Scheduler.WorkloadOrBuilder getWorkloadsOrBuilder(
        int index);

    /**
     * <pre>
     * Parameters to be used if none of workloads specified in `workloads` match.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters default_workload_parameters = 2 [json_name = "defaultWorkloadParameters"];</code>
     * @return Whether the defaultWorkloadParameters field is set.
     */
    boolean hasDefaultWorkloadParameters();
    /**
     * <pre>
     * Parameters to be used if none of workloads specified in `workloads` match.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters default_workload_parameters = 2 [json_name = "defaultWorkloadParameters"];</code>
     * @return The defaultWorkloadParameters.
     */
    com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters getDefaultWorkloadParameters();
    /**
     * <pre>
     * Parameters to be used if none of workloads specified in `workloads` match.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters default_workload_parameters = 2 [json_name = "defaultWorkloadParameters"];</code>
     */
    com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.ParametersOrBuilder getDefaultWorkloadParametersOrBuilder();

    /**
     * <pre>
     * Automatically estimate the size of a request in each workload, based on
     * historical latency. Each workload's `tokens` will be set to average
     * latency of flows in that workload during last few seconds (exact duration
     * of this average can change).
     * Make sure to not provide `tokens` in workload definitions or in the flow
     * if you want to use this feature.
     * </pre>
     *
     * <code>bool auto_tokens = 3 [json_name = "autoTokens"];</code>
     * @return The autoTokens.
     */
    boolean getAutoTokens();

    /**
     * <pre>
     * Timeout as a factor of tokens for a flow in a workload in case auto_tokens is set to true.
     * If a flow is not able to get tokens within `timeout_factor * tokens` of duration,
     * it will be rejected.
     * This value impacts the prioritization and fairness because the larger the timeout the higher the chance a request has to get scheduled.
     * </pre>
     *
     * <code>double timeout_factor = 4 [json_name = "timeoutFactor"];</code>
     * @return The timeoutFactor.
     */
    double getTimeoutFactor();

    /**
     * <pre>
     * Max Timeout is the value with which the flow timeout is capped.
     * When auto_tokens feature is not enabled, this value is used as the
     * timeout for the flow, otherwise it is used as a cap for the timeout.
     * :::caution
     * This timeout needs to be strictly less than the timeout set on the
     * client for the whole GRPC call:
     * * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
     * * in case of libraries, timeout configured... TODO.
     * We're using fail-open logic in integrations, so if the GRPC timeout
     * fires first, the flow will end up being unconditionally allowed while
     * it're still waiting on the scheduler.
     * To avoid such cases, the end-to-end GRPC timeout should also contain
     * some headroom for constant overhead like serialization, etc. Default
     * value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
     * tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
     * :::
     * </pre>
     *
     * <code>.google.protobuf.Duration max_timeout = 5 [json_name = "maxTimeout"];</code>
     * @return Whether the maxTimeout field is set.
     */
    boolean hasMaxTimeout();
    /**
     * <pre>
     * Max Timeout is the value with which the flow timeout is capped.
     * When auto_tokens feature is not enabled, this value is used as the
     * timeout for the flow, otherwise it is used as a cap for the timeout.
     * :::caution
     * This timeout needs to be strictly less than the timeout set on the
     * client for the whole GRPC call:
     * * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
     * * in case of libraries, timeout configured... TODO.
     * We're using fail-open logic in integrations, so if the GRPC timeout
     * fires first, the flow will end up being unconditionally allowed while
     * it're still waiting on the scheduler.
     * To avoid such cases, the end-to-end GRPC timeout should also contain
     * some headroom for constant overhead like serialization, etc. Default
     * value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
     * tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
     * :::
     * </pre>
     *
     * <code>.google.protobuf.Duration max_timeout = 5 [json_name = "maxTimeout"];</code>
     * @return The maxTimeout.
     */
    com.google.protobuf.Duration getMaxTimeout();
    /**
     * <pre>
     * Max Timeout is the value with which the flow timeout is capped.
     * When auto_tokens feature is not enabled, this value is used as the
     * timeout for the flow, otherwise it is used as a cap for the timeout.
     * :::caution
     * This timeout needs to be strictly less than the timeout set on the
     * client for the whole GRPC call:
     * * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
     * * in case of libraries, timeout configured... TODO.
     * We're using fail-open logic in integrations, so if the GRPC timeout
     * fires first, the flow will end up being unconditionally allowed while
     * it're still waiting on the scheduler.
     * To avoid such cases, the end-to-end GRPC timeout should also contain
     * some headroom for constant overhead like serialization, etc. Default
     * value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
     * tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
     * :::
     * </pre>
     *
     * <code>.google.protobuf.Duration max_timeout = 5 [json_name = "maxTimeout"];</code>
     */
    com.google.protobuf.DurationOrBuilder getMaxTimeoutOrBuilder();
  }
  /**
   * <pre>
   * Scheduler parameters
   * </pre>
   *
   * Protobuf type {@code aperture.policy.language.v1.Scheduler.Parameters}
   */
  public static final class Parameters extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:aperture.policy.language.v1.Scheduler.Parameters)
      ParametersOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Parameters.newBuilder() to construct.
    private Parameters(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Parameters() {
      workloads_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Parameters();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Parameters(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                workloads_ = new java.util.ArrayList<com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload>();
                mutable_bitField0_ |= 0x00000001;
              }
              workloads_.add(
                  input.readMessage(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.parser(), extensionRegistry));
              break;
            }
            case 18: {
              com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.Builder subBuilder = null;
              if (defaultWorkloadParameters_ != null) {
                subBuilder = defaultWorkloadParameters_.toBuilder();
              }
              defaultWorkloadParameters_ = input.readMessage(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(defaultWorkloadParameters_);
                defaultWorkloadParameters_ = subBuilder.buildPartial();
              }

              break;
            }
            case 24: {

              autoTokens_ = input.readBool();
              break;
            }
            case 33: {

              timeoutFactor_ = input.readDouble();
              break;
            }
            case 42: {
              com.google.protobuf.Duration.Builder subBuilder = null;
              if (maxTimeout_ != null) {
                subBuilder = maxTimeout_.toBuilder();
              }
              maxTimeout_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(maxTimeout_);
                maxTimeout_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (com.google.protobuf.UninitializedMessageException e) {
        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          workloads_ = java.util.Collections.unmodifiableList(workloads_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Parameters_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Parameters_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.class, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.Builder.class);
    }

    public static final int WORKLOADS_FIELD_NUMBER = 1;
    private java.util.List<com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload> workloads_;
    /**
     * <pre>
     * List of workloads to be used in scheduler.
     * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
     * allows for load-shedding to be "smarter" than just "randomly deny 50% of
     * requests". There are two aspects of this "smartness":
     * * Scheduler can more precisely calculate concurrency if it understands
     *   that flows belonging to different classes have different weights (eg.
     *   inserts vs lookups).
     * * Setting different priorities to different workloads lets the scheduler
     *   avoid dropping important traffic during overload.
     * Each workload in this list specifies also a matcher that's used to
     * determine which flow will be categorized into which workload.
     * In case of multiple matching workloads, the first matching one will be used.
     * If none of workloads match, `default_workload` will be used.
     * :::info
     * See also [workload definition in the concepts
     * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
     * :::
     * </pre>
     *
     * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
     */
    @java.lang.Override
    public java.util.List<com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload> getWorkloadsList() {
      return workloads_;
    }
    /**
     * <pre>
     * List of workloads to be used in scheduler.
     * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
     * allows for load-shedding to be "smarter" than just "randomly deny 50% of
     * requests". There are two aspects of this "smartness":
     * * Scheduler can more precisely calculate concurrency if it understands
     *   that flows belonging to different classes have different weights (eg.
     *   inserts vs lookups).
     * * Setting different priorities to different workloads lets the scheduler
     *   avoid dropping important traffic during overload.
     * Each workload in this list specifies also a matcher that's used to
     * determine which flow will be categorized into which workload.
     * In case of multiple matching workloads, the first matching one will be used.
     * If none of workloads match, `default_workload` will be used.
     * :::info
     * See also [workload definition in the concepts
     * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
     * :::
     * </pre>
     *
     * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.fluxninja.generated.aperture.policy.language.v1.Scheduler.WorkloadOrBuilder> 
        getWorkloadsOrBuilderList() {
      return workloads_;
    }
    /**
     * <pre>
     * List of workloads to be used in scheduler.
     * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
     * allows for load-shedding to be "smarter" than just "randomly deny 50% of
     * requests". There are two aspects of this "smartness":
     * * Scheduler can more precisely calculate concurrency if it understands
     *   that flows belonging to different classes have different weights (eg.
     *   inserts vs lookups).
     * * Setting different priorities to different workloads lets the scheduler
     *   avoid dropping important traffic during overload.
     * Each workload in this list specifies also a matcher that's used to
     * determine which flow will be categorized into which workload.
     * In case of multiple matching workloads, the first matching one will be used.
     * If none of workloads match, `default_workload` will be used.
     * :::info
     * See also [workload definition in the concepts
     * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
     * :::
     * </pre>
     *
     * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
     */
    @java.lang.Override
    public int getWorkloadsCount() {
      return workloads_.size();
    }
    /**
     * <pre>
     * List of workloads to be used in scheduler.
     * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
     * allows for load-shedding to be "smarter" than just "randomly deny 50% of
     * requests". There are two aspects of this "smartness":
     * * Scheduler can more precisely calculate concurrency if it understands
     *   that flows belonging to different classes have different weights (eg.
     *   inserts vs lookups).
     * * Setting different priorities to different workloads lets the scheduler
     *   avoid dropping important traffic during overload.
     * Each workload in this list specifies also a matcher that's used to
     * determine which flow will be categorized into which workload.
     * In case of multiple matching workloads, the first matching one will be used.
     * If none of workloads match, `default_workload` will be used.
     * :::info
     * See also [workload definition in the concepts
     * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
     * :::
     * </pre>
     *
     * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
     */
    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload getWorkloads(int index) {
      return workloads_.get(index);
    }
    /**
     * <pre>
     * List of workloads to be used in scheduler.
     * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
     * allows for load-shedding to be "smarter" than just "randomly deny 50% of
     * requests". There are two aspects of this "smartness":
     * * Scheduler can more precisely calculate concurrency if it understands
     *   that flows belonging to different classes have different weights (eg.
     *   inserts vs lookups).
     * * Setting different priorities to different workloads lets the scheduler
     *   avoid dropping important traffic during overload.
     * Each workload in this list specifies also a matcher that's used to
     * determine which flow will be categorized into which workload.
     * In case of multiple matching workloads, the first matching one will be used.
     * If none of workloads match, `default_workload` will be used.
     * :::info
     * See also [workload definition in the concepts
     * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
     * :::
     * </pre>
     *
     * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
     */
    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.WorkloadOrBuilder getWorkloadsOrBuilder(
        int index) {
      return workloads_.get(index);
    }

    public static final int DEFAULT_WORKLOAD_PARAMETERS_FIELD_NUMBER = 2;
    private com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters defaultWorkloadParameters_;
    /**
     * <pre>
     * Parameters to be used if none of workloads specified in `workloads` match.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters default_workload_parameters = 2 [json_name = "defaultWorkloadParameters"];</code>
     * @return Whether the defaultWorkloadParameters field is set.
     */
    @java.lang.Override
    public boolean hasDefaultWorkloadParameters() {
      return defaultWorkloadParameters_ != null;
    }
    /**
     * <pre>
     * Parameters to be used if none of workloads specified in `workloads` match.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters default_workload_parameters = 2 [json_name = "defaultWorkloadParameters"];</code>
     * @return The defaultWorkloadParameters.
     */
    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters getDefaultWorkloadParameters() {
      return defaultWorkloadParameters_ == null ? com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.getDefaultInstance() : defaultWorkloadParameters_;
    }
    /**
     * <pre>
     * Parameters to be used if none of workloads specified in `workloads` match.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters default_workload_parameters = 2 [json_name = "defaultWorkloadParameters"];</code>
     */
    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.ParametersOrBuilder getDefaultWorkloadParametersOrBuilder() {
      return getDefaultWorkloadParameters();
    }

    public static final int AUTO_TOKENS_FIELD_NUMBER = 3;
    private boolean autoTokens_;
    /**
     * <pre>
     * Automatically estimate the size of a request in each workload, based on
     * historical latency. Each workload's `tokens` will be set to average
     * latency of flows in that workload during last few seconds (exact duration
     * of this average can change).
     * Make sure to not provide `tokens` in workload definitions or in the flow
     * if you want to use this feature.
     * </pre>
     *
     * <code>bool auto_tokens = 3 [json_name = "autoTokens"];</code>
     * @return The autoTokens.
     */
    @java.lang.Override
    public boolean getAutoTokens() {
      return autoTokens_;
    }

    public static final int TIMEOUT_FACTOR_FIELD_NUMBER = 4;
    private double timeoutFactor_;
    /**
     * <pre>
     * Timeout as a factor of tokens for a flow in a workload in case auto_tokens is set to true.
     * If a flow is not able to get tokens within `timeout_factor * tokens` of duration,
     * it will be rejected.
     * This value impacts the prioritization and fairness because the larger the timeout the higher the chance a request has to get scheduled.
     * </pre>
     *
     * <code>double timeout_factor = 4 [json_name = "timeoutFactor"];</code>
     * @return The timeoutFactor.
     */
    @java.lang.Override
    public double getTimeoutFactor() {
      return timeoutFactor_;
    }

    public static final int MAX_TIMEOUT_FIELD_NUMBER = 5;
    private com.google.protobuf.Duration maxTimeout_;
    /**
     * <pre>
     * Max Timeout is the value with which the flow timeout is capped.
     * When auto_tokens feature is not enabled, this value is used as the
     * timeout for the flow, otherwise it is used as a cap for the timeout.
     * :::caution
     * This timeout needs to be strictly less than the timeout set on the
     * client for the whole GRPC call:
     * * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
     * * in case of libraries, timeout configured... TODO.
     * We're using fail-open logic in integrations, so if the GRPC timeout
     * fires first, the flow will end up being unconditionally allowed while
     * it're still waiting on the scheduler.
     * To avoid such cases, the end-to-end GRPC timeout should also contain
     * some headroom for constant overhead like serialization, etc. Default
     * value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
     * tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
     * :::
     * </pre>
     *
     * <code>.google.protobuf.Duration max_timeout = 5 [json_name = "maxTimeout"];</code>
     * @return Whether the maxTimeout field is set.
     */
    @java.lang.Override
    public boolean hasMaxTimeout() {
      return maxTimeout_ != null;
    }
    /**
     * <pre>
     * Max Timeout is the value with which the flow timeout is capped.
     * When auto_tokens feature is not enabled, this value is used as the
     * timeout for the flow, otherwise it is used as a cap for the timeout.
     * :::caution
     * This timeout needs to be strictly less than the timeout set on the
     * client for the whole GRPC call:
     * * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
     * * in case of libraries, timeout configured... TODO.
     * We're using fail-open logic in integrations, so if the GRPC timeout
     * fires first, the flow will end up being unconditionally allowed while
     * it're still waiting on the scheduler.
     * To avoid such cases, the end-to-end GRPC timeout should also contain
     * some headroom for constant overhead like serialization, etc. Default
     * value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
     * tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
     * :::
     * </pre>
     *
     * <code>.google.protobuf.Duration max_timeout = 5 [json_name = "maxTimeout"];</code>
     * @return The maxTimeout.
     */
    @java.lang.Override
    public com.google.protobuf.Duration getMaxTimeout() {
      return maxTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : maxTimeout_;
    }
    /**
     * <pre>
     * Max Timeout is the value with which the flow timeout is capped.
     * When auto_tokens feature is not enabled, this value is used as the
     * timeout for the flow, otherwise it is used as a cap for the timeout.
     * :::caution
     * This timeout needs to be strictly less than the timeout set on the
     * client for the whole GRPC call:
     * * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
     * * in case of libraries, timeout configured... TODO.
     * We're using fail-open logic in integrations, so if the GRPC timeout
     * fires first, the flow will end up being unconditionally allowed while
     * it're still waiting on the scheduler.
     * To avoid such cases, the end-to-end GRPC timeout should also contain
     * some headroom for constant overhead like serialization, etc. Default
     * value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
     * tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
     * :::
     * </pre>
     *
     * <code>.google.protobuf.Duration max_timeout = 5 [json_name = "maxTimeout"];</code>
     */
    @java.lang.Override
    public com.google.protobuf.DurationOrBuilder getMaxTimeoutOrBuilder() {
      return getMaxTimeout();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < workloads_.size(); i++) {
        output.writeMessage(1, workloads_.get(i));
      }
      if (defaultWorkloadParameters_ != null) {
        output.writeMessage(2, getDefaultWorkloadParameters());
      }
      if (autoTokens_ != false) {
        output.writeBool(3, autoTokens_);
      }
      if (java.lang.Double.doubleToRawLongBits(timeoutFactor_) != 0) {
        output.writeDouble(4, timeoutFactor_);
      }
      if (maxTimeout_ != null) {
        output.writeMessage(5, getMaxTimeout());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < workloads_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, workloads_.get(i));
      }
      if (defaultWorkloadParameters_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getDefaultWorkloadParameters());
      }
      if (autoTokens_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, autoTokens_);
      }
      if (java.lang.Double.doubleToRawLongBits(timeoutFactor_) != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(4, timeoutFactor_);
      }
      if (maxTimeout_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getMaxTimeout());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters)) {
        return super.equals(obj);
      }
      com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters other = (com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters) obj;

      if (!getWorkloadsList()
          .equals(other.getWorkloadsList())) return false;
      if (hasDefaultWorkloadParameters() != other.hasDefaultWorkloadParameters()) return false;
      if (hasDefaultWorkloadParameters()) {
        if (!getDefaultWorkloadParameters()
            .equals(other.getDefaultWorkloadParameters())) return false;
      }
      if (getAutoTokens()
          != other.getAutoTokens()) return false;
      if (java.lang.Double.doubleToLongBits(getTimeoutFactor())
          != java.lang.Double.doubleToLongBits(
              other.getTimeoutFactor())) return false;
      if (hasMaxTimeout() != other.hasMaxTimeout()) return false;
      if (hasMaxTimeout()) {
        if (!getMaxTimeout()
            .equals(other.getMaxTimeout())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getWorkloadsCount() > 0) {
        hash = (37 * hash) + WORKLOADS_FIELD_NUMBER;
        hash = (53 * hash) + getWorkloadsList().hashCode();
      }
      if (hasDefaultWorkloadParameters()) {
        hash = (37 * hash) + DEFAULT_WORKLOAD_PARAMETERS_FIELD_NUMBER;
        hash = (53 * hash) + getDefaultWorkloadParameters().hashCode();
      }
      hash = (37 * hash) + AUTO_TOKENS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getAutoTokens());
      hash = (37 * hash) + TIMEOUT_FACTOR_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          java.lang.Double.doubleToLongBits(getTimeoutFactor()));
      if (hasMaxTimeout()) {
        hash = (37 * hash) + MAX_TIMEOUT_FIELD_NUMBER;
        hash = (53 * hash) + getMaxTimeout().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Scheduler parameters
     * </pre>
     *
     * Protobuf type {@code aperture.policy.language.v1.Scheduler.Parameters}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:aperture.policy.language.v1.Scheduler.Parameters)
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.ParametersOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Parameters_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Parameters_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.class, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.Builder.class);
      }

      // Construct using com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getWorkloadsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (workloadsBuilder_ == null) {
          workloads_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          workloadsBuilder_.clear();
        }
        if (defaultWorkloadParametersBuilder_ == null) {
          defaultWorkloadParameters_ = null;
        } else {
          defaultWorkloadParameters_ = null;
          defaultWorkloadParametersBuilder_ = null;
        }
        autoTokens_ = false;

        timeoutFactor_ = 0D;

        if (maxTimeoutBuilder_ == null) {
          maxTimeout_ = null;
        } else {
          maxTimeout_ = null;
          maxTimeoutBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Parameters_descriptor;
      }

      @java.lang.Override
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters getDefaultInstanceForType() {
        return com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.getDefaultInstance();
      }

      @java.lang.Override
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters build() {
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters buildPartial() {
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters result = new com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters(this);
        int from_bitField0_ = bitField0_;
        if (workloadsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            workloads_ = java.util.Collections.unmodifiableList(workloads_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.workloads_ = workloads_;
        } else {
          result.workloads_ = workloadsBuilder_.build();
        }
        if (defaultWorkloadParametersBuilder_ == null) {
          result.defaultWorkloadParameters_ = defaultWorkloadParameters_;
        } else {
          result.defaultWorkloadParameters_ = defaultWorkloadParametersBuilder_.build();
        }
        result.autoTokens_ = autoTokens_;
        result.timeoutFactor_ = timeoutFactor_;
        if (maxTimeoutBuilder_ == null) {
          result.maxTimeout_ = maxTimeout_;
        } else {
          result.maxTimeout_ = maxTimeoutBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters) {
          return mergeFrom((com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters other) {
        if (other == com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.getDefaultInstance()) return this;
        if (workloadsBuilder_ == null) {
          if (!other.workloads_.isEmpty()) {
            if (workloads_.isEmpty()) {
              workloads_ = other.workloads_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureWorkloadsIsMutable();
              workloads_.addAll(other.workloads_);
            }
            onChanged();
          }
        } else {
          if (!other.workloads_.isEmpty()) {
            if (workloadsBuilder_.isEmpty()) {
              workloadsBuilder_.dispose();
              workloadsBuilder_ = null;
              workloads_ = other.workloads_;
              bitField0_ = (bitField0_ & ~0x00000001);
              workloadsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getWorkloadsFieldBuilder() : null;
            } else {
              workloadsBuilder_.addAllMessages(other.workloads_);
            }
          }
        }
        if (other.hasDefaultWorkloadParameters()) {
          mergeDefaultWorkloadParameters(other.getDefaultWorkloadParameters());
        }
        if (other.getAutoTokens() != false) {
          setAutoTokens(other.getAutoTokens());
        }
        if (other.getTimeoutFactor() != 0D) {
          setTimeoutFactor(other.getTimeoutFactor());
        }
        if (other.hasMaxTimeout()) {
          mergeMaxTimeout(other.getMaxTimeout());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload> workloads_ =
        java.util.Collections.emptyList();
      private void ensureWorkloadsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          workloads_ = new java.util.ArrayList<com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload>(workloads_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Builder, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.WorkloadOrBuilder> workloadsBuilder_;

      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public java.util.List<com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload> getWorkloadsList() {
        if (workloadsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(workloads_);
        } else {
          return workloadsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public int getWorkloadsCount() {
        if (workloadsBuilder_ == null) {
          return workloads_.size();
        } else {
          return workloadsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload getWorkloads(int index) {
        if (workloadsBuilder_ == null) {
          return workloads_.get(index);
        } else {
          return workloadsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public Builder setWorkloads(
          int index, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload value) {
        if (workloadsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWorkloadsIsMutable();
          workloads_.set(index, value);
          onChanged();
        } else {
          workloadsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public Builder setWorkloads(
          int index, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Builder builderForValue) {
        if (workloadsBuilder_ == null) {
          ensureWorkloadsIsMutable();
          workloads_.set(index, builderForValue.build());
          onChanged();
        } else {
          workloadsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public Builder addWorkloads(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload value) {
        if (workloadsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWorkloadsIsMutable();
          workloads_.add(value);
          onChanged();
        } else {
          workloadsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public Builder addWorkloads(
          int index, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload value) {
        if (workloadsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWorkloadsIsMutable();
          workloads_.add(index, value);
          onChanged();
        } else {
          workloadsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public Builder addWorkloads(
          com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Builder builderForValue) {
        if (workloadsBuilder_ == null) {
          ensureWorkloadsIsMutable();
          workloads_.add(builderForValue.build());
          onChanged();
        } else {
          workloadsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public Builder addWorkloads(
          int index, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Builder builderForValue) {
        if (workloadsBuilder_ == null) {
          ensureWorkloadsIsMutable();
          workloads_.add(index, builderForValue.build());
          onChanged();
        } else {
          workloadsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public Builder addAllWorkloads(
          java.lang.Iterable<? extends com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload> values) {
        if (workloadsBuilder_ == null) {
          ensureWorkloadsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, workloads_);
          onChanged();
        } else {
          workloadsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public Builder clearWorkloads() {
        if (workloadsBuilder_ == null) {
          workloads_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          workloadsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public Builder removeWorkloads(int index) {
        if (workloadsBuilder_ == null) {
          ensureWorkloadsIsMutable();
          workloads_.remove(index);
          onChanged();
        } else {
          workloadsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Builder getWorkloadsBuilder(
          int index) {
        return getWorkloadsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.WorkloadOrBuilder getWorkloadsOrBuilder(
          int index) {
        if (workloadsBuilder_ == null) {
          return workloads_.get(index);  } else {
          return workloadsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public java.util.List<? extends com.fluxninja.generated.aperture.policy.language.v1.Scheduler.WorkloadOrBuilder> 
           getWorkloadsOrBuilderList() {
        if (workloadsBuilder_ != null) {
          return workloadsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(workloads_);
        }
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Builder addWorkloadsBuilder() {
        return getWorkloadsFieldBuilder().addBuilder(
            com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.getDefaultInstance());
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Builder addWorkloadsBuilder(
          int index) {
        return getWorkloadsFieldBuilder().addBuilder(
            index, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.getDefaultInstance());
      }
      /**
       * <pre>
       * List of workloads to be used in scheduler.
       * Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
       * allows for load-shedding to be "smarter" than just "randomly deny 50% of
       * requests". There are two aspects of this "smartness":
       * * Scheduler can more precisely calculate concurrency if it understands
       *   that flows belonging to different classes have different weights (eg.
       *   inserts vs lookups).
       * * Setting different priorities to different workloads lets the scheduler
       *   avoid dropping important traffic during overload.
       * Each workload in this list specifies also a matcher that's used to
       * determine which flow will be categorized into which workload.
       * In case of multiple matching workloads, the first matching one will be used.
       * If none of workloads match, `default_workload` will be used.
       * :::info
       * See also [workload definition in the concepts
       * section](/concepts/flow-control/components/concurrency-limiter.md#workload).
       * :::
       * </pre>
       *
       * <code>repeated .aperture.policy.language.v1.Scheduler.Workload workloads = 1 [json_name = "workloads"];</code>
       */
      public java.util.List<com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Builder> 
           getWorkloadsBuilderList() {
        return getWorkloadsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Builder, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.WorkloadOrBuilder> 
          getWorkloadsFieldBuilder() {
        if (workloadsBuilder_ == null) {
          workloadsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Builder, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.WorkloadOrBuilder>(
                  workloads_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          workloads_ = null;
        }
        return workloadsBuilder_;
      }

      private com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters defaultWorkloadParameters_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.Builder, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.ParametersOrBuilder> defaultWorkloadParametersBuilder_;
      /**
       * <pre>
       * Parameters to be used if none of workloads specified in `workloads` match.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters default_workload_parameters = 2 [json_name = "defaultWorkloadParameters"];</code>
       * @return Whether the defaultWorkloadParameters field is set.
       */
      public boolean hasDefaultWorkloadParameters() {
        return defaultWorkloadParametersBuilder_ != null || defaultWorkloadParameters_ != null;
      }
      /**
       * <pre>
       * Parameters to be used if none of workloads specified in `workloads` match.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters default_workload_parameters = 2 [json_name = "defaultWorkloadParameters"];</code>
       * @return The defaultWorkloadParameters.
       */
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters getDefaultWorkloadParameters() {
        if (defaultWorkloadParametersBuilder_ == null) {
          return defaultWorkloadParameters_ == null ? com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.getDefaultInstance() : defaultWorkloadParameters_;
        } else {
          return defaultWorkloadParametersBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Parameters to be used if none of workloads specified in `workloads` match.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters default_workload_parameters = 2 [json_name = "defaultWorkloadParameters"];</code>
       */
      public Builder setDefaultWorkloadParameters(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters value) {
        if (defaultWorkloadParametersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          defaultWorkloadParameters_ = value;
          onChanged();
        } else {
          defaultWorkloadParametersBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Parameters to be used if none of workloads specified in `workloads` match.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters default_workload_parameters = 2 [json_name = "defaultWorkloadParameters"];</code>
       */
      public Builder setDefaultWorkloadParameters(
          com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.Builder builderForValue) {
        if (defaultWorkloadParametersBuilder_ == null) {
          defaultWorkloadParameters_ = builderForValue.build();
          onChanged();
        } else {
          defaultWorkloadParametersBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Parameters to be used if none of workloads specified in `workloads` match.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters default_workload_parameters = 2 [json_name = "defaultWorkloadParameters"];</code>
       */
      public Builder mergeDefaultWorkloadParameters(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters value) {
        if (defaultWorkloadParametersBuilder_ == null) {
          if (defaultWorkloadParameters_ != null) {
            defaultWorkloadParameters_ =
              com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.newBuilder(defaultWorkloadParameters_).mergeFrom(value).buildPartial();
          } else {
            defaultWorkloadParameters_ = value;
          }
          onChanged();
        } else {
          defaultWorkloadParametersBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Parameters to be used if none of workloads specified in `workloads` match.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters default_workload_parameters = 2 [json_name = "defaultWorkloadParameters"];</code>
       */
      public Builder clearDefaultWorkloadParameters() {
        if (defaultWorkloadParametersBuilder_ == null) {
          defaultWorkloadParameters_ = null;
          onChanged();
        } else {
          defaultWorkloadParameters_ = null;
          defaultWorkloadParametersBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Parameters to be used if none of workloads specified in `workloads` match.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters default_workload_parameters = 2 [json_name = "defaultWorkloadParameters"];</code>
       */
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.Builder getDefaultWorkloadParametersBuilder() {
        
        onChanged();
        return getDefaultWorkloadParametersFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Parameters to be used if none of workloads specified in `workloads` match.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters default_workload_parameters = 2 [json_name = "defaultWorkloadParameters"];</code>
       */
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.ParametersOrBuilder getDefaultWorkloadParametersOrBuilder() {
        if (defaultWorkloadParametersBuilder_ != null) {
          return defaultWorkloadParametersBuilder_.getMessageOrBuilder();
        } else {
          return defaultWorkloadParameters_ == null ?
              com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.getDefaultInstance() : defaultWorkloadParameters_;
        }
      }
      /**
       * <pre>
       * Parameters to be used if none of workloads specified in `workloads` match.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.Scheduler.Workload.Parameters default_workload_parameters = 2 [json_name = "defaultWorkloadParameters"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.Builder, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.ParametersOrBuilder> 
          getDefaultWorkloadParametersFieldBuilder() {
        if (defaultWorkloadParametersBuilder_ == null) {
          defaultWorkloadParametersBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.Parameters.Builder, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Workload.ParametersOrBuilder>(
                  getDefaultWorkloadParameters(),
                  getParentForChildren(),
                  isClean());
          defaultWorkloadParameters_ = null;
        }
        return defaultWorkloadParametersBuilder_;
      }

      private boolean autoTokens_ ;
      /**
       * <pre>
       * Automatically estimate the size of a request in each workload, based on
       * historical latency. Each workload's `tokens` will be set to average
       * latency of flows in that workload during last few seconds (exact duration
       * of this average can change).
       * Make sure to not provide `tokens` in workload definitions or in the flow
       * if you want to use this feature.
       * </pre>
       *
       * <code>bool auto_tokens = 3 [json_name = "autoTokens"];</code>
       * @return The autoTokens.
       */
      @java.lang.Override
      public boolean getAutoTokens() {
        return autoTokens_;
      }
      /**
       * <pre>
       * Automatically estimate the size of a request in each workload, based on
       * historical latency. Each workload's `tokens` will be set to average
       * latency of flows in that workload during last few seconds (exact duration
       * of this average can change).
       * Make sure to not provide `tokens` in workload definitions or in the flow
       * if you want to use this feature.
       * </pre>
       *
       * <code>bool auto_tokens = 3 [json_name = "autoTokens"];</code>
       * @param value The autoTokens to set.
       * @return This builder for chaining.
       */
      public Builder setAutoTokens(boolean value) {
        
        autoTokens_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Automatically estimate the size of a request in each workload, based on
       * historical latency. Each workload's `tokens` will be set to average
       * latency of flows in that workload during last few seconds (exact duration
       * of this average can change).
       * Make sure to not provide `tokens` in workload definitions or in the flow
       * if you want to use this feature.
       * </pre>
       *
       * <code>bool auto_tokens = 3 [json_name = "autoTokens"];</code>
       * @return This builder for chaining.
       */
      public Builder clearAutoTokens() {
        
        autoTokens_ = false;
        onChanged();
        return this;
      }

      private double timeoutFactor_ ;
      /**
       * <pre>
       * Timeout as a factor of tokens for a flow in a workload in case auto_tokens is set to true.
       * If a flow is not able to get tokens within `timeout_factor * tokens` of duration,
       * it will be rejected.
       * This value impacts the prioritization and fairness because the larger the timeout the higher the chance a request has to get scheduled.
       * </pre>
       *
       * <code>double timeout_factor = 4 [json_name = "timeoutFactor"];</code>
       * @return The timeoutFactor.
       */
      @java.lang.Override
      public double getTimeoutFactor() {
        return timeoutFactor_;
      }
      /**
       * <pre>
       * Timeout as a factor of tokens for a flow in a workload in case auto_tokens is set to true.
       * If a flow is not able to get tokens within `timeout_factor * tokens` of duration,
       * it will be rejected.
       * This value impacts the prioritization and fairness because the larger the timeout the higher the chance a request has to get scheduled.
       * </pre>
       *
       * <code>double timeout_factor = 4 [json_name = "timeoutFactor"];</code>
       * @param value The timeoutFactor to set.
       * @return This builder for chaining.
       */
      public Builder setTimeoutFactor(double value) {
        
        timeoutFactor_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Timeout as a factor of tokens for a flow in a workload in case auto_tokens is set to true.
       * If a flow is not able to get tokens within `timeout_factor * tokens` of duration,
       * it will be rejected.
       * This value impacts the prioritization and fairness because the larger the timeout the higher the chance a request has to get scheduled.
       * </pre>
       *
       * <code>double timeout_factor = 4 [json_name = "timeoutFactor"];</code>
       * @return This builder for chaining.
       */
      public Builder clearTimeoutFactor() {
        
        timeoutFactor_ = 0D;
        onChanged();
        return this;
      }

      private com.google.protobuf.Duration maxTimeout_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> maxTimeoutBuilder_;
      /**
       * <pre>
       * Max Timeout is the value with which the flow timeout is capped.
       * When auto_tokens feature is not enabled, this value is used as the
       * timeout for the flow, otherwise it is used as a cap for the timeout.
       * :::caution
       * This timeout needs to be strictly less than the timeout set on the
       * client for the whole GRPC call:
       * * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
       * * in case of libraries, timeout configured... TODO.
       * We're using fail-open logic in integrations, so if the GRPC timeout
       * fires first, the flow will end up being unconditionally allowed while
       * it're still waiting on the scheduler.
       * To avoid such cases, the end-to-end GRPC timeout should also contain
       * some headroom for constant overhead like serialization, etc. Default
       * value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
       * tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
       * :::
       * </pre>
       *
       * <code>.google.protobuf.Duration max_timeout = 5 [json_name = "maxTimeout"];</code>
       * @return Whether the maxTimeout field is set.
       */
      public boolean hasMaxTimeout() {
        return maxTimeoutBuilder_ != null || maxTimeout_ != null;
      }
      /**
       * <pre>
       * Max Timeout is the value with which the flow timeout is capped.
       * When auto_tokens feature is not enabled, this value is used as the
       * timeout for the flow, otherwise it is used as a cap for the timeout.
       * :::caution
       * This timeout needs to be strictly less than the timeout set on the
       * client for the whole GRPC call:
       * * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
       * * in case of libraries, timeout configured... TODO.
       * We're using fail-open logic in integrations, so if the GRPC timeout
       * fires first, the flow will end up being unconditionally allowed while
       * it're still waiting on the scheduler.
       * To avoid such cases, the end-to-end GRPC timeout should also contain
       * some headroom for constant overhead like serialization, etc. Default
       * value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
       * tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
       * :::
       * </pre>
       *
       * <code>.google.protobuf.Duration max_timeout = 5 [json_name = "maxTimeout"];</code>
       * @return The maxTimeout.
       */
      public com.google.protobuf.Duration getMaxTimeout() {
        if (maxTimeoutBuilder_ == null) {
          return maxTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : maxTimeout_;
        } else {
          return maxTimeoutBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Max Timeout is the value with which the flow timeout is capped.
       * When auto_tokens feature is not enabled, this value is used as the
       * timeout for the flow, otherwise it is used as a cap for the timeout.
       * :::caution
       * This timeout needs to be strictly less than the timeout set on the
       * client for the whole GRPC call:
       * * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
       * * in case of libraries, timeout configured... TODO.
       * We're using fail-open logic in integrations, so if the GRPC timeout
       * fires first, the flow will end up being unconditionally allowed while
       * it're still waiting on the scheduler.
       * To avoid such cases, the end-to-end GRPC timeout should also contain
       * some headroom for constant overhead like serialization, etc. Default
       * value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
       * tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
       * :::
       * </pre>
       *
       * <code>.google.protobuf.Duration max_timeout = 5 [json_name = "maxTimeout"];</code>
       */
      public Builder setMaxTimeout(com.google.protobuf.Duration value) {
        if (maxTimeoutBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxTimeout_ = value;
          onChanged();
        } else {
          maxTimeoutBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Max Timeout is the value with which the flow timeout is capped.
       * When auto_tokens feature is not enabled, this value is used as the
       * timeout for the flow, otherwise it is used as a cap for the timeout.
       * :::caution
       * This timeout needs to be strictly less than the timeout set on the
       * client for the whole GRPC call:
       * * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
       * * in case of libraries, timeout configured... TODO.
       * We're using fail-open logic in integrations, so if the GRPC timeout
       * fires first, the flow will end up being unconditionally allowed while
       * it're still waiting on the scheduler.
       * To avoid such cases, the end-to-end GRPC timeout should also contain
       * some headroom for constant overhead like serialization, etc. Default
       * value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
       * tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
       * :::
       * </pre>
       *
       * <code>.google.protobuf.Duration max_timeout = 5 [json_name = "maxTimeout"];</code>
       */
      public Builder setMaxTimeout(
          com.google.protobuf.Duration.Builder builderForValue) {
        if (maxTimeoutBuilder_ == null) {
          maxTimeout_ = builderForValue.build();
          onChanged();
        } else {
          maxTimeoutBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Max Timeout is the value with which the flow timeout is capped.
       * When auto_tokens feature is not enabled, this value is used as the
       * timeout for the flow, otherwise it is used as a cap for the timeout.
       * :::caution
       * This timeout needs to be strictly less than the timeout set on the
       * client for the whole GRPC call:
       * * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
       * * in case of libraries, timeout configured... TODO.
       * We're using fail-open logic in integrations, so if the GRPC timeout
       * fires first, the flow will end up being unconditionally allowed while
       * it're still waiting on the scheduler.
       * To avoid such cases, the end-to-end GRPC timeout should also contain
       * some headroom for constant overhead like serialization, etc. Default
       * value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
       * tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
       * :::
       * </pre>
       *
       * <code>.google.protobuf.Duration max_timeout = 5 [json_name = "maxTimeout"];</code>
       */
      public Builder mergeMaxTimeout(com.google.protobuf.Duration value) {
        if (maxTimeoutBuilder_ == null) {
          if (maxTimeout_ != null) {
            maxTimeout_ =
              com.google.protobuf.Duration.newBuilder(maxTimeout_).mergeFrom(value).buildPartial();
          } else {
            maxTimeout_ = value;
          }
          onChanged();
        } else {
          maxTimeoutBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Max Timeout is the value with which the flow timeout is capped.
       * When auto_tokens feature is not enabled, this value is used as the
       * timeout for the flow, otherwise it is used as a cap for the timeout.
       * :::caution
       * This timeout needs to be strictly less than the timeout set on the
       * client for the whole GRPC call:
       * * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
       * * in case of libraries, timeout configured... TODO.
       * We're using fail-open logic in integrations, so if the GRPC timeout
       * fires first, the flow will end up being unconditionally allowed while
       * it're still waiting on the scheduler.
       * To avoid such cases, the end-to-end GRPC timeout should also contain
       * some headroom for constant overhead like serialization, etc. Default
       * value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
       * tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
       * :::
       * </pre>
       *
       * <code>.google.protobuf.Duration max_timeout = 5 [json_name = "maxTimeout"];</code>
       */
      public Builder clearMaxTimeout() {
        if (maxTimeoutBuilder_ == null) {
          maxTimeout_ = null;
          onChanged();
        } else {
          maxTimeout_ = null;
          maxTimeoutBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Max Timeout is the value with which the flow timeout is capped.
       * When auto_tokens feature is not enabled, this value is used as the
       * timeout for the flow, otherwise it is used as a cap for the timeout.
       * :::caution
       * This timeout needs to be strictly less than the timeout set on the
       * client for the whole GRPC call:
       * * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
       * * in case of libraries, timeout configured... TODO.
       * We're using fail-open logic in integrations, so if the GRPC timeout
       * fires first, the flow will end up being unconditionally allowed while
       * it're still waiting on the scheduler.
       * To avoid such cases, the end-to-end GRPC timeout should also contain
       * some headroom for constant overhead like serialization, etc. Default
       * value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
       * tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
       * :::
       * </pre>
       *
       * <code>.google.protobuf.Duration max_timeout = 5 [json_name = "maxTimeout"];</code>
       */
      public com.google.protobuf.Duration.Builder getMaxTimeoutBuilder() {
        
        onChanged();
        return getMaxTimeoutFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Max Timeout is the value with which the flow timeout is capped.
       * When auto_tokens feature is not enabled, this value is used as the
       * timeout for the flow, otherwise it is used as a cap for the timeout.
       * :::caution
       * This timeout needs to be strictly less than the timeout set on the
       * client for the whole GRPC call:
       * * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
       * * in case of libraries, timeout configured... TODO.
       * We're using fail-open logic in integrations, so if the GRPC timeout
       * fires first, the flow will end up being unconditionally allowed while
       * it're still waiting on the scheduler.
       * To avoid such cases, the end-to-end GRPC timeout should also contain
       * some headroom for constant overhead like serialization, etc. Default
       * value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
       * tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
       * :::
       * </pre>
       *
       * <code>.google.protobuf.Duration max_timeout = 5 [json_name = "maxTimeout"];</code>
       */
      public com.google.protobuf.DurationOrBuilder getMaxTimeoutOrBuilder() {
        if (maxTimeoutBuilder_ != null) {
          return maxTimeoutBuilder_.getMessageOrBuilder();
        } else {
          return maxTimeout_ == null ?
              com.google.protobuf.Duration.getDefaultInstance() : maxTimeout_;
        }
      }
      /**
       * <pre>
       * Max Timeout is the value with which the flow timeout is capped.
       * When auto_tokens feature is not enabled, this value is used as the
       * timeout for the flow, otherwise it is used as a cap for the timeout.
       * :::caution
       * This timeout needs to be strictly less than the timeout set on the
       * client for the whole GRPC call:
       * * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
       * * in case of libraries, timeout configured... TODO.
       * We're using fail-open logic in integrations, so if the GRPC timeout
       * fires first, the flow will end up being unconditionally allowed while
       * it're still waiting on the scheduler.
       * To avoid such cases, the end-to-end GRPC timeout should also contain
       * some headroom for constant overhead like serialization, etc. Default
       * value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
       * tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
       * :::
       * </pre>
       *
       * <code>.google.protobuf.Duration max_timeout = 5 [json_name = "maxTimeout"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
          getMaxTimeoutFieldBuilder() {
        if (maxTimeoutBuilder_ == null) {
          maxTimeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                  getMaxTimeout(),
                  getParentForChildren(),
                  isClean());
          maxTimeout_ = null;
        }
        return maxTimeoutBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:aperture.policy.language.v1.Scheduler.Parameters)
    }

    // @@protoc_insertion_point(class_scope:aperture.policy.language.v1.Scheduler.Parameters)
    private static final com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters();
    }

    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Parameters>
        PARSER = new com.google.protobuf.AbstractParser<Parameters>() {
      @java.lang.Override
      public Parameters parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Parameters(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Parameters> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Parameters> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface OutsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:aperture.policy.language.v1.Scheduler.Outs)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Accepted concurrency is actual concurrency on a control point that this
     * scheduler is applied on.
     * :::info
     * Concurrency is a unitless number describing mean number of
     * [flows](/concepts/flow-control/flow-control.md#flow) being
     * concurrently processed by the system (system = control point).
     * Concurrency is calculated as _work_ done per unit of time (so
     * work-seconds per world-seconds). Work-seconds are computed based on
     * token-weights of of flows (which are either estimated via `auto_tokens`
     * or specified by `Workload.tokens`).
     * :::
     * Value of this signal is aggregated from all the relevant schedulers.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.OutPort accepted_concurrency = 1 [json_name = "acceptedConcurrency"];</code>
     * @return Whether the acceptedConcurrency field is set.
     */
    boolean hasAcceptedConcurrency();
    /**
     * <pre>
     * Accepted concurrency is actual concurrency on a control point that this
     * scheduler is applied on.
     * :::info
     * Concurrency is a unitless number describing mean number of
     * [flows](/concepts/flow-control/flow-control.md#flow) being
     * concurrently processed by the system (system = control point).
     * Concurrency is calculated as _work_ done per unit of time (so
     * work-seconds per world-seconds). Work-seconds are computed based on
     * token-weights of of flows (which are either estimated via `auto_tokens`
     * or specified by `Workload.tokens`).
     * :::
     * Value of this signal is aggregated from all the relevant schedulers.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.OutPort accepted_concurrency = 1 [json_name = "acceptedConcurrency"];</code>
     * @return The acceptedConcurrency.
     */
    com.fluxninja.generated.aperture.policy.language.v1.OutPort getAcceptedConcurrency();
    /**
     * <pre>
     * Accepted concurrency is actual concurrency on a control point that this
     * scheduler is applied on.
     * :::info
     * Concurrency is a unitless number describing mean number of
     * [flows](/concepts/flow-control/flow-control.md#flow) being
     * concurrently processed by the system (system = control point).
     * Concurrency is calculated as _work_ done per unit of time (so
     * work-seconds per world-seconds). Work-seconds are computed based on
     * token-weights of of flows (which are either estimated via `auto_tokens`
     * or specified by `Workload.tokens`).
     * :::
     * Value of this signal is aggregated from all the relevant schedulers.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.OutPort accepted_concurrency = 1 [json_name = "acceptedConcurrency"];</code>
     */
    com.fluxninja.generated.aperture.policy.language.v1.OutPortOrBuilder getAcceptedConcurrencyOrBuilder();

    /**
     * <pre>
     * Incoming concurrency is concurrency that'd be needed to accept all the
     * flows entering the scheduler.
     * This is computed in the same way as `accepted_concurrency`, but summing
     * up work-seconds from all the flows entering scheduler, including
     * rejected ones.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.OutPort incoming_concurrency = 2 [json_name = "incomingConcurrency"];</code>
     * @return Whether the incomingConcurrency field is set.
     */
    boolean hasIncomingConcurrency();
    /**
     * <pre>
     * Incoming concurrency is concurrency that'd be needed to accept all the
     * flows entering the scheduler.
     * This is computed in the same way as `accepted_concurrency`, but summing
     * up work-seconds from all the flows entering scheduler, including
     * rejected ones.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.OutPort incoming_concurrency = 2 [json_name = "incomingConcurrency"];</code>
     * @return The incomingConcurrency.
     */
    com.fluxninja.generated.aperture.policy.language.v1.OutPort getIncomingConcurrency();
    /**
     * <pre>
     * Incoming concurrency is concurrency that'd be needed to accept all the
     * flows entering the scheduler.
     * This is computed in the same way as `accepted_concurrency`, but summing
     * up work-seconds from all the flows entering scheduler, including
     * rejected ones.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.OutPort incoming_concurrency = 2 [json_name = "incomingConcurrency"];</code>
     */
    com.fluxninja.generated.aperture.policy.language.v1.OutPortOrBuilder getIncomingConcurrencyOrBuilder();
  }
  /**
   * <pre>
   * Output for the Scheduler component.
   * </pre>
   *
   * Protobuf type {@code aperture.policy.language.v1.Scheduler.Outs}
   */
  public static final class Outs extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:aperture.policy.language.v1.Scheduler.Outs)
      OutsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Outs.newBuilder() to construct.
    private Outs(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Outs() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Outs();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Outs(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.fluxninja.generated.aperture.policy.language.v1.OutPort.Builder subBuilder = null;
              if (acceptedConcurrency_ != null) {
                subBuilder = acceptedConcurrency_.toBuilder();
              }
              acceptedConcurrency_ = input.readMessage(com.fluxninja.generated.aperture.policy.language.v1.OutPort.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(acceptedConcurrency_);
                acceptedConcurrency_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              com.fluxninja.generated.aperture.policy.language.v1.OutPort.Builder subBuilder = null;
              if (incomingConcurrency_ != null) {
                subBuilder = incomingConcurrency_.toBuilder();
              }
              incomingConcurrency_ = input.readMessage(com.fluxninja.generated.aperture.policy.language.v1.OutPort.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(incomingConcurrency_);
                incomingConcurrency_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (com.google.protobuf.UninitializedMessageException e) {
        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Outs_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Outs_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.class, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.Builder.class);
    }

    public static final int ACCEPTED_CONCURRENCY_FIELD_NUMBER = 1;
    private com.fluxninja.generated.aperture.policy.language.v1.OutPort acceptedConcurrency_;
    /**
     * <pre>
     * Accepted concurrency is actual concurrency on a control point that this
     * scheduler is applied on.
     * :::info
     * Concurrency is a unitless number describing mean number of
     * [flows](/concepts/flow-control/flow-control.md#flow) being
     * concurrently processed by the system (system = control point).
     * Concurrency is calculated as _work_ done per unit of time (so
     * work-seconds per world-seconds). Work-seconds are computed based on
     * token-weights of of flows (which are either estimated via `auto_tokens`
     * or specified by `Workload.tokens`).
     * :::
     * Value of this signal is aggregated from all the relevant schedulers.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.OutPort accepted_concurrency = 1 [json_name = "acceptedConcurrency"];</code>
     * @return Whether the acceptedConcurrency field is set.
     */
    @java.lang.Override
    public boolean hasAcceptedConcurrency() {
      return acceptedConcurrency_ != null;
    }
    /**
     * <pre>
     * Accepted concurrency is actual concurrency on a control point that this
     * scheduler is applied on.
     * :::info
     * Concurrency is a unitless number describing mean number of
     * [flows](/concepts/flow-control/flow-control.md#flow) being
     * concurrently processed by the system (system = control point).
     * Concurrency is calculated as _work_ done per unit of time (so
     * work-seconds per world-seconds). Work-seconds are computed based on
     * token-weights of of flows (which are either estimated via `auto_tokens`
     * or specified by `Workload.tokens`).
     * :::
     * Value of this signal is aggregated from all the relevant schedulers.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.OutPort accepted_concurrency = 1 [json_name = "acceptedConcurrency"];</code>
     * @return The acceptedConcurrency.
     */
    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.OutPort getAcceptedConcurrency() {
      return acceptedConcurrency_ == null ? com.fluxninja.generated.aperture.policy.language.v1.OutPort.getDefaultInstance() : acceptedConcurrency_;
    }
    /**
     * <pre>
     * Accepted concurrency is actual concurrency on a control point that this
     * scheduler is applied on.
     * :::info
     * Concurrency is a unitless number describing mean number of
     * [flows](/concepts/flow-control/flow-control.md#flow) being
     * concurrently processed by the system (system = control point).
     * Concurrency is calculated as _work_ done per unit of time (so
     * work-seconds per world-seconds). Work-seconds are computed based on
     * token-weights of of flows (which are either estimated via `auto_tokens`
     * or specified by `Workload.tokens`).
     * :::
     * Value of this signal is aggregated from all the relevant schedulers.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.OutPort accepted_concurrency = 1 [json_name = "acceptedConcurrency"];</code>
     */
    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.OutPortOrBuilder getAcceptedConcurrencyOrBuilder() {
      return getAcceptedConcurrency();
    }

    public static final int INCOMING_CONCURRENCY_FIELD_NUMBER = 2;
    private com.fluxninja.generated.aperture.policy.language.v1.OutPort incomingConcurrency_;
    /**
     * <pre>
     * Incoming concurrency is concurrency that'd be needed to accept all the
     * flows entering the scheduler.
     * This is computed in the same way as `accepted_concurrency`, but summing
     * up work-seconds from all the flows entering scheduler, including
     * rejected ones.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.OutPort incoming_concurrency = 2 [json_name = "incomingConcurrency"];</code>
     * @return Whether the incomingConcurrency field is set.
     */
    @java.lang.Override
    public boolean hasIncomingConcurrency() {
      return incomingConcurrency_ != null;
    }
    /**
     * <pre>
     * Incoming concurrency is concurrency that'd be needed to accept all the
     * flows entering the scheduler.
     * This is computed in the same way as `accepted_concurrency`, but summing
     * up work-seconds from all the flows entering scheduler, including
     * rejected ones.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.OutPort incoming_concurrency = 2 [json_name = "incomingConcurrency"];</code>
     * @return The incomingConcurrency.
     */
    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.OutPort getIncomingConcurrency() {
      return incomingConcurrency_ == null ? com.fluxninja.generated.aperture.policy.language.v1.OutPort.getDefaultInstance() : incomingConcurrency_;
    }
    /**
     * <pre>
     * Incoming concurrency is concurrency that'd be needed to accept all the
     * flows entering the scheduler.
     * This is computed in the same way as `accepted_concurrency`, but summing
     * up work-seconds from all the flows entering scheduler, including
     * rejected ones.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.OutPort incoming_concurrency = 2 [json_name = "incomingConcurrency"];</code>
     */
    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.OutPortOrBuilder getIncomingConcurrencyOrBuilder() {
      return getIncomingConcurrency();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (acceptedConcurrency_ != null) {
        output.writeMessage(1, getAcceptedConcurrency());
      }
      if (incomingConcurrency_ != null) {
        output.writeMessage(2, getIncomingConcurrency());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (acceptedConcurrency_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getAcceptedConcurrency());
      }
      if (incomingConcurrency_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getIncomingConcurrency());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs)) {
        return super.equals(obj);
      }
      com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs other = (com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs) obj;

      if (hasAcceptedConcurrency() != other.hasAcceptedConcurrency()) return false;
      if (hasAcceptedConcurrency()) {
        if (!getAcceptedConcurrency()
            .equals(other.getAcceptedConcurrency())) return false;
      }
      if (hasIncomingConcurrency() != other.hasIncomingConcurrency()) return false;
      if (hasIncomingConcurrency()) {
        if (!getIncomingConcurrency()
            .equals(other.getIncomingConcurrency())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasAcceptedConcurrency()) {
        hash = (37 * hash) + ACCEPTED_CONCURRENCY_FIELD_NUMBER;
        hash = (53 * hash) + getAcceptedConcurrency().hashCode();
      }
      if (hasIncomingConcurrency()) {
        hash = (37 * hash) + INCOMING_CONCURRENCY_FIELD_NUMBER;
        hash = (53 * hash) + getIncomingConcurrency().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Output for the Scheduler component.
     * </pre>
     *
     * Protobuf type {@code aperture.policy.language.v1.Scheduler.Outs}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:aperture.policy.language.v1.Scheduler.Outs)
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.OutsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Outs_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Outs_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.class, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.Builder.class);
      }

      // Construct using com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (acceptedConcurrencyBuilder_ == null) {
          acceptedConcurrency_ = null;
        } else {
          acceptedConcurrency_ = null;
          acceptedConcurrencyBuilder_ = null;
        }
        if (incomingConcurrencyBuilder_ == null) {
          incomingConcurrency_ = null;
        } else {
          incomingConcurrency_ = null;
          incomingConcurrencyBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_Outs_descriptor;
      }

      @java.lang.Override
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs getDefaultInstanceForType() {
        return com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.getDefaultInstance();
      }

      @java.lang.Override
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs build() {
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs buildPartial() {
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs result = new com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs(this);
        if (acceptedConcurrencyBuilder_ == null) {
          result.acceptedConcurrency_ = acceptedConcurrency_;
        } else {
          result.acceptedConcurrency_ = acceptedConcurrencyBuilder_.build();
        }
        if (incomingConcurrencyBuilder_ == null) {
          result.incomingConcurrency_ = incomingConcurrency_;
        } else {
          result.incomingConcurrency_ = incomingConcurrencyBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs) {
          return mergeFrom((com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs other) {
        if (other == com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.getDefaultInstance()) return this;
        if (other.hasAcceptedConcurrency()) {
          mergeAcceptedConcurrency(other.getAcceptedConcurrency());
        }
        if (other.hasIncomingConcurrency()) {
          mergeIncomingConcurrency(other.getIncomingConcurrency());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.fluxninja.generated.aperture.policy.language.v1.OutPort acceptedConcurrency_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.fluxninja.generated.aperture.policy.language.v1.OutPort, com.fluxninja.generated.aperture.policy.language.v1.OutPort.Builder, com.fluxninja.generated.aperture.policy.language.v1.OutPortOrBuilder> acceptedConcurrencyBuilder_;
      /**
       * <pre>
       * Accepted concurrency is actual concurrency on a control point that this
       * scheduler is applied on.
       * :::info
       * Concurrency is a unitless number describing mean number of
       * [flows](/concepts/flow-control/flow-control.md#flow) being
       * concurrently processed by the system (system = control point).
       * Concurrency is calculated as _work_ done per unit of time (so
       * work-seconds per world-seconds). Work-seconds are computed based on
       * token-weights of of flows (which are either estimated via `auto_tokens`
       * or specified by `Workload.tokens`).
       * :::
       * Value of this signal is aggregated from all the relevant schedulers.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort accepted_concurrency = 1 [json_name = "acceptedConcurrency"];</code>
       * @return Whether the acceptedConcurrency field is set.
       */
      public boolean hasAcceptedConcurrency() {
        return acceptedConcurrencyBuilder_ != null || acceptedConcurrency_ != null;
      }
      /**
       * <pre>
       * Accepted concurrency is actual concurrency on a control point that this
       * scheduler is applied on.
       * :::info
       * Concurrency is a unitless number describing mean number of
       * [flows](/concepts/flow-control/flow-control.md#flow) being
       * concurrently processed by the system (system = control point).
       * Concurrency is calculated as _work_ done per unit of time (so
       * work-seconds per world-seconds). Work-seconds are computed based on
       * token-weights of of flows (which are either estimated via `auto_tokens`
       * or specified by `Workload.tokens`).
       * :::
       * Value of this signal is aggregated from all the relevant schedulers.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort accepted_concurrency = 1 [json_name = "acceptedConcurrency"];</code>
       * @return The acceptedConcurrency.
       */
      public com.fluxninja.generated.aperture.policy.language.v1.OutPort getAcceptedConcurrency() {
        if (acceptedConcurrencyBuilder_ == null) {
          return acceptedConcurrency_ == null ? com.fluxninja.generated.aperture.policy.language.v1.OutPort.getDefaultInstance() : acceptedConcurrency_;
        } else {
          return acceptedConcurrencyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Accepted concurrency is actual concurrency on a control point that this
       * scheduler is applied on.
       * :::info
       * Concurrency is a unitless number describing mean number of
       * [flows](/concepts/flow-control/flow-control.md#flow) being
       * concurrently processed by the system (system = control point).
       * Concurrency is calculated as _work_ done per unit of time (so
       * work-seconds per world-seconds). Work-seconds are computed based on
       * token-weights of of flows (which are either estimated via `auto_tokens`
       * or specified by `Workload.tokens`).
       * :::
       * Value of this signal is aggregated from all the relevant schedulers.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort accepted_concurrency = 1 [json_name = "acceptedConcurrency"];</code>
       */
      public Builder setAcceptedConcurrency(com.fluxninja.generated.aperture.policy.language.v1.OutPort value) {
        if (acceptedConcurrencyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          acceptedConcurrency_ = value;
          onChanged();
        } else {
          acceptedConcurrencyBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Accepted concurrency is actual concurrency on a control point that this
       * scheduler is applied on.
       * :::info
       * Concurrency is a unitless number describing mean number of
       * [flows](/concepts/flow-control/flow-control.md#flow) being
       * concurrently processed by the system (system = control point).
       * Concurrency is calculated as _work_ done per unit of time (so
       * work-seconds per world-seconds). Work-seconds are computed based on
       * token-weights of of flows (which are either estimated via `auto_tokens`
       * or specified by `Workload.tokens`).
       * :::
       * Value of this signal is aggregated from all the relevant schedulers.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort accepted_concurrency = 1 [json_name = "acceptedConcurrency"];</code>
       */
      public Builder setAcceptedConcurrency(
          com.fluxninja.generated.aperture.policy.language.v1.OutPort.Builder builderForValue) {
        if (acceptedConcurrencyBuilder_ == null) {
          acceptedConcurrency_ = builderForValue.build();
          onChanged();
        } else {
          acceptedConcurrencyBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Accepted concurrency is actual concurrency on a control point that this
       * scheduler is applied on.
       * :::info
       * Concurrency is a unitless number describing mean number of
       * [flows](/concepts/flow-control/flow-control.md#flow) being
       * concurrently processed by the system (system = control point).
       * Concurrency is calculated as _work_ done per unit of time (so
       * work-seconds per world-seconds). Work-seconds are computed based on
       * token-weights of of flows (which are either estimated via `auto_tokens`
       * or specified by `Workload.tokens`).
       * :::
       * Value of this signal is aggregated from all the relevant schedulers.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort accepted_concurrency = 1 [json_name = "acceptedConcurrency"];</code>
       */
      public Builder mergeAcceptedConcurrency(com.fluxninja.generated.aperture.policy.language.v1.OutPort value) {
        if (acceptedConcurrencyBuilder_ == null) {
          if (acceptedConcurrency_ != null) {
            acceptedConcurrency_ =
              com.fluxninja.generated.aperture.policy.language.v1.OutPort.newBuilder(acceptedConcurrency_).mergeFrom(value).buildPartial();
          } else {
            acceptedConcurrency_ = value;
          }
          onChanged();
        } else {
          acceptedConcurrencyBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Accepted concurrency is actual concurrency on a control point that this
       * scheduler is applied on.
       * :::info
       * Concurrency is a unitless number describing mean number of
       * [flows](/concepts/flow-control/flow-control.md#flow) being
       * concurrently processed by the system (system = control point).
       * Concurrency is calculated as _work_ done per unit of time (so
       * work-seconds per world-seconds). Work-seconds are computed based on
       * token-weights of of flows (which are either estimated via `auto_tokens`
       * or specified by `Workload.tokens`).
       * :::
       * Value of this signal is aggregated from all the relevant schedulers.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort accepted_concurrency = 1 [json_name = "acceptedConcurrency"];</code>
       */
      public Builder clearAcceptedConcurrency() {
        if (acceptedConcurrencyBuilder_ == null) {
          acceptedConcurrency_ = null;
          onChanged();
        } else {
          acceptedConcurrency_ = null;
          acceptedConcurrencyBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Accepted concurrency is actual concurrency on a control point that this
       * scheduler is applied on.
       * :::info
       * Concurrency is a unitless number describing mean number of
       * [flows](/concepts/flow-control/flow-control.md#flow) being
       * concurrently processed by the system (system = control point).
       * Concurrency is calculated as _work_ done per unit of time (so
       * work-seconds per world-seconds). Work-seconds are computed based on
       * token-weights of of flows (which are either estimated via `auto_tokens`
       * or specified by `Workload.tokens`).
       * :::
       * Value of this signal is aggregated from all the relevant schedulers.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort accepted_concurrency = 1 [json_name = "acceptedConcurrency"];</code>
       */
      public com.fluxninja.generated.aperture.policy.language.v1.OutPort.Builder getAcceptedConcurrencyBuilder() {
        
        onChanged();
        return getAcceptedConcurrencyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Accepted concurrency is actual concurrency on a control point that this
       * scheduler is applied on.
       * :::info
       * Concurrency is a unitless number describing mean number of
       * [flows](/concepts/flow-control/flow-control.md#flow) being
       * concurrently processed by the system (system = control point).
       * Concurrency is calculated as _work_ done per unit of time (so
       * work-seconds per world-seconds). Work-seconds are computed based on
       * token-weights of of flows (which are either estimated via `auto_tokens`
       * or specified by `Workload.tokens`).
       * :::
       * Value of this signal is aggregated from all the relevant schedulers.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort accepted_concurrency = 1 [json_name = "acceptedConcurrency"];</code>
       */
      public com.fluxninja.generated.aperture.policy.language.v1.OutPortOrBuilder getAcceptedConcurrencyOrBuilder() {
        if (acceptedConcurrencyBuilder_ != null) {
          return acceptedConcurrencyBuilder_.getMessageOrBuilder();
        } else {
          return acceptedConcurrency_ == null ?
              com.fluxninja.generated.aperture.policy.language.v1.OutPort.getDefaultInstance() : acceptedConcurrency_;
        }
      }
      /**
       * <pre>
       * Accepted concurrency is actual concurrency on a control point that this
       * scheduler is applied on.
       * :::info
       * Concurrency is a unitless number describing mean number of
       * [flows](/concepts/flow-control/flow-control.md#flow) being
       * concurrently processed by the system (system = control point).
       * Concurrency is calculated as _work_ done per unit of time (so
       * work-seconds per world-seconds). Work-seconds are computed based on
       * token-weights of of flows (which are either estimated via `auto_tokens`
       * or specified by `Workload.tokens`).
       * :::
       * Value of this signal is aggregated from all the relevant schedulers.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort accepted_concurrency = 1 [json_name = "acceptedConcurrency"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.fluxninja.generated.aperture.policy.language.v1.OutPort, com.fluxninja.generated.aperture.policy.language.v1.OutPort.Builder, com.fluxninja.generated.aperture.policy.language.v1.OutPortOrBuilder> 
          getAcceptedConcurrencyFieldBuilder() {
        if (acceptedConcurrencyBuilder_ == null) {
          acceptedConcurrencyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.fluxninja.generated.aperture.policy.language.v1.OutPort, com.fluxninja.generated.aperture.policy.language.v1.OutPort.Builder, com.fluxninja.generated.aperture.policy.language.v1.OutPortOrBuilder>(
                  getAcceptedConcurrency(),
                  getParentForChildren(),
                  isClean());
          acceptedConcurrency_ = null;
        }
        return acceptedConcurrencyBuilder_;
      }

      private com.fluxninja.generated.aperture.policy.language.v1.OutPort incomingConcurrency_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.fluxninja.generated.aperture.policy.language.v1.OutPort, com.fluxninja.generated.aperture.policy.language.v1.OutPort.Builder, com.fluxninja.generated.aperture.policy.language.v1.OutPortOrBuilder> incomingConcurrencyBuilder_;
      /**
       * <pre>
       * Incoming concurrency is concurrency that'd be needed to accept all the
       * flows entering the scheduler.
       * This is computed in the same way as `accepted_concurrency`, but summing
       * up work-seconds from all the flows entering scheduler, including
       * rejected ones.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort incoming_concurrency = 2 [json_name = "incomingConcurrency"];</code>
       * @return Whether the incomingConcurrency field is set.
       */
      public boolean hasIncomingConcurrency() {
        return incomingConcurrencyBuilder_ != null || incomingConcurrency_ != null;
      }
      /**
       * <pre>
       * Incoming concurrency is concurrency that'd be needed to accept all the
       * flows entering the scheduler.
       * This is computed in the same way as `accepted_concurrency`, but summing
       * up work-seconds from all the flows entering scheduler, including
       * rejected ones.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort incoming_concurrency = 2 [json_name = "incomingConcurrency"];</code>
       * @return The incomingConcurrency.
       */
      public com.fluxninja.generated.aperture.policy.language.v1.OutPort getIncomingConcurrency() {
        if (incomingConcurrencyBuilder_ == null) {
          return incomingConcurrency_ == null ? com.fluxninja.generated.aperture.policy.language.v1.OutPort.getDefaultInstance() : incomingConcurrency_;
        } else {
          return incomingConcurrencyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Incoming concurrency is concurrency that'd be needed to accept all the
       * flows entering the scheduler.
       * This is computed in the same way as `accepted_concurrency`, but summing
       * up work-seconds from all the flows entering scheduler, including
       * rejected ones.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort incoming_concurrency = 2 [json_name = "incomingConcurrency"];</code>
       */
      public Builder setIncomingConcurrency(com.fluxninja.generated.aperture.policy.language.v1.OutPort value) {
        if (incomingConcurrencyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          incomingConcurrency_ = value;
          onChanged();
        } else {
          incomingConcurrencyBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Incoming concurrency is concurrency that'd be needed to accept all the
       * flows entering the scheduler.
       * This is computed in the same way as `accepted_concurrency`, but summing
       * up work-seconds from all the flows entering scheduler, including
       * rejected ones.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort incoming_concurrency = 2 [json_name = "incomingConcurrency"];</code>
       */
      public Builder setIncomingConcurrency(
          com.fluxninja.generated.aperture.policy.language.v1.OutPort.Builder builderForValue) {
        if (incomingConcurrencyBuilder_ == null) {
          incomingConcurrency_ = builderForValue.build();
          onChanged();
        } else {
          incomingConcurrencyBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Incoming concurrency is concurrency that'd be needed to accept all the
       * flows entering the scheduler.
       * This is computed in the same way as `accepted_concurrency`, but summing
       * up work-seconds from all the flows entering scheduler, including
       * rejected ones.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort incoming_concurrency = 2 [json_name = "incomingConcurrency"];</code>
       */
      public Builder mergeIncomingConcurrency(com.fluxninja.generated.aperture.policy.language.v1.OutPort value) {
        if (incomingConcurrencyBuilder_ == null) {
          if (incomingConcurrency_ != null) {
            incomingConcurrency_ =
              com.fluxninja.generated.aperture.policy.language.v1.OutPort.newBuilder(incomingConcurrency_).mergeFrom(value).buildPartial();
          } else {
            incomingConcurrency_ = value;
          }
          onChanged();
        } else {
          incomingConcurrencyBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Incoming concurrency is concurrency that'd be needed to accept all the
       * flows entering the scheduler.
       * This is computed in the same way as `accepted_concurrency`, but summing
       * up work-seconds from all the flows entering scheduler, including
       * rejected ones.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort incoming_concurrency = 2 [json_name = "incomingConcurrency"];</code>
       */
      public Builder clearIncomingConcurrency() {
        if (incomingConcurrencyBuilder_ == null) {
          incomingConcurrency_ = null;
          onChanged();
        } else {
          incomingConcurrency_ = null;
          incomingConcurrencyBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Incoming concurrency is concurrency that'd be needed to accept all the
       * flows entering the scheduler.
       * This is computed in the same way as `accepted_concurrency`, but summing
       * up work-seconds from all the flows entering scheduler, including
       * rejected ones.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort incoming_concurrency = 2 [json_name = "incomingConcurrency"];</code>
       */
      public com.fluxninja.generated.aperture.policy.language.v1.OutPort.Builder getIncomingConcurrencyBuilder() {
        
        onChanged();
        return getIncomingConcurrencyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Incoming concurrency is concurrency that'd be needed to accept all the
       * flows entering the scheduler.
       * This is computed in the same way as `accepted_concurrency`, but summing
       * up work-seconds from all the flows entering scheduler, including
       * rejected ones.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort incoming_concurrency = 2 [json_name = "incomingConcurrency"];</code>
       */
      public com.fluxninja.generated.aperture.policy.language.v1.OutPortOrBuilder getIncomingConcurrencyOrBuilder() {
        if (incomingConcurrencyBuilder_ != null) {
          return incomingConcurrencyBuilder_.getMessageOrBuilder();
        } else {
          return incomingConcurrency_ == null ?
              com.fluxninja.generated.aperture.policy.language.v1.OutPort.getDefaultInstance() : incomingConcurrency_;
        }
      }
      /**
       * <pre>
       * Incoming concurrency is concurrency that'd be needed to accept all the
       * flows entering the scheduler.
       * This is computed in the same way as `accepted_concurrency`, but summing
       * up work-seconds from all the flows entering scheduler, including
       * rejected ones.
       * </pre>
       *
       * <code>.aperture.policy.language.v1.OutPort incoming_concurrency = 2 [json_name = "incomingConcurrency"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.fluxninja.generated.aperture.policy.language.v1.OutPort, com.fluxninja.generated.aperture.policy.language.v1.OutPort.Builder, com.fluxninja.generated.aperture.policy.language.v1.OutPortOrBuilder> 
          getIncomingConcurrencyFieldBuilder() {
        if (incomingConcurrencyBuilder_ == null) {
          incomingConcurrencyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.fluxninja.generated.aperture.policy.language.v1.OutPort, com.fluxninja.generated.aperture.policy.language.v1.OutPort.Builder, com.fluxninja.generated.aperture.policy.language.v1.OutPortOrBuilder>(
                  getIncomingConcurrency(),
                  getParentForChildren(),
                  isClean());
          incomingConcurrency_ = null;
        }
        return incomingConcurrencyBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:aperture.policy.language.v1.Scheduler.Outs)
    }

    // @@protoc_insertion_point(class_scope:aperture.policy.language.v1.Scheduler.Outs)
    private static final com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs();
    }

    public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Outs>
        PARSER = new com.google.protobuf.AbstractParser<Outs>() {
      @java.lang.Override
      public Outs parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Outs(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Outs> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Outs> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public static final int OUT_PORTS_FIELD_NUMBER = 1;
  private com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs outPorts_;
  /**
   * <pre>
   * Output ports for the Scheduler component.
   * </pre>
   *
   * <code>.aperture.policy.language.v1.Scheduler.Outs out_ports = 1 [json_name = "outPorts"];</code>
   * @return Whether the outPorts field is set.
   */
  @java.lang.Override
  public boolean hasOutPorts() {
    return outPorts_ != null;
  }
  /**
   * <pre>
   * Output ports for the Scheduler component.
   * </pre>
   *
   * <code>.aperture.policy.language.v1.Scheduler.Outs out_ports = 1 [json_name = "outPorts"];</code>
   * @return The outPorts.
   */
  @java.lang.Override
  public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs getOutPorts() {
    return outPorts_ == null ? com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.getDefaultInstance() : outPorts_;
  }
  /**
   * <pre>
   * Output ports for the Scheduler component.
   * </pre>
   *
   * <code>.aperture.policy.language.v1.Scheduler.Outs out_ports = 1 [json_name = "outPorts"];</code>
   */
  @java.lang.Override
  public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.OutsOrBuilder getOutPortsOrBuilder() {
    return getOutPorts();
  }

  public static final int PARAMETERS_FIELD_NUMBER = 2;
  private com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters parameters_;
  /**
   * <pre>
   * Scheduler parameters.
   * </pre>
   *
   * <code>.aperture.policy.language.v1.Scheduler.Parameters parameters = 2 [json_name = "parameters"];</code>
   * @return Whether the parameters field is set.
   */
  @java.lang.Override
  public boolean hasParameters() {
    return parameters_ != null;
  }
  /**
   * <pre>
   * Scheduler parameters.
   * </pre>
   *
   * <code>.aperture.policy.language.v1.Scheduler.Parameters parameters = 2 [json_name = "parameters"];</code>
   * @return The parameters.
   */
  @java.lang.Override
  public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters getParameters() {
    return parameters_ == null ? com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.getDefaultInstance() : parameters_;
  }
  /**
   * <pre>
   * Scheduler parameters.
   * </pre>
   *
   * <code>.aperture.policy.language.v1.Scheduler.Parameters parameters = 2 [json_name = "parameters"];</code>
   */
  @java.lang.Override
  public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.ParametersOrBuilder getParametersOrBuilder() {
    return getParameters();
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (outPorts_ != null) {
      output.writeMessage(1, getOutPorts());
    }
    if (parameters_ != null) {
      output.writeMessage(2, getParameters());
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (outPorts_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(1, getOutPorts());
    }
    if (parameters_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(2, getParameters());
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof com.fluxninja.generated.aperture.policy.language.v1.Scheduler)) {
      return super.equals(obj);
    }
    com.fluxninja.generated.aperture.policy.language.v1.Scheduler other = (com.fluxninja.generated.aperture.policy.language.v1.Scheduler) obj;

    if (hasOutPorts() != other.hasOutPorts()) return false;
    if (hasOutPorts()) {
      if (!getOutPorts()
          .equals(other.getOutPorts())) return false;
    }
    if (hasParameters() != other.hasParameters()) return false;
    if (hasParameters()) {
      if (!getParameters()
          .equals(other.getParameters())) return false;
    }
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (hasOutPorts()) {
      hash = (37 * hash) + OUT_PORTS_FIELD_NUMBER;
      hash = (53 * hash) + getOutPorts().hashCode();
    }
    if (hasParameters()) {
      hash = (37 * hash) + PARAMETERS_FIELD_NUMBER;
      hash = (53 * hash) + getParameters().hashCode();
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(com.fluxninja.generated.aperture.policy.language.v1.Scheduler prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * Weighted Fair Queuing-based workload scheduler
   * :::note
   * Each Agent instantiates an independent copy of the scheduler, but output
   * signals for accepted and incoming concurrency are aggregated across all agents.
   * :::
   * See [ConcurrencyLimiter](#concurrency-limiter) for more context.
   * </pre>
   *
   * Protobuf type {@code aperture.policy.language.v1.Scheduler}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:aperture.policy.language.v1.Scheduler)
      com.fluxninja.generated.aperture.policy.language.v1.SchedulerOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.fluxninja.generated.aperture.policy.language.v1.Scheduler.class, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Builder.class);
    }

    // Construct using com.fluxninja.generated.aperture.policy.language.v1.Scheduler.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
      }
    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      if (outPortsBuilder_ == null) {
        outPorts_ = null;
      } else {
        outPorts_ = null;
        outPortsBuilder_ = null;
      }
      if (parametersBuilder_ == null) {
        parameters_ = null;
      } else {
        parameters_ = null;
        parametersBuilder_ = null;
      }
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Scheduler_descriptor;
    }

    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler getDefaultInstanceForType() {
      return com.fluxninja.generated.aperture.policy.language.v1.Scheduler.getDefaultInstance();
    }

    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler build() {
      com.fluxninja.generated.aperture.policy.language.v1.Scheduler result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler buildPartial() {
      com.fluxninja.generated.aperture.policy.language.v1.Scheduler result = new com.fluxninja.generated.aperture.policy.language.v1.Scheduler(this);
      if (outPortsBuilder_ == null) {
        result.outPorts_ = outPorts_;
      } else {
        result.outPorts_ = outPortsBuilder_.build();
      }
      if (parametersBuilder_ == null) {
        result.parameters_ = parameters_;
      } else {
        result.parameters_ = parametersBuilder_.build();
      }
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.fluxninja.generated.aperture.policy.language.v1.Scheduler) {
        return mergeFrom((com.fluxninja.generated.aperture.policy.language.v1.Scheduler)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.fluxninja.generated.aperture.policy.language.v1.Scheduler other) {
      if (other == com.fluxninja.generated.aperture.policy.language.v1.Scheduler.getDefaultInstance()) return this;
      if (other.hasOutPorts()) {
        mergeOutPorts(other.getOutPorts());
      }
      if (other.hasParameters()) {
        mergeParameters(other.getParameters());
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      com.fluxninja.generated.aperture.policy.language.v1.Scheduler parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.fluxninja.generated.aperture.policy.language.v1.Scheduler) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }

    private com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs outPorts_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.Builder, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.OutsOrBuilder> outPortsBuilder_;
    /**
     * <pre>
     * Output ports for the Scheduler component.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Outs out_ports = 1 [json_name = "outPorts"];</code>
     * @return Whether the outPorts field is set.
     */
    public boolean hasOutPorts() {
      return outPortsBuilder_ != null || outPorts_ != null;
    }
    /**
     * <pre>
     * Output ports for the Scheduler component.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Outs out_ports = 1 [json_name = "outPorts"];</code>
     * @return The outPorts.
     */
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs getOutPorts() {
      if (outPortsBuilder_ == null) {
        return outPorts_ == null ? com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.getDefaultInstance() : outPorts_;
      } else {
        return outPortsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Output ports for the Scheduler component.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Outs out_ports = 1 [json_name = "outPorts"];</code>
     */
    public Builder setOutPorts(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs value) {
      if (outPortsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        outPorts_ = value;
        onChanged();
      } else {
        outPortsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Output ports for the Scheduler component.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Outs out_ports = 1 [json_name = "outPorts"];</code>
     */
    public Builder setOutPorts(
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.Builder builderForValue) {
      if (outPortsBuilder_ == null) {
        outPorts_ = builderForValue.build();
        onChanged();
      } else {
        outPortsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Output ports for the Scheduler component.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Outs out_ports = 1 [json_name = "outPorts"];</code>
     */
    public Builder mergeOutPorts(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs value) {
      if (outPortsBuilder_ == null) {
        if (outPorts_ != null) {
          outPorts_ =
            com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.newBuilder(outPorts_).mergeFrom(value).buildPartial();
        } else {
          outPorts_ = value;
        }
        onChanged();
      } else {
        outPortsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Output ports for the Scheduler component.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Outs out_ports = 1 [json_name = "outPorts"];</code>
     */
    public Builder clearOutPorts() {
      if (outPortsBuilder_ == null) {
        outPorts_ = null;
        onChanged();
      } else {
        outPorts_ = null;
        outPortsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Output ports for the Scheduler component.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Outs out_ports = 1 [json_name = "outPorts"];</code>
     */
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.Builder getOutPortsBuilder() {
      
      onChanged();
      return getOutPortsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Output ports for the Scheduler component.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Outs out_ports = 1 [json_name = "outPorts"];</code>
     */
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.OutsOrBuilder getOutPortsOrBuilder() {
      if (outPortsBuilder_ != null) {
        return outPortsBuilder_.getMessageOrBuilder();
      } else {
        return outPorts_ == null ?
            com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.getDefaultInstance() : outPorts_;
      }
    }
    /**
     * <pre>
     * Output ports for the Scheduler component.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Outs out_ports = 1 [json_name = "outPorts"];</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.Builder, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.OutsOrBuilder> 
        getOutPortsFieldBuilder() {
      if (outPortsBuilder_ == null) {
        outPortsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Outs.Builder, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.OutsOrBuilder>(
                getOutPorts(),
                getParentForChildren(),
                isClean());
        outPorts_ = null;
      }
      return outPortsBuilder_;
    }

    private com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters parameters_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.Builder, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.ParametersOrBuilder> parametersBuilder_;
    /**
     * <pre>
     * Scheduler parameters.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Parameters parameters = 2 [json_name = "parameters"];</code>
     * @return Whether the parameters field is set.
     */
    public boolean hasParameters() {
      return parametersBuilder_ != null || parameters_ != null;
    }
    /**
     * <pre>
     * Scheduler parameters.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Parameters parameters = 2 [json_name = "parameters"];</code>
     * @return The parameters.
     */
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters getParameters() {
      if (parametersBuilder_ == null) {
        return parameters_ == null ? com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.getDefaultInstance() : parameters_;
      } else {
        return parametersBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Scheduler parameters.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Parameters parameters = 2 [json_name = "parameters"];</code>
     */
    public Builder setParameters(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters value) {
      if (parametersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        parameters_ = value;
        onChanged();
      } else {
        parametersBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Scheduler parameters.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Parameters parameters = 2 [json_name = "parameters"];</code>
     */
    public Builder setParameters(
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.Builder builderForValue) {
      if (parametersBuilder_ == null) {
        parameters_ = builderForValue.build();
        onChanged();
      } else {
        parametersBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Scheduler parameters.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Parameters parameters = 2 [json_name = "parameters"];</code>
     */
    public Builder mergeParameters(com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters value) {
      if (parametersBuilder_ == null) {
        if (parameters_ != null) {
          parameters_ =
            com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.newBuilder(parameters_).mergeFrom(value).buildPartial();
        } else {
          parameters_ = value;
        }
        onChanged();
      } else {
        parametersBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Scheduler parameters.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Parameters parameters = 2 [json_name = "parameters"];</code>
     */
    public Builder clearParameters() {
      if (parametersBuilder_ == null) {
        parameters_ = null;
        onChanged();
      } else {
        parameters_ = null;
        parametersBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Scheduler parameters.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Parameters parameters = 2 [json_name = "parameters"];</code>
     */
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.Builder getParametersBuilder() {
      
      onChanged();
      return getParametersFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Scheduler parameters.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Parameters parameters = 2 [json_name = "parameters"];</code>
     */
    public com.fluxninja.generated.aperture.policy.language.v1.Scheduler.ParametersOrBuilder getParametersOrBuilder() {
      if (parametersBuilder_ != null) {
        return parametersBuilder_.getMessageOrBuilder();
      } else {
        return parameters_ == null ?
            com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.getDefaultInstance() : parameters_;
      }
    }
    /**
     * <pre>
     * Scheduler parameters.
     * </pre>
     *
     * <code>.aperture.policy.language.v1.Scheduler.Parameters parameters = 2 [json_name = "parameters"];</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.Builder, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.ParametersOrBuilder> 
        getParametersFieldBuilder() {
      if (parametersBuilder_ == null) {
        parametersBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.Parameters.Builder, com.fluxninja.generated.aperture.policy.language.v1.Scheduler.ParametersOrBuilder>(
                getParameters(),
                getParentForChildren(),
                isClean());
        parameters_ = null;
      }
      return parametersBuilder_;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:aperture.policy.language.v1.Scheduler)
  }

  // @@protoc_insertion_point(class_scope:aperture.policy.language.v1.Scheduler)
  private static final com.fluxninja.generated.aperture.policy.language.v1.Scheduler DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new com.fluxninja.generated.aperture.policy.language.v1.Scheduler();
  }

  public static com.fluxninja.generated.aperture.policy.language.v1.Scheduler getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<Scheduler>
      PARSER = new com.google.protobuf.AbstractParser<Scheduler>() {
    @java.lang.Override
    public Scheduler parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new Scheduler(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<Scheduler> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<Scheduler> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.fluxninja.generated.aperture.policy.language.v1.Scheduler getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

