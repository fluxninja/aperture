// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: aperture/policy/language/v1/flowcontrol.proto

package com.fluxninja.generated.aperture.policy.language.v1;

/**
 * <pre>
 * Rego define a set of labels that are extracted after evaluating a rego module.
 * :::info
 * You can use the [live-preview](/concepts/flow-control/resources/classifier.md#live-previewing-requests) feature to first preview the input to the classifier before writing the labeling logic.
 * :::
 * :::info
 * Special rego variables:
 * - `data.&lt;package&gt;.tokens`: Number of tokens for this request. This value is used by rate limiters and concurrency limiters when making decisions. The value provided here will override any value provided in the policy configuration for the workload. When this label is provided, it is not emitted as part of flow labels or telemetry and is solely used while processing the request.
 * :::
 * Example of Rego module which also disables telemetry visibility of label:
 * ```yaml
 * rego:
 *   labels:
 *     user:
 *       telemetry: false
 *   module: |
 *     package user_from_cookie
 *     cookies := split(input.attributes.request.http.headers.cookie, "; ")
 *     user := user {
 *         cookie := cookies[_]
 *         startswith(cookie, "session=")
 *         session := substring(cookie, count("session="), -1)
 *         parts := split(session, ".")
 *         object := json.unmarshal(base64url.decode(parts[0]))
 *         user := object.user
 *     }
 * ```
 * </pre>
 *
 * Protobuf type {@code aperture.policy.language.v1.Rego}
 */
public final class Rego extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:aperture.policy.language.v1.Rego)
    RegoOrBuilder {
private static final long serialVersionUID = 0L;
  // Use Rego.newBuilder() to construct.
  private Rego(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private Rego() {
    module_ = "";
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(
      UnusedPrivateParameter unused) {
    return new Rego();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private Rego(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 10: {
            if (!((mutable_bitField0_ & 0x00000001) != 0)) {
              labels_ = com.google.protobuf.MapField.newMapField(
                  LabelsDefaultEntryHolder.defaultEntry);
              mutable_bitField0_ |= 0x00000001;
            }
            com.google.protobuf.MapEntry<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties>
            labels__ = input.readMessage(
                LabelsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
            labels_.getMutableMap().put(
                labels__.getKey(), labels__.getValue());
            break;
          }
          case 18: {
            java.lang.String s = input.readStringRequireUtf8();

            module_ = s;
            break;
          }
          default: {
            if (!parseUnknownField(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (com.google.protobuf.UninitializedMessageException e) {
      throw e.asInvalidProtocolBufferException().setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Rego_descriptor;
  }

  @SuppressWarnings({"rawtypes"})
  @java.lang.Override
  protected com.google.protobuf.MapField internalGetMapField(
      int number) {
    switch (number) {
      case 1:
        return internalGetLabels();
      default:
        throw new RuntimeException(
            "Invalid map field number: " + number);
    }
  }
  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Rego_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.fluxninja.generated.aperture.policy.language.v1.Rego.class, com.fluxninja.generated.aperture.policy.language.v1.Rego.Builder.class);
  }

  public interface LabelPropertiesOrBuilder extends
      // @@protoc_insertion_point(interface_extends:aperture.policy.language.v1.Rego.LabelProperties)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Decides if the created flow label should be available as an attribute in OLAP telemetry and
     * propagated in [baggage](/concepts/flow-control/flow-label.md#baggage)
     * :::note
     * The flow label is always accessible in Aperture Policies regardless of this setting.
     * :::
     * :::caution
     * When using [FluxNinja ARC extension](arc/extension.md), telemetry enabled
     * labels are sent to FluxNinja ARC for observability. Telemetry should be disabled for
     * sensitive labels.
     * :::
     * </pre>
     *
     * <code>bool telemetry = 1 [json_name = "telemetry"];</code>
     * @return The telemetry.
     */
    boolean getTelemetry();
  }
  /**
   * Protobuf type {@code aperture.policy.language.v1.Rego.LabelProperties}
   */
  public static final class LabelProperties extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:aperture.policy.language.v1.Rego.LabelProperties)
      LabelPropertiesOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use LabelProperties.newBuilder() to construct.
    private LabelProperties(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private LabelProperties() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new LabelProperties();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private LabelProperties(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {

              telemetry_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (com.google.protobuf.UninitializedMessageException e) {
        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Rego_LabelProperties_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Rego_LabelProperties_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties.class, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties.Builder.class);
    }

    public static final int TELEMETRY_FIELD_NUMBER = 1;
    private boolean telemetry_;
    /**
     * <pre>
     * Decides if the created flow label should be available as an attribute in OLAP telemetry and
     * propagated in [baggage](/concepts/flow-control/flow-label.md#baggage)
     * :::note
     * The flow label is always accessible in Aperture Policies regardless of this setting.
     * :::
     * :::caution
     * When using [FluxNinja ARC extension](arc/extension.md), telemetry enabled
     * labels are sent to FluxNinja ARC for observability. Telemetry should be disabled for
     * sensitive labels.
     * :::
     * </pre>
     *
     * <code>bool telemetry = 1 [json_name = "telemetry"];</code>
     * @return The telemetry.
     */
    @java.lang.Override
    public boolean getTelemetry() {
      return telemetry_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (telemetry_ != false) {
        output.writeBool(1, telemetry_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (telemetry_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, telemetry_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties)) {
        return super.equals(obj);
      }
      com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties other = (com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties) obj;

      if (getTelemetry()
          != other.getTelemetry()) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + TELEMETRY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getTelemetry());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code aperture.policy.language.v1.Rego.LabelProperties}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:aperture.policy.language.v1.Rego.LabelProperties)
        com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelPropertiesOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Rego_LabelProperties_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Rego_LabelProperties_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties.class, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties.Builder.class);
      }

      // Construct using com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        telemetry_ = false;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Rego_LabelProperties_descriptor;
      }

      @java.lang.Override
      public com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties getDefaultInstanceForType() {
        return com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties.getDefaultInstance();
      }

      @java.lang.Override
      public com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties build() {
        com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties buildPartial() {
        com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties result = new com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties(this);
        result.telemetry_ = telemetry_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties) {
          return mergeFrom((com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties other) {
        if (other == com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties.getDefaultInstance()) return this;
        if (other.getTelemetry() != false) {
          setTelemetry(other.getTelemetry());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private boolean telemetry_ ;
      /**
       * <pre>
       * Decides if the created flow label should be available as an attribute in OLAP telemetry and
       * propagated in [baggage](/concepts/flow-control/flow-label.md#baggage)
       * :::note
       * The flow label is always accessible in Aperture Policies regardless of this setting.
       * :::
       * :::caution
       * When using [FluxNinja ARC extension](arc/extension.md), telemetry enabled
       * labels are sent to FluxNinja ARC for observability. Telemetry should be disabled for
       * sensitive labels.
       * :::
       * </pre>
       *
       * <code>bool telemetry = 1 [json_name = "telemetry"];</code>
       * @return The telemetry.
       */
      @java.lang.Override
      public boolean getTelemetry() {
        return telemetry_;
      }
      /**
       * <pre>
       * Decides if the created flow label should be available as an attribute in OLAP telemetry and
       * propagated in [baggage](/concepts/flow-control/flow-label.md#baggage)
       * :::note
       * The flow label is always accessible in Aperture Policies regardless of this setting.
       * :::
       * :::caution
       * When using [FluxNinja ARC extension](arc/extension.md), telemetry enabled
       * labels are sent to FluxNinja ARC for observability. Telemetry should be disabled for
       * sensitive labels.
       * :::
       * </pre>
       *
       * <code>bool telemetry = 1 [json_name = "telemetry"];</code>
       * @param value The telemetry to set.
       * @return This builder for chaining.
       */
      public Builder setTelemetry(boolean value) {
        
        telemetry_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Decides if the created flow label should be available as an attribute in OLAP telemetry and
       * propagated in [baggage](/concepts/flow-control/flow-label.md#baggage)
       * :::note
       * The flow label is always accessible in Aperture Policies regardless of this setting.
       * :::
       * :::caution
       * When using [FluxNinja ARC extension](arc/extension.md), telemetry enabled
       * labels are sent to FluxNinja ARC for observability. Telemetry should be disabled for
       * sensitive labels.
       * :::
       * </pre>
       *
       * <code>bool telemetry = 1 [json_name = "telemetry"];</code>
       * @return This builder for chaining.
       */
      public Builder clearTelemetry() {
        
        telemetry_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:aperture.policy.language.v1.Rego.LabelProperties)
    }

    // @@protoc_insertion_point(class_scope:aperture.policy.language.v1.Rego.LabelProperties)
    private static final com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties();
    }

    public static com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LabelProperties>
        PARSER = new com.google.protobuf.AbstractParser<LabelProperties>() {
      @java.lang.Override
      public LabelProperties parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new LabelProperties(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<LabelProperties> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<LabelProperties> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public static final int LABELS_FIELD_NUMBER = 1;
  private static final class LabelsDefaultEntryHolder {
    static final com.google.protobuf.MapEntry<
        java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties> defaultEntry =
            com.google.protobuf.MapEntry
            .<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties>newDefaultInstance(
                com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Rego_LabelsEntry_descriptor, 
                com.google.protobuf.WireFormat.FieldType.STRING,
                "",
                com.google.protobuf.WireFormat.FieldType.MESSAGE,
                com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties.getDefaultInstance());
  }
  private com.google.protobuf.MapField<
      java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties> labels_;
  private com.google.protobuf.MapField<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties>
  internalGetLabels() {
    if (labels_ == null) {
      return com.google.protobuf.MapField.emptyMapField(
          LabelsDefaultEntryHolder.defaultEntry);
    }
    return labels_;
  }

  public int getLabelsCount() {
    return internalGetLabels().getMap().size();
  }
  /**
   * <pre>
   * A map of {key, value} pairs mapping from
   * [flow label](/concepts/flow-control/flow-label.md) keys to queries that define
   * how to extract and propagate flow labels with that key.
   * The name of the label maps to a variable in the rego module, i.e. it maps to `data.&lt;package&gt;.&lt;label&gt;` variable.
   * </pre>
   *
   * <code>map&lt;string, .aperture.policy.language.v1.Rego.LabelProperties&gt; labels = 1 [json_name = "labels"];</code>
   */

  @java.lang.Override
  public boolean containsLabels(
      java.lang.String key) {
    if (key == null) { throw new NullPointerException("map key"); }
    return internalGetLabels().getMap().containsKey(key);
  }
  /**
   * Use {@link #getLabelsMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties> getLabels() {
    return getLabelsMap();
  }
  /**
   * <pre>
   * A map of {key, value} pairs mapping from
   * [flow label](/concepts/flow-control/flow-label.md) keys to queries that define
   * how to extract and propagate flow labels with that key.
   * The name of the label maps to a variable in the rego module, i.e. it maps to `data.&lt;package&gt;.&lt;label&gt;` variable.
   * </pre>
   *
   * <code>map&lt;string, .aperture.policy.language.v1.Rego.LabelProperties&gt; labels = 1 [json_name = "labels"];</code>
   */
  @java.lang.Override

  public java.util.Map<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties> getLabelsMap() {
    return internalGetLabels().getMap();
  }
  /**
   * <pre>
   * A map of {key, value} pairs mapping from
   * [flow label](/concepts/flow-control/flow-label.md) keys to queries that define
   * how to extract and propagate flow labels with that key.
   * The name of the label maps to a variable in the rego module, i.e. it maps to `data.&lt;package&gt;.&lt;label&gt;` variable.
   * </pre>
   *
   * <code>map&lt;string, .aperture.policy.language.v1.Rego.LabelProperties&gt; labels = 1 [json_name = "labels"];</code>
   */
  @java.lang.Override

  public com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties getLabelsOrDefault(
      java.lang.String key,
      com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties defaultValue) {
    if (key == null) { throw new NullPointerException("map key"); }
    java.util.Map<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties> map =
        internalGetLabels().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <pre>
   * A map of {key, value} pairs mapping from
   * [flow label](/concepts/flow-control/flow-label.md) keys to queries that define
   * how to extract and propagate flow labels with that key.
   * The name of the label maps to a variable in the rego module, i.e. it maps to `data.&lt;package&gt;.&lt;label&gt;` variable.
   * </pre>
   *
   * <code>map&lt;string, .aperture.policy.language.v1.Rego.LabelProperties&gt; labels = 1 [json_name = "labels"];</code>
   */
  @java.lang.Override

  public com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties getLabelsOrThrow(
      java.lang.String key) {
    if (key == null) { throw new NullPointerException("map key"); }
    java.util.Map<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties> map =
        internalGetLabels().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static final int MODULE_FIELD_NUMBER = 2;
  private volatile java.lang.Object module_;
  /**
   * <pre>
   * Source code of the rego module.
   * :::Note
   * Must include a "package" declaration.
   * :::
   * </pre>
   *
   * <code>string module = 2 [json_name = "module"];</code>
   * @return The module.
   */
  @java.lang.Override
  public java.lang.String getModule() {
    java.lang.Object ref = module_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      module_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Source code of the rego module.
   * :::Note
   * Must include a "package" declaration.
   * :::
   * </pre>
   *
   * <code>string module = 2 [json_name = "module"];</code>
   * @return The bytes for module.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getModuleBytes() {
    java.lang.Object ref = module_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      module_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    com.google.protobuf.GeneratedMessageV3
      .serializeStringMapTo(
        output,
        internalGetLabels(),
        LabelsDefaultEntryHolder.defaultEntry,
        1);
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(module_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 2, module_);
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    for (java.util.Map.Entry<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties> entry
         : internalGetLabels().getMap().entrySet()) {
      com.google.protobuf.MapEntry<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties>
      labels__ = LabelsDefaultEntryHolder.defaultEntry.newBuilderForType()
          .setKey(entry.getKey())
          .setValue(entry.getValue())
          .build();
      size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, labels__);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(module_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, module_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof com.fluxninja.generated.aperture.policy.language.v1.Rego)) {
      return super.equals(obj);
    }
    com.fluxninja.generated.aperture.policy.language.v1.Rego other = (com.fluxninja.generated.aperture.policy.language.v1.Rego) obj;

    if (!internalGetLabels().equals(
        other.internalGetLabels())) return false;
    if (!getModule()
        .equals(other.getModule())) return false;
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (!internalGetLabels().getMap().isEmpty()) {
      hash = (37 * hash) + LABELS_FIELD_NUMBER;
      hash = (53 * hash) + internalGetLabels().hashCode();
    }
    hash = (37 * hash) + MODULE_FIELD_NUMBER;
    hash = (53 * hash) + getModule().hashCode();
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.fluxninja.generated.aperture.policy.language.v1.Rego parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Rego parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Rego parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Rego parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Rego parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Rego parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Rego parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Rego parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Rego parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Rego parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Rego parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static com.fluxninja.generated.aperture.policy.language.v1.Rego parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(com.fluxninja.generated.aperture.policy.language.v1.Rego prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * Rego define a set of labels that are extracted after evaluating a rego module.
   * :::info
   * You can use the [live-preview](/concepts/flow-control/resources/classifier.md#live-previewing-requests) feature to first preview the input to the classifier before writing the labeling logic.
   * :::
   * :::info
   * Special rego variables:
   * - `data.&lt;package&gt;.tokens`: Number of tokens for this request. This value is used by rate limiters and concurrency limiters when making decisions. The value provided here will override any value provided in the policy configuration for the workload. When this label is provided, it is not emitted as part of flow labels or telemetry and is solely used while processing the request.
   * :::
   * Example of Rego module which also disables telemetry visibility of label:
   * ```yaml
   * rego:
   *   labels:
   *     user:
   *       telemetry: false
   *   module: |
   *     package user_from_cookie
   *     cookies := split(input.attributes.request.http.headers.cookie, "; ")
   *     user := user {
   *         cookie := cookies[_]
   *         startswith(cookie, "session=")
   *         session := substring(cookie, count("session="), -1)
   *         parts := split(session, ".")
   *         object := json.unmarshal(base64url.decode(parts[0]))
   *         user := object.user
   *     }
   * ```
   * </pre>
   *
   * Protobuf type {@code aperture.policy.language.v1.Rego}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:aperture.policy.language.v1.Rego)
      com.fluxninja.generated.aperture.policy.language.v1.RegoOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Rego_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 1:
          return internalGetLabels();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMutableMapField(
        int number) {
      switch (number) {
        case 1:
          return internalGetMutableLabels();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Rego_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.fluxninja.generated.aperture.policy.language.v1.Rego.class, com.fluxninja.generated.aperture.policy.language.v1.Rego.Builder.class);
    }

    // Construct using com.fluxninja.generated.aperture.policy.language.v1.Rego.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
      }
    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      internalGetMutableLabels().clear();
      module_ = "";

      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return com.fluxninja.generated.aperture.policy.language.v1.FlowcontrolProto.internal_static_aperture_policy_language_v1_Rego_descriptor;
    }

    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Rego getDefaultInstanceForType() {
      return com.fluxninja.generated.aperture.policy.language.v1.Rego.getDefaultInstance();
    }

    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Rego build() {
      com.fluxninja.generated.aperture.policy.language.v1.Rego result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.fluxninja.generated.aperture.policy.language.v1.Rego buildPartial() {
      com.fluxninja.generated.aperture.policy.language.v1.Rego result = new com.fluxninja.generated.aperture.policy.language.v1.Rego(this);
      int from_bitField0_ = bitField0_;
      result.labels_ = internalGetLabels();
      result.labels_.makeImmutable();
      result.module_ = module_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.fluxninja.generated.aperture.policy.language.v1.Rego) {
        return mergeFrom((com.fluxninja.generated.aperture.policy.language.v1.Rego)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.fluxninja.generated.aperture.policy.language.v1.Rego other) {
      if (other == com.fluxninja.generated.aperture.policy.language.v1.Rego.getDefaultInstance()) return this;
      internalGetMutableLabels().mergeFrom(
          other.internalGetLabels());
      if (!other.getModule().isEmpty()) {
        module_ = other.module_;
        onChanged();
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      com.fluxninja.generated.aperture.policy.language.v1.Rego parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.fluxninja.generated.aperture.policy.language.v1.Rego) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }
    private int bitField0_;

    private com.google.protobuf.MapField<
        java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties> labels_;
    private com.google.protobuf.MapField<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties>
    internalGetLabels() {
      if (labels_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            LabelsDefaultEntryHolder.defaultEntry);
      }
      return labels_;
    }
    private com.google.protobuf.MapField<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties>
    internalGetMutableLabels() {
      onChanged();;
      if (labels_ == null) {
        labels_ = com.google.protobuf.MapField.newMapField(
            LabelsDefaultEntryHolder.defaultEntry);
      }
      if (!labels_.isMutable()) {
        labels_ = labels_.copy();
      }
      return labels_;
    }

    public int getLabelsCount() {
      return internalGetLabels().getMap().size();
    }
    /**
     * <pre>
     * A map of {key, value} pairs mapping from
     * [flow label](/concepts/flow-control/flow-label.md) keys to queries that define
     * how to extract and propagate flow labels with that key.
     * The name of the label maps to a variable in the rego module, i.e. it maps to `data.&lt;package&gt;.&lt;label&gt;` variable.
     * </pre>
     *
     * <code>map&lt;string, .aperture.policy.language.v1.Rego.LabelProperties&gt; labels = 1 [json_name = "labels"];</code>
     */

    @java.lang.Override
    public boolean containsLabels(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetLabels().getMap().containsKey(key);
    }
    /**
     * Use {@link #getLabelsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties> getLabels() {
      return getLabelsMap();
    }
    /**
     * <pre>
     * A map of {key, value} pairs mapping from
     * [flow label](/concepts/flow-control/flow-label.md) keys to queries that define
     * how to extract and propagate flow labels with that key.
     * The name of the label maps to a variable in the rego module, i.e. it maps to `data.&lt;package&gt;.&lt;label&gt;` variable.
     * </pre>
     *
     * <code>map&lt;string, .aperture.policy.language.v1.Rego.LabelProperties&gt; labels = 1 [json_name = "labels"];</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties> getLabelsMap() {
      return internalGetLabels().getMap();
    }
    /**
     * <pre>
     * A map of {key, value} pairs mapping from
     * [flow label](/concepts/flow-control/flow-label.md) keys to queries that define
     * how to extract and propagate flow labels with that key.
     * The name of the label maps to a variable in the rego module, i.e. it maps to `data.&lt;package&gt;.&lt;label&gt;` variable.
     * </pre>
     *
     * <code>map&lt;string, .aperture.policy.language.v1.Rego.LabelProperties&gt; labels = 1 [json_name = "labels"];</code>
     */
    @java.lang.Override

    public com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties getLabelsOrDefault(
        java.lang.String key,
        com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties> map =
          internalGetLabels().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * A map of {key, value} pairs mapping from
     * [flow label](/concepts/flow-control/flow-label.md) keys to queries that define
     * how to extract and propagate flow labels with that key.
     * The name of the label maps to a variable in the rego module, i.e. it maps to `data.&lt;package&gt;.&lt;label&gt;` variable.
     * </pre>
     *
     * <code>map&lt;string, .aperture.policy.language.v1.Rego.LabelProperties&gt; labels = 1 [json_name = "labels"];</code>
     */
    @java.lang.Override

    public com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties getLabelsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties> map =
          internalGetLabels().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public Builder clearLabels() {
      internalGetMutableLabels().getMutableMap()
          .clear();
      return this;
    }
    /**
     * <pre>
     * A map of {key, value} pairs mapping from
     * [flow label](/concepts/flow-control/flow-label.md) keys to queries that define
     * how to extract and propagate flow labels with that key.
     * The name of the label maps to a variable in the rego module, i.e. it maps to `data.&lt;package&gt;.&lt;label&gt;` variable.
     * </pre>
     *
     * <code>map&lt;string, .aperture.policy.language.v1.Rego.LabelProperties&gt; labels = 1 [json_name = "labels"];</code>
     */

    public Builder removeLabels(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      internalGetMutableLabels().getMutableMap()
          .remove(key);
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties>
    getMutableLabels() {
      return internalGetMutableLabels().getMutableMap();
    }
    /**
     * <pre>
     * A map of {key, value} pairs mapping from
     * [flow label](/concepts/flow-control/flow-label.md) keys to queries that define
     * how to extract and propagate flow labels with that key.
     * The name of the label maps to a variable in the rego module, i.e. it maps to `data.&lt;package&gt;.&lt;label&gt;` variable.
     * </pre>
     *
     * <code>map&lt;string, .aperture.policy.language.v1.Rego.LabelProperties&gt; labels = 1 [json_name = "labels"];</code>
     */
    public Builder putLabels(
        java.lang.String key,
        com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties value) {
      if (key == null) { throw new NullPointerException("map key"); }
      if (value == null) {
  throw new NullPointerException("map value");
}

      internalGetMutableLabels().getMutableMap()
          .put(key, value);
      return this;
    }
    /**
     * <pre>
     * A map of {key, value} pairs mapping from
     * [flow label](/concepts/flow-control/flow-label.md) keys to queries that define
     * how to extract and propagate flow labels with that key.
     * The name of the label maps to a variable in the rego module, i.e. it maps to `data.&lt;package&gt;.&lt;label&gt;` variable.
     * </pre>
     *
     * <code>map&lt;string, .aperture.policy.language.v1.Rego.LabelProperties&gt; labels = 1 [json_name = "labels"];</code>
     */

    public Builder putAllLabels(
        java.util.Map<java.lang.String, com.fluxninja.generated.aperture.policy.language.v1.Rego.LabelProperties> values) {
      internalGetMutableLabels().getMutableMap()
          .putAll(values);
      return this;
    }

    private java.lang.Object module_ = "";
    /**
     * <pre>
     * Source code of the rego module.
     * :::Note
     * Must include a "package" declaration.
     * :::
     * </pre>
     *
     * <code>string module = 2 [json_name = "module"];</code>
     * @return The module.
     */
    public java.lang.String getModule() {
      java.lang.Object ref = module_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        module_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Source code of the rego module.
     * :::Note
     * Must include a "package" declaration.
     * :::
     * </pre>
     *
     * <code>string module = 2 [json_name = "module"];</code>
     * @return The bytes for module.
     */
    public com.google.protobuf.ByteString
        getModuleBytes() {
      java.lang.Object ref = module_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        module_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Source code of the rego module.
     * :::Note
     * Must include a "package" declaration.
     * :::
     * </pre>
     *
     * <code>string module = 2 [json_name = "module"];</code>
     * @param value The module to set.
     * @return This builder for chaining.
     */
    public Builder setModule(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      module_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Source code of the rego module.
     * :::Note
     * Must include a "package" declaration.
     * :::
     * </pre>
     *
     * <code>string module = 2 [json_name = "module"];</code>
     * @return This builder for chaining.
     */
    public Builder clearModule() {
      
      module_ = getDefaultInstance().getModule();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Source code of the rego module.
     * :::Note
     * Must include a "package" declaration.
     * :::
     * </pre>
     *
     * <code>string module = 2 [json_name = "module"];</code>
     * @param value The bytes for module to set.
     * @return This builder for chaining.
     */
    public Builder setModuleBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      module_ = value;
      onChanged();
      return this;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:aperture.policy.language.v1.Rego)
  }

  // @@protoc_insertion_point(class_scope:aperture.policy.language.v1.Rego)
  private static final com.fluxninja.generated.aperture.policy.language.v1.Rego DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new com.fluxninja.generated.aperture.policy.language.v1.Rego();
  }

  public static com.fluxninja.generated.aperture.policy.language.v1.Rego getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<Rego>
      PARSER = new com.google.protobuf.AbstractParser<Rego>() {
    @java.lang.Override
    public Rego parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new Rego(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<Rego> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<Rego> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.fluxninja.generated.aperture.policy.language.v1.Rego getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

