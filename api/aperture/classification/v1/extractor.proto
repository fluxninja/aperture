syntax = "proto3";

package aperture.classification.v1;

import "protoc-gen-openapiv2/options/annotations.proto";

// Defines a high-level way to specify how to extract a flow label given http request metadata, without a need to write regod code.
// There are multiple variants of extractor, specify exactly one:
// - JSON Extractor
// - Address Extractor
// - JWT Extractor
message Extractor {
  oneof variant {
    // Use an attribute with no convertion.
    // Attribute path is a dot-separated path to attribute.
    //
    // Should be either:
    // * one of the fields of [Attribute Context][attribute-context], or
    // * a special "request.http.bearer" pseudo-attribute.
    // Eg. "request.http.method" or "request.http.header.user-agent"
    //
    // Note: The same attribute path syntax is shared by other extractor variants,
    // wherever attribute path is needed in their "from" syntax.
    //
    // Example:
    // ```yaml
    // from: request.http.headers.user-agent
    // ```
    // [attribute-context]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/attribute_context.proto"
    string from = 1;

    // Deserialize a json, and extract one of the fields.
    JSONExtractor json = 2;

    // Display an address as a single string - `<ip>:<port>`.
    AddressExtractor address = 3;

    // Parse the attribute as JWT and read the payload.
    JWTExtractor jwt = 4;

    // Match HTTP Path to given path templates.
    PathTemplateMatcher path_templates = 5;
  }
}

// Deserialize a json, and extract one of the fields.
//
// Example:
// ```yaml
// from: request.http.body
// pointer: /user/name
// ```
message JSONExtractor {
  // Attribute path pointing to some strings - eg. "request.http.body".
  string from = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "required"
      }
    }
  }]; //@gotags: validate:"required"

  // Json pointer represents a parsed json pointer which allows to select a specified field from the json payload.
  //
  // Note: Uses [json pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,
  // eg. `/foo/bar`. If the pointer points into an object, it'd be stringified.
  string pointer = 2;
}

// Display an [Address][ext-authz-address] as a single string, eg. `<ip>:<port>`.
// IP addresses in attribute context are defined as objects with separate ip and port fields.
// This is a helper to display an address as a single string.
//
// Note: Use with care, as it might accidentally introduce a high-cardinality flow label values.
//
// [ext-authz-address]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address
//
// Example:
// ```yaml
// from: "source.address # or dstination.address"
// ```
message AddressExtractor {
  // Attribute path pointing to some string - eg. "source.address".
  string from = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "required"
      }
    }
  }]; //@gotags: validate:"required"
}

// Parse the attribute as JWT and read the payload.
// Specify a field to be extracted from payload using "json_pointer".
//
// Note: The signature is not verified against the secret (we're assuming there's some
// other parts of the system that handles such verification).
//
// Example:
// ```yaml
// from: request.http.bearer
// json_pointer: /user/email
// ```
message JWTExtractor {
  // Jwt token can be pulled from any input attribute, but most likely you'd want to use "request.http.bearer".
  string from = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "required"
      }
    }
  }]; //@gotags: validate:"required"

  // Json pointer allowing to select a specified field from the json payload.
  //
  // Note: Uses [json pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,
  // eg. `/foo/bar`. If the pointer points into an object, it'd be stringified.
  string json_pointer = 2;
}

// Matches HTTP Path to given path templates.
// HTTP path will be matched against given path templates.
// If a match occurs, the value associated with the path template will be treated as a result.
// In case of multiple path templates matching, the most specific one will be chosen.
message PathTemplateMatcher {
  // Template value keys are OpenAPI-inspired path templates.
  //
  // Examples:
  // ```
  // /register
  // /users/{user_id}
  // /static/*
  // ```
  //
  // * Static path segment `/foo` matches a path segment exactly.
  // * `/{param}` matches arbitrary path segment.
  // (The param name is ignored and can be omitted (`{}`))
  // * The parameter must cover whole segment.
  // * Additionally, path template can end with `/*` wildcard to match
  // arbitrary number of trailing segments (0 or more).
  // * Multiple consecutive `/` are ignored, as well as trailing `/`.
  // * Parametrized path segments must come after static segments.
  // * `*`, if present, must come last.
  // * Most specific template \"wins\" (`/foo` over `/{}` and `/{}` over `/*`).
  //
  // See also <https://swagger.io/specification/#path-templating-matching>"
  map<string, string> template_values = 1;
}
