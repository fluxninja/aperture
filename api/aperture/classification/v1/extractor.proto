syntax = "proto3";

package aperture.classification.v1;

import "protoc-gen-openapiv2/options/annotations.proto";

message Extractor {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      description: "Defines a high-level way to specify how to extract a flow label given http request metadata, without a need to write regod code.\nThere are multiple variants of extractor, specify exactly one:\n- JSON Extractor\n- Address Extractor\n- JWT Extractor"
    }
  };

  oneof variant {
    string from = 1 [
      (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
        description: "Use an attribute with no convertion.\nAttribute path is a dot-separated path to attribute. Should be either:\n* one of the fields of [Attribute Context][attribute-context], or\n* a special \"request.http.bearer\" pseudo-attribute.\nEg. \"request.http.method\" or \"request.http.header.user-agent\"\n\nNote: The same attribute path syntax is shared by other extractor variants, wherever attribute path is needed in their \"from\" syntax.\n\n[attribute-context]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/attribute_context.proto"
        example: "{\"'yaml\":{\"from\": \"request.http.headers.user-agent\"}}"
      }
    ];

    JSONExtractor json = 2 [
      (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
        description: "Deserialize a json, and extract one of the fields."
      }
    ];

    AddressExtractor address = 3 [
      (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
        description: "Display an address as a single string. eg. `<ip>:<port>`."
      }
    ];

    JWTExtractor jwt = 4 [
      (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
        description: "Parse the attribute as JWT and read the payload."
      }
    ];

    PathTemplateMatcher path_templates = 5 [
      (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
        description: "Match HTTP Path to given path templates."
      }
    ];
  }
}

message JSONExtractor {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      description: "Deserialize a json, and extract one of the fields."
    }
    example: "{\"'yaml\":{\"from\": \"request.http.body\", \"pointer\": \"/user/name\"}}"
  };

  string from = 1 [
    (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      description: "Attribute path pointing to some strings. eg. \"request.http.body\"."
      extensions: {
        key: "x-go-validate";
        value {
          string_value: "required"
        }
      }
    }
  ]; //@gotags: validate:"required"

  string pointer = 2 [
    (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      description: "Json pointer represents a parsed json pointer which allows to select a specified field from the json payload.\n\nNote: Uses [json pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax, eg. `/foo/bar`.\nIf the pointer points into an object, it'd be stringified."
    }
  ];
}

message AddressExtractor {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      description: "Display an [Address][ext-authz-address] as a single string, eg. `<ip>:<port>`.\nIP addresses in attribute context are defined as objects with separate ip and port fields.\nThis is a helper to display an address as a single string.\n\nNote: Use with care, as it might accidentally introduce a high-cardinality flow label values.\n\n[ext-authz-address]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address"
    }
    example: "{\"'yaml\":{\"from\": \"source.address # or dstination.address\"}}"
  };

  string from = 1 [
    (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      description: "Attribute path pointing to some string. eg. \"source.address\"."
      extensions: {
        key: "x-go-validate";
        value {
          string_value: "required"
        }
      }
    }
  ]; //@gotags: validate:"required"
}

message JWTExtractor {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      description: "Parse the attribute as JWT and read the payload.\nSpecify a field to be extracted from payload using \"json_pointer\".\n\nNote: The signature is not verified against the secret (we're assuming there's some \nother parts of the system that handles such verification)."
    }
    example: "{\"yaml\":{\"from\": \"request.http.bearer\", \"json_pointer\": \"/user/email\"}}"
  };

  string from = 1 [
    (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      description: "Jwt token can be pulled from any input attribute, but most likely you'd want to use \"request.http.bearer\"."
      extensions: {
        key: "x-go-validate";
        value {
          string_value: "required"
        }
      }
    }
  ]; //@gotags: validate:"required"

  string json_pointer = 2 [
    (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      description: "Json pointer allowing to select a specified field from the json payload.\n\nNote: Uses [json pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax, eg. `/foo/bar`.\nIf the pointer points into an object, it'd be stringified."
    }
  ];
}

message PathTemplateMatcher {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      description: "Matches HTTP Path to given path templates.\nHTTP path will be matched against given path templates. \nIf a match occurs, the value associated with the path template will be treated as a result.\nIn case of multiple path templates matching, the most specific one will be chosen."
    }
  };

  map<string, string> template_values = 1 [
    (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      description: "Template value keys are OpenAPI-inspired path templates.\n\n* Static path segment `/foo` matches a path segment exactly\n* `/{param}` matches arbitrary path segment.\n(The param name is ignored and can be omitted (`{}`))\n* The parameter must cover whole segment.\n* Additionally, path template can end with `/*` wildcard to match\n  arbitrary number of trailing segments (0 or more).\n* Multiple consecutive `/` are ignored, as well as trailing `/`.\n* Parametrized path segments must come after static segments.\n* `*`, if present, must come last.\n* Most specific template \"wins\" (`/foo` over `/{}` and `/{}` over `/*`).\n\nSee also <https://swagger.io/specification/#path-templating-matching>"
      example: "{\"/register\": \"/register\", \"/user/{userId}\": \"/user/{userId}\", \"/static/*\": \"/static/*\"}"
    }
  ];
}
