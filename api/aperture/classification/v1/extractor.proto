syntax = "proto3";

package aperture.classification.v1;

import "protoc-gen-openapiv2/options/annotations.proto";

  // Defines a high-level way to specify how to extract a flow label given http request metadata, without a need to write regod code.
  // There are multiple variants of extractor, specify exactly one:
  // - JSON Extractor
  // - Address Extractor
  // - JWT Extractor
message Extractor {

  oneof variant {
    string from = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      description: "Use an attribute with no convertion.\nAttribute path is a dot-separated path to attribute. Should be either:\n* one of the fields of [Attribute Context][attribute-context], or\n* a special \"request.http.bearer\" pseudo-attribute.\nEg. \"request.http.method\" or \"request.http.header.user-agent\"\n\nNote: The same attribute path syntax is shared by other extractor variants, wherever attribute path is needed in their \"from\" syntax.\n\n[attribute-context]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/attribute_context.proto"
      example: "{\"'yaml\":{\"from\": \"request.http.headers.user-agent\"}}"
    }];

    JSONExtractor json = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      description: "Deserialize a json, and extract one of the fields."
    }];

    AddressExtractor address = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      description: "Display an address as a single string. eg. `<ip>:<port>`."
    }];

    JWTExtractor jwt = 4 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      description: "Parse the attribute as JWT and read the payload."
    }];

    PathTemplateMatcher path_templates = 5 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      description: "Match HTTP Path to given path templates."
    }];
  }
}

  // Deserialize a json, and extract one of the fields.
  // 
  // Example:
  // ```yaml
  // from: request.http.body
  // pointer: /user/name
  // ```
message JSONExtractor {

  string from = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    description: "Attribute path pointing to some strings. eg. \"request.http.body\"."
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "required"
      }
    }
  }]; //@gotags: validate:"required"

  string pointer = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    description: "Json pointer represents a parsed json pointer which allows to select a specified field from the json payload.\n\nNote: Uses [json pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax, eg. `/foo/bar`.\nIf the pointer points into an object, it'd be stringified."
  }];
}

  // Display an [Address][ext-authz-address] as a single string, eg. `<ip>:<port>`.
  // IP addresses in attribute context are defined as objects with separate ip and port fields.
  // This is a helper to display an address as a single string.
  // 
  // Note: Use with care, as it might accidentally introduce a high-cardinality flow label values.
  // 
  // [ext-authz-address]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address
  // 
  // Example:
  // ```yaml
  // from: "source.address # or dstination.address"
  // ```
message AddressExtractor {

  string from = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    description: "Attribute path pointing to some string. eg. \"source.address\"."
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "required"
      }
    }
  }]; //@gotags: validate:"required"
}

  // Parse the attribute as JWT and read the payload.
  // Specify a field to be extracted from payload using "json_pointer".
  // 
  // Note: The signature is not verified against the secret (we're assuming there's some 
  // other parts of the system that handles such verification).
  // 
  // Example:
  // ```yaml
  // from: request.http.bearer
  // json_pointer: /user/email
  // ```
message JWTExtractor {

  string from = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    description: "Jwt token can be pulled from any input attribute, but most likely you'd want to use \"request.http.bearer\"."
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "required"
      }
    }
  }]; //@gotags: validate:"required"

  string json_pointer = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    description: "Json pointer allowing to select a specified field from the json payload.\n\nNote: Uses [json pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax, eg. `/foo/bar`.\nIf the pointer points into an object, it'd be stringified."
  }];
}

  // Matches HTTP Path to given path templates.
  // HTTP path will be matched against given path templates. 
  // If a match occurs, the value associated with the path template will be treated as a result.
  // In case of multiple path templates matching, the most specific one will be chosen.
message PathTemplateMatcher {

  map<string, string> template_values = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    description: "Template value keys are OpenAPI-inspired path templates.\n\n* Static path segment `/foo` matches a path segment exactly\n* `/{param}` matches arbitrary path segment.\n(The param name is ignored and can be omitted (`{}`))\n* The parameter must cover whole segment.\n* Additionally, path template can end with `/*` wildcard to match\n  arbitrary number of trailing segments (0 or more).\n* Multiple consecutive `/` are ignored, as well as trailing `/`.\n* Parametrized path segments must come after static segments.\n* `*`, if present, must come last.\n* Most specific template \"wins\" (`/foo` over `/{}` and `/{}` over `/*`).\n\nSee also <https://swagger.io/specification/#path-templating-matching>"
    example: "{\"/register\": \"/register\", \"/user/{userId}\": \"/user/{userId}\", \"/static/*\": \"/static/*\"}"
  }];
}
