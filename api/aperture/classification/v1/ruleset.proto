syntax = "proto3";

package aperture.classification.v1;

import "aperture/classification/v1/extractor.proto";
import "aperture/policy/language/v1/selector.proto";
import "google/api/annotations.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/wrappers.proto";

service RulesService {
  rpc AllRules(google.protobuf.Empty) returns (AllRulesResponse) {
    option (google.api.http) = {
      get: "/v1/rules"
    };
  }
}

message AllRulesResponse {
  AllRules all_rules = 1;
}

// All the ruleset name to ruleset mapping.
message AllRules {
  // A map of {key, value} pairs mapping from the name of the classifier to the values of the classifier.
  map<string, Classifier> all_rules = 1;
}

// Set of classification rules sharing a common selector.
//
// Example:
// ```yaml
// selector:
//   service: service1.default.svc.cluster.local
//   control_point:
//     traffic: ingress
// rules:
//   user:
//     extractor:
//       from: request.http.headers.user
// ```
message Classifier {
  // Defines where to apply the flow classification rule.
  policy.language.v1.Selector selector = 1;

  // A map of {key, value} pairs mapping from flow label names to rules that define how to extract and propagate them.
  map<string, Rule> rules = 2;
}

// Rule describes a single Flow Classification Rule.
// Flow classification rule extracts a value from request metadata.
// More specifically, from `input`, which has the same spec as [Envoy's External Authorization Attribute Context][attribute-context].
// See <https://play.openpolicyagent.org/p/gU7vcLkc70> for an example input.
// There are two ways to define a flow classification rule:
// * Using a declarative extractor â€“ suitable from simple cases, such as directly reading a value from header or a field from json body.
// * Rego expression.
//
// Performance note: It's recommended to use declarative extractors where possible, as they may be slightly performant than Rego expressions.
// [attribute-context](https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/attribute_context.proto)
//
// Example:
// ```yaml
// Example of Declarative JSON extractor:
//   yaml:
//     extractor:
//       json:
//         from: request.http.body
//         pointer: /user/name
//     propagate: true
//     hidden: false
// Example of Rego module:
//   yaml:
//     rego:
//       query: data.user_from_cookie.user
//       source:
//         package: user_from_cookie
//         cookies: "split(input.attributes.request.http.headers.cookie, ';')"
//         cookie: "cookies[_]"
//         cookie.startswith: "('session=')"
//         session: "substring(cookie, count('session='), -1)"
//         parts: "split(session, '.')"
//         object: "json.unmarshal(base64url.decode(parts[0]))"
//         user: object.user
//     propagate: false
//     hidden: true
// ```
message Rule {
  // Raw rego rules are compiled 1:1 to rego queries.
  // High-level extractor-based rules are compiled into a single rego query.
  message Rego {
    // Source code of the rego module.
    //
    // Note: Must include a "package" declaration.
    string source = 1;

    // Query string to extract a value (eg. `data.<mymodulename>.<variablename>`).
    //
    // Note: The module name must match the package name from the "source".
    string query = 2;
  }

  oneof source {
    // High-level flow label declarative extractor.
    // Rego extractor extracts a value from the rego module.
    Extractor extractor = 1;

    // Rego module to extract a value from the rego module.
    Rego rego = 2;
  }

  // Decides if the created label should be applied to the whole flow (propagated in baggage) (default=true).
  google.protobuf.BoolValue propagate = 3;

  // Decides if the created flow label should be hidden from the telemetry.
  bool hidden = 4;
}
