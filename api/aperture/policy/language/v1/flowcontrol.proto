syntax = "proto3";

package aperture.policy.language.v1;

import "aperture/policy/language/v1/label_matcher.proto";
import "aperture/policy/language/v1/ports.proto";
import "aperture/policy/language/v1/std_components.proto";
import "google/protobuf/duration.proto";

// Describes which flow in which service a [flow control
// component](/concepts/flow-control/flow-control.md#components) should apply
// to
//
// :::info
//
// See also [FlowSelector overview](/concepts/flow-control/flow-selector.md).
//
// :::
message FlowSelector {
  // Match agent group and service
  ServiceSelector service_selector = 1; // @gotags: validate:"required"
  // Match control points and labels
  FlowMatcher flow_matcher = 2; // @gotags: validate:"required"
}

// Describes which service a [flow control or observability
// component](/concepts/flow-control/flow-control.md#components) should apply
// to
//
// :::info
//
// See also [FlowSelector overview](/concepts/flow-control/flow-selector.md).
//
// :::
message ServiceSelector {
  // Which [agent-group](/concepts/flow-control/flow-selector.md#agent-group) this
  // selector applies to.
  //
  // :::info
  //
  // Agent Groups are used to scope policies to a subset of agents connected to the same controller.
  // This is especially useful in the Kubernetes sidecar installation because service discovery is switched off in that mode.
  // The agents within an agent group form a peer to peer cluster and constantly share state.
  //
  // :::
  string agent_group = 1; // @gotags: default:"default"

  // The Fully Qualified Domain Name of the
  // [service](/concepts/flow-control/flow-selector.md) to select.
  //
  // In Kubernetes, this is the FQDN of the Service object.
  //
  // :::info
  //
  // `any` matches all services.
  //
  // :::
  //
  // :::info
  //
  // In the Kubernetes sidecar installation mode, service discovery is switched off by default.
  // To scope policies to services, the `service` should be set to `any` and instead, `agent_group` name should be used.
  //
  // :::
  //
  // :::info
  //
  // An entity (for example, Kubernetes pod) may belong to multiple services.
  //
  // :::
  string service = 2; // @gotags: default:"any"
}

// Describes which flows a [flow control
// component](/concepts/flow-control/flow-control.md#components) should apply
// to
//
// :::info
//
// See also [FlowSelector overview](/concepts/flow-control/flow-selector.md).
//
// :::
// Example:
// ```yaml
// control_point: ingress
// label_matcher:
//   match_labels:
//     user_tier: gold
//   match_expressions:
//     - key: query
//       operator: In
//       values:
//         - insert
//         - delete
//   expression:
//     label_matches:
//         - label: user_agent
//           regex: ^(?!.*Chrome).*Safari
// ```
message FlowMatcher {
  // [Control Point](/concepts/flow-control/flow-selector.md#control-point)
  // identifies the location of a Flow within a Service. For an SDK based insertion, a Control Point can represent a particular feature or execution
  // block within a Service. In case of Service Mesh or Middleware insertion, a Control Point can identify ingress vs egress calls or distinct listeners
  // or filter chains.
  string control_point = 1; // @gotags: validate:"required"

  // Label matcher allows to add _additional_ condition on
  // [flow labels](/concepts/flow-control/flow-label.md)
  // must also be satisfied (in addition to service+control point matching)
  //
  // :::info
  //
  // See also [Label Matcher overview](/concepts/flow-control/flow-selector.md#label-matcher).
  //
  // :::
  //
  // :::note
  //
  // [Classifiers](#classifier) _can_ use flow labels created by some other
  // classifier, but only if they were created at some previous control point
  // (and propagated in baggage).
  //
  // This limitation doesn't apply to selectors of other entities, like
  // Flux Meters or Actuators. It's valid to create a flow label on a control
  // point using classifier, and immediately use it for matching on the same
  // control point.
  //
  // :::
  LabelMatcher label_matcher = 2;
}

// FlowControl Resources
message FlowControlResources {
  // Flux Meters are installed in the data-plane and form the observability leg of the feedback loop.
  //
  // Flux Meter created metrics can be consumed as input to the circuit via the PromQL component.
  map<string, FluxMeter> flux_meters = 1; // @gotags: validate:"dive"
  // Classifiers are installed in the data-plane and are used to label the requests based on payload content.
  //
  // The flow labels created by Classifiers can be matched by Flux Meters to create metrics for control purposes.
  repeated Classifier classifiers = 2; // @gotags: validate:"dive"
}

// Flux Meter gathers metrics for the traffic that matches its selector.
// The histogram created by Flux Meter measures the workload latency by default.
//
// :::info
//
// See also [Flux Meter overview](/concepts/flow-control/resources/flux-meter.md).
//
// :::
// Example:
// ```yaml
// static_buckets:
//    buckets: [5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]
// flow_selector:
//   service_selector:
//      agent_group: demoapp
//      service: service1-demo-app.demoapp.svc.cluster.local
//   flow_matcher:
//      control_point: ingress
// attribute_key: response_duration_ms
// ```
message FluxMeter {
  // StaticBuckets holds the static value of the buckets where latency histogram will be stored.
  message StaticBuckets {
    // The buckets in which latency histogram will be stored.
    repeated double buckets = 1; // @gotags: default:"[5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]"
  }

  // LinearBuckets creates `count` number of buckets, each `width` wide, where the lowest bucket has an
  // upper bound of `start`. The final +inf bucket isn't counted.
  message LinearBuckets {
    // Upper bound of the lowest bucket.
    double start = 1;

    // Width of each bucket.
    double width = 2;

    // Number of buckets.
    int32 count = 3; // @gotags: validate:"gt=0"
  }

  // ExponentialBuckets creates `count` number of buckets where the lowest bucket has an upper bound of `start`
  // and each following bucket's upper bound is `factor` times the previous bucket's upper bound. The final +inf
  // bucket isn't counted.
  message ExponentialBuckets {
    // Upper bound of the lowest bucket.
    double start = 1; // @gotags: validate:"gt=0.0"

    // Factor to be multiplied to the previous bucket's upper bound to calculate the following bucket's upper bound.
    double factor = 2; // @gotags: validate:"gt=1.0"

    // Number of buckets.
    int32 count = 3; // @gotags: validate:"gt=0"
  }

  // ExponentialBucketsRange creates `count` number of buckets where the lowest bucket is `min` and the highest
  // bucket is `max`. The final +inf bucket isn't counted.
  message ExponentialBucketsRange {
    // Lowest bucket.
    double min = 1; // @gotags: validate:"gt=0.0"

    // Highest bucket.
    double max = 2;

    // Number of buckets.
    int32 count = 3; // @gotags: validate:"gt=0"
  }

  // The selection criteria for the traffic that will be measured.
  FlowSelector flow_selector = 1;

  // Latency histogram buckets (in ms) for this Flux Meter.
  oneof histogram_buckets {
    StaticBuckets static_buckets = 2;
    LinearBuckets linear_buckets = 3;
    ExponentialBuckets exponential_buckets = 4;
    ExponentialBucketsRange exponential_buckets_range = 5;
  }

  // Key of the attribute in access log or span from which the metric for this flux meter is read.
  //
  // :::info
  //
  // For list of available attributes in Envoy access logs, refer
  // [Envoy Filter](/get-started/integrations/flow-control/envoy/istio.md#envoy-filter)
  //
  // :::
  //
  string attribute_key = 6; // @gotags: default:"workload_duration_ms"
}

// Set of classification rules sharing a common selector
//
// :::info
//
// See also [Classifier overview](/concepts/flow-control/resources/classifier.md).
//
// :::
// Example
// ```yaml
// flow_selector:
//   service_selector:
//      agent_group: demoapp
//      service: service1-demo-app.demoapp.svc.cluster.local
//   flow_matcher:
//      control_point: ingress
//      label_matcher:
//         match_labels:
//           user_tier: gold
//         match_expressions:
//           - key: user_type
//             operator: In
// rules:
//   user:
//    extractor:
//      from: request.http.headers.user-agent
//   telemetry: false
// ```
message Classifier {
  // Defines where to apply the flow classification rule.
  FlowSelector flow_selector = 1; // @gotags: validate:"required"

  // A map of {key, value} pairs mapping from
  // [flow label](/concepts/flow-control/flow-label.md) keys to rules that define
  // how to extract and propagate flow labels with that key.
  map<string, Rule> rules = 2; // @gotags: validate:"dive,keys,required,endkeys,required"

  // Rego based classification
  //
  // Rego is a policy language used to express complex policies in a concise and declarative way.
  // It can be used to define flow classification rules by writing custom queries that extract values from request metadata.
  // For simple cases, such as directly reading a value from header or a field from JSON body, declarative extractors are recommended.
  Rego rego = 3;
}

// Rule describes a single classification Rule
//
// Example of a JSON extractor:
// ```yaml
// extractor:
//   json:
//     from: request.http.body
//     pointer: /user/name
// ```
message Rule {
  // Raw Rego rules are compiled 1:1 to Rego queries
  //
  // High-level extractor-based rules are compiled into a single Rego query.
  //
  // Deprecated: 1.5.0
  message Rego {
    // Source code of the Rego module.
    //
    // Note: Must include a "package" declaration.
    string source = 1; // @gotags: validate:"deprecated,required"

    // Query string to extract a value (for example, `data.<mymodulename>.<variablename>`).
    //
    // Note: The module name must match the package name from the `source`.
    string query = 2; // @gotags: validate:"deprecated,required"
  }

  oneof source {
    // High-level declarative extractor.
    Extractor extractor = 1;

    // Rego module to extract a value from.
    //
    // Deprecated: 1.5.0
    Rego rego = 2;
  } // @gotags: validate:"required"

  // Decides if the created flow label should be available as an attribute in OLAP telemetry and
  // propagated in [baggage](/concepts/flow-control/flow-label.md#baggage)
  //
  // :::note
  //
  // The flow label is always accessible in Aperture Policies regardless of this setting.
  //
  // :::
  //
  // :::caution
  //
  // When using [FluxNinja ARC extension](arc/extension.md), telemetry enabled
  // labels are sent to FluxNinja ARC for observability. Telemetry should be disabled for
  // sensitive labels.
  //
  // :::
  bool telemetry = 3; // @gotags: default:"true"
}

// Rego define a set of labels that are extracted after evaluating a Rego module.
//
// :::info
//
// You can use the [live-preview](/concepts/flow-control/resources/classifier.md#live-previewing-requests) feature to first preview the input to the classifier before writing the labeling logic.
//
// :::
//
// :::info
//
// Special Rego variables:
// - `data.<package>.tokens`: Number of tokens for this request. This value is used by rate limiters and concurrency limiters when making decisions. The value provided here will override any value provided in the policy configuration for the workload. When this label is provided, it isn't emitted as part of flow labels or telemetry and is solely used while processing the request.
//
// :::
//
// Example of Rego module which also disables telemetry visibility of label:
// ```yaml
// rego:
//   labels:
//     user:
//       telemetry: false
//   module: |
//     package user_from_cookie
//     cookies := split(input.attributes.request.http.headers.cookie, "; ")
//     user := user {
//         cookie := cookies[_]
//         startswith(cookie, "session=")
//         session := substring(cookie, count("session="), -1)
//         parts := split(session, ".")
//         object := json.unmarshal(base64url.decode(parts[0]))
//         user := object.user
//     }
// ```
message Rego {
  message LabelProperties {
    // Decides if the created flow label should be available as an attribute in OLAP telemetry and
    // propagated in [baggage](/concepts/flow-control/flow-label.md#baggage)
    //
    // :::note
    //
    // The flow label is always accessible in Aperture Policies regardless of this setting.
    //
    // :::
    //
    // :::caution
    //
    // When using [FluxNinja ARC extension](arc/extension.md), telemetry enabled
    // labels are sent to FluxNinja ARC for observability. Telemetry should be disabled for
    // sensitive labels.
    //
    // :::
    bool telemetry = 1; // @gotags: default:"true"
  }

  // A map of {key, value} pairs mapping from
  // [flow label](/concepts/flow-control/flow-label.md) keys to queries that define
  // how to extract and propagate flow labels with that key.
  // The name of the label maps to a variable in the Rego module. It maps to `data.<package>.<label>` variable.
  map<string, LabelProperties> labels = 1; // @gotags: validate:"required,gt=0,dive,keys,required,endkeys,required"

  // Source code of the Rego module.
  //
  // :::Note
  //
  // Must include a "package" declaration.
  //
  // :::
  string module = 2; // @gotags: validate:"required"
}

// Defines a high-level way to specify how to extract a flow label value given HTTP request metadata, without a need to write Rego code
//
// There are multiple variants of extractor, specify exactly one.
message Extractor {
  oneof variant {
    // Use an attribute with no conversion
    //
    // Attribute path is a dot-separated path to attribute.
    //
    // Should be either:
    // * one of the fields of [Attribute Context][attribute-context], or
    // * a special `request.http.bearer` pseudo-attribute.
    // For example, `request.http.method` or `request.http.header.user-agent`
    //
    // Note: The same attribute path syntax is shared by other extractor variants,
    // wherever attribute path is needed in their "from" syntax.
    //
    // Example:
    // ```yaml
    // from: request.http.headers.user-agent
    // ```
    // [attribute-context]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/attribute_context.proto
    string from = 1;

    // Parse JSON, and extract one of the fields.
    JSONExtractor json = 2;

    // Display an address as a single string - `<ip>:<port>`.
    AddressExtractor address = 3;

    // Parse the attribute as JWT and read the payload.
    JWTExtractor jwt = 4;

    // Match HTTP Path to given path templates.
    PathTemplateMatcher path_templates = 5;
  }
}

// Parse JSON, and extract one of the fields
//
// Example:
// ```yaml
// from: request.http.body
// pointer: /user/name
// ```
message JSONExtractor {
  // Attribute path pointing to some strings - for example, `request.http.body`.
  string from = 1; //@gotags: validate:"required"

  // JSON pointer represents a parsed JSON pointer which allows to select a specified field from the payload.
  //
  // Note: Uses [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,
  // for example, `/foo/bar`. If the pointer points into an object, it'd be converted to a string.
  string pointer = 2;
}

// Display an [Address][ext-authz-address] as a single string, for example, `<ip>:<port>`
//
// IP addresses in attribute context are defined as objects with separate IP and port fields.
// This is a helper to display an address as a single string.
//
// :::caution
//
// This might introduce high-cardinality flow label values.
//
// :::
//
// [ext-authz-address]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address
//
// Example:
// ```yaml
// from: "source.address # or destination.address"
// ```
message AddressExtractor {
  // Attribute path pointing to some string - for example, `source.address`.
  string from = 1; //@gotags: validate:"required"
}

// Parse the attribute as JWT and read the payload
//
// Specify a field to be extracted from payload using `json_pointer`.
//
// Note: The signature isn't verified against the secret (assuming there's some
// other part of the system that handles such verification).
//
// Example:
// ```yaml
// from: request.http.bearer
// json_pointer: /user/email
// ```
message JWTExtractor {
  // JWT (JSON Web Token) can be extracted from any input attribute, but most likely you'd want to use `request.http.bearer`.
  string from = 1; //@gotags: validate:"required"

  // JSON pointer allowing to select a specified field from the payload.
  //
  // Note: Uses [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,
  // for example, `/foo/bar`. If the pointer points into an object, it'd be converted to a string.
  string json_pointer = 2;
}

// Matches HTTP Path to given path templates
//
// HTTP path will be matched against given path templates.
// If a match occurs, the value associated with the path template will be treated as a result.
// In case of multiple path templates matching, the most specific one will be chosen.
message PathTemplateMatcher {
  // Template value keys are OpenAPI-inspired path templates.
  //
  // * Static path segment `/foo` matches a path segment exactly
  // * `/{param}` matches arbitrary path segment.
  //   (The parameter name is ignored and can be omitted (`{}`))
  // * The parameter must cover whole segment.
  // * Additionally, path template can end with `/*` wildcard to match
  //   arbitrary number of trailing segments (0 or more).
  // * Multiple consecutive `/` are ignored, as well as trailing `/`.
  // * Parametrized path segments must come after static segments.
  // * `*`, if present, must come last.
  // * Most specific template "wins" (`/foo` over `/{}` and `/{}` over `/*`).
  //
  // See also <https://swagger.io/specification/#path-templating-matching>
  //
  // Example:
  // ```yaml
  // /register: register
  // "/user/{userId}": user
  // /static/*: other
  // ```
  map<string, string> template_values = 1; // @gotags: validate:"gt=0,dive,keys,required,endkeys,required"
}

// FlowControl components are used to regulate requests flow.
message FlowControl {
  oneof component {
    // Rate Limiter provides service protection by applying rate limiter.
    RateLimiter rate_limiter = 1;

    // Concurrency Limiter provides service protection by applying prioritized load shedding of flows using a network scheduler (for example, Weighted Fair Queuing).
    ConcurrencyLimiter concurrency_limiter = 2;

    // AIMD Concurrency control component is based on Additive Increase and Multiplicative Decrease of Concurrency. It takes a signal and setpoint as inputs and reduces concurrency limits proportionally (or any arbitrary power) based on deviation of the signal from setpoint. Internally implemented as a nested circuit.
    AIMDConcurrencyController aimd_concurrency_controller = 3;
  }
}

// Limits the traffic on a control point to specified rate
//
// :::info
//
// See also [Rate Limiter overview](/concepts/flow-control/components/rate-limiter.md).
//
// :::
//
// RateLimiting is done on per-label-value basis. Use `label_key`
// to select which label should be used as key.
message RateLimiter {
  message Parameters {
    message LazySync {
      // Enables lazy sync
      bool enabled = 1; // @gotags: default:"false"

      // Number of times to lazy sync within the `limit_reset_interval`.
      uint32 num_sync = 2; // @gotags: default:"5" validate:"gt=0"
    }

    // Time after which the limit for a given label value will be reset.
    google.protobuf.Duration limit_reset_interval = 1; // @gotags: default:"60s"

    // Specifies which label the rate limiter should be keyed by.
    //
    // Rate limiting is done independently for each value of the
    // [label](/concepts/flow-control/flow-label.md) with given key.
    // For example, to give each user a separate limit, assuming you
    // have a _user_ flow
    // label set up, set `label_key: "user"`.
    string label_key = 2; // @gotags: validate:"required"

    // Configuration of lazy-syncing behaviour of rate limiter
    LazySync lazy_sync = 3;
  }

  message Override {
    // Value of the label for which the override should be applied.
    string label_value = 1; // @gotags: validate:"required"

    // Amount by which the `in_ports.limit` should be multiplied for
    // this label value.
    double limit_scale_factor = 2; // @gotags: default:"1.0"
  }

  // Dynamic Configuration for the rate limiter
  message DynamicConfig {
    // Allows to specify different limits for particular label values.
    repeated Override overrides = 1; // @gotags: validate:"dive"
  }

  // Inputs for the RateLimiter component
  message Ins {
    // Number of flows allowed per `limit_reset_interval` per each label.
    // Negative values disable the rate limiter.
    //
    // :::tip
    //
    // Negative limit can be useful to _conditionally_ enable the rate limiter
    // under certain circumstances. [Decider](#decider) might be helpful.
    //
    // :::
    InPort limit = 1; // @gotags: validate:"required"
  }

  // Input ports for the RateLimiter component
  Ins in_ports = 1; // @gotags: validate:"required"

  // Which control point to apply this rate limiter to.
  FlowSelector flow_selector = 2; // @gotags: validate:"required"

  // Parameters for the RateLimiter component
  Parameters parameters = 3; // @gotags: validate:"required"

  // Configuration key for DynamicConfig
  string dynamic_config_key = 4;

  // Default configuration
  DynamicConfig default_config = 5;
}

// Concurrency Limiter is an actuator component that regulates flows to provide active service protection
//
// :::info
//
// See also [Concurrency Limiter overview](/concepts/flow-control/components/concurrency-limiter.md).
//
// :::
//
// It's based on the actuation strategy (for example, load actuator) and workload scheduling which is based on Weighted Fair Queuing principles.
// Concurrency is calculated in terms of total tokens which translate to (avg. latency \* in-flight requests) (Little's Law).
//
// ConcurrencyLimiter configuration is split into two parts: An actuation
// strategy and a scheduler. Right now, only `load_actuator` strategy is available.
message ConcurrencyLimiter {
  // Flow Selector decides the service and flows at which the concurrency limiter is applied.
  FlowSelector flow_selector = 1; // @gotags: validate:"required"

  // Configuration of Weighted Fair Queuing-based workload scheduler.
  //
  // Contains configuration of per-agent scheduler, and also defines some
  // output signals.
  Scheduler scheduler = 2; // @gotags: validate:"required"

  oneof actuation_strategy {
    // Actuator based on limiting the accepted concurrency under incoming concurrency * load multiplier.
    //
    // Actuation strategy defines the input signal that will drive the scheduler.
    LoadActuator load_actuator = 3;
  }
}

// Weighted Fair Queuing-based workload scheduler
//
// :::note
//
// Each Agent instantiates an independent copy of the scheduler, but output
// signals for accepted and incoming concurrency are aggregated across all agents.
//
// :::
//
// See [ConcurrencyLimiter](#concurrency-limiter) for more context.
message Scheduler {
  // Workload defines a class of requests that preferably have similar properties such as response latency or desired priority.
  message Workload {
    // Parameters defines parameters such as priority, tokens and fairness key that are applicable to flows within a workload.
    message Parameters {
      // Describes priority level of the requests within the workload.
      // Priority level ranges from 0 to 255.
      // Higher numbers means higher priority level.
      // Priority levels have non-linear effect on the workload scheduling. The following formula is used to determine the position of a request in the queue based on virtual finish time:
      //
      // $$
      // \text{virtual\_finish\_time} = \text{virtual\_time} + \left(\text{tokens} \cdot \left(\text{256} - \text{priority}\right)\right)
      // $$
      //
      uint32 priority = 1; // @gotags: validate:"gte=0,lte=255" default:"0"

      // Tokens determines the cost of admitting a single request the workload, which is typically defined as milliseconds of response latency.
      // This override is applicable only if tokens for the request aren't specified in the request.
      uint64 tokens = 2;

      // Fairness key is a label key that can be used to provide fairness within a workload.
      // Any [flow label](/concepts/flow-control/flow-label.md) can be used here. For example, if
      // you have a classifier that sets `user` flow label, you might want to set
      // `fairness_key = "user"`.
      string fairness_key = 3;
    }

    // Parameters associated with flows matching the label matcher.
    Parameters parameters = 1; // @gotags: validate:"required"

    // Label Matcher to select a Workload based on
    // [flow labels](/concepts/flow-control/flow-label.md).
    LabelMatcher label_matcher = 2; // @gotags: validate:"required"
  }

  // Scheduler parameters
  message Parameters {
    // List of workloads to be used in scheduler.
    //
    // Categorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads
    // allows for load-shedding to be "intelligent" compared to random rejections.
    // There are two aspects of this "intelligence":
    // * Scheduler can more precisely calculate concurrency if it understands
    //   that flows belonging to different classes have different weights (for example, insert vs select queries).
    // * Setting different priorities to different workloads lets the scheduler
    //   avoid dropping important traffic during overload.
    //
    // Each workload in this list specifies also a matcher that's used to
    // determine which flow will be categorized into which workload.
    // In case of multiple matching workloads, the first matching one will be used.
    // If none of workloads match, `default_workload` will be used.
    //
    // :::info
    //
    // See also [workload definition in the concepts
    // section](/concepts/flow-control/components/concurrency-limiter.md#workload).
    //
    // :::
    repeated Workload workloads = 1; // @gotags: validate:"dive"

    // Parameters to be used if none of workloads specified in `workloads` match.
    Workload.Parameters default_workload_parameters = 2;

    // Automatically estimate the size of a request in each workload, based on
    // historical latency. Each workload's `tokens` will be set to average
    // latency of flows in that workload during last few seconds (exact duration
    // of this average can change).
    // Make sure to not provide `tokens` in workload definitions or in the flow
    // if you want to use this feature.
    bool auto_tokens = 3; // @gotags: default:"true"

    // Timeout as a factor of tokens for a flow in a workload in case `auto_tokens` is set to true.
    //
    // If a flow isn't able to get tokens within `timeout_factor * tokens` of duration,
    // it will be rejected.
    //
    // This value impacts the prioritization and fairness because the larger the timeout the higher the chance a request has to get scheduled.
    double timeout_factor = 4; // @gotags: validate:"gte=0.0" default:"0.5"

    // Max Timeout is the value with which the flow timeout is capped.
    // When `auto_tokens` feature isn't enabled, this value is used as the
    // timeout for the flow, otherwise it's used as a cap for the timeout.
    //
    // :::caution
    //
    // This timeout needs to be strictly less than the timeout set on the
    // client for the whole GRPC call:
    // * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
    // * in case of libraries, is configured during the client initialization.
    //
    // Fail-open logic is use for flow control APIs, so if the GRPC timeout
    // fires first, the flow will end up being unconditionally allowed while
    // it's still waiting on the scheduler.
    //
    // To avoid such cases, the end-to-end GRPC timeout should also contain
    // some headroom for constant overhead like serialization, etc. Default
    // value for GRPC timeouts is 500ms, giving 50ms of headroom, so when
    // tweaking this timeout, make sure to adjust the GRPC timeout accordingly.
    //
    // :::
    google.protobuf.Duration max_timeout = 5; // @gotags: default:"0.49s"
  }

  // Output for the Scheduler component.
  message Outs {
    // Accepted concurrency is actual concurrency on a control point that this
    // scheduler is applied on.
    //
    // :::info
    //
    // Concurrency is a unit less number describing mean number of
    // [flows](/concepts/flow-control/flow-control.md#flow) being
    // concurrently processed by the system (system = control point).
    // Concurrency is calculated as _work_ done per unit of time (so
    // work-seconds per world-seconds). Work-seconds are computed based on
    // token-weights of flows (which are either estimated via `auto_tokens`
    // or specified by `Workload.tokens`).
    //
    // :::
    //
    // Value of this signal is aggregated from all the relevant schedulers.
    OutPort accepted_concurrency = 1;

    // Incoming concurrency is concurrency that'd be needed to accept all the
    // flows entering the scheduler.
    //
    // This is computed in the same way as `accepted_concurrency`, but summing
    // up work-seconds from all the flows entering scheduler, including
    // rejected ones.
    OutPort incoming_concurrency = 2;
  }

  // Output ports for the Scheduler component.
  Outs out_ports = 1;

  // Scheduler parameters.
  Parameters parameters = 2; // @gotags: validate:"required"
}

// Takes the load multiplier input signal and publishes it to the schedulers in the data-plane
message LoadActuator {
  // Dynamic Configuration for LoadActuator
  message DynamicConfig {
    // Decides whether to run the load actuator in dry-run mode. Dry run mode ensures that no traffic gets dropped by this load actuator.
    // Useful for observing the behavior of Load Actuator without disrupting any real traffic.
    bool dry_run = 1;
  }

  // Input for the Load Actuator component.
  message Ins {
    // Load multiplier is ratio of [incoming
    // concurrency](#scheduler-outs) that needs to be accepted.
    InPort load_multiplier = 1;
  }

  // Input ports for the Load Actuator component.
  Ins in_ports = 1;

  // Configuration key for DynamicConfig.
  string dynamic_config_key = 2;

  // Default configuration.
  DynamicConfig default_config = 3;
}

// High level concurrency control component. Baselines a signal via exponential moving average and applies concurrency limits based on deviation of signal from the baseline. Internally implemented as a nested circuit.
message AIMDConcurrencyController {
  // Inputs for the AIMDConcurrencyController component.
  message Ins {
    // The signal to the controller.
    InPort signal = 1;
    // The setpoint to the controller.
    InPort setpoint = 2;
  }

  // Outputs for the AIMDConcurrencyController component.
  message Outs {
    // Is overload is a Boolean signal that indicates whether the service is overloaded based on the deviation of the signal from the setpoint taking into account some tolerance.
    OutPort is_overload = 1;
    // Desired Load multiplier is the ratio of desired concurrency to the incoming concurrency.
    OutPort desired_load_multiplier = 2;
    // Observed Load multiplier is the ratio of accepted concurrency to the incoming concurrency.
    OutPort observed_load_multiplier = 3;
    // Accepted concurrency is the number of concurrent requests that are accepted by the service.
    OutPort accepted_concurrency = 4;
    // IncomingConcurrency is the number of concurrent requests that are received by the service.
    OutPort incoming_concurrency = 5;
  }

  // Input ports for the AIMDConcurrencyController component.
  Ins in_ports = 1;

  // Output ports for the AIMDConcurrencyController component.
  Outs out_ports = 2;

  // Flow Selector decides the service and flows at which the concurrency limiter is applied.
  FlowSelector flow_selector = 3; // @gotags: validate:"required"

  // Scheduler parameters.
  Scheduler.Parameters scheduler_parameters = 4; // @gotags: validate:"required"

  // Gradient parameters for the controller.
  GradientController.Parameters gradient_parameters = 5;

  // Current accepted concurrency is multiplied with this number to dynamically calculate the upper concurrency limit of a Service during normal (non-overload) state. This protects the Service from sudden spikes.
  double max_load_multiplier = 6; // @gotags: default:"2.0"

  // Linear increment to load multiplier in each execution tick when the system isn't in overloaded state.
  double load_multiplier_linear_increment = 7; // @gotags: default:"0.0025"

  // Configuration for embedded Alerter.
  Alerter.Parameters alerter_parameters = 8;

  // Configuration key for load actuation.
  string dynamic_config_key = 9;

  // Default configuration.
  LoadActuator.DynamicConfig default_config = 10;
}
