syntax = "proto3";

package aperture.policy.language.v1;

import "aperture/policy/language/v1/autoscale.proto";
import "aperture/policy/language/v1/flowcontrol.proto";
import "aperture/policy/language/v1/ports.proto";
import "aperture/policy/language/v1/query.proto";
import "aperture/policy/language/v1/std_components.proto";
import "aperture/policy/language/v1/telemetry_collector.proto";
import "google/api/annotations.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/struct.proto";
import "protoc-gen-openapiv2/options/annotations.proto";
import "validate/validate.proto";

service PolicyService {
  // GetPolicy returns a policy with the specified name.
  rpc GetPolicy(GetPolicyRequest) returns (GetPolicyResponse) {
    option (google.api.http) = {get: "/v1/policies/{name}"};
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: ["aperture-controller"];
    };
  }

  // GetPolicies returns all policies.
  rpc GetPolicies(google.protobuf.Empty) returns (GetPoliciesResponse) {
    option (google.api.http) = {get: "/v1/policies"};
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: ["aperture-controller"];
    };
  }

  // UpsertPolicy creates/updates policy based on the provided request.
  rpc UpsertPolicy(UpsertPolicyRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/policies/{policy_name}"
      body: "*",
      additional_bindings: {
        patch: "/v1/policies/{policy_name}"
        body: "*"
      }
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: ["aperture-controller"];
    };
  }

  // PostDynamicConfig creates/updates dynamic configuration based on the provided request.
  rpc PostDynamicConfig(PostDynamicConfigRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/dynamic-configs/{policy_name}"
      body: "*"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: ["aperture-controller"];
    };
  }

  // DeletePolicy removes a policy with the specified name.
  rpc DeletePolicy(DeletePolicyRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {delete: "/v1/policies/{name}"};
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: ["aperture-controller"];
    };
  }
}

// GetPolicyRequest is a request to get a policy with given name.
message GetPolicyRequest {
  string name = 1;
}

// GetPolicyResponse is a response containing the requested Policy.
message GetPolicyResponse {
  Policy policy = 1;
}

// PostPolicyRequest is a request to create or update Policy.
message UpsertPolicyRequest {
  string policy_name = 1 [(validate.rules).string.min_len = 1];
  Policy policy = 2 [(validate.rules).message.required = true];
  // The paths to update.
  google.protobuf.FieldMask update_mask = 3;
  PolicyMetadata policy_metadata = 4;
}

// PostDynamicConfigRequest is a request to patch dynamic configuration for Policy.
message PostDynamicConfigRequest {
  string policy_name = 1 [(validate.rules).string.min_len = 1];
  google.protobuf.Struct dynamic_config = 2 [(validate.rules).message.required = true];
}

// DeletePolicyRequest is a request to delete a policy with given name.
message DeletePolicyRequest {
  string name = 1;
}

// GetPoliciesResponse is a response containing all Policies.
message GetPoliciesResponse {
  Policies policies = 1;
}

// Policies is a collection of Policies.
message Policies {
  map<string, Policy> policies = 1;
}

// Policy expresses observability-driven control logic.
//
// :::info
//
// See also [Policy overview](/concepts/policy/policy.md).
//
// :::
//
// Policy specification contains a circuit that defines the controller logic and resources that need to be setup.
message Policy {
  // Defines the control-loop logic of the policy.
  Circuit circuit = 1;
  // Resources (such as Flux Meters, Classifiers) to setup.
  Resources resources = 2;
}

// Circuit is graph of inter-connected signal processing components.
//
// :::info
//
// See also [Circuit overview](/concepts/policy/circuit.md).
//
// :::
//
// Signals flow between components through ports.
// As signals traverse the circuit, they get processed, stored within components or get acted upon (for example, load-shed, rate-limit, auto-scale and so on).
// Circuit is evaluated periodically to respond to changes in signal readings.
//
// :::info Signals
//
// Signals are floating point values.
//
// A signal can also have a special **Invalid** value. It's usually used to
// communicate that signal does not have a meaningful value at the moment, for example,
// [PromQL](#prom-q-l) emits such a value if it cannot execute a query.
// Components know when their input signals are invalid and can act
// accordingly. They can either propagate the invalid signal, by making their
// output itself invalid (for example,
// [ArithmeticCombinator](#arithmetic-combinator)) or use some different
// logic, for example, [Extrapolator](#extrapolator). Refer to a component's
// docs on how exactly it handles invalid inputs.
//
// :::
message Circuit {
  // Evaluation interval (tick) is the time between consecutive runs of the policy circuit.
  // This interval is typically aligned with how often the corrective action (actuation) needs to be taken.
  google.protobuf.Duration evaluation_interval = 1; // @gotags: default:"0.5s"

  // Defines a signal processing graph as a list of components.
  repeated Component components = 2; // @gotags: validate:"dive"
}

// Resources that need to be setup for the policy to function
//
// :::info
//
// See also [Resources overview](/concepts/policy/resources.md).
//
// :::
message Resources {
  // TelemetryCollector configures OpenTelemetry collector integration.
  repeated TelemetryCollector telemetry_collectors = 1;
  // FlowControlResources are resources that are provided by flow control integration.
  FlowControlResources flow_control = 101;
}

// Computational block that forms the circuit
//
// :::info
//
// See also [Components overview](/concepts/policy/circuit.md#components).
//
// :::
//
// Signals flow into the components from input ports and results are emitted on output ports.
// Components are wired to each other based on signal names forming an execution graph of the circuit.
//
// :::note
//
// Loops are broken by the runtime at the earliest component index that is part of the loop.
// The looped signals are saved in the tick they're generated and served in the subsequent tick.
//
// :::
//
// See also [Policy](#policy) for a higher-level explanation of circuits.
message Component {
  oneof component {
    // Gradient controller calculates the ratio between the signal and the setpoint to determine the magnitude of the correction that need to be applied.
    // This controller can be used to build AIMD (Additive Increase, Multiplicative Decrease) or MIMD style response.
    GradientController gradient_controller = 1;

    // Exponential Moving Average filter.
    EMA ema = 2;

    // Applies the given operator on input operands (signals) and emits the result.
    ArithmeticCombinator arithmetic_combinator = 3;

    // Decider emits the binary result of comparison operator on two operands.
    Decider decider = 4;

    // Switcher acts as a switch that emits one of the two signals based on third signal.
    Switcher switcher = 5;

    // Simple Moving Average filter.
    SMA sma = 6;

    // Emits a variable signal which can be changed at runtime via dynamic configuration.
    Variable variable = 9;

    // Takes an input signal and emits the square root of the input signal.
    UnaryOperator unary_operator = 10;

    // Takes an input signal and emits the extrapolated value; either mirroring the input value or repeating the last known value up to the maximum extrapolation interval.
    Extrapolator extrapolator = 11;

    // Emits the maximum of the input signals.
    Max max = 12;

    // Emits the minimum of the input signals.
    Min min = 13;

    // Picks the first valid input signal and emits it.
    FirstValid first_valid = 14;

    // Alerter reacts to a signal and generates alert to send to alert manager.
    Alerter alerter = 15;

    // Accumulates sum of signal every tick.
    Integrator integrator = 16;

    // Differentiator calculates rate of change per tick.
    Differentiator differentiator = 17;

    // Logical AND.
    And and = 19;

    // Logical OR.
    Or or = 20;

    // Logical NOT.
    Inverter inverter = 21;

    // Generates 0 and 1 in turns.
    PulseGenerator pulse_generator = 22;

    // Holds the last valid signal value for the specified duration then waits for next valid value to hold.
    Holder holder = 23;

    // Nested circuit defines a sub-circuit as a high-level component. It consists of a list of components and a map of input and output ports.
    NestedCircuit nested_circuit = 24;

    // Nested signal ingress is a special type of component that allows to inject a signal into a nested circuit.
    NestedSignalIngress nested_signal_ingress = 25;

    // Nested signal egress is a special type of component that allows to extract a signal from a nested circuit.
    NestedSignalEgress nested_signal_egress = 26;

    // Generates the specified signal.
    SignalGenerator signal_generator = 27;

    // BoolVariable emits a constant Boolean signal which can be changed at runtime via dynamic configuration.
    BoolVariable bool_variable = 28;

    // Query components that are query databases such as Prometheus.
    Query query = 100;

    // FlowControl components are used to regulate requests flow.
    FlowControl flow_control = 101;

    // AutoScale components are used to scale the service.
    AutoScale auto_scale = 102;
  }
}

// Nested circuit defines a sub-circuit as a high-level component. It consists of a list of components and a map of input and output ports.
message NestedCircuit {
  // Maps input port names to input ports.
  map<string, InPort> in_ports_map = 1;
  // Maps output port names to output ports.
  map<string, OutPort> out_ports_map = 2;

  // List of components in the nested circuit.
  repeated Component components = 3; // @gotags: validate:"dive"
  // Name of the nested circuit component. This name is displayed by graph visualization tools.
  string name = 4;
  // Short description of the nested circuit component. This description is displayed by graph visualization tools.
  string short_description = 5;
}

message PolicyMetadata {
  string blueprints_uri = 1;
  string blueprint_name = 2;
  string values = 3;
}
