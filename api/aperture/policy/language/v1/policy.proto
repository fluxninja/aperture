syntax = "proto3";

package aperture.policy.language.v1;

import "aperture/common/labelmatcher/v1/labelmatcher.proto";
import "aperture/common/selector/v1/selector.proto";
import "google/api/annotations.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

// Note: this is unused at this time.
service PolicyService {
  rpc AllPolicies(google.protobuf.Empty) returns (AllPoliciesResponse) {
    option (google.api.http) = {
      get: "/v1/policies"
    };
  }
}

message AllPoliciesResponse {
  AllPolicies all_policies = 1;
}

message AllPolicies {
  map<string, Policy> all_policies = 1;
}

// Policy is defined as a dataflow graph (circuit) of inter-connected components.
//
// Signals flow between components via ports.
// As signals traverse the circuit, they get processed, stored within components or get acted upon (e.g. load shed, rate-limit, auto-scale etc.).
// Policies are evaluated periodically in order to respond to changes in signal readings.
//
// :::info
// **Signal**
//
// Signals are floating-point values.
//
// A signal also have a special **Invalid** value. It's usually used to
// communicate that signal doesn't have a meaningful value at the moment, eg.
// [PromQL](#-v1promql) emits such a value if it cannot execute a query.
// Components know when their input signals are invalid and can act
// accordingly. They can either propagate the invalidness, by making their
// output itself invalid (like eg.
// [ArithmeticCombinator](#-v1arithmeticcombinator)) or use some different
// logic, like eg. [Extrapolator](#-v1extrapolator). Refer to a component's
// docs on how exactly it handles invalid inputs.
// :::
message Policy {
  // Defines a signal processing graph as a list of components.
  repeated Component circuit = 1;

  // Evaluation interval (tick) is the time period between consecutive runs of the policy circuit.
  // This interval is typically aligned with how often the corrective action (actuation) needs to be taken.
  google.protobuf.Duration evaluation_interval = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        string_value: "0.5s"
      }
    }
  }]; // @gotags: default:"0.5s"

  // FluxMeters are installed in the data-plane and form the observability leg of the feedback loop.
  //
  // FluxMeters'-created metrics can be consumed as input to the circuit via the PromQL component.
  map<string, FluxMeter> flux_meters = 3;
}

// FluxMeter gathers metrics for the traffic that matches its selector.
//
// Example of a selector that creates a histogram metric for all HTTP requests
// to particular service:
// ```yaml
// selector:
//   service: myservice.mynamespace.svc.cluster.local
//   control_point:
//     traffic: ingress
// ```
message FluxMeter {
  // What latency should we measure in the histogram created by this FluxMeter.
  //
  // * For traffic control points, fluxmeter will measure the duration of the
  //   whole http transaction (including sending request and receiving
  //   response).
  // * For feature control points, fluxmeter will measure execution of the span
  //   associated with particular feature. What contributes to the span's
  //   duration is entirely up to the user code that uses Aperture library.
  common.selector.v1.Selector selector = 1;

  // Latency histogram buckets (in ms) for this FluxMeter.
  repeated double histogram_buckets = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        string_value: "[5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]"
      }
    }
  }]; // @gotags: default:"[5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]"
}

// Computational block that form the circuit
//
// Signals flow into the components via input ports and results are emitted on output ports.
// Components are wired to each other based on signal names forming an execution graph of the circuit.
//
// :::note
// Loops are broken by the runtime at the earliest component index that is part of the loop.
// The looped signals are saved in the tick they are generated and served in the subsequent tick.
// :::
//
// There are three categories of components:
// * "source" components – they take some sort of input from "the real world" and output
//   a signal based on this input. Example: [PromQL](#-v1promql). In the UI
//   they're represented by green color.
// * internal components – "pure" components that don't interact with the "real world".
//   Examples: [GradientController](#-v1gradientcontroller), [Max](#-v1max).
//   :::note
//   Internal components's output can depend on their internal state, in addition to the inputs.
//   Eg. see the [Exponential Moving Average filter](#-v1ema).
//   :::
// * "sink" components – they affect the real world.
//   [Scheduler](#-v1scheduler) and [RateLimiter](#-languagev1ratelimiter).
//   Also sometimes called _actuators_. In the UI, represented by orange color.
//   Sink components are usually also "sources" too, they usually emit a
//   feedback signal, like `accepted_concurrency` in case of ConcurrencyLimiter.
//
// :::tip
// Sometimes you may want to use a constant value as one of component's inputs.
// You can use the [Constant](#-constant) component for this.
// :::
//
// See also [Policy](#-v1policy) for a higher-level explanation of circuits.
message Component {
  oneof component {
    // Gradient controller basically calculates the ratio between the signal and the setpoint to determine the magnitude of the correction that need to be applied.
    // This controller can be used to build AIMD (Additive Increase, Multiplicative Decrease) or MIMD style response.
    GradientController gradient_controller = 1;

    // Exponential Moving Average filter.
    EMA ema = 2;

    // Applies the given operator on input operands (signals) and emits the result.
    ArithmeticCombinator arithmetic_combinator = 3;

    // Decider acts as a switch that emits one of the two signals based on the binary result of comparison operator on two operands.
    Decider decider = 4;

    // Concurrency Limiter provides service protection by applying prioritized load shedding of flows using a network scheduler (e.g. Weighted Fair Queuing).
    ConcurrencyLimiter concurrency_limiter = 5;

    // Rate Limiter provides service protection by applying rate limiter.
    RateLimiter rate_limiter = 6;

    // Periodically runs a Prometheus query in the background and emits the result.
    PromQL promql = 7;

    // Emits a constant signal.
    Constant constant = 8;

    // Takes an input signal and emits the square root of the input signal.
    Sqrt sqrt = 9;

    // Takes an input signal and emits the extrapolated value; either mirroring the input value or repeating the last known value up to the maximum extrapolation interval.
    Extrapolator extrapolator = 10;

    // Emits the maximum of the input siganls.
    Max max = 11;

    // Emits the minimum of the input signals.
    Min min = 12;
  }
}

// Components are interconnected with each other via Ports.
message Port {
  // Name of the incoming or outgoing Signal on the Port.
  string signal_name = 1;
}

// Gradient controller is a type of controller which tries to adjust the
// control variable proportionally to the relative difference between setpoint
// and actual value of the signal.
//
// The `gradient` describes a corrective factor that should be applied to the
// control variable to get the signal closer to the setpoint. It is computed as follows:
//
// $$
// \text{gradient} = \frac{\text{setpoint}}{\text{signal}} \cdot \text{tolerance}
// $$
//
// `gradient` is then clamped to [min_gradient, max_gradient] range.
//
// The output of gradient controller is computed as follows:
// $$
// \text{output} = \text{gradient}_{\text{clamped}} \cdot \text{control\_variable} + \text{optimize}.
// $$
//
// Note the additional `optimize` signal, that can be used to "nudge" the
// controller into desired idle state.
//
// The output can be _optionally_ clamped to desired range using `max` and
// `min` input.
//
// :::caution
// Some changes are expected in the near future:
// [#182](https://github.com/fluxninja/aperture/issues/182)
// :::
message GradientController {
  // Inputs for the Gradient Controller component.
  message Ins {
    // Signal to be used for the gradient computation.
    Port signal = 1;

    // Setpoint to be used for the gradient computation.
    Port setpoint = 2;

    // Optimize signal is added to the output of the gradient calculation.
    Port optimize = 3;

    // Maximum value to limit the output signal.
    Port max = 4;

    // Minimum value to limit the output signal.
    Port min = 5;

    // Actual current value of the control variable.
    //
    // This signal is multiplied by the gradient to produce the output.
    Port control_variable = 6;
  }

  // Outputs for the Gradient Controller component.
  message Outs {
    // Computed desired value of the control variable.
    Port output = 1;
  }

  // Input ports of the Gradient Controller.
  Ins in_ports = 1;

  // Output ports of the Gradient Controller.
  Outs out_ports = 2;

  // Tolerance is a way to pre-multiply a setpoint by given value.
  //
  // Value of tolerance should be close or equal to 1, eg. 1.1.
  //
  // :::caution
  // [This is going to be deprecated](https://github.com/fluxninja/aperture/issues/182).
  // :::
  double tolerance = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "gte=0.0"
      }
    }
  }]; // @gotags: validate:"gte=0.0"

  // Minimum gradient which clamps the computed gradient value to the range, [min_gradient, max_gradient].
  double min_gradient = 4 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        number_value: -1.7976931348623157e+308
      }
    }
  }]; // @gotags: default:"-1.79769313486231570814527423731704356798070e+308"

  // Maximum gradient which clamps the computed gradient value to the range, [min_gradient, max_gradient].
  double max_gradient = 5 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        number_value: 1.7976931348623157e+308
      }
    }
  }]; // @gotags: default:"1.79769313486231570814527423731704356798070e+308"
}

// Exponential Moving Average (EMA) is a type of moving average that applies exponenially more weight to recent signal readings
//
// At any time EMA component operates in one of the following states:
// 1. Warm up state: The first warm_up_window samples are used to compute the initial EMA.
//    If an invalid reading is received during the warm_up_window, the last good average is emitted and the state gets reset back to beginning of Warm up state.
// 2. Normal state: The EMA is computed using following formula.
//
// The EMA for a series $Y$ is calculated recursively as:
//
// $$
// \text{EMA} _t =
// \begin{cases}
//   Y_0, &\text{for } t = 0 \\
//   \alpha Y_t + (1 - \alpha) \text{EMA} _{t-1}, &\text{for }t > 0
// \end{cases}
// $$
//
// The coefficient $\alpha$ represents the degree of weighting decrease, a constant smoothing factor between 0 and 1.
// A higher $\alpha$ discounts older observations faster.
// The $\alpha$ is computed using ema\_window:
//
// $$
// \alpha = \frac{2}{N + 1} \quad\text{where } N = \frac{\text{ema\_window}}{\text{evalutation\_period}}
// $$
//
// The EMA filter also employs a min-max-envolope logic during warm up stage, explained [here](#-v1emains).
message EMA {
  // Inputs for the EMA component.
  message Ins {
    // Input signal to be used for the EMA computation.
    Port input = 1;

    // Upper bound of the moving average.
    //
    // Used during the warm-up stage: if the signal would exceed `max_envelope`
    // it's multiplied by `correction_factor_on_max_envelope_violation` **once per tick**.
    //
    // :::note
    // If the signal deviates from `max_envelope` faster than the correction
    // faster, it might end up exceeding the envelope.
    // :::
    //
    // :::note
    // The envelope logic is **not** used outside the warm-up stage!
    // :::
    Port max_envelope = 2;

    // Lower bound of the moving average.
    //
    // Used during the warm-up stage analoguously to `max_envelope`.
    Port min_envelope = 3;
  }

  // Outputs for the EMA component.
  message Outs {
    // Exponential moving average of the series of reading as an output signal.
    Port output = 1;
  }

  // Input ports for the EMA component.
  Ins in_ports = 1;

  // Output ports for the EMA component.
  Outs out_ports = 2;

  // Duration of EMA sampling window.
  google.protobuf.Duration ema_window = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        string_value: "5s"
      }
    }
  }]; // @gotags: default:"5s"

  // Duration of EMA warming up window.
  //
  // The initial value of the EMA is the average of signal readings received during the warm up window.
  google.protobuf.Duration warm_up_window = 4 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        string_value: "0s"
      }
    }
  }]; // @gotags: default:"0s"

  // Correction factor to apply on the output value if its in violation of the min envelope.
  double correction_factor_on_min_envelope_violation = 5 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        number_value: 1
      }
    }
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "gte=1.0"
      }
    }
  }]; // @gotags: validate:"gte=1.0" default:"1.0"

  // Correction factor to apply on the output value if its in violation of the max envelope.
  double correction_factor_on_max_envelope_violation = 6 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        number_value: 1
      }
    }
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "gte=0,lte=1.0"
      }
    }
  }]; // @gotags: validate:"gte=0,lte=1.0" default:"1.0"
}

// Type of combinator that computes the arithmetic operation on the operand signals.
message ArithmeticCombinator {
  // Inputs for the Arithmetic Combinator component.
  message Ins {
    // Left hand side of the arithmetic operation.
    Port lhs = 1;

    // Right hand side of the arithmetic operation.
    Port rhs = 2;
  }

  // Outputs for the Arithmetic Combinator component.
  message Outs {
    // Result of arithmetic operation.
    Port output = 1;
  }

  // Input ports for the Arithmetic Combinator component.
  Ins in_ports = 1;

  // Output ports for the Arithmetic Combinator component.
  Outs out_ports = 2;

  // Operator of the arithmetic operation.
  //
  // The arithmetic operation can be addition, subtraction, multiplication, division, XOR, right bit shift or left bit shift.
  // In case of XOR and bitshifts, value of signals is cast to integers before performing the operation.
  string operator = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "oneof=add sub mul div xor lshift rshift"
      }
    }
  }]; // @gotags: validate:"oneof=add sub mul div xor lshift rshift"
}

// Type of combinator that computes the comparison operation on lhs and rhs signals and switches between `on_true` and `on_false` signals based on the result of the comparison.
//
// The comparison operator can be greater-than, less-than, greater-than-or-equal, less-than-or-equal, equal, or not-equal.
//
// This component also supports time-based response, i.e. the output
// transitions between on_true or on_false signal if the decider condition is
// true or false for at least "positive_for" or "negative_for" duration. If
// `true_for` and `false_for` durations are zero then the transitions are
// instantaneous.
message Decider {
  // Inputs for the Decider component.
  message Ins {
    // Left hand side input signal for the comparison operation.
    Port lhs = 1;

    // Right hand side input signal for the comparison operation.
    Port rhs = 2;

    // Output signal when the result of the operation is true.
    Port on_true = 3;

    // Output signal when the result of the operation is false.
    Port on_false = 4;
  }

  // Outputs for the Decider component.
  message Outs {
    // Selected signal (on_true or on_false).
    Port output = 1;
  }

  // Input ports for the Decider component.
  Ins in_ports = 1;

  // Output ports for the Decider component.
  Outs out_ports = 2;

  // Comparison operator that computes operation on lhs and rhs input signals.
  string operator = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "oneof=gt lt gte lte eq neq"
      }
    }
  }]; // @gotags: validate:"oneof=gt lt gte lte eq neq"

  // Duration of time to wait before a transition to true state.
  // If the duration is zero, the transition will happen instantaneously.
  google.protobuf.Duration true_for = 4 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        string_value: "0s"
      }
    }
  }]; // @gotags: default:"0s"

  // Duration of time to wait before a transition to false state.
  // If the duration is zero, the transition will happen instantaneously.
  google.protobuf.Duration false_for = 5 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        string_value: "0s"
      }
    }
  }]; // @gotags: default:"0s"
}

message RateLimiter {
  message LazySyncConfig {
    bool enabled = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      extensions: {
        key: "x-go-default"
        value: {
          bool_value: true
        }
      }
    }]; // @gotags: default:"true"

    // Number of times to lazy sync within the limit_reset_interval.
    uint32 num_sync = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      extensions: {
        key: "x-go-default"
        value: {
          number_value: 5
        }
      }
      extensions: {
        key: "x-go-validate"
        value: {
          string_value: "gt=0"
        }
      }
    }]; // @gotags: default:"5" validate:"gt=0"
  }

  message OverrideConfig {
    string label_value = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      extensions: {
        key: "x-go-validate"
        value: {
          string_value: "required"
        }
      }
    }]; // @gotags: validate:"required"

    double limit_scale_factor = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      extensions: {
        key: "x-go-default"
        value: {
          number_value: 1
        }
      }
    }]; // @gotags: default:"1.0"
  }

  message Ins {
    // negative limit means no limit is applied.
    Port limit = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      extensions: {
        key: "x-go-validate"
        value: {
          string_value: "required"
        }
      }
      extensions: {
        key: "x-go-default"
        value: {
          number_value: -1
        }
      }
    }]; // @gotags: validate:"required" default:"-1.0"
  }

  Ins in_ports = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "required"
      }
    }
  }]; // @gotags: validate:"required"

  common.selector.v1.Selector selector = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "required"
      }
    }
  }]; // @gotags: validate:"required"

  google.protobuf.Duration limit_reset_interval = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        string_value: "60s"
      }
    }
  }]; // @gotags: default:"60s"

  string label_key = 4 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "required"
      }
    }
  }]; // @gotags: validate:"required"

  repeated OverrideConfig overrides = 5;
  LazySyncConfig lazy_sync_config = 6;
}

// Concurrency Limiter is an actuator component that regulates flows in order to provide active service protection.
// It is based on the actuation strategy (e.g. load shed) and workload scheduling which is based on Weighted Fair Queuing principles.
// Concurrency is calculated in terms of total tokens which translate to (avg. latency \* inflight requests), i.e. Little's Law.
message ConcurrencyLimiter {
  // Weighted Fair Queuing based workfload scheduler.
  Scheduler scheduler = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "required"
      }
    }
  }]; // @gotags: validate:"required"

  oneof actuation_strategy {
    // Actuator based on load shedding a portion of requests.
    LoadShedActuator load_shed_actuator = 2;
  }
}

// Weighted Fair Queuing based workload scheduler.
message Scheduler {
  // Workload defines a class of requests that preferably have similar properties such as response latency.
  message Workload {
    // Describes priority level of the requests within the workload.
    // Priority level ranges from 0 to 255.
    // Higher numbers means higher priority level.
    uint32 priority = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      extensions: {
        key: "x-go-validate"
        value: {
          string_value: "gte=0,lte=255"
        }
      }
    }]; // @gotags: validate:"gte=0,lte=255"

    // Tokens determines the cost of admitting a single request the workload, which is typically defined as milliseconds of response latency.
    // This override is applicable only if auto_tokens is set to false.
    uint64 tokens = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      extensions: {
        key: "x-go-default"
        value: {
          number_value: 1
        }
      }
    }]; // @gotags: default:"1"

    // Timeout override decides how long a request in the workload can wait for tokens.
    // This value impacts the fairness because the larger the timeout the higher the chance a request has to get scheduled.
    google.protobuf.Duration timeout = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      extensions: {
        key: "x-go-default"
        value: {
          string_value: "0.005s"
        }
      }
    }]; // @gotags: default:"0.005s"

    string fairness_key = 4;
  }

  message WorkloadAndLabelMatcher {
    // Workload associated with requests matching the label matcher.
    Workload workload = 1;

    // Label Matcher to select a Workload.
    common.labelmatcher.v1.LabelMatcher label_matcher = 2;
  }

  // Output for the Scheduler component.
  message Outs {
    // Accepted concurrency is the number of accepted tokens/sec.
    Port accepted_concurrency = 1;

    // Incoming concurrency is the number of incoming tokens/sec.
    Port incoming_concurrency = 2;
  }

  // Output ports for the Scheduler component.
  Outs out_ports = 1;

  // Selector decides for which service or flows the scheduler will be applied.
  common.selector.v1.Selector selector = 2;

  bool auto_tokens = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        string_value: "true"
      }
    }
  }]; // @gotags: default:"true"

  Workload default_workload = 4;
  // list of workloads
  // workload can describe priority, tokens (if auto_tokens are set to false) and timeout
  repeated WorkloadAndLabelMatcher workloads = 5;
}

// Takes the load shed factor input signal and publishes it to the schedulers in the data-plane.
message LoadShedActuator {
  // Input for the Load Shed Actuator component.
  message Ins {
    // Load shedding factor is a fraction of incoming concurrency (tokens \* requests) that needs to be dropped.
    Port load_shed_factor = 1;
  }

  // Input ports for the Load Shed Actuator component.
  Ins in_ports = 1;
}

// Component that runs a Prometheus query periodically and returns the result as an output signal.
message PromQL {
  // Output for the PromQL component.
  message Outs {
    // The result of the Prometheus query as an output signal.
    Port output = 1;
  }

  // Output ports for the PromQL component.
  Outs out_ports = 1;

  // Describes the Prometheus query to be run.
  //
  // :::caution
  // TODO we should describe how to construct the query, eg. how to employ the
  // fluxmeters here or link to appropriate place in docs.
  // :::
  string query_string = 2;

  // Describes the interval between successive evaluations of the Prometheus query.
  google.protobuf.Duration evaluation_interval = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        string_value: "10s"
      }
    }
  }]; // @gotags: default:"10s"
}

// Component that emits a constant value as an output signal.
message Constant {
  // Outputs for the Constant component.
  message Outs {
    // The constant value is emitted to the output port.
    Port output = 1;
  }

  // Output ports for the Constant component.
  Outs out_ports = 1;

  // The constant value to be emitted.
  double value = 2;
}

// Takes an input signal and emits the square root of it multiplied by scale as an output.
//
// $$
// \text{output} = \text{scale} \sqrt{\text{input}}
// $$
message Sqrt {
  // Inputs for the Sqrt component.
  message Ins {
    // Input signal.
    Port input = 1;
  }

  // Outputs for the Sqrt component.
  message Outs {
    // Output signal.
    Port output = 1;
  }

  // Input ports for the Sqrt component.
  Ins in_ports = 1;

  // Output ports for the Sqrt component.
  Outs out_ports = 2;

  // Scaling factor to be multiplied with the square root of the input signal.
  double scale = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        number_value: 1
      }
    }
  }]; // @gotags default:"1.0"
}

// Extrapolates the input signal by repeating the last valid value during the period in which it is invalid.
// It does so until `maximum_extrapolation_interval` is reached, beyond which it emits invalid signal unless input signal becomes valid again.
message Extrapolator {
  // Inputs for the Extrapolator component.
  message Ins {
    // Input signal for the Extrapolator component.
    Port input = 1;
  }

  // Outputs for the Extrapolator component.
  message Outs {
    // Extrapolated signal.
    Port output = 1;
  }

  // Input ports for the Extrapolator component.
  Ins in_ports = 1;

  // Output ports for the Extrapolator component.
  Outs out_ports = 2;

  // Maximum time interval to repeat the last valid value of input signal.
  google.protobuf.Duration max_extrapolation_interval = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        string_value: "10s"
      }
    }
  }]; // @gotags: default:"10s"
}

// Takes a list of input signals and emits the signal with the maximum value.
// Max: output = max([]inputs).
message Max {
  // Inputs for the Max component.
  message Ins {
    // Array of input signals.
    repeated Port inputs = 1;
  }

  // Output for the Max component.
  message Outs {
    // Signal with maximum value as an output signal.
    Port output = 1;
  }

  // Input ports for the Max component.
  Ins in_ports = 1;

  // Output ports for the Max component.
  Outs out_ports = 2;
}

// Takes an array of input signals and emits the signal with the minimum value.
// Min: output = min([]inputs).
message Min {
  // Inputs for the Min component.
  message Ins {
    // Array of input signals.
    repeated Port inputs = 1;
  }

  // Output ports for the Min component.
  message Outs {
    // Signal with minimum value as an output signal.
    Port output = 1;
  }

  // Input ports for the Min component.
  Ins in_ports = 1;

  // Output ports for the Min component.
  Outs out_ports = 2;
}
