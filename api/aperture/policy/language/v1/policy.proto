syntax = "proto3";

package aperture.policy.language.v1;

import "aperture/policy/language/v1/autoscale.proto";
import "aperture/policy/language/v1/flowcontrol.proto";
import "aperture/policy/language/v1/ports.proto";
import "aperture/policy/language/v1/query.proto";
import "aperture/policy/language/v1/std_components.proto";
import "google/api/annotations.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

service PolicyService {
  rpc GetPolicies(google.protobuf.Empty) returns (GetPoliciesResponse) {
    option (google.api.http) = {get: "/v1/policies"};
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: ["aperture-controller"];
    };
  }
}

message GetPoliciesResponse {
  Policies policies = 1;
}

message Policies {
  map<string, Policy> policies = 1;
}

// Policy expresses observability-driven control logic.
//
// :::info
//
// See also [Policy overview](/concepts/policy/policy.md).
//
// :::
//
// Policy specification contains a circuit that defines the controller logic and resources that need to be setup.
message Policy {
  // Defines the control-loop logic of the policy.
  Circuit circuit = 1;
  // Resources (such as Flux Meters, Classifiers) to setup.
  Resources resources = 2;
}

// Circuit is graph of inter-connected signal processing components.
//
// :::info
//
// See also [Circuit overview](/concepts/policy/circuit.md).
//
// :::
//
// Signals flow between components through ports.
// As signals traverse the circuit, they get processed, stored within components or get acted upon (for example, load-shed, rate-limit, auto-scale and so on).
// Circuit is evaluated periodically to respond to changes in signal readings.
//
// :::info Signals
//
// Signals are floating point values.
//
// A signal can also have a special **Invalid** value. It's usually used to
// communicate that signal does not have a meaningful value at the moment, for example,
// [PromQL](#prom-q-l) emits such a value if it cannot execute a query.
// Components know when their input signals are invalid and can act
// accordingly. They can either propagate the invalid signal, by making their
// output itself invalid (for example,
// [ArithmeticCombinator](#arithmetic-combinator)) or use some different
// logic, for example, [Extrapolator](#extrapolator). Refer to a component's
// docs on how exactly it handles invalid inputs.
//
// :::
message Circuit {
  // Evaluation interval (tick) is the time between consecutive runs of the policy circuit.
  // This interval is typically aligned with how often the corrective action (actuation) needs to be taken.
  google.protobuf.Duration evaluation_interval = 1; // @gotags: default:"0.5s"

  // Defines a signal processing graph as a list of components.
  repeated Component components = 2; // @gotags: validate:"dive"
}

// Resources that need to be setup for the policy to function
//
// :::info
//
// See also [Resources overview](/concepts/policy/resources.md).
//
// :::
message Resources {
  // Flux Meters are installed in the data-plane and form the observability leg of the feedback loop.
  //
  // Flux Meter created metrics can be consumed as input to the circuit through the PromQL component.
  //
  // Deprecated: v1.5.0. Use `flow_control.flux_meters` instead.
  map<string, FluxMeter> flux_meters = 1; // @gotags: validate:"deprecated,dive"
  // Classifiers are installed in the data-plane and are used to label the requests based on payload content.
  //
  // The flow labels created by Classifiers can be matched by Flux Meters to create metrics for control purposes.
  //
  // Deprecated: v1.5.0. Use `flow_control.classifiers` instead.
  repeated Classifier classifiers = 2; // @gotags: validate:"deprecated,dive"

  // FlowControlResources are resources that are provided by flow control integration.
  FlowControlResources flow_control = 101;
}

// Computational block that forms the circuit
//
// :::info
//
// See also [Components overview](/concepts/policy/circuit.md#components).
//
// :::
//
// Signals flow into the components from input ports and results are emitted on output ports.
// Components are wired to each other based on signal names forming an execution graph of the circuit.
//
// :::note
//
// Loops are broken by the runtime at the earliest component index that is part of the loop.
// The looped signals are saved in the tick they're generated and served in the subsequent tick.
//
// :::
//
// There are three categories of components:
// * "source" components: they take some sort of input from "the real world" and output
//   a signal based on this input. Example: [PromQL](#prom-q-l). In the UI
//   they're represented by green color.
// * signal processor components: processing components that do not interact with the external systems.
//   Examples: [GradientController](#gradient-controller), [Max](#max).
//
//   :::note
//
//   Signal processor components' output can depend on their internal state, in addition to the inputs.
//   Eg. see the [Exponential Moving Average filter](#e-m-a).
//
//   :::
//
// * "sink" components:Â they affect the real world.
//   [ConcurrencyLimiter](#concurrency-limiter) and [RateLimiter](#rate-limiter).
//   In the UI, represented by orange color.  Sink components usually come in pairs with a
//   "sources" component which emits a feedback signal, like
//   `accepted_concurrency` emitted by ConcurrencyLimiter.
//
// :::tip
//
// Sometimes you might want to use a constant value as one of component's inputs.
// You can create an input port containing the constant value instead of being connected to a signal.
// To do so, use the [InPort](#in_port)'s .withConstantSignal(constant_signal) method.
// You can also use it to provide special math values such as NaN and +- Inf.
// If You need to provide the same constant signal to multiple components,
// You can use the [Variable](#variable) component.
//
// :::
//
// See also [Policy](#policy) for a higher-level explanation of circuits.
message Component {
  oneof component {
    // Gradient controller calculates the ratio between the signal and the setpoint to determine the magnitude of the correction that need to be applied.
    // This controller can be used to build AIMD (Additive Increase, Multiplicative Decrease) or MIMD style response.
    GradientController gradient_controller = 1;

    // Exponential Moving Average filter.
    EMA ema = 2;

    // Applies the given operator on input operands (signals) and emits the result.
    ArithmeticCombinator arithmetic_combinator = 3;

    // Decider emits the binary result of comparison operator on two operands.
    Decider decider = 4;

    // Switcher acts as a switch that emits one of the two signals based on third signal.
    Switcher switcher = 5;

    // Emits a variable signal which can be set to invalid.
    Variable variable = 9;

    // Takes an input signal and emits the square root of the input signal.
    UnaryOperator unary_operator = 10;

    // Takes an input signal and emits the extrapolated value; either mirroring the input value or repeating the last known value up to the maximum extrapolation interval.
    Extrapolator extrapolator = 11;

    // Emits the maximum of the input signals.
    Max max = 12;

    // Emits the minimum of the input signals.
    Min min = 13;

    // Picks the first valid input signal and emits it.
    FirstValid first_valid = 14;

    // Alerter reacts to a signal and generates alert to send to alert manager.
    Alerter alerter = 15;

    // Accumulates sum of signal every tick.
    Integrator integrator = 16;

    // Differentiator calculates rate of change per tick.
    Differentiator differentiator = 17;

    // Logical AND.
    And and = 19;

    // Logical OR.
    Or or = 20;

    // Logical NOT.
    Inverter inverter = 21;

    // Generates 0 and 1 in turns.
    PulseGenerator pulse_generator = 22;

    // Holds the last valid signal value for the specified duration then waits for next valid value to hold.
    Holder holder = 23;

    // Nested circuit defines a sub-circuit as a high-level component. It consists of a list of components and a map of input and output ports.
    NestedCircuit nested_circuit = 24;

    // Nested signal ingress is a special type of component that allows to inject a signal into a nested circuit.
    NestedSignalIngress nested_signal_ingress = 25;

    // Nested signal egress is a special type of component that allows to extract a signal from a nested circuit.
    NestedSignalEgress nested_signal_egress = 26;

    // Query components that are query databases such as Prometheus.
    Query query = 100;

    // FlowControl components are used to regulate requests flow.
    FlowControl flow_control = 101;

    // AutoScale components are used to scale the service.
    AutoScale auto_scale = 102;
  }
}

// Nested circuit defines a sub-circuit as a high-level component. It consists of a list of components and a map of input and output ports.
message NestedCircuit {
  // Maps input port names to input ports.
  map<string, InPort> in_ports_map = 1;
  // Maps output port names to output ports.
  map<string, OutPort> out_ports_map = 2;

  // List of components in the nested circuit.
  repeated Component components = 3; // @gotags: validate:"dive"
  // Name of the nested circuit component. This name is displayed by graph visualization tools.
  string name = 4;
  // Short description of the nested circuit component. This description is displayed by graph visualization tools.
  string short_description = 5;
}
