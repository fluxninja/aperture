syntax = "proto3";

package aperture.policy.language.v1;

import "aperture/policy/language/v1/labelmatcher.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

// Describes where a rule or actuation component should apply to.
//
// Example:
// ```yaml
// selector:
//   namespace: default
//   service: service1
//   control_point:
//     traffic: ingress # Allowed values are `ingress` and `egress`.
//   label_matcher:
//     match_labels:
//       user_tier: gold
//     match_expressions:
//       - key: query
//         operator: In
//         values:
//           - insert
//           - delete
//       - label: user_agent
//         regex: ^(?!.*Chrome).*Safari
// ```
message Selector {
  // Describes where this selector applies to.
  string agent_group = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        string_value: "default"
      }
    }
  }]; // @gotags: default:"default"

  // The service (name) of the entities.
  // In k8s, this is the FQDN of the Service object.
  //
  // Note: Entity may belong to multiple services.
  string service = 2;

  // Describes control point within the entity where the policy should apply to.
  ControlPoint control_point = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "required"
      }
    }
  }]; // @gotags: validate:"required"

  // Allows to add _additional_ condition on labels that must also be satisfied (in addition to namespace+service+control point matching).
  // The label matcher allows to match on infra labels, flow labels and request labels.
  // Arbitrary label matcher can be used to match infra labels.
  // For policies, the matcher can be used to match flow labels.
  //
  // Note: For classification we can only match flow labels that were created at some **previous** control point.
  //
  // In case of k8s, infra labels are labels on entities (note: there might exist some additional labels).
  // Flow label names are always prefixed with `flow_`.
  // Request labels are always prefixed with `request_`.
  // Available request labels are `id` (available as `request_id`), `method`, `path`, `host`, `scheme`, `size`, `protocol`.
  // (mapped from fields of [HttpRequest](https://github.com/envoyproxy/envoy/blob/637a92a56e2739b5f78441c337171968f18b46ee/api/envoy/service/auth/v3/attribute_context.proto#L102)).
  // Also, (non-pseudo) headers are available as `request_header_<headername>`.
  //
  // Note: Request headers are only available for "traffic" control points.
  LabelMatcher label_matcher = 4;
}

// Identifies control point within a service that the rule or policy should apply to.
// Controlpoint is either a library feature name or one of ingress/egress traffic control point.
message ControlPoint {
  // @gotags: validate:"required"
  oneof controlpoint {
    // Name of FlunxNinja library's feature.
    // Feature corresponds to a block of code that can be "switched off" which usually is a "named opentelemetry's Span".
    //
    // Note: Flowcontrol only.
    string feature = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      extensions: {
        key: "x-go-validate"
        value: {
          string_value: "required"
        }
      }
    }]; //@gotags: validate:"required"

    // Type of traffic service, either "ingress" or "egress".
    // Apply the policy to the whole incoming/outgoing traffic of a service.
    // Usually powered by integration with a proxy (like envoy) or a web framework.
    //
    // * Flowcontrol: Blockable atom here is a single HTTP-transaction.
    // * Classification: Apply the classification rules to every incoming/outgoing request and attach the resulting flow labels to baggage and telemetry.
    string traffic = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      extensions: {
        key: "x-go-validate"
        value: {
          string_value: "required,oneof=ingress egress"
        }
      }
    }]; // @gotags: validate:"required,oneof=ingress egress"
  }
}
