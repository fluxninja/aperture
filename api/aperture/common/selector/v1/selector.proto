syntax = "proto3";

package aperture.common.selector.v1;

import "aperture/common/labelmatcher/v1/labelmatcher.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

// Describes where a rule or actuation component should apply to
//
// Example:
// ```yaml
// selector:
//   service: service1.default.svc.cluster.local
//   control_point:
//     traffic: ingress # Allowed values are `ingress` and `egress`.
//   label_matcher:
//     match_labels:
//       user_tier: gold
//     match_expressions:
//       - key: query
//         operator: In
//         values:
//           - insert
//           - delete
//       - label: user_agent
//         regex: ^(?!.*Chrome).*Safari
// ```
message Selector {
  // Describes where this selector applies to.
  string agent_group = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        string_value: "default"
      }
    }
  }]; // @gotags: default:"default"

  // The service (name) of the entities.
  // In k8s, this is the FQDN of the Service object.
  //
  // Note: Entity may belong to multiple services.
  string service = 2;

  // Describes control point within the entity where the policy should apply to.
  ControlPoint control_point = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "required"
      }
    }
  }]; // @gotags: validate:"required"

  // Label matcher allows to add _additional_ condition on
  // [flow labels](/concepts/flow-control/label/label.md)
  // must also be satisfied (in addition to service+control point matching)
  //
  // :::note
  // [Classifiers](#v1-classifier) _can_ use flow labels created by some other
  // classifier, but only if they were created at some previous control point
  // (and propagated in baggage).
  //
  // This limitation doesn't apply to selectors of other entities, like
  // FluxMeters or actuators. It's valid to create a flow label on a control
  // point using classifier, and immediately use it for matching on the same
  // control point.
  // :::
  common.labelmatcher.v1.LabelMatcher label_matcher = 4;
}

// Identifies control point within a service that the rule or policy should apply to.
// Controlpoint is either a library feature name or one of ingress/egress traffic control point.
message ControlPoint {
  // @gotags: validate:"required"
  oneof controlpoint {
    // Name of FlunxNinja library's feature.
    // Feature corresponds to a block of code that can be "switched off" which usually is a "named opentelemetry's Span".
    //
    // Note: Flowcontrol only.
    string feature = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      extensions: {
        key: "x-go-validate"
        value: {
          string_value: "required"
        }
      }
    }]; //@gotags: validate:"required"

    // Type of traffic service, either "ingress" or "egress".
    // Apply the policy to the whole incoming/outgoing traffic of a service.
    // Usually powered by integration with a proxy (like envoy) or a web framework.
    //
    // * Flowcontrol: Blockable atom here is a single HTTP-transaction.
    // * Classification: Apply the classification rules to every incoming/outgoing request and attach the resulting flow labels to baggage and telemetry.
    string traffic = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      extensions: {
        key: "x-go-validate"
        value: {
          string_value: "required,oneof=ingress egress"
        }
      }
    }]; // @gotags: validate:"required,oneof=ingress egress"
  }
}
