syntax = "proto3";

package aperture.common.selector.v1;

import "aperture/common/labelmatcher/v1/labelmatcher.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

// Describes where a rule or actuation component should apply to
//
// Example:
// ```yaml
// selector:
//   service: service1.default.svc.cluster.local
//   control_point:
//     traffic: ingress # Allowed values are `ingress` and `egress`.
//   label_matcher:
//     match_labels:
//       user_tier: gold
//     match_expressions:
//       - key: query
//         operator: In
//         values:
//           - insert
//           - delete
//       - label: user_agent
//         regex: ^(?!.*Chrome).*Safari
// ```
message Selector {
  // Describes where this selector applies to.
  string agent_group = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-default"
      value: {
        string_value: "default"
      }
    }
  }]; // @gotags: default:"default"

  // The service (name) of the entities.
  // In k8s, this is the FQDN of the Service object.
  //
  // Note: Entity may belong to multiple services.
  string service = 2;

  // Describes control point within the entity where the policy should apply to.
  ControlPoint control_point = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    extensions: {
      key: "x-go-validate"
      value: {
        string_value: "required"
      }
    }
  }]; // @gotags: validate:"required"

  // Label matcher allows to add _additional_ condition on labels that must
  // also be satisfied (in addition to service+control point matching)
  //
  // This matcher allows to match on flow labels and request labels.
  // (Note: For classification we can only match flow labels that were created at
  // some **previous** control point).
  //
  // Flow labels are available with the same label key as defined in
  // classification rule.
  //
  // Request labels are always prefixed with `request_`. Available request
  // labels are `id` (available as `request_id`), `method`, `path`, `host`,
  // `scheme`, `size`, `protocol` (mapped from fields of
  // [HttpRequest](https://github.com/envoyproxy/envoy/blob/637a92a56e2739b5f78441c337171968f18b46ee/api/envoy/service/auth/v3/attribute_context.proto#L102)).
  // Also, (non-pseudo) headers are available as `request_header_<headername>`, where
  // `<headername>` is a headername normalised to lowercase, eg. `request_header_user-agent`.
  //
  // Note: Request headers are only available for `traffic` control points.
  common.labelmatcher.v1.LabelMatcher label_matcher = 4;
}

// Identifies control point within a service that the rule or policy should apply to.
// Controlpoint is either a library feature name or one of ingress/egress traffic control point.
message ControlPoint {
  // @gotags: validate:"required"
  oneof controlpoint {
    // Name of FlunxNinja library's feature.
    // Feature corresponds to a block of code that can be "switched off" which usually is a "named opentelemetry's Span".
    //
    // Note: Flowcontrol only.
    string feature = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      extensions: {
        key: "x-go-validate"
        value: {
          string_value: "required"
        }
      }
    }]; //@gotags: validate:"required"

    // Type of traffic service, either "ingress" or "egress".
    // Apply the policy to the whole incoming/outgoing traffic of a service.
    // Usually powered by integration with a proxy (like envoy) or a web framework.
    //
    // * Flowcontrol: Blockable atom here is a single HTTP-transaction.
    // * Classification: Apply the classification rules to every incoming/outgoing request and attach the resulting flow labels to baggage and telemetry.
    string traffic = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      extensions: {
        key: "x-go-validate"
        value: {
          string_value: "required,oneof=ingress egress"
        }
      }
    }]; // @gotags: validate:"required,oneof=ingress egress"
  }
}
