package rollupprocessor

import (
	"math"
	"strings"

	"go.opentelemetry.io/collector/pdata/pcommon"
	"golang.org/x/exp/slices"
	"google.golang.org/protobuf/encoding/protowire"
)

// key returns key used in the hashmap.
//
// The exact key generated by this function is not important. We only care that
// same set of attributes map to the same key and different â€“ to different.
//
// The returned key is not-really a textual string, but using string here to be
// able to use it as hashmap keys.
//
// Note: Map is just a wrapper over list of KeyValues, which are
// protobuf-generated structs, so we could in theory just serialize them using
// protobuf, but these KeyValues are unfortunately not exposed.
//
// Note: Previous implementation was doing json.Marshal(am.AsRaw()), but it
// turned to be too slow.
func key(am pcommon.Map, ignore map[string]struct{}) string {
	// Provide some initial capacity to avoid too many reallocs.
	key := make([]byte, 0, am.Len()*60)
	for _, kv := range sortedByKeys(am) {
		if _, exists := ignore[kv.key]; exists {
			// Skipping all fields from which we will get rolled up values, as
			// those are dimensions not to be considered as "key".
			continue
		}
		key = keyAppendString(key, kv.key)
		key = keyAppendValue(key, kv.val)
	}
	return string(key)
}

func keyAppendString(key []byte, s string) []byte {
	key = append(key, s...)
	key = append(key, '\xff')
	return key
}

func keyAppendValue(key []byte, value pcommon.Value) []byte {
	// Note: We do not really expect non-ignored attributes of types other than
	// str and list, but handle all types somehow anyway.
	switch value.Type() {
	case pcommon.ValueTypeStr:
		key = append(key, 'S')
		key = keyAppendString(key, value.Str())
	case pcommon.ValueTypeBytes:
		key = append(key, 'B')
		key = protowire.AppendBytes(key, value.Bytes().AsRaw())
	case pcommon.ValueTypeBool:
		if value.Bool() {
			key = append(key, 'T')
		} else {
			key = append(key, 'F')
		}
	case pcommon.ValueTypeSlice:
		key = append(key, 'L')
		s := value.Slice()
		key = protowire.AppendVarint(key, uint64(s.Len()))
		for i := 0; i < s.Len(); i++ {
			key = keyAppendValue(key, s.At(i))
		}
	case pcommon.ValueTypeMap:
		key = append(key, 'M')
		m := value.Map()
		key = protowire.AppendVarint(key, uint64(m.Len()))
		for _, kv := range sortedByKeys(m) {
			key = keyAppendString(key, kv.key)
			key = keyAppendValue(key, kv.val)
		}
	case pcommon.ValueTypeEmpty:
		key = append(key, 'E')
	case pcommon.ValueTypeInt:
		key = append(key, 'I')
		key = protowire.AppendVarint(key, uint64(value.Int()))
	case pcommon.ValueTypeDouble:
		key = append(key, 'D')
		key = protowire.AppendFixed64(key, math.Float64bits(value.Double()))
	}
	return key
}

type kv struct {
	key string
	val pcommon.Value
}

func sortedByKeys(m pcommon.Map) []kv {
	// Note: Sorting kv structs is faster than sorting just keys and using Get
	// afterwards.
	kvs := make([]kv, 0, m.Len())
	m.Range(func(k string, v pcommon.Value) bool {
		kvs = append(kvs, kv{k, v})
		return true
	})
	slices.SortFunc(kvs, func(left, right kv) int { return strings.Compare(left.key, right.key) })
	return kvs
}
