---
title: Policy
sidebar_position: 1
sidebar_label: Policy Language
---

```mdx-code-block
import DocCardList from '@theme/DocCardList';
```

:::info See also

[Policy reference](/reference/configuration/spec.md#policy)

:::

Aperture's policy language enables expression of closed-loop [control
systems][control-system] in a declarative manner. Aperture includes pre-packaged
[blueprints][blueprints] that can be used both as a guide for creating new
policies, or used as-is.

Policies provide a framework for defining and managing reliability criteria and
conditions. They allow service operators to define and enforce reliability
policies programmatically, running in a continuous control loop. In an
application reliability context, policies codify the capability of the
application to modify its operational state to achieve the best possible mode of
operation despite overload and failures.

Aperture's control loop policies are programmable "circuits" that are evaluated
periodically. One of the primary goals of these policies is to calculate the
deviation from objectives and apply counter-measures, such as load throttling
and workload queuing, to keep the system in a safe operational zone. The
policies are used to express where the metrics are collected from and where the
actuation happens, along with signal processing needed to perform corrective
actions from health metrics. For instance, a policy can be written to detect
overload build-up at an upstream service and trigger load throttling at a
downstream service.

The policy specification consists of two parts:

1. A [Circuit](#circuit) that expresses the Control System as an execution
   graph.
2. A list of [Resources](#resources) which are required to support the circuit.

## Circuit

A [circuit][circuit] in Aperture's policy language represents the signal
processing circuit of the control system as an execution graph. It captures the
process of evaluating the system's current state and describes the actions to be
taken based on that evaluation. A circuit is made up of nodes, which represent
the various components of the control system, including signal processing
components, and edges, which represent the flow of signals between the nodes.

Observability-driven control is an important aspect of Aperture's policy
language. By monitoring signals such as request latency, error rate, and
saturation, Aperture's circuits can detect deviations from service-level
objectives and trigger appropriate actions to restore system stability and
reliability. The circuit is the heart of the policy specification and is
responsible for the logic of the control system.

<DocCardList />

## Resources

:::info See also

[Resources reference](/reference/configuration/spec.md#resources)

:::

The resources section in the Policy describes resources needed to set up a
circuit. It's possible but not recommended to share resources across Policies
since resources are always defined in the global scope. Resources can be
referenced inside the Circuit, the exact reference mechanism depends on the type
of Resource.

Examples:

1. [Flux Meters][flux-meter]: The metrics generated by Flux Meter can be
   referenced inside [PromQL Components][promql-reference]
2. [Flow Classifiers][flow-classifier]: The labels generated by Classifiers can
   be referred inside [Selectors][selector-reference].

[flux-meter]: /concepts/flux-meter.md
[flow-classifier]: /concepts/classifier.md
[promql-reference]: /reference/configuration/spec.md#prom-q-l
[selector-reference]: /reference/configuration/spec.md#selector
[circuit]: /concepts/advanced/circuit.md
[blueprints]: /reference/blueprints/blueprints.md
[control-system]: https://en.wikipedia.org/wiki/Control_system
