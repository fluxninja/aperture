---
id: policy-service-get-policies
title: PolicyService_GetPolicies
description: "PolicyService_GetPolicies"
sidebar_label: get /v1/policies
hide_title: true
hide_table_of_contents: true
api: {"operationId":"PolicyService_GetPolicies","responses":{"200":{"description":"A successful response.","content":{"application/json":{"schema":{"type":"object","properties":{"policies":{"type":"object","properties":{"policies":{"type":"object","additionalProperties":{"type":"object","properties":{"circuit":{"description":"Defines the control-loop logic of the policy.","type":"object","properties":{"components":{"type":"array","items":{"type":"object","properties":{"arithmetic_combinator":{"description":"Applies the given operator on input operands (signals) and emits the result.","type":"object","properties":{"in_ports":{"description":"Input ports for the Arithmetic Combinator component.","type":"object","properties":{"lhs":{"description":"Left hand side of the arithmetic operation.","type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"},"rhs":{"description":"Right hand side of the arithmetic operation.","type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"}}},"operator":{"type":"string","description":"Operator of the arithmetic operation.\n\nThe arithmetic operation can be addition, subtraction, multiplication, division, XOR, right bit shift or left bit shift.\nIn case of XOR and bitshifts, value of signals is cast to integers before performing the operation.","x-go-validate":"oneof=add sub mul div xor lshift rshift"},"out_ports":{"description":"Output ports for the Arithmetic Combinator component.","type":"object","properties":{"output":{"description":"Result of arithmetic operation.","type":"object","properties":{"signal_name":{"type":"string","description":"Name of the outgoing Signal on the OutPort."}},"title":"Components produce output for other components via OutPorts"}}}},"title":"Type of combinator that computes the arithmetic operation on the operand signals"},"concurrency_limiter":{"description":"Concurrency Limiter provides service protection by applying prioritized load shedding of flows using a network scheduler (e.g. Weighted Fair Queuing).","type":"object","properties":{"load_shed_actuator":{"description":"Actuator based on load shedding a portion of requests.\n\nActuation strategy defines the input signal that will drive the scheduler.","type":"object","properties":{"in_ports":{"description":"Input ports for the Load Shed Actuator component.","type":"object","properties":{"load_shed_factor":{"description":"Load shedding factor is a fraction of [incoming\nconcurrency](#v1-scheduler-outs) that needs to be dropped.","type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"}}}},"title":"Takes the load shed factor input signal and publishes it to the schedulers in the data-plane"},"scheduler":{"description":"Configuration of Weighted Fair Queuing-based workload scheduler.\n\nContains configuration of per-agent scheduler, and also defines some\noutput signals.","x-go-validate":"required","type":"object","properties":{"auto_tokens":{"type":"boolean","description":"Automatically estimate the size of a request in each workload, based on\nhistorical latency. Each workload's `tokens` will be set to average\nlatency of flows in that workload during last few seconds (exact duration\nof this average can change).","x-go-default":"true"},"default_workload_parameters":{"description":"WorkloadParameters to be used if none of workloads specified in `workloads` match.","x-go-validate":"required","type":"object","properties":{"fairness_key":{"type":"string","description":"Fairness key is a label key that can be used to provide fairness within a workload.\nAny [flow label](/concepts/flow-control/flow-label.md) can be used here. Eg. if\nyou have a classifier that sets `user` flow label, you might want to set\n`fairness_key = \"user\"`."},"priority":{"type":"integer","format":"int64","description":"Describes priority level of the requests within the workload.\nPriority level ranges from 0 to 255.\nHigher numbers means higher priority level.","x-go-validate":"gte=0,lte=255"},"tokens":{"type":"string","format":"uint64","description":"Tokens determines the cost of admitting a single request the workload, which is typically defined as milliseconds of response latency.\nThis override is applicable only if `auto_tokens` is set to false.","x-go-default":1}}},"max_timeout":{"type":"string","description":":::caution\nThis timeout needs to be strictly less than the timeout set on the\nclient for the whole GRPC call:\n* in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,\n* in case of libraries, timeout configured... TODO.\n\nWe're using fail-open logic in integrations, so if the GRPC timeout\nfires first, the flow will end up being unconditionally allowed while\nit're still waiting on the scheduler.\n\nTo avoid such cases, the end-to-end GRPC timeout should also contain\nsome headroom for constant overhead like serialization, etc. Default\nvalue for GRPC timeouts is 500ms, giving 50ms of headeroom, so when\ntweaking this timeout, make sure to adjust the GRPC timeout accordingly.\n:::","title":"Max Timeout is the value with which the flow timeout calculated by `timeout_factor` is capped","x-go-default":"0.45s"},"out_ports":{"description":"Output ports for the Scheduler component.","type":"object","properties":{"accepted_concurrency":{"description":"Accepted concurrency is the number of accepted tokens per second.\n\n:::info\n**Accepted tokens** are tokens associated with\n[flows](/concepts/flow-control/flow-control.md#flow) that were accepted by\nthis scheduler. Number of tokens for a flow is determined by a\n[workload parameters](#scheduler-workload-parameters) that the flow was assigned to (either\nvia `auto_tokens` or explicitly by `Workload.tokens`).\n:::\n\nValue of this signal is the sum across all the relevant schedulers.","type":"object","properties":{"signal_name":{"type":"string","description":"Name of the outgoing Signal on the OutPort."}},"title":"Components produce output for other components via OutPorts"},"incoming_concurrency":{"description":"Incoming concurrency is the number of incoming tokens/sec.\nThis is the same as `accepted_concurrency`, but across all the flows\nentering scheduler, including rejected ones.","type":"object","properties":{"signal_name":{"type":"string","description":"Name of the outgoing Signal on the OutPort."}},"title":"Components produce output for other components via OutPorts"}}},"timeout_factor":{"type":"number","format":"double","description":"If a flow is not able to get tokens within `timeout_factor` * `tokens` of duration,\nit will be rejected.\n\nThis value impacts the prioritization and fairness because the larger the timeout the higher the chance a request has to get scheduled.","title":"Timeout as a factor of tokens for a flow in a workload","x-go-default":0.5,"x-go-validate":"gte=0.0"},"workloads":{"type":"array","items":{"type":"object","properties":{"label_matcher":{"description":"Label Matcher to select a Workload based on\n[flow labels](/concepts/flow-control/flow-label.md).","x-go-validate":"required","type":"object","properties":{"expression":{"description":"An arbitrary expression to be evaluated on the labels.","type":"object","properties":{"all":{"description":"The expression is true when all subexpressions are true.","type":"object","properties":{"of":{"type":"array","items":{"type":"object","properties":"circular()","description":"MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals: { label = app, value = frobnicator }\n```","title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"},"description":"List of subexpressions of the match expression."}},"title":"List of MatchExpressions that is used for all/any matching"},"any":{"description":"The expression is true when any subexpression is true.","type":"object","properties":{"of":{"type":"array","items":{"type":"object","properties":"circular()","description":"MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals: { label = app, value = frobnicator }\n```","title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"},"description":"List of subexpressions of the match expression."}},"title":"List of MatchExpressions that is used for all/any matching"},"label_equals":{"description":"The expression is true when label value equals given value.","type":"object","properties":{"label":{"type":"string","description":"Name of the label to equal match the value.","x-go-validate":"required"},"value":{"type":"string","description":"Exact value that the label should be equal to."}}},"label_exists":{"type":"string","description":"The expression is true when label with given name exists.","x-go-validate":"required"},"label_matches":{"description":"The expression is true when label matches given regex.","type":"object","properties":{"label":{"type":"string","description":"Name of the label to match the regular expression.","x-go-validate":"required"},"regex":{"type":"string","description":"Regular expression that should match the label value.\nIt uses [golang's regular expression syntax](https://github.com/google/re2/wiki/Syntax).","x-go-validate":"required"}}},"not":{"type":"object","properties":"circular()","description":"MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals: { label = app, value = frobnicator }\n```","title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"}},"title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"},"match_expressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string","description":"Label key that the selector applies to.","x-go-validate":"required"},"operator":{"type":"string","description":"Logical operator which represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.","x-go-validate":"oneof=In NotIn Exists DoesNotExists"},"values":{"type":"array","items":{"type":"string"},"description":"An array of string values that relates to the key by an operator.\nIf the operator is In or NotIn, the values array must be non-empty.\nIf the operator is Exists or DoesNotExist, the values array must be empty."}},"description":"Label selector requirement which is a selector that contains values, a key, and an operator that relates the key and values."},"description":"List of k8s-style label matcher requirements.\n\nNote: The requirements are ANDed."},"match_labels":{"type":"object","additionalProperties":{"type":"string"},"description":"A map of {key,value} pairs representing labels to be matched.\nA single {key,value} in the matchLabels requires that the label \"key\" is present and equal to \"value\".\n\nNote: The requirements are ANDed."}},"title":"Allows to define rules whether a map of\n[labels](/concepts/flow-control/flow-label.md)\nshould be considered a match or not"},"workload_parameters":{"description":"WorkloadParameters associated with flows matching the label matcher.","x-go-validate":"required","type":"object","properties":{"fairness_key":{"type":"string","description":"Fairness key is a label key that can be used to provide fairness within a workload.\nAny [flow label](/concepts/flow-control/flow-label.md) can be used here. Eg. if\nyou have a classifier that sets `user` flow label, you might want to set\n`fairness_key = \"user\"`."},"priority":{"type":"integer","format":"int64","description":"Describes priority level of the requests within the workload.\nPriority level ranges from 0 to 255.\nHigher numbers means higher priority level.","x-go-validate":"gte=0,lte=255"},"tokens":{"type":"string","format":"uint64","description":"Tokens determines the cost of admitting a single request the workload, which is typically defined as milliseconds of response latency.\nThis override is applicable only if `auto_tokens` is set to false.","x-go-default":1}}}},"description":"Workload defines a class of requests that preferably have similar properties such as response latency or desired priority."},"description":"List of workloads to be used in scheduler.\n\nCategorizing [flows](/concepts/flow-control/flow-control.md#flow) into workloads\nallows for load-shedding to be \"smarter\" than just \"randomly deny 50% of\nrequests\". There are two aspects of this \"smartness\":\n* Scheduler can more precisely calculate concurrency if it understands\n  that flows belonging to different classes have different weights (eg.\n  inserts vs lookups).\n* Setting different priorities to different workloads lets the scheduler\n  avoid dropping important traffic during overload.\n\nEach workload in this list specifies also a matcher that's used to\ndetermine which flow will be categorized into which workload.\nIn case of multiple matching workloads, the first matching one will be used.\nIf none of workloads match, `default_workload` will be used.\n\n:::info\nSee also [workload definition in the concepts\nsection](/concepts/flow-control/concurrency-limiter.md#workload).\n:::"}},"title":"Weighted Fair Queuing-based workload scheduler"},"selector":{"description":"Selector decides the service and flows at which the concurrency limiter is applied.","x-go-validate":"required","type":"object","properties":{"flow_selector":{"x-go-validate":"required","type":"object","properties":{"control_point":{"description":"Describes\n[control point](/concepts/flow-control/flow-control.md#control-point)\nwithin the entity where the policy should apply to.","x-go-validate":"required","type":"object","properties":{"feature":{"type":"string","description":"Name of Aperture SDK's feature.\nFeature corresponds to a block of code that can be \"switched off\" which usually is a \"named opentelemetry's Span\".\n\nNote: Flowcontrol only.","x-go-validate":"required"},"traffic":{"type":"string","description":"Type of traffic service, either \"ingress\" or \"egress\".\nApply the policy to the whole incoming/outgoing traffic of a service.\nUsually powered by integration with a proxy (like envoy) or a web framework.\n\n* Flowcontrol: Blockable atom here is a single HTTP-transaction.\n* Classification: Apply the classification rules to every incoming/outgoing request and attach the resulting flow labels to baggage and telemetry.","x-go-validate":"required,oneof=ingress egress"}}},"label_matcher":{"description":":::info\nSee also [Label Matcher overview](/concepts/flow-control/selector.md#label-matcher).\n:::\n\n:::note\n[Classifiers](#v1-classifier) _can_ use flow labels created by some other\nclassifier, but only if they were created at some previous control point\n(and propagated in baggage).\n\nThis limitation doesn't apply to selectors of other entities, like\nFluxMeters or actuators. It's valid to create a flow label on a control\npoint using classifier, and immediately use it for matching on the same\ncontrol point.\n:::","title":"Label matcher allows to add _additional_ condition on\n[flow labels](/concepts/flow-control/flow-label.md)\nmust also be satisfied (in addition to service+control point matching)","type":"object","properties":{"expression":{"description":"An arbitrary expression to be evaluated on the labels.","type":"object","properties":{"all":{"description":"The expression is true when all subexpressions are true.","type":"object","properties":{"of":{"type":"array","items":{"type":"object","properties":"circular()","description":"MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals: { label = app, value = frobnicator }\n```","title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"},"description":"List of subexpressions of the match expression."}},"title":"List of MatchExpressions that is used for all/any matching"},"any":{"description":"The expression is true when any subexpression is true.","type":"object","properties":{"of":{"type":"array","items":{"type":"object","properties":"circular()","description":"MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals: { label = app, value = frobnicator }\n```","title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"},"description":"List of subexpressions of the match expression."}},"title":"List of MatchExpressions that is used for all/any matching"},"label_equals":{"description":"The expression is true when label value equals given value.","type":"object","properties":{"label":{"type":"string","description":"Name of the label to equal match the value.","x-go-validate":"required"},"value":{"type":"string","description":"Exact value that the label should be equal to."}}},"label_exists":{"type":"string","description":"The expression is true when label with given name exists.","x-go-validate":"required"},"label_matches":{"description":"The expression is true when label matches given regex.","type":"object","properties":{"label":{"type":"string","description":"Name of the label to match the regular expression.","x-go-validate":"required"},"regex":{"type":"string","description":"Regular expression that should match the label value.\nIt uses [golang's regular expression syntax](https://github.com/google/re2/wiki/Syntax).","x-go-validate":"required"}}},"not":{"type":"object","properties":"circular()","description":"MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals: { label = app, value = frobnicator }\n```","title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"}},"title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"},"match_expressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string","description":"Label key that the selector applies to.","x-go-validate":"required"},"operator":{"type":"string","description":"Logical operator which represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.","x-go-validate":"oneof=In NotIn Exists DoesNotExists"},"values":{"type":"array","items":{"type":"string"},"description":"An array of string values that relates to the key by an operator.\nIf the operator is In or NotIn, the values array must be non-empty.\nIf the operator is Exists or DoesNotExist, the values array must be empty."}},"description":"Label selector requirement which is a selector that contains values, a key, and an operator that relates the key and values."},"description":"List of k8s-style label matcher requirements.\n\nNote: The requirements are ANDed."},"match_labels":{"type":"object","additionalProperties":{"type":"string"},"description":"A map of {key,value} pairs representing labels to be matched.\nA single {key,value} in the matchLabels requires that the label \"key\" is present and equal to \"value\".\n\nNote: The requirements are ANDed."}}}},"description":":::info\nSee also [Selector overview](/concepts/flow-control/selector.md).\n:::\n\nExample:\n```yaml\ncontrol_point:\n  traffic: ingress # Allowed values are `ingress` and `egress`.\nlabel_matcher:\n  match_labels:\n    user_tier: gold\n  match_expressions:\n    - key: query\n      operator: In\n      values:\n        - insert\n        - delete\n    - label: user_agent\n      regex: ^(?!.*Chrome).*Safari\n```","title":"Describes which flows a [dataplane\ncomponent](/concepts/flow-control/flow-control.md#components) should apply\nto"},"service_selector":{"x-go-validate":"required","type":"object","properties":{"agent_group":{"type":"string","description":"Which [agent-group](/concepts/service.md#agent-group) this\nselector applies to.","x-go-default":"default"},"service":{"type":"string","description":"The Fully Qualified Domain Name of the\n[service](/concepts/service.md) to select.\n\nIn kubernetes, this is the FQDN of the Service object.\n\nEmpty string means all services within an agent group (catch-all).\n\n:::note\nOne entity may belong to multiple services.\n:::"}},"description":":::info\nSee also [Selector overview](/concepts/flow-control/selector.md).\n:::","title":"Describes which service a [dataplane\ncomponent](/concepts/flow-control/flow-control.md#components) should apply\nto"}},"title":"Describes which flow in which service a [dataplane\ncomponent](/concepts/flow-control/flow-control.md#components) should apply\nto"}},"title":"Concurrency Limiter is an actuator component that regulates flows in order to provide active service protection"},"constant":{"description":"Emits a constant signal.","type":"object","properties":{"out_ports":{"description":"Output ports for the Constant component.","type":"object","properties":{"output":{"description":"The constant value is emitted to the output port.","type":"object","properties":{"signal_name":{"type":"string","description":"Name of the outgoing Signal on the OutPort."}},"title":"Components produce output for other components via OutPorts"}}},"value":{"type":"number","format":"double","description":"The constant value to be emitted."}},"title":"Component that emits a constant value as an output signal"},"decider":{"description":"Decider emits the binary result of comparison operator on two operands.","type":"object","properties":{"false_for":{"type":"string","description":"Duration of time to wait before a transition to false state.\nIf the duration is zero, the transition will happen instantaneously.","x-go-default":"0s"},"in_ports":{"description":"Input ports for the Decider component.","type":"object","properties":{"lhs":{"description":"Left hand side input signal for the comparison operation.","type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"},"rhs":{"description":"Right hand side input signal for the comparison operation.","type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"}}},"operator":{"type":"string","description":"Comparison operator that computes operation on lhs and rhs input signals.","x-go-validate":"oneof=gt lt gte lte eq neq"},"out_ports":{"description":"Output ports for the Decider component.","type":"object","properties":{"output":{"description":"Selected signal (1.0 or 0.0).","type":"object","properties":{"signal_name":{"type":"string","description":"Name of the outgoing Signal on the OutPort."}},"title":"Components produce output for other components via OutPorts"}}},"true_for":{"type":"string","description":"Duration of time to wait before a transition to true state.\nIf the duration is zero, the transition will happen instantaneously.","x-go-default":"0s"}},"title":"Type of combinator that computes the comparison operation on lhs and rhs signals"},"ema":{"description":"Exponential Moving Average filter.","type":"object","properties":{"correction_factor_on_max_envelope_violation":{"type":"number","format":"double","description":"Correction factor to apply on the output value if its in violation of the max envelope.","x-go-default":1,"x-go-validate":"gte=0,lte=1.0"},"correction_factor_on_min_envelope_violation":{"type":"number","format":"double","description":"Correction factor to apply on the output value if its in violation of the min envelope.","x-go-default":1,"x-go-validate":"gte=1.0"},"ema_window":{"type":"string","description":"Duration of EMA sampling window.","x-go-default":"5s"},"in_ports":{"description":"Input ports for the EMA component.","type":"object","properties":{"input":{"description":"Input signal to be used for the EMA computation.","type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"},"max_envelope":{"description":"Upper bound of the moving average.\n\nUsed during the warm-up stage: if the signal would exceed `max_envelope`\nit's multiplied by `correction_factor_on_max_envelope_violation` **once per tick**.\n\n:::note\nIf the signal deviates from `max_envelope` faster than the correction\nfaster, it might end up exceeding the envelope.\n:::\n\n:::note\nThe envelope logic is **not** used outside the warm-up stage!\n:::","type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"},"min_envelope":{"description":"Lower bound of the moving average.\n\nUsed during the warm-up stage analogously to `max_envelope`.","type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"}}},"out_ports":{"description":"Output ports for the EMA component.","type":"object","properties":{"output":{"description":"Exponential moving average of the series of reading as an output signal.","type":"object","properties":{"signal_name":{"type":"string","description":"Name of the outgoing Signal on the OutPort."}},"title":"Components produce output for other components via OutPorts"}}},"warm_up_window":{"type":"string","description":"Duration of EMA warming up window.\n\nThe initial value of the EMA is the average of signal readings received during the warm up window.","x-go-default":"0s"}},"title":"Exponential Moving Average (EMA) is a type of moving average that applies exponentially more weight to recent signal readings"},"extrapolator":{"description":"Takes an input signal and emits the extrapolated value; either mirroring the input value or repeating the last known value up to the maximum extrapolation interval.","type":"object","properties":{"in_ports":{"description":"Input ports for the Extrapolator component.","type":"object","properties":{"input":{"description":"Input signal for the Extrapolator component.","type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"}}},"max_extrapolation_interval":{"type":"string","description":"Maximum time interval to repeat the last valid value of input signal.","x-go-default":"10s"},"out_ports":{"description":"Output ports for the Extrapolator component.","type":"object","properties":{"output":{"description":"Extrapolated signal.","type":"object","properties":{"signal_name":{"type":"string","description":"Name of the outgoing Signal on the OutPort."}},"title":"Components produce output for other components via OutPorts"}}}},"title":"Extrapolates the input signal by repeating the last valid value during the period in which it is invalid"},"gradient_controller":{"description":"Gradient controller basically calculates the ratio between the signal and the setpoint to determine the magnitude of the correction that need to be applied.\nThis controller can be used to build AIMD (Additive Increase, Multiplicative Decrease) or MIMD style response.","type":"object","properties":{"in_ports":{"description":"Input ports of the Gradient Controller.","type":"object","properties":{"control_variable":{"description":"Actual current value of the control variable.\n\nThis signal is multiplied by the gradient to produce the output.","type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"},"max":{"description":"Maximum value to limit the output signal.","type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"},"min":{"description":"Minimum value to limit the output signal.","type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"},"optimize":{"description":"Optimize signal is added to the output of the gradient calculation.","type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"},"setpoint":{"description":"Setpoint to be used for the gradient computation.","type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"},"signal":{"description":"Signal to be used for the gradient computation.","type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"}}},"max_gradient":{"type":"number","format":"double","description":"Maximum gradient which clamps the computed gradient value to the range, [min_gradient, max_gradient].","x-go-default":1.7976931348623157e+308},"min_gradient":{"type":"number","format":"double","description":"Minimum gradient which clamps the computed gradient value to the range, [min_gradient, max_gradient].","x-go-default":-1.7976931348623157e+308},"out_ports":{"description":"Output ports of the Gradient Controller.","type":"object","properties":{"output":{"description":"Computed desired value of the control variable.","type":"object","properties":{"signal_name":{"type":"string","description":"Name of the outgoing Signal on the OutPort."}},"title":"Components produce output for other components via OutPorts"}}},"slope":{"type":"number","format":"double","description":"Slope controls the aggressiveness and direction of the Gradient Controller.\n\nSlope is used as exponent on the signal to setpoint ratio in computation\nof the gradient (see the [main description](#v1-gradient-controller) for\nexact equation). Good intuition for this parameter is \"What should the\nGradient Controller do to the control variable when signal is too high\",\neg.:\n* $\\text{slope} = 1$: when signal is too high, increase control variable,\n* $\\text{slope} = -1$: when signal is too high, decrease control variable,\n* $\\text{slope} = -0.5$: when signal is to high, decrease control variable more slowly.\n\nThe sign of slope depends on correlation between the signal and control variable:\n* Use $\\text{slope} < 0$ if signal and control variable are _positively_\ncorrelated (eg. Per-pod CPU usage and total concurrency).\n* Use $\\text{slope} > 0$ if signal and control variable are _negatively_\ncorrelated (eg. Per-pod CPU usage and number of pods).\n\n:::note\nYou need to set _negative_ slope for a _positive_ correlation, as you're\ndescribing the _action_ which controller should make when the signal\nincreases.\n:::\n\nThe magnitude of slope describes how aggressively should the controller\nreact to a deviation of signal.\nWith $|\\text{slope}| = 1$, the controller will aim to bring the signal to\nthe setpoint in one tick (assuming linear correlation with signal and setpoint).\nSmaller magnitudes of slope will make the controller adjust the control\nvariable more slowly.\n\nWe recommend setting $|\\text{slope}| < 1$ (eg. $\\pm0.8$).\nIf you experience overshooting, consider lowering the magnitude even more.\nValues of $|\\text{slope}| > 1$ are not recommended.\n\n:::note\nRemember that the gradient and output signal can be (optionally) clamped,\nso the _slope_ might not fully describe aggressiveness of the controller.\n:::","x-go-validate":"required"}},"title":"Gradient controller is a type of controller which tries to adjust the\ncontrol variable proportionally to the relative difference between setpoint\nand actual value of the signal"},"max":{"description":"Emits the maximum of the input signals.","type":"object","properties":{"in_ports":{"description":"Input ports for the Max component.","type":"object","properties":{"inputs":{"type":"array","items":{"type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"},"description":"Array of input signals."}}},"out_ports":{"description":"Output ports for the Max component.","type":"object","properties":{"output":{"description":"Signal with maximum value as an output signal.","type":"object","properties":{"signal_name":{"type":"string","description":"Name of the outgoing Signal on the OutPort."}},"title":"Components produce output for other components via OutPorts"}}}},"title":"Takes a list of input signals and emits the signal with the maximum value"},"min":{"description":"Emits the minimum of the input signals.","type":"object","properties":{"in_ports":{"description":"Input ports for the Min component.","type":"object","properties":{"inputs":{"type":"array","items":{"type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts"},"description":"Array of input signals."}}},"out_ports":{"description":"Output ports for the Min component.","type":"object","properties":{"output":{"description":"Signal with minimum value as an output signal.","type":"object","properties":{"signal_name":{"type":"string","description":"Name of the outgoing Signal on the OutPort."}},"title":"Components produce output for other components via OutPorts"}}}}},"promql":{"description":"Periodically runs a Prometheus query in the background and emits the result.","type":"object","properties":{"evaluation_interval":{"type":"string","description":"Describes the interval between successive evaluations of the Prometheus query.","x-go-default":"10s"},"out_ports":{"description":"Output ports for the PromQL component.","type":"object","properties":{"output":{"description":"The result of the Prometheus query as an output signal.","type":"object","properties":{"signal_name":{"type":"string","description":"Name of the outgoing Signal on the OutPort."}},"title":"Components produce output for other components via OutPorts"}}},"query_string":{"type":"string","description":"Describes the Prometheus query to be run.\n\n:::caution\nTODO we should describe how to construct the query, eg. how to employ the\nfluxmeters here or link to appropriate place in docs.\n:::"}},"title":"Component that runs a Prometheus query periodically and returns the result as an output signal"},"rate_limiter":{"description":"Rate Limiter provides service protection by applying rate limiter.","type":"object","properties":{"dynamic_config_key":{"type":"string","title":"Configuration key for DynamicConfig"},"in_ports":{"x-go-validate":"required","type":"object","properties":{"limit":{"type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts","description":"Number of flows allowed per _limit\\_reset\\_interval_ per each label.\nNegative values disable the ratelimiter.\n\n:::tip\nNegative limit can be useful to _conditionally_ enable the ratelimiter\nunder certain circumstances. [Decider](#v1-decider) might be helpful.\n:::","x-go-validate":"required"}},"title":"Inputs for the RateLimiter component"},"init_config":{"title":"Initial configuration","type":"object","properties":{"overrides":{"type":"array","items":{"type":"object","properties":{"label_value":{"type":"string","description":"Value of the label for which the override should be applied.","x-go-validate":"required"},"limit_scale_factor":{"type":"number","format":"double","description":"Amount by which the _in\\_ports.limit_ should be multiplied for this label value.","x-go-default":1}}},"description":"Allows to specify different limits for particular label values."}}},"label_key":{"type":"string","description":"Specifies which label the ratelimiter should be keyed by.\n\nRate limiting is done independently for each value of the\n[label](/concepts/flow-control/flow-label.md) with given key.\nEg., to give each user a separate limit, assuming you have a _user_ flow\nlabel set up, set `label_key: \"user\"`.","x-go-validate":"required"},"lazy_sync":{"title":"Configuration of lazy-syncing behaviour of ratelimiter","type":"object","properties":{"enabled":{"type":"boolean","title":"Enables lazy sync","x-go-default":false},"num_sync":{"type":"integer","format":"int64","description":"Number of times to lazy sync within the _limit\\_reset\\_interval_.","x-go-default":5,"x-go-validate":"gt=0"}}},"limit_reset_interval":{"type":"string","description":"Time after which the limit for a given label value will be reset.","x-go-default":"60s"},"selector":{"description":"Which control point to apply this ratelimiter to.","x-go-validate":"required","type":"object","properties":{"flow_selector":{"x-go-validate":"required","type":"object","properties":{"control_point":{"description":"Describes\n[control point](/concepts/flow-control/flow-control.md#control-point)\nwithin the entity where the policy should apply to.","x-go-validate":"required","type":"object","properties":{"feature":{"type":"string","description":"Name of Aperture SDK's feature.\nFeature corresponds to a block of code that can be \"switched off\" which usually is a \"named opentelemetry's Span\".\n\nNote: Flowcontrol only.","x-go-validate":"required"},"traffic":{"type":"string","description":"Type of traffic service, either \"ingress\" or \"egress\".\nApply the policy to the whole incoming/outgoing traffic of a service.\nUsually powered by integration with a proxy (like envoy) or a web framework.\n\n* Flowcontrol: Blockable atom here is a single HTTP-transaction.\n* Classification: Apply the classification rules to every incoming/outgoing request and attach the resulting flow labels to baggage and telemetry.","x-go-validate":"required,oneof=ingress egress"}}},"label_matcher":{"description":":::info\nSee also [Label Matcher overview](/concepts/flow-control/selector.md#label-matcher).\n:::\n\n:::note\n[Classifiers](#v1-classifier) _can_ use flow labels created by some other\nclassifier, but only if they were created at some previous control point\n(and propagated in baggage).\n\nThis limitation doesn't apply to selectors of other entities, like\nFluxMeters or actuators. It's valid to create a flow label on a control\npoint using classifier, and immediately use it for matching on the same\ncontrol point.\n:::","title":"Label matcher allows to add _additional_ condition on\n[flow labels](/concepts/flow-control/flow-label.md)\nmust also be satisfied (in addition to service+control point matching)","type":"object","properties":{"expression":{"description":"An arbitrary expression to be evaluated on the labels.","type":"object","properties":{"all":{"description":"The expression is true when all subexpressions are true.","type":"object","properties":{"of":{"type":"array","items":{"type":"object","properties":"circular()","description":"MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals: { label = app, value = frobnicator }\n```","title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"},"description":"List of subexpressions of the match expression."}},"title":"List of MatchExpressions that is used for all/any matching"},"any":{"description":"The expression is true when any subexpression is true.","type":"object","properties":{"of":{"type":"array","items":{"type":"object","properties":"circular()","description":"MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals: { label = app, value = frobnicator }\n```","title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"},"description":"List of subexpressions of the match expression."}},"title":"List of MatchExpressions that is used for all/any matching"},"label_equals":{"description":"The expression is true when label value equals given value.","type":"object","properties":{"label":{"type":"string","description":"Name of the label to equal match the value.","x-go-validate":"required"},"value":{"type":"string","description":"Exact value that the label should be equal to."}}},"label_exists":{"type":"string","description":"The expression is true when label with given name exists.","x-go-validate":"required"},"label_matches":{"description":"The expression is true when label matches given regex.","type":"object","properties":{"label":{"type":"string","description":"Name of the label to match the regular expression.","x-go-validate":"required"},"regex":{"type":"string","description":"Regular expression that should match the label value.\nIt uses [golang's regular expression syntax](https://github.com/google/re2/wiki/Syntax).","x-go-validate":"required"}}},"not":{"type":"object","properties":"circular()","description":"MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals: { label = app, value = frobnicator }\n```","title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"}},"title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"},"match_expressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string","description":"Label key that the selector applies to.","x-go-validate":"required"},"operator":{"type":"string","description":"Logical operator which represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.","x-go-validate":"oneof=In NotIn Exists DoesNotExists"},"values":{"type":"array","items":{"type":"string"},"description":"An array of string values that relates to the key by an operator.\nIf the operator is In or NotIn, the values array must be non-empty.\nIf the operator is Exists or DoesNotExist, the values array must be empty."}},"description":"Label selector requirement which is a selector that contains values, a key, and an operator that relates the key and values."},"description":"List of k8s-style label matcher requirements.\n\nNote: The requirements are ANDed."},"match_labels":{"type":"object","additionalProperties":{"type":"string"},"description":"A map of {key,value} pairs representing labels to be matched.\nA single {key,value} in the matchLabels requires that the label \"key\" is present and equal to \"value\".\n\nNote: The requirements are ANDed."}}}},"description":":::info\nSee also [Selector overview](/concepts/flow-control/selector.md).\n:::\n\nExample:\n```yaml\ncontrol_point:\n  traffic: ingress # Allowed values are `ingress` and `egress`.\nlabel_matcher:\n  match_labels:\n    user_tier: gold\n  match_expressions:\n    - key: query\n      operator: In\n      values:\n        - insert\n        - delete\n    - label: user_agent\n      regex: ^(?!.*Chrome).*Safari\n```","title":"Describes which flows a [dataplane\ncomponent](/concepts/flow-control/flow-control.md#components) should apply\nto"},"service_selector":{"x-go-validate":"required","type":"object","properties":{"agent_group":{"type":"string","description":"Which [agent-group](/concepts/service.md#agent-group) this\nselector applies to.","x-go-default":"default"},"service":{"type":"string","description":"The Fully Qualified Domain Name of the\n[service](/concepts/service.md) to select.\n\nIn kubernetes, this is the FQDN of the Service object.\n\nEmpty string means all services within an agent group (catch-all).\n\n:::note\nOne entity may belong to multiple services.\n:::"}},"description":":::info\nSee also [Selector overview](/concepts/flow-control/selector.md).\n:::","title":"Describes which service a [dataplane\ncomponent](/concepts/flow-control/flow-control.md#components) should apply\nto"}},"title":"Describes which flow in which service a [dataplane\ncomponent](/concepts/flow-control/flow-control.md#components) should apply\nto"}},"title":"Limits the traffic on a control point to specified rate"},"sqrt":{"description":"Takes an input signal and emits the square root of the input signal.","type":"object","properties":{"in_ports":{"description":"Input ports for the Sqrt component.","type":"object","properties":{"input":{"type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts","description":"Input signal."}}},"out_ports":{"description":"Output ports for the Sqrt component.","type":"object","properties":{"output":{"description":"Output signal.","type":"object","properties":{"signal_name":{"type":"string","description":"Name of the outgoing Signal on the OutPort."}},"title":"Components produce output for other components via OutPorts"}}},"scale":{"type":"number","format":"double","description":"Scaling factor to be multiplied with the square root of the input signal.","x-go-default":1}},"title":"Takes an input signal and emits the square root of it multiplied by scale as an output"},"switcher":{"description":"Switcher acts as a switch that emits one of the two signals based on third signal.","type":"object","properties":{"in_ports":{"description":"Input ports for the Switcher component.","type":"object","properties":{"on_false":{"type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts","description":"Output signal when switch is invalid or 0.0."},"on_true":{"type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts","description":"Output signal when switch is valid and not 0.0."},"switch":{"type":"object","properties":{"constant_value":{"type":"number","format":"double","description":"Constant value to be used for this InPort instead of a signal."},"signal_name":{"type":"string","description":"Name of the incoming Signal on the InPort."}},"title":"Components receive input from other components via InPorts","description":"Decides whether to return on_true or on_false."}}},"out_ports":{"description":"Output ports for the Switcher component.","type":"object","properties":{"output":{"description":"Selected signal (on_true or on_false).","type":"object","properties":{"signal_name":{"type":"string","description":"Name of the outgoing Signal on the OutPort."}},"title":"Components produce output for other components via OutPorts"}}}},"title":"Type of combinator that switches between `on_true` and `on_false` signals based on switch input"}},"description":":::info\nSee also [Components overview](/concepts/policy/circuit.md#components).\n:::\n\nSignals flow into the components via input ports and results are emitted on output ports.\nComponents are wired to each other based on signal names forming an execution graph of the circuit.\n\n:::note\nLoops are broken by the runtime at the earliest component index that is part of the loop.\nThe looped signals are saved in the tick they are generated and served in the subsequent tick.\n:::\n\nThere are three categories of components:\n* \"source\" components – they take some sort of input from \"the real world\" and output\n  a signal based on this input. Example: [PromQL](#v1-prom-q-l). In the UI\n  they're represented by green color.\n* signal processor components – \"pure\" components that don't interact with the \"real world\".\n  Examples: [GradientController](#v1-gradient-controller), [Max](#v1-max).\n  :::note\n  Signal processor components's output can depend on their internal state, in addition to the inputs.\n  Eg. see the [Exponential Moving Average filter](#v1-e-m-a).\n  :::\n* \"sink\" components – they affect the real world.\n  [ConcurrencyLimiter.LoadShedActuator](#v1-concurrency-limiter) and [RateLimiter](#v1-rate-limiter).\n  In the UI, represented by orange color.  Sink components usually come in pairs with a\n  \"sources\" component which emits a feedback signal, like\n  `accepted_concurrency` emitted by ConcurrencyLimiter.Scheduler.\n\n:::tip\nSometimes you may want to use a constant value as one of component's inputs.\nYou can create an input port containing the constant value instead of being connected to a signal.\nTo do so, use the [InPort](#v1-in_port)'s .withConstantValue(constant_value) method.\nIf You need to provide the same constant signal to multiple components,\nYou can use the [Constant](#v1-constant) component.\n:::\n\nSee also [Policy](#v1-policy) for a higher-level explanation of circuits.","title":"Computational block that form the circuit"},"description":"Defines a signal processing graph as a list of components."},"evaluation_interval":{"type":"string","description":"Evaluation interval (tick) is the time period between consecutive runs of the policy circuit.\nThis interval is typically aligned with how often the corrective action (actuation) needs to be taken.","x-go-default":"0.5s"}},"title":"Circuit is defined as a dataflow graph of inter-connected components"},"resources":{"description":"Resources (FluxMeters, Classifiers etc.) to setup.","type":"object","properties":{"classifiers":{"type":"array","items":{"type":"object","properties":{"rules":{"type":"object","additionalProperties":{"type":"object","properties":{"extractor":{"description":"High-level declarative extractor.","type":"object","properties":{"address":{"description":"Display an address as a single string - `<ip>:<port>`.","type":"object","properties":{"from":{"type":"string","description":"Attribute path pointing to some string - eg. \"source.address\".","x-go-validate":"required"}},"title":"Display an [Address][ext-authz-address] as a single string, eg. `<ip>:<port>`"},"from":{"type":"string","description":"Attribute path is a dot-separated path to attribute.\n\nShould be either:\n* one of the fields of [Attribute Context][attribute-context], or\n* a special \"request.http.bearer\" pseudo-attribute.\nEg. \"request.http.method\" or \"request.http.header.user-agent\"\n\nNote: The same attribute path syntax is shared by other extractor variants,\nwherever attribute path is needed in their \"from\" syntax.\n\nExample:\n```yaml\nfrom: request.http.headers.user-agent\n```\n[attribute-context]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/attribute_context.proto\"","title":"Use an attribute with no conversion"},"json":{"description":"Deserialize a json, and extract one of the fields.","type":"object","properties":{"from":{"type":"string","description":"Attribute path pointing to some strings - eg. \"request.http.body\".","x-go-validate":"required"},"pointer":{"type":"string","description":"Json pointer represents a parsed json pointer which allows to select a specified field from the json payload.\n\nNote: Uses [json pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,\neg. `/foo/bar`. If the pointer points into an object, it'd be stringified."}},"title":"Deserialize a json, and extract one of the fields"},"jwt":{"description":"Parse the attribute as JWT and read the payload.","type":"object","properties":{"from":{"type":"string","description":"Jwt token can be pulled from any input attribute, but most likely you'd want to use \"request.http.bearer\".","x-go-validate":"required"},"json_pointer":{"type":"string","description":"Json pointer allowing to select a specified field from the json payload.\n\nNote: Uses [json pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,\neg. `/foo/bar`. If the pointer points into an object, it'd be stringified."}},"title":"Parse the attribute as JWT and read the payload"},"path_templates":{"description":"Match HTTP Path to given path templates.","type":"object","properties":{"template_values":{"type":"object","additionalProperties":{"type":"string"},"description":"Template value keys are OpenAPI-inspired path templates.\n\n* Static path segment `/foo` matches a path segment exactly\n* `/{param}` matches arbitrary path segment.\n  (The param name is ignored and can be omitted (`{}`))\n* The parameter must cover whole segment.\n* Additionally, path template can end with `/*` wildcard to match\n  arbitrary number of trailing segments (0 or more).\n* Multiple consecutive `/` are ignored, as well as trailing `/`.\n* Parametrized path segments must come after static segments.\n* `*`, if present, must come last.\n* Most specific template \"wins\" (`/foo` over `/{}` and `/{}` over `/*`).\n\nSee also <https://swagger.io/specification/#path-templating-matching>\n\nExample:\n```yaml\n/register: register\n\"/user/{userId}\": user\n/static/*: other\n```","x-go-validate":"required"}},"title":"Matches HTTP Path to given path templates"}},"title":"Defines a high-level way to specify how to extract a flow label value given http request metadata, without a need to write rego code"},"rego":{"description":"Rego module to extract a value from the rego module.","type":"object","properties":{"query":{"type":"string","description":"Query string to extract a value (eg. `data.<mymodulename>.<variablename>`).\n\nNote: The module name must match the package name from the \"source\".","x-go-validate":"required"},"source":{"type":"string","description":"Source code of the rego module.\n\nNote: Must include a \"package\" declaration.","x-go-validate":"required"}},"title":"Raw rego rules are compiled 1:1 to rego queries"},"telemetry":{"type":"boolean","description":":::note\nThe flow label is always accessible in Aperture Policies regardless of this setting.\n:::\n\n:::caution\nWhen using [FluxNinja Cloud plugin](cloud/plugin.md), telemetry enabled\nlabels are sent to FluxNinha Cloud for observability. Telemetry should be disabled for\nsensitive labels.\n:::","title":"Decides if the created flow label should be available as an attribute in OLAP telemetry and\npropagated in [baggage](/concepts/flow-control/flow-label.md#baggage))","x-go-validate":"required"}},"description":"Flow classification rule extracts a value from request metadata.\nMore specifically, from `input`, which has the same spec as [Envoy's External Authorization Attribute Context][attribute-context].\nSee <https://play.openpolicyagent.org/p/gU7vcLkc70> for an example input.\nThere are two ways to define a flow classification rule:\n* Using a declarative extractor – suitable from simple cases, such as directly reading a value from header or a field from json body.\n* Rego expression.\n\nPerformance note: It's recommended to use declarative extractors where possible, as they may be slightly performant than Rego expressions.\n[attribute-context](https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/attribute_context.proto)\n\nExample of Declarative JSON extractor:\n```yaml\nextractor:\n  json:\n    from: request.http.body\n    pointer: /user/name\n```\n\nExample of Rego module which also disables propagation of a label:\n```yaml\nrego:\n  query: data.user_from_cookie.user\n  source: |\n    package: user_from_cookie\n    cookies: split(input.attributes.request.http.headers.cookie, ';')\n    cookie: cookies[_]\n    cookie.startswith: ('session=')\n    session: substring(cookie, count('session='), -1)\n    parts: split(session, '.')\n    object: json.unmarshal(base64url.decode(parts[0]))\n    user: object.user\npropagate: false\n```","title":"Rule describes a single Flow Classification Rule"},"description":"A map of {key, value} pairs mapping from\n[flow label](/concepts/flow-control/flow-label.md) keys to rules that define\nhow to extract and propagate flow labels with that key.","x-go-validate":"required,gt=0,dive,keys,required,endkeys,required"},"selector":{"description":"Defines where to apply the flow classification rule.","x-go-validate":"required","type":"object","properties":{"flow_selector":{"x-go-validate":"required","type":"object","properties":{"control_point":{"description":"Describes\n[control point](/concepts/flow-control/flow-control.md#control-point)\nwithin the entity where the policy should apply to.","x-go-validate":"required","type":"object","properties":{"feature":{"type":"string","description":"Name of Aperture SDK's feature.\nFeature corresponds to a block of code that can be \"switched off\" which usually is a \"named opentelemetry's Span\".\n\nNote: Flowcontrol only.","x-go-validate":"required"},"traffic":{"type":"string","description":"Type of traffic service, either \"ingress\" or \"egress\".\nApply the policy to the whole incoming/outgoing traffic of a service.\nUsually powered by integration with a proxy (like envoy) or a web framework.\n\n* Flowcontrol: Blockable atom here is a single HTTP-transaction.\n* Classification: Apply the classification rules to every incoming/outgoing request and attach the resulting flow labels to baggage and telemetry.","x-go-validate":"required,oneof=ingress egress"}}},"label_matcher":{"description":":::info\nSee also [Label Matcher overview](/concepts/flow-control/selector.md#label-matcher).\n:::\n\n:::note\n[Classifiers](#v1-classifier) _can_ use flow labels created by some other\nclassifier, but only if they were created at some previous control point\n(and propagated in baggage).\n\nThis limitation doesn't apply to selectors of other entities, like\nFluxMeters or actuators. It's valid to create a flow label on a control\npoint using classifier, and immediately use it for matching on the same\ncontrol point.\n:::","title":"Label matcher allows to add _additional_ condition on\n[flow labels](/concepts/flow-control/flow-label.md)\nmust also be satisfied (in addition to service+control point matching)","type":"object","properties":{"expression":{"description":"An arbitrary expression to be evaluated on the labels.","type":"object","properties":{"all":{"description":"The expression is true when all subexpressions are true.","type":"object","properties":{"of":{"type":"array","items":{"type":"object","properties":"circular()","description":"MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals: { label = app, value = frobnicator }\n```","title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"},"description":"List of subexpressions of the match expression."}},"title":"List of MatchExpressions that is used for all/any matching"},"any":{"description":"The expression is true when any subexpression is true.","type":"object","properties":{"of":{"type":"array","items":{"type":"object","properties":"circular()","description":"MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals: { label = app, value = frobnicator }\n```","title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"},"description":"List of subexpressions of the match expression."}},"title":"List of MatchExpressions that is used for all/any matching"},"label_equals":{"description":"The expression is true when label value equals given value.","type":"object","properties":{"label":{"type":"string","description":"Name of the label to equal match the value.","x-go-validate":"required"},"value":{"type":"string","description":"Exact value that the label should be equal to."}}},"label_exists":{"type":"string","description":"The expression is true when label with given name exists.","x-go-validate":"required"},"label_matches":{"description":"The expression is true when label matches given regex.","type":"object","properties":{"label":{"type":"string","description":"Name of the label to match the regular expression.","x-go-validate":"required"},"regex":{"type":"string","description":"Regular expression that should match the label value.\nIt uses [golang's regular expression syntax](https://github.com/google/re2/wiki/Syntax).","x-go-validate":"required"}}},"not":{"type":"object","properties":"circular()","description":"MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals: { label = app, value = frobnicator }\n```","title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"}},"title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"},"match_expressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string","description":"Label key that the selector applies to.","x-go-validate":"required"},"operator":{"type":"string","description":"Logical operator which represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.","x-go-validate":"oneof=In NotIn Exists DoesNotExists"},"values":{"type":"array","items":{"type":"string"},"description":"An array of string values that relates to the key by an operator.\nIf the operator is In or NotIn, the values array must be non-empty.\nIf the operator is Exists or DoesNotExist, the values array must be empty."}},"description":"Label selector requirement which is a selector that contains values, a key, and an operator that relates the key and values."},"description":"List of k8s-style label matcher requirements.\n\nNote: The requirements are ANDed."},"match_labels":{"type":"object","additionalProperties":{"type":"string"},"description":"A map of {key,value} pairs representing labels to be matched.\nA single {key,value} in the matchLabels requires that the label \"key\" is present and equal to \"value\".\n\nNote: The requirements are ANDed."}}}},"description":":::info\nSee also [Selector overview](/concepts/flow-control/selector.md).\n:::\n\nExample:\n```yaml\ncontrol_point:\n  traffic: ingress # Allowed values are `ingress` and `egress`.\nlabel_matcher:\n  match_labels:\n    user_tier: gold\n  match_expressions:\n    - key: query\n      operator: In\n      values:\n        - insert\n        - delete\n    - label: user_agent\n      regex: ^(?!.*Chrome).*Safari\n```","title":"Describes which flows a [dataplane\ncomponent](/concepts/flow-control/flow-control.md#components) should apply\nto"},"service_selector":{"x-go-validate":"required","type":"object","properties":{"agent_group":{"type":"string","description":"Which [agent-group](/concepts/service.md#agent-group) this\nselector applies to.","x-go-default":"default"},"service":{"type":"string","description":"The Fully Qualified Domain Name of the\n[service](/concepts/service.md) to select.\n\nIn kubernetes, this is the FQDN of the Service object.\n\nEmpty string means all services within an agent group (catch-all).\n\n:::note\nOne entity may belong to multiple services.\n:::"}},"description":":::info\nSee also [Selector overview](/concepts/flow-control/selector.md).\n:::","title":"Describes which service a [dataplane\ncomponent](/concepts/flow-control/flow-control.md#components) should apply\nto"}},"title":"Describes which flow in which service a [dataplane\ncomponent](/concepts/flow-control/flow-control.md#components) should apply\nto"}},"description":":::info\nSee also [Classifier overview](/concepts/flow-control/flow-classifier.md).\n:::\n\nExample:\n```yaml\nselector:\n  service_selector:\n    service: service1.default.svc.cluster.local\n  flow_selector:\n    control_point:\n      traffic: ingress\nrules:\n  user:\n    extractor:\n      from: request.http.headers.user\n```","title":"Set of classification rules sharing a common selector"},"description":"Classifiers are installed in the data-plane and are used to label the requests based on payload content.\n\nThe flow labels created by Classifiers can be matched by FluxMeters to create metrics for control purposes."},"flux_meters":{"type":"object","additionalProperties":{"type":"object","properties":{"attribute_key":{"type":"string","description":"Key of the attribute in access log or span from which the metric for this flux meter is read.\n\n:::info\nFor list of available attributes in Envoy access logs, refer\n[Envoy Filter](/get-started/installation/agent/envoy/istio.md#envoy-filter)\n:::","x-go-default":"workload_duration_ms"},"exponential_buckets":{"type":"object","properties":{"count":{"type":"integer","format":"int32","description":"Number of buckets.","x-go-validate":"gt=0"},"factor":{"type":"number","format":"double","description":"Factor to be multiplied to the previous bucket's upper bound to calculate the following bucket's upper bound.","x-go-validate":"gt=1.0"},"start":{"type":"number","format":"double","description":"Upper bound of the lowest bucket.","x-go-validate":"gt=0"}},"description":"ExponentialBuckets creates `count` number of buckets where the lowest bucket has an upper bound of `start`\nand each following bucket's upper bound is `factor` times the previous bucket's upper bound. The final +inf\nbucket is not counted."},"exponential_buckets_range":{"type":"object","properties":{"count":{"type":"integer","format":"int32","description":"Number of buckets.","x-go-validate":"gt=0"},"max":{"type":"number","format":"double","description":"Highest bucket."},"min":{"type":"number","format":"double","description":"Lowest bucket.","x-go-validate":"gt=0"}},"description":"ExponentialBucketsRange creates `count` number of buckets where the lowest bucket is `min` and the highest\nbucket is `max`. The final +inf bucket is not counted."},"linear_buckets":{"type":"object","properties":{"count":{"type":"integer","format":"int32","description":"Number of buckets.","x-go-validate":"gt=0"},"start":{"type":"number","format":"double","description":"Upper bound of the lowest bucket."},"width":{"type":"number","format":"double","description":"Width of each bucket."}},"description":"LinearBuckets creates `count` number of buckets, each `width` wide, where the lowest bucket has an\nupper bound of `start`. The final +inf bucket is not counted."},"selector":{"description":"What latency should we measure in the histogram created by this FluxMeter.\n\n* For traffic control points, fluxmeter will measure the duration of the\n  whole http transaction (including sending request and receiving\n  response).\n* For feature control points, fluxmeter will measure execution of the span\n  associated with particular feature. What contributes to the span's\n  duration is entirely up to the user code that uses Aperture SDK.","type":"object","properties":{"flow_selector":{"x-go-validate":"required","type":"object","properties":{"control_point":{"description":"Describes\n[control point](/concepts/flow-control/flow-control.md#control-point)\nwithin the entity where the policy should apply to.","x-go-validate":"required","type":"object","properties":{"feature":{"type":"string","description":"Name of Aperture SDK's feature.\nFeature corresponds to a block of code that can be \"switched off\" which usually is a \"named opentelemetry's Span\".\n\nNote: Flowcontrol only.","x-go-validate":"required"},"traffic":{"type":"string","description":"Type of traffic service, either \"ingress\" or \"egress\".\nApply the policy to the whole incoming/outgoing traffic of a service.\nUsually powered by integration with a proxy (like envoy) or a web framework.\n\n* Flowcontrol: Blockable atom here is a single HTTP-transaction.\n* Classification: Apply the classification rules to every incoming/outgoing request and attach the resulting flow labels to baggage and telemetry.","x-go-validate":"required,oneof=ingress egress"}}},"label_matcher":{"description":":::info\nSee also [Label Matcher overview](/concepts/flow-control/selector.md#label-matcher).\n:::\n\n:::note\n[Classifiers](#v1-classifier) _can_ use flow labels created by some other\nclassifier, but only if they were created at some previous control point\n(and propagated in baggage).\n\nThis limitation doesn't apply to selectors of other entities, like\nFluxMeters or actuators. It's valid to create a flow label on a control\npoint using classifier, and immediately use it for matching on the same\ncontrol point.\n:::","title":"Label matcher allows to add _additional_ condition on\n[flow labels](/concepts/flow-control/flow-label.md)\nmust also be satisfied (in addition to service+control point matching)","type":"object","properties":{"expression":{"description":"An arbitrary expression to be evaluated on the labels.","type":"object","properties":{"all":{"description":"The expression is true when all subexpressions are true.","type":"object","properties":{"of":{"type":"array","items":{"type":"object","properties":"circular()","description":"MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals: { label = app, value = frobnicator }\n```","title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"},"description":"List of subexpressions of the match expression."}},"title":"List of MatchExpressions that is used for all/any matching"},"any":{"description":"The expression is true when any subexpression is true.","type":"object","properties":{"of":{"type":"array","items":{"type":"object","properties":"circular()","description":"MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals: { label = app, value = frobnicator }\n```","title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"},"description":"List of subexpressions of the match expression."}},"title":"List of MatchExpressions that is used for all/any matching"},"label_equals":{"description":"The expression is true when label value equals given value.","type":"object","properties":{"label":{"type":"string","description":"Name of the label to equal match the value.","x-go-validate":"required"},"value":{"type":"string","description":"Exact value that the label should be equal to."}}},"label_exists":{"type":"string","description":"The expression is true when label with given name exists.","x-go-validate":"required"},"label_matches":{"description":"The expression is true when label matches given regex.","type":"object","properties":{"label":{"type":"string","description":"Name of the label to match the regular expression.","x-go-validate":"required"},"regex":{"type":"string","description":"Regular expression that should match the label value.\nIt uses [golang's regular expression syntax](https://github.com/google/re2/wiki/Syntax).","x-go-validate":"required"}}},"not":{"type":"object","properties":"circular()","description":"MatchExpression has multiple variants, exactly one should be set.\n\nExample:\n```yaml\nall:\n  of:\n    - label_exists: foo\n    - label_equals: { label = app, value = frobnicator }\n```","title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"}},"title":"Defines a [map<string, string> → bool] expression to be evaluated on labels"},"match_expressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string","description":"Label key that the selector applies to.","x-go-validate":"required"},"operator":{"type":"string","description":"Logical operator which represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.","x-go-validate":"oneof=In NotIn Exists DoesNotExists"},"values":{"type":"array","items":{"type":"string"},"description":"An array of string values that relates to the key by an operator.\nIf the operator is In or NotIn, the values array must be non-empty.\nIf the operator is Exists or DoesNotExist, the values array must be empty."}},"description":"Label selector requirement which is a selector that contains values, a key, and an operator that relates the key and values."},"description":"List of k8s-style label matcher requirements.\n\nNote: The requirements are ANDed."},"match_labels":{"type":"object","additionalProperties":{"type":"string"},"description":"A map of {key,value} pairs representing labels to be matched.\nA single {key,value} in the matchLabels requires that the label \"key\" is present and equal to \"value\".\n\nNote: The requirements are ANDed."}}}},"description":":::info\nSee also [Selector overview](/concepts/flow-control/selector.md).\n:::\n\nExample:\n```yaml\ncontrol_point:\n  traffic: ingress # Allowed values are `ingress` and `egress`.\nlabel_matcher:\n  match_labels:\n    user_tier: gold\n  match_expressions:\n    - key: query\n      operator: In\n      values:\n        - insert\n        - delete\n    - label: user_agent\n      regex: ^(?!.*Chrome).*Safari\n```","title":"Describes which flows a [dataplane\ncomponent](/concepts/flow-control/flow-control.md#components) should apply\nto"},"service_selector":{"x-go-validate":"required","type":"object","properties":{"agent_group":{"type":"string","description":"Which [agent-group](/concepts/service.md#agent-group) this\nselector applies to.","x-go-default":"default"},"service":{"type":"string","description":"The Fully Qualified Domain Name of the\n[service](/concepts/service.md) to select.\n\nIn kubernetes, this is the FQDN of the Service object.\n\nEmpty string means all services within an agent group (catch-all).\n\n:::note\nOne entity may belong to multiple services.\n:::"}},"description":":::info\nSee also [Selector overview](/concepts/flow-control/selector.md).\n:::","title":"Describes which service a [dataplane\ncomponent](/concepts/flow-control/flow-control.md#components) should apply\nto"}},"title":"Describes which flow in which service a [dataplane\ncomponent](/concepts/flow-control/flow-control.md#components) should apply\nto"},"static_buckets":{"type":"object","properties":{"buckets":{"type":"array","items":{"type":"number","format":"double"},"x-go-default":"[5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]"}},"description":"StaticBuckets holds the static value of the buckets where latency histogram will be stored."}},"description":":::info\nSee also [FluxMeter overview](/concepts/flow-control/flux-meter.md).\n:::\n\nExample of a selector that creates a histogram metric for all HTTP requests\nto particular service:\n```yaml\nselector:\n  service_selector:\n    service: myservice.mynamespace.svc.cluster.local\n  flow_selector:\n    control_point:\n      traffic: ingress\n```","title":"FluxMeter gathers metrics for the traffic that matches its selector"},"description":"FluxMeters are installed in the data-plane and form the observability leg of the feedback loop.\n\nFluxMeters'-created metrics can be consumed as input to the circuit via the PromQL component."}},"title":"Resources that need to be setup for the policy to function"}},"description":":::info\nSee also [Policy overview](/concepts/policy/policy.md).\n:::\n\nPolicy specification contains a circuit that defines the controller logic and resources that need to be setup.","title":"Policy expresses reliability automation workflow that automatically protects services"}}}}}}}}},"default":{"description":"An unexpected error response.","content":{"application/json":{"schema":{"type":"object","properties":{"code":{"type":"integer","format":"int32"},"details":{"type":"array","items":{"type":"object","properties":{"@type":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."}},"additionalProperties":{},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"}},"message":{"type":"string"}}}}}}},"tags":["aperture-controller"],"description":"PolicyService_GetPolicies","method":"get","path":"/v1/policies","info":{"title":"Aperture API","version":"1.0"},"postman":{"name":"Policy Service Get Policies","description":{"type":"text/plain"},"url":{"path":["v1","policies"],"host":["{{baseUrl}}"],"query":[],"variable":[]},"header":[{"key":"Accept","value":"application/json"}],"method":"GET"}}
sidebar_class_name: "get api-method"
info_path: ./local/references/api/controller/aperture-api
custom_edit_url: ""
---

import ApiTabs from "@theme/ApiTabs";
import MimeTabs from "@theme/MimeTabs";
import ParamsItem from "@theme/ParamsItem";
import ResponseSamples from "@theme/ResponseSamples";
import SchemaItem from "@theme/SchemaItem"
import SchemaTabs from "@theme/SchemaTabs";
import DiscriminatorTabs from "@theme/DiscriminatorTabs";
import TabItem from "@theme/TabItem";

## PolicyService_GetPolicies



PolicyService_GetPolicies

<div><ApiTabs><TabItem label={"200"} value={"200"}><div>

A successful response.

</div><div><MimeTabs groupId={"mime-type"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs groupId={"schema-tabs"}><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>policies</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>policies</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><li><div><code>property name*</code><span style={{"opacity":"0.6"}}> object</span></div></li></div></details></SchemaItem></div></details></SchemaItem></ul></details></TabItem><TabItem label={"Example (from schema)"} value={"Example (from schema)"}><ResponseSamples responseExample={"{\n  \"policies\": {\n    \"policies\": {}\n  }\n}"} language={"json"}></ResponseSamples></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem><TabItem label={"default"} value={"default"}><div>

An unexpected error response.

</div><div><MimeTabs groupId={"mime-type"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs groupId={"schema-tabs"}><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"code"} required={false} schemaDescription={undefined} schemaName={"int32"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>details</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"@type"} required={false} schemaDescription={"A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"message"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></ul></details></TabItem><TabItem label={"Example (from schema)"} value={"Example (from schema)"}><ResponseSamples responseExample={"{\n  \"code\": 0,\n  \"details\": [\n    {\n      \"@type\": \"string\"\n    }\n  ],\n  \"message\": \"string\"\n}"} language={"json"}></ResponseSamples></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem></ApiTabs></div>
