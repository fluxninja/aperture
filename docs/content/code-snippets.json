{
  "go": {
    "clientConstructor": "opts := aperture.Options{\n\t\tAddress:     apertureAgentAddr,\n\t\tDialOptions: grpcOptions(apertureAgentInsecureBool, apertureAgentSkipVerifyBool),\n\t\tAPIKey:      getEnvOrDefault(\"APERTURE_API_KEY\", \"\"),\n\t}\n\n\t// initialize Aperture Client with the provided options.\n\tapertureClient, err := aperture.NewClient(ctx, opts)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to create client: %v\", err)\n\t}"
  },
  "py": {
    "apertureDecorator": "flow_params = FlowParams(\n    check_timeout=timedelta(seconds=200),\n)\n\n\n@app.get(\"/super\")\n@aperture_client.decorate(\n    \"awesomeFeature\", params=flow_params, on_reject=lambda: (\"Flow was rejected\", 503)\n)\nasync def super_handler():\n    # Simulate work being done\n    await asyncio.sleep(2)\n    return \"\", 202",
    "cacheFlow": "# business logic produces labels\n    labels = {\n        \"key\": \"some-value\",\n    }\n    flow_params = FlowParams(\n        check_timeout=timedelta(seconds=200),\n        explicit_labels=labels,\n        global_cache_keys=[\"cache-key\"],\n        result_cache_key=\"result-key\",\n    )\n    # start_flow performs a flowcontrol.v1.Check call to Aperture Agent.\n    # It returns a Flow or raises an error if any.\n    flow = aperture_client.start_flow(\n        control_point=\"super3\",\n        params=flow_params,\n    )\n    result_string = None\n    cache_value = None\n\n    # Check if flow check was successful.\n    if not flow.success:\n        logger.info(\"Flow check failed - will fail-open\")\n\n    # See whether flow was accepted by Aperture Agent.\n    if flow.should_run():\n        logging.info(\"Flow accepted\")\n\n        # 1. Check if the response is cached in Aperture from a previous request\n\n        if flow.result_cache().get_lookup_status() == LookupStatus.MISS:\n            logging.info(\"Result Cache Miss, setting result cache\")\n            # Do Actual Work\n            # After completing the work, you can return store the response in cache and return it, for example:\n            result_string = \"foo\"\n            # save to result cache for 10 seconds\n            flow.set_result_cache(result_string, timedelta(seconds=10))\n        else:\n            result_string = flow.result_cache().get_value()\n            logging.info(\"Result Cache Hit: {}\".format(result_string))\n\n        # 2. Check if the cache for a 'cache-key' is present\n        if flow.global_cache(\"cache-key\").get_lookup_status() == LookupStatus.MISS:\n            logging.info(\n                \"Cache Miss, setting global cache for key: '{}'\".format(\"cache-key\")\n            )\n            # save to global cache for key for 10 seconds\n            flow.set_global_cache(\"cache-key\", \"awesome-value\", timedelta(seconds=10))\n            cache_value = \"awesome-value\"\n        else:\n            logging.info(\"Cache Hit\")\n            # get value from global cache for 'cache-key'\n            logging.info(\n                \"Cache Value: {}\".format(flow.global_cache(\"cache-key\").get_value())\n            )\n            cache_value = flow.global_cache(\"cache-key\").get_value()\n    else:\n        # handle flow rejection by Aperture Agent\n        flow.set_status(FlowStatus.Error)\n\n    if flow:\n        flow.end()",
    "clientConstructor": "agent_address = os.getenv(\"APERTURE_AGENT_ADDRESS\", default_agent_address)\napi_key = os.getenv(\"APERTURE_API_KEY\", \"\")\ninsecure = os.getenv(\"APERTURE_AGENT_INSECURE\", \"true\").lower() == \"true\"\n\naperture_client = ApertureClient.new_client(\n    address=agent_address, insecure=insecure, api_key=api_key\n)",
    "contextManagerFlow": "flow_params = FlowParams(\n        explicit_labels=labels,\n        check_timeout=timedelta(seconds=200),\n    )\n\n    with aperture_client.start_flow(\n        control_point=\"AwesomeFeature\",\n        params=flow_params,\n    ) as flow:\n        if flow.should_run():\n            # do actual work\n            # if you do not call flow.end() explicitly, it will be called automatically\n            # when the context manager exits - with the status of the flow\n            # depending on whether an error was raised or not\n            pass",
    "manualFlow": "# business logic produces labels\n    labels = {\n        \"key\": \"value\",\n    }\n    flow_params = FlowParams(\n        check_timeout=timedelta(seconds=200),\n        explicit_labels=labels,\n    )\n    # start_flow performs a flowcontrol.v1.Check call to Aperture Agent.\n    # It returns a Flow or raises an error if any.\n    flow = aperture_client.start_flow(\n        control_point=\"AwesomeFeature\",\n        params=flow_params,\n    )\n\n    # Check if flow check was successful.\n    if not flow.success:\n        logger.info(\"Flow check failed - will fail-open\")\n\n    # See whether flow was accepted by Aperture Agent.\n    if flow.should_run():\n        # do actual work\n        pass\n    else:\n        # handle flow rejection by Aperture Agent\n        flow.set_status(FlowStatus.Error)\n    flow.end()\n    # Simulate work being done\n    await asyncio.sleep(2)\n    return \"\", 202"
  },
  "ts": {
    "clientConstructor": "import { ApertureClient } from \"@fluxninja/aperture-js\";\n\n// Create aperture client\nexport const apertureClient = new ApertureClient({\n  address: \"ORGANIZATION.app.fluxninja.com:443\",\n  apiKey: \"API_KEY\",\n});",
    "handleRequest": "import { FlowStatus, LookupStatus } from \"@fluxninja/aperture-js\";\nimport { Request, Response } from \"express\";\n\nasync function handleRequest(req: Request, res: Response) {\n  const flow = await apertureClient.startFlow(\"archimedes-service\", {\n    labels: {\n      user: \"user1\",\n      tier: \"premium\",\n    },\n    grpcCallOptions: {\n      deadline: Date.now() + 300, // 300ms deadline\n    },\n    resultCacheKey: \"cache\", // optional, in case caching is needed\n  });\n\n  if (flow.shouldRun()) {\n    // Check if the response is cached in Aperture from a previous request\n    if (flow.resultCache().getLookupStatus() === LookupStatus.Hit) {\n      res.send({ message: flow.resultCache().getValue()?.toString() });\n    } else {\n      // Do Actual Work\n      // After completing the work, you can return store the response in cache and return it, for example:\n      const resString = \"foo\";\n\n      // create a new buffer\n      const buffer = Buffer.from(resString);\n\n      // set cache value\n      const setResp = await flow.setResultCache({\n        value: buffer,\n        ttl: {\n          seconds: 30,\n          nanos: 0,\n        },\n      });\n      if (setResp.getError()) {\n        console.log(`Error setting cache value: ${setResp.getError()}`);\n      }\n\n\n      res.send({ message: resString });\n    }\n  } else {\n    // Aperture has rejected the request due to a rate limiting policy\n    res.status(429).send({ message: \"Too many requests\" });\n    // Handle flow rejection\n    flow.setStatus(FlowStatus.Error);\n  }\n\n  flow.end();\n}",
    "setResultCache": "// set cache value\n      const setResp = await flow.setResultCache({\n        value: buffer,\n        ttl: {\n          seconds: 30,\n          nanos: 0,\n        },\n      });\n      if (setResp.getError()) {\n        console.log(`Error setting cache value: ${setResp.getError()}`);\n      }"
  }
}
