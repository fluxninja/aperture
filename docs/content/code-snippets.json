{
  "cs": {
    "handleRequest": "var labels = new Dictionary\u003cstring, string\u003e();\n            labels.Add(\"key\", \"value\");\n            var pms = new FeatureFlowParams(\n                featureName,\n                labels,\n                false,\n                TimeSpan.FromSeconds(5));\n            var flow = sdk.StartFlow(pms);\n            if (flow.ShouldRun())\n            {\n                Thread.Sleep(2000);\n                SimpleHandlePath((int)HttpStatusCode.OK, \"Hello world!\", response);\n            }\n            else\n            {\n                SimpleHandlePath(flow.GetRejectionHttpStatusCode(), \"REJECTED!\", response);\n            }\n\n            flow.End();"
  },
  "go": {
    "clientConstructor": "agentAddress := \"ORGANIZATION.app.fluxninja.com:443\"\n\tapiKey := \"API_KEY\"\n\n\topts := aperture.Options{\n\t\tAddress:     agentAddress,\n\t\tDialOptions: grpcOptions(apertureAgentInsecureBool, apertureAgentSkipVerifyBool),\n\t\tAPIKey:      apiKey,\n\t}\n\n\t// initialize Aperture Client with the provided options.\n\tapertureClient, err := aperture.NewClient(ctx, opts)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to create client: %v\", err)\n\t}",
    "grpcOptions": "// grpcOptions creates a new gRPC client that will be passed in order to initialize the Aperture client.\nfunc grpcOptions(insecureMode, skipVerify bool) []grpc.DialOption {\n\tvar grpcDialOptions []grpc.DialOption\n\tgrpcDialOptions = append(grpcDialOptions, grpc.WithConnectParams(grpc.ConnectParams{\n\t\tBackoff:           backoff.DefaultConfig,\n\t\tMinConnectTimeout: time.Second * 10,\n\t}))\n\tgrpcDialOptions = append(grpcDialOptions, grpc.WithUserAgent(\"aperture-go\"))\n\tif insecureMode {\n\t\tgrpcDialOptions = append(grpcDialOptions, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\t} else if skipVerify {\n\t\tgrpcDialOptions = append(grpcDialOptions, grpc.WithTransportCredentials(credentials.NewTLS(\u0026tls.Config{\n\t\t\tInsecureSkipVerify: true, //nolint:gosec // For testing purposes only\n\t\t})))\n\t} else {\n\t\tcertPool, err := x509.SystemCertPool()\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tgrpcDialOptions = append(grpcDialOptions, grpc.WithTransportCredentials(credentials.NewClientTLSFromCert(certPool, \"\")))\n\t}\n\treturn grpcDialOptions\n}"
  },
  "java": {
    "ArmeriaCreateApertureSDK": "ApertureSDK apertureSDK;\n        try {\n            apertureSDK = ApertureSDK.builder()\n                    .setAddress(\"ORGANIZATION.app.fluxninja.com:443\")\n                    .setAPIKey(\"API_KEY\")\n                    .addIgnoredPaths(\"/health,/connected\")\n                    .useInsecureGrpc(insecureGrpc) // Optional: Defaults to true\n                    .setRootCertificateFile(rootCertFile)\n                    .build();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }",
    "ArmeriaCreateHTTPService": "public static HttpService createHelloHTTPService() {\n        return new AbstractHttpService() {\n            @Override\n            protected HttpResponse doGet(ServiceRequestContext ctx, HttpRequest req) {\n                return HttpResponse.of(\"Hello, world!\");\n            }\n        };\n    }",
    "ArmeriadecorateService": "ApertureHTTPService decoratedService = createHelloHTTPService()\n                .decorate(\n                        ApertureHTTPService.newDecorator(\n                                apertureSDK,\n                                controlPointName,\n                                rampMode,\n                                Duration.ofMillis(1000)));\n        serverBuilder.service(\"/super\", decoratedService);",
    "NettyCreateSDK": "try {\n            sdk =\n                    ApertureSDK.builder()\n                            .setAddress(this.agentAddress)\n                            .setAPIKey(this.agentAPIKey)\n                            .useInsecureGrpc(insecureGrpc)\n                            .setRootCertificateFile(rootCertFile)\n                            .build();\n        } catch (IOException ex) {\n            throw new RuntimeException(ex);\n        }",
    "NettyImports": "import com.fluxninja.aperture.netty.ApertureServerHandler;",
    "NettyInitChannel": "@Override\n    protected void initChannel(Channel ch) {\n\n        try {\n            sdk =\n                    ApertureSDK.builder()\n                            .setAddress(this.agentAddress)\n                            .setAPIKey(this.agentAPIKey)\n                            .useInsecureGrpc(insecureGrpc)\n                            .setRootCertificateFile(rootCertFile)\n                            .build();\n        } catch (IOException ex) {\n            throw new RuntimeException(ex);\n        }\n\n\n        ChannelPipeline pipeline = ch.pipeline();\n        pipeline.addLast(new HttpServerCodec());\n        pipeline.addLast(new HttpObjectAggregator(Integer.MAX_VALUE));\n        // ApertureServerHandler must be added before the response-generating\n        // HelloWorldHandler,\n        // but after the codec handler.\n        pipeline.addLast(new ApertureServerHandler(sdk, controlPointName, rampMode, flowTimeout));\n        pipeline.addLast(new HelloWorldHandler());\n    }",
    "NettyServerInitializer": "public class ServerInitializer extends ChannelInitializer\u003cChannel\u003e {"
  },
  "py": {
    "apertureDecorator": "flow_params = FlowParams(\n    check_timeout=timedelta(seconds=200),\n)\n\n\n@app.get(\"/super\")\n@aperture_client.decorate(\n    \"awesomeFeature\", params=flow_params, on_reject=lambda: (\"Flow was rejected\", 503)\n)\nasync def super_handler():\n    # Simulate work being done\n    await asyncio.sleep(2)\n    return \"\", 202",
    "cacheFlow": "# business logic produces labels\n    labels = {\n        \"key\": \"some-value\",\n    }\n    flow_params = FlowParams(\n        check_timeout=timedelta(seconds=200),\n        explicit_labels=labels,\n        global_cache_keys=[\"cache-key\"],\n        result_cache_key=\"result-key\",\n    )\n    # start_flow performs a flowcontrol.v1.Check call to Aperture Agent.\n    # It returns a Flow or raises an error if any.\n    flow = aperture_client.start_flow(\n        control_point=\"super3\",\n        params=flow_params,\n    )\n    result_string = None\n    cache_value = None\n\n    # Check if flow check was successful.\n    if not flow.success:\n        logger.info(\"Flow check failed - will fail-open\")\n\n    # See whether flow was accepted by Aperture Agent.\n    if flow.should_run():\n        logging.info(\"Flow accepted\")\n\n        # 1. Check if the response is cached in Aperture from a previous request\n\n        if flow.result_cache().get_lookup_status() == LookupStatus.MISS:\n            logging.info(\"Result Cache Miss, setting result cache\")\n            # Do Actual Work\n            # After completing the work, you can return store the response in cache and return it, for example:\n            result_string = \"foo\"\n            # save to result cache for 10 seconds\n            flow.set_result_cache(result_string, timedelta(seconds=10))\n        else:\n            result_string = flow.result_cache().get_value()\n            logging.info(\"Result Cache Hit: {}\".format(result_string))\n\n        # 2. Check if the cache for a 'cache-key' is present\n        if flow.global_cache(\"cache-key\").get_lookup_status() == LookupStatus.MISS:\n            logging.info(\n                \"Cache Miss, setting global cache for key: '{}'\".format(\"cache-key\")\n            )\n            # save to global cache for key for 10 seconds\n            flow.set_global_cache(\"cache-key\", \"awesome-value\", timedelta(seconds=10))\n            cache_value = \"awesome-value\"\n        else:\n            logging.info(\"Cache Hit\")\n            # get value from global cache for 'cache-key'\n            logging.info(\n                \"Cache Value: {}\".format(flow.global_cache(\"cache-key\").get_value())\n            )\n            cache_value = flow.global_cache(\"cache-key\").get_value()\n    else:\n        # handle flow rejection by Aperture Agent\n        flow.set_status(FlowStatus.Error)\n\n    if flow:\n        flow.end()",
    "clientConstructor": "from aperture_sdk import ApertureClient, FlowParams\n\nagent_address = os.getenv(\"APERTURE_AGENT_ADDRESS\", default_agent_address)\napi_key = os.getenv(\"APERTURE_API_KEY\", \"\")\ninsecure = os.getenv(\"APERTURE_AGENT_INSECURE\", \"true\").lower() == \"true\"\n\naperture_client = ApertureClient.new_client(\n    address=agent_address, insecure=insecure, api_key=api_key\n)",
    "contextManagerFlow": "flow_params = FlowParams(\n        explicit_labels=labels,\n        check_timeout=timedelta(seconds=200),\n    )\n\n    with aperture_client.start_flow(\n        control_point=\"AwesomeFeature\",\n        params=flow_params,\n    ) as flow:\n        if flow.should_run():\n            # do actual work\n            # if you do not call flow.end() explicitly, it will be called automatically\n            # when the context manager exits - with the status of the flow\n            # depending on whether an error was raised or not\n            pass",
    "manualFlow": "# business logic produces labels\n    labels = {\n        \"key\": \"value\",\n    }\n    flow_params = FlowParams(\n        check_timeout=timedelta(seconds=200),\n        explicit_labels=labels,\n    )\n    # start_flow performs a flowcontrol.v1.Check call to Aperture Agent.\n    # It returns a Flow or raises an error if any.\n    flow = aperture_client.start_flow(\n        control_point=\"AwesomeFeature\",\n        params=flow_params,\n    )\n\n    # Check if flow check was successful.\n    if not flow.success:\n        logger.info(\"Flow check failed - will fail-open\")\n\n    # See whether flow was accepted by Aperture Agent.\n    if flow.should_run():\n        # do actual work\n        pass\n    else:\n        # handle flow rejection by Aperture Agent\n        flow.set_status(FlowStatus.Error)\n    flow.end()\n    # Simulate work being done\n    await asyncio.sleep(2)\n    return \"\", 202"
  },
  "ts": {
    "clientConstructor": "import { ApertureClient } from \"@fluxninja/aperture-js\";\n\n// Create aperture client\nexport const apertureClient = new ApertureClient({\n  address: \"ORGANIZATION.app.fluxninja.com:443\",\n  apiKey: \"API_KEY\",\n});",
    "handleRequestRateLimit": "async function handleRequestRateLimit(req: Request, res: Response) {\n  const flow = await apertureClient.startFlow(\"awesomeFeature\", {\n    labels: {\n      user_id: \"some_user_id\",\n    },\n    grpcCallOptions: {\n      deadline: Date.now() + 300, // ms\n    },\n  });\n\n  if (flow.ShouldRun()) {\n    // Add business logic to process incoming request\n    console.log(\"Request accepted. Processing...\");\n  } else {\n    console.log(\"Request rate-limited. Try again later.\");\n    // Handle flow rejection\n    flow.SetStatus(FlowStatus.Error);\n  }\n\n  if (flow) {\n    flow.End();\n  }\n}",
    "handleRequestWithCache": "import { FlowStatus, LookupStatus } from \"@fluxninja/aperture-js\";\nimport { Request, Response } from \"express\";\n\nasync function handleRequest(req: Request, res: Response) {\n  const flow = await apertureClient.startFlow(\"archimedes-service\", {\n    labels: {\n      user: \"user1\",\n      tier: \"premium\",\n    },\n    grpcCallOptions: {\n      deadline: Date.now() + 300, // 300ms deadline\n    },\n    resultCacheKey: \"cache\", // optional, in case caching is needed\n  });\n\n  if (flow.shouldRun()) {\n    // Check if the response is cached in Aperture from a previous request\n    if (flow.resultCache().getLookupStatus() === LookupStatus.Hit) {\n      res.send({ message: flow.resultCache().getValue()?.toString() });\n    } else {\n      // Do Actual Work\n      // After completing the work, you can return store the response in cache and return it, for example:\n      const resString = \"foo\";\n\n      // create a new buffer\n      const buffer = Buffer.from(resString);\n\n      // set cache value\n      const setResp = await flow.setResultCache({\n        value: buffer,\n        ttl: {\n          seconds: 30,\n          nanos: 0,\n        },\n      });\n      if (setResp.getError()) {\n        console.log(`Error setting cache value: ${setResp.getError()}`);\n      }\n\n\n      res.send({ message: resString });\n    }\n  } else {\n    // Aperture has rejected the request due to a rate limiting policy\n    res.status(429).send({ message: \"Too many requests\" });\n    // Handle flow rejection\n    flow.setStatus(FlowStatus.Error);\n  }\n\n  flow.end();\n}",
    "setResultCache": "// set cache value\n      const setResp = await flow.setResultCache({\n        value: buffer,\n        ttl: {\n          seconds: 30,\n          nanos: 0,\n        },\n      });\n      if (setResp.getError()) {\n        console.log(`Error setting cache value: ${setResp.getError()}`);\n      }"
  }
}
