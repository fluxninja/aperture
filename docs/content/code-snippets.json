{
  "cs": {
    "handleRequest": "// do some business logic to collect labels\n            var labels = new Dictionary\u003cstring, string\u003e();\n            labels.Add(\"userId\", \"some_user_id\");\n            labels.Add(\"userTier\", \"gold\");\n            labels.Add(\"priority\", \"100\");\n\n            var rampMode = false;\n            var flowTimeout = TimeSpan.FromSeconds(5);\n            var pms = new FeatureFlowParams(\n                \"featureName\",\n                labels,\n                rampMode,\n                flowTimeout,\n                new Grpc.Core.CallOptions(),\n                \"test\",\n                new RepeatedField\u003cstring\u003e { \"test\" });\n            var flow = sdk.StartFlow(pms);\n            if (flow.ShouldRun())\n            {\n                // do actual work\n                Thread.Sleep(2000);\n                SimpleHandlePath((int)HttpStatusCode.OK, \"Hello world!\", response);\n            }\n            else\n            {\n                // handle flow rejection by Aperture Agent\n                flow.SetStatus(FlowStatus.Error);\n                SimpleHandlePath(flow.GetRejectionHttpStatusCode(), \"REJECTED!\", response);\n            }\n\n            var endResponse = flow.End();\n            if (endResponse.Error != null)\n            {\n                // handle end failure\n                log.Error(\"Failed to end flow: {e}\", endResponse.Error);\n            }\n            else if (endResponse.FlowEndResponse != null)\n            {\n                // handle end success\n                log.Info(\"Ended flow with response: \" + endResponse.FlowEndResponse.ToString());\n            }"
  },
  "go": {
    "clientConstructor": "opts := aperture.Options{\n\t\tAddress:     \"ORGANIZATION.app.fluxninja.com:443\",\n\t\tDialOptions: grpcOptions(apertureAgentInsecureBool, apertureAgentSkipVerifyBool),\n\t\tAPIKey:      getEnvOrDefault(\"APERTURE_API_KEY\", \"\"),\n\t}\n\n\t// initialize Aperture Client with the provided options.\n\tapertureClient, err := aperture.NewClient(ctx, opts)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to create client: %v\", err)\n\t}",
    "defineFlowParams": "flowParams := aperture.FlowParams{\n\t\tLabels:   labels,\n\t\tRampMode: false,\n\t}",
    "defineLabels": "// business logic produces labels\n\tlabels := map[string]string{\n\t\t\"userId\":   \"some_user_id\",\n\t\t\"userTier\": \"premium\",\n\t\t\"priority\": \"100\",\n\t}",
    "grpcOptions": "// grpcOptions creates a new gRPC client that will be passed in order to initialize the Aperture client.\nfunc grpcOptions(insecureMode, skipVerify bool) []grpc.DialOption {\n\tvar grpcDialOptions []grpc.DialOption\n\tgrpcDialOptions = append(grpcDialOptions, grpc.WithConnectParams(grpc.ConnectParams{\n\t\tBackoff:           backoff.DefaultConfig,\n\t\tMinConnectTimeout: time.Second * 10,\n\t}))\n\tgrpcDialOptions = append(grpcDialOptions, grpc.WithUserAgent(\"aperture-go\"))\n\tif insecureMode {\n\t\tgrpcDialOptions = append(grpcDialOptions, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\t} else if skipVerify {\n\t\tgrpcDialOptions = append(grpcDialOptions, grpc.WithTransportCredentials(credentials.NewTLS(\u0026tls.Config{\n\t\t\tInsecureSkipVerify: true, //nolint:gosec // For testing purposes only\n\t\t})))\n\t} else {\n\t\tcertPool, err := x509.SystemCertPool()\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tgrpcDialOptions = append(grpcDialOptions, grpc.WithTransportCredentials(credentials.NewClientTLSFromCert(certPool, \"\")))\n\t}\n\treturn grpcDialOptions\n}",
    "manualFlowNoCaching": "// business logic produces labels\n\tlabels := map[string]string{\n\t\t\"userId\":   \"some_user_id\",\n\t\t\"userTier\": \"premium\",\n\t\t\"priority\": \"100\",\n\t}\n\n\n\tflowParams := aperture.FlowParams{\n\t\tLabels:   labels,\n\t\tRampMode: false,\n\t}\n\n\n\tflow := a.apertureClient.StartFlow(r.Context(), \"featureName\", flowParams)\n\t// StartFlow performs a flowcontrolv1.Check call to Aperture Agent. It returns a Flow object.\n\n\n\t// See whether flow was accepted by Aperture Agent.\n\tif flow.ShouldRun() {\n\n\t\t// do actual work\n\n\t\tlog.Println(\"Flow Accepted Processing work\")\n\t\tw.WriteHeader(http.StatusAccepted)\n\t\tw.Write([]byte(\"Super!\"))\n\n\t} else {\n\n\t\t// handle flow rejection by Aperture Agent\n\t\tlog.Println(\"Flow Rejected\")\n\t\tflow.SetStatus(aperture.Error)\n\t\tw.WriteHeader(http.StatusForbidden)\n\t}\n\n\tendResponse:= flow.End()\n\tif endResponse.Error != nil {\n\t\tlog.Printf(\"Failed to end flow: %+v\", endResponse.Error)\n\t}\n\n\tlog.Printf(\"Flow ended with response: %+v\", endResponse.FlowEndResponse)",
    "middleware": "middlewareParams := aperture.MiddlewareParams{\n\t\tTimeout:              2000 * time.Millisecond,\n\t\tIgnoredPathsCompiled: []*regexp.Regexp{regexp.MustCompile(\"/health.*\")},\n\t\tIgnoredPaths:         []string{\"/connected\"},\n\t}\n\n\tmiddleware, err := middleware.NewHTTPMiddleware(apertureClient, \"awesomeFeature\", middlewareParams)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to create HTTP middleware: %v\", err)\n\t}\n\tsuperRouter.Use(middleware.Handle)",
    "startFlow": "flow := a.apertureClient.StartFlow(r.Context(), \"featureName\", flowParams)\n\t// StartFlow performs a flowcontrolv1.Check call to Aperture Agent. It returns a Flow object."
  },
  "java": {
    "ArmeriaCreateApertureSDK": "ApertureSDK apertureSDK;\n        try {\n            apertureSDK =\n                    ApertureSDK.builder()\n                            .setAddress(agentHost)\n                            .setAPIKey(apiKey)\n                            .addIgnoredPaths(\"/health,/connected\")\n                            .useInsecureGrpc(insecureGrpc) // Optional: Defaults to true\n                            .setRootCertificateFile(rootCertFile)\n                            .build();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }",
    "ArmeriaCreateHTTPService": "public static HttpService createHelloHTTPService() {\n        return new AbstractHttpService() {\n            @Override\n            protected HttpResponse doGet(ServiceRequestContext ctx, HttpRequest req) {\n                return HttpResponse.of(\"Hello, world!\");\n            }\n        };\n    }",
    "ArmeriadecorateService": "ApertureHTTPService decoratedService =\n                createHelloHTTPService()\n                        .decorate(\n                                ApertureHTTPService.newDecorator(\n                                        apertureSDK,\n                                        controlPointName,\n                                        rampMode,\n                                        Duration.ofMillis(1000)));\n        serverBuilder.service(\"/super\", decoratedService);",
    "NettyCreateSDK": "try {\n            sdk =\n                    ApertureSDK.builder()\n                            .setAddress(this.agentAddress)\n                            .setAPIKey(this.agentAPIKey)\n                            .useInsecureGrpc(insecureGrpc) // Optional: Defaults to true\n                            .setRootCertificateFile(rootCertFile)\n                            .addIgnoredPaths(\"/health,/connected\")\n                            .build();\n        } catch (IOException ex) {\n            throw new RuntimeException(ex);\n        }",
    "NettyInitChannel": "@Override\n    protected void initChannel(Channel ch) {\n\n        try {\n            sdk =\n                    ApertureSDK.builder()\n                            .setAddress(this.agentAddress)\n                            .setAPIKey(this.agentAPIKey)\n                            .useInsecureGrpc(insecureGrpc) // Optional: Defaults to true\n                            .setRootCertificateFile(rootCertFile)\n                            .addIgnoredPaths(\"/health,/connected\")\n                            .build();\n        } catch (IOException ex) {\n            throw new RuntimeException(ex);\n        }\n\n\n        ChannelPipeline pipeline = ch.pipeline();\n        pipeline.addLast(new HttpServerCodec());\n        pipeline.addLast(new HttpObjectAggregator(Integer.MAX_VALUE));\n        // ApertureServerHandler must be added before the response-generating\n        // HelloWorldHandler,\n        // but after the codec handler.\n        pipeline.addLast(new ApertureServerHandler(sdk, controlPointName, rampMode, flowTimeout));\n        pipeline.addLast(new HelloWorldHandler());\n    }",
    "StandaloneExampleFlow": "Map\u003cString, String\u003e labels = new HashMap\u003c\u003e();\n\n        // business logic produces labels\n        labels.put(\"userId\", \"some_user_id\");\n        labels.put(\"userTier\", \"gold\");\n        labels.put(\"priority\", \"100\");\n\n        Boolean rampMode = false;\n\n        FeatureFlowParameters params =\n                FeatureFlowParameters.newBuilder(\"featureName\")\n                        .setExplicitLabels(labels)\n                        .setRampMode(rampMode)\n                        .setFlowTimeout(Duration.ofMillis(1000))\n                        .build();\n        // StartFlow performs a flowcontrolv1.Check call to Aperture. It returns a Flow.\n        Flow flow = this.apertureSDK.startFlow(params);\n\n        // See whether flow was accepted by Aperture.\n        try {\n            if (flow.shouldRun()) {\n                // do actual work\n                res.status(202);\n            } else {\n                // handle flow rejection by Aperture\n                res.status(flow.getRejectionHttpStatusCode());\n            }\n        } catch (Exception e) {\n            // Flow Status captures whether the feature captured by the Flow was\n            // successful or resulted in an error. When not explicitly set,\n            // the default value is FlowStatus.OK .\n            flow.setStatus(FlowStatus.Error);\n            logger.error(\"Error in flow execution\", e);\n        } finally {\n            EndResponse endResponse = flow.end();\n            if (endResponse.getError() != null) {\n                logger.error(\"Error ending flow\", endResponse.getError());\n            }\n\n            logger.info(\"Flow End response: {}\", endResponse.getFlowEndResponse());\n        }",
    "StandaloneExampleSDKInit": "ApertureSDK apertureSDK;\n        try {\n            apertureSDK =\n                    ApertureSDK.builder()\n                            .setAddress(agentAddress)\n                            .setAPIKey(apiKey)\n                            .useInsecureGrpc(insecureGrpc)\n                            .setRootCertificateFile(rootCertFile)\n                            .build();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }"
  },
  "py": {
    "apertureDecorator": "flow_params = FlowParams(\n    check_timeout=timedelta(seconds=200),\n)\n\n\n@app.get(\"/super\")\n@aperture_client.decorate(\n    \"awesomeFeature\", params=flow_params, on_reject=lambda: (\"Flow was rejected\", 503)\n)\nasync def super_handler():\n    # Simulate work being done\n    await asyncio.sleep(2)\n    return \"\", 202",
    "cacheFlow": "# business logic produces labels\n    labels = {\n        \"key\": \"some-value\",\n    }\n    flow_params = FlowParams(\n        check_timeout=timedelta(seconds=200),\n        explicit_labels=labels,\n        global_cache_keys=[\"cache-key\"],\n        result_cache_key=\"result-key\",\n    )\n    # start_flow performs a flowcontrol.v1.Check call to Aperture Agent.\n    # It returns a Flow or raises an error if any.\n    flow = aperture_client.start_flow(\n        control_point=\"super3\",\n        params=flow_params,\n    )\n    result_string = None\n    cache_value = None\n\n    # Check if flow check was successful.\n    if not flow.success:\n        logger.info(\"Flow check failed - will fail-open\")\n\n    # See whether flow was accepted by Aperture Agent.\n    if flow.should_run():\n        logging.info(\"Flow accepted\")\n\n        # 1. Check if the response is cached in Aperture from a previous request\n\n        if flow.result_cache().get_lookup_status() == LookupStatus.MISS:\n            logging.info(\"Result Cache Miss, setting result cache\")\n            # Do Actual Work\n            # After completing the work, you can return store the response in cache and return it, for example:\n            result_string = \"foo\"\n            # save to result cache for 10 seconds\n            flow.set_result_cache(result_string, timedelta(seconds=10))\n        else:\n            result_string = flow.result_cache().get_value()\n            logging.info(\"Result Cache Hit: {}\".format(result_string))\n\n        # 2. Check if the cache for a 'cache-key' is present\n        if flow.global_cache(\"cache-key\").get_lookup_status() == LookupStatus.MISS:\n            logging.info(\n                \"Cache Miss, setting global cache for key: '{}'\".format(\"cache-key\")\n            )\n            # save to global cache for key for 10 seconds\n            flow.set_global_cache(\"cache-key\", \"awesome-value\", timedelta(seconds=10))\n            cache_value = \"awesome-value\"\n        else:\n            logging.info(\"Cache Hit\")\n            # get value from global cache for 'cache-key'\n            logging.info(\n                \"Cache Value: {}\".format(flow.global_cache(\"cache-key\").get_value())\n            )\n            cache_value = flow.global_cache(\"cache-key\").get_value()\n    else:\n        # handle flow rejection by Aperture Agent\n        flow.set_status(FlowStatus.Error)\n\n    if flow:\n        flow.end()",
    "clientConstructor": "from aperture_sdk.client import ApertureClient, FlowParams\n\nagent_address = os.getenv(\"APERTURE_AGENT_ADDRESS\", default_agent_address)\napi_key = os.getenv(\"APERTURE_API_KEY\", \"\")\ninsecure = os.getenv(\"APERTURE_AGENT_INSECURE\", \"true\").lower() == \"true\"\n\naperture_client = ApertureClient.new_client(\n    address=agent_address, insecure=insecure, api_key=api_key\n)",
    "contextManagerFlow": "flow_params = FlowParams(\n        explicit_labels=labels,\n        check_timeout=timedelta(seconds=200),\n    )\n\n    with aperture_client.start_flow(\n        control_point=\"AwesomeFeature\",\n        params=flow_params,\n    ) as flow:\n        if flow.should_run():\n            # do actual work\n            # if you do not call flow.end() explicitly, it will be called automatically\n            # when the context manager exits - with the status of the flow\n            # depending on whether an error was raised or not\n            pass",
    "manualFlow": "# business logic produces labels\n    labels = {\n        \"userId\": \"some_user_id\",\n        \"userTier\": \"gold\",\n        \"priority\": \"100\",\n    }\n    flow_params = FlowParams(\n        check_timeout=timedelta(seconds=200),\n        explicit_labels=labels,\n    )\n    # start_flow performs a flowcontrol.v1.Check call to Aperture Agent.\n    # It returns a Flow or raises an error if any.\n    flow = aperture_client.start_flow(\n        control_point=\"AwesomeFeature\",\n        params=flow_params,\n    )\n\n    # Check if flow check was successful.\n    if not flow.success:\n        logger.info(\"Flow check failed - will fail-open\")\n\n    # See whether flow was accepted by Aperture Agent.\n    if flow.should_run():\n        # do actual work\n        pass\n    else:\n        # handle flow rejection by Aperture Agent\n        flow.set_status(FlowStatus.Error)\n    res = flow.end()\n    if res.get_error():\n        logger.error(\"Error: {}\".format(res.get_error()))\n    elif res.get_flow_end_response():\n        logger.info(\"Flow End Response: {}\".format(res.get_flow_end_response()))\n\n    # Simulate work being done\n    await asyncio.sleep(2)\n    return \"\", 202"
  },
  "ts": {
    "CLFlowShouldRun": "if (flow.shouldRun()) {\n    console.log(\"Request accepted. Processing...\" + flow.checkResponse());\n  } else {\n    console.log(\"Request rejected due to concurrency limit. Try again later.\");\n  }\n\n  flow.end();",
    "CLStartFlow": "const flow = await apertureClient.startFlow(\"concurrency-limiting-feature\", {\n    labels: {\n      user_id: \"some_user_id\",\n    },\n    grpcCallOptions: {\n      deadline: Date.now() + 300,\n    },\n  });",
    "CStartFlow": "flow = await apertureClient.startFlow(\"caching-example\", {\n            labels: {\n                user_id: \"some_user_id\",\n            },\n            grpcCallOptions: {\n                deadline: Date.now() + 5000, // ms\n            },\n            resultCacheKey: \"cache\",\n        });",
    "CacheLookup": "if (flow.resultCache().getLookupStatus() === LookupStatus.Hit) {\n            console.log(flow.resultCache().getValue()?.toString());\n        } else {\n            console.log(\"Cache miss, setting cache value\");\n\n            const resString = \"Hello, world!\";\n            const buffer = Buffer.from(resString);\n            const setResp = await flow.setResultCache({\n                value: buffer,\n                ttl: {\n                    seconds: 10,\n                    nanos: 0,\n                },\n            });\n        }\n\n        flow.end();",
    "Priority": "const userTiers = {\n    \"platinum\": 8,\n    \"gold\": 4,\n    \"silver\": 2,\n    \"free\": 1,\n};",
    "QSPriority": "const userPriority = userTiers[tier] || 1;\n\n    const flow = await apertureClient.startFlow(\"quota-scheduling-feature\", {\n        labels: {\n            user_id: \"some_user_id\",\n            priority: userPriority.toString(),\n            workload: `${tier} user`,\n        },\n        grpcCallOptions: {\n            deadline: Date.now() + 120000, // ms\n        },\n    });\n    console.log(`Request sent for ${tier} tier with priority ${userPriority}.`);\n    flow.end();",
    "QSStartFlow": "const flow = await apertureClient.startFlow(\"quota-scheduling-feature\", {\n        labels: {\n            user_id: \"some_user_id\",\n            priority: priority.toString(),\n            workload: `${tier} user`,\n        },\n        grpcCallOptions: {\n            deadline: Date.now() + 120000, // ms\n        },\n    });\n    console.log(`Request sent for ${tier} tier with priority ${priority}.`);\n    flow.end();",
    "QSUI": "const flow = await apertureClient.startFlow(\"quota-scheduling-feature\", {\n        labels: {\n            user_id: \"some_user_id\",\n            priority: \"100\",\n            workload: \"gold user\",\n        },\n        grpcCallOptions: {\n            deadline: Date.now() + 120000, // ms\n        },\n    });\n    console.log(`Request sent for ${tier} tier with priority ${priority}.`);\n    flow.end();",
    "RLFlowShouldRun": "if (flow.shouldRun()) {\n            console.log(\"Request accepted. Processing...\");\n        } else {\n            console.log(\"Request rate-limited. Try again later.\");\n        }\n\n        flow.end();",
    "RLStartFlow": "const flow = await apertureClient.startFlow(\"rate-limiting-feature\", {\n            labels: {\n                user_id: \"some_user_id\",\n            },\n            grpcCallOptions: {\n                deadline: Date.now() + 300, // ms\n            },\n        });",
    "UIQSTokens": "let userTokens;\n    switch (userType) {\n    case \"premium\":\n        userTokens = 100;\n        break;\n    case \"gold\":\n        userTokens = 50;\n        break;\n    default:\n        userTokens = 0;\n    }\n    const flow = await apertureClient.startFlow(\"quota-scheduling-feature\", {\n        labels: {\n            user_id: \"some_user_id\",\n            product_tier: \"trial\",\n            priority: \"100\",\n            tokens: userTokens.toString(),\n        },\n        grpcCallOptions: {\n            deadline: Date.now() + 120000, // ms\n        },\n    });",
    "UIQSWorkload": "let userWorkload = \"subscriber\";\n    const flow = await apertureClient.startFlow(\"quota-scheduling-feature\", {\n        labels: {\n            user_id: \"some_user_id\",\n            product_tier: \"trial\",\n            priority: priority.toString(),\n            workload: userWorkload,\n        },\n        grpcCallOptions: {\n            deadline: Date.now() + 120000, // ms\n        },\n    });",
    "UIRLLabelMatcher": "const flow = await apertureClient.startFlow(\"rate-limiting-feature\", {\n        labels: {\n            user_id: \"user1\",\n            customer_tier: \"gold\",\n            product_tier: \"trial\",\n          },\n        grpcCallOptions: {\n            deadline: Date.now() + 300, // ms\n        },\n    });",
    "UIRLTokens": "const flow = await apertureClient.startFlow(\"rate-limiting-feature\", {\n        labels: {\n          user_id: \"user1\",\n          tier: \"premium\",\n          tokens: \"50\",\n\n        },\n        grpcCallOptions: {\n          deadline: Date.now() + 300, // 300ms deadline\n        },\n      });",
    "clientConstructor": "import { ApertureClient } from \"@fluxninja/aperture-js\";\n\n// Create aperture client\nexport const apertureClient = new ApertureClient({\n  address: \"ORGANIZATION.app.fluxninja.com:443\",\n  apiKey: \"API_KEY\",\n});",
    "handleConcurrencyLimit": "async function sendRequest(apertureClient: ApertureClient) {\n  const flow = await apertureClient.startFlow(\"concurrency-limiting-feature\", {\n    labels: {\n      user_id: \"some_user_id\",\n    },\n    grpcCallOptions: {\n      deadline: Date.now() + 300,\n    },\n  });\n\n  if (flow.shouldRun()) {\n    console.log(\"Request accepted. Processing...\" + flow.checkResponse());\n  } else {\n    console.log(\"Request rejected due to concurrency limit. Try again later.\");\n  }\n\n  flow.end();\n}\n\nasync function handleConcurrencyLimit(apertureClient: ApertureClient) {\n  const requestsPerSecond = 10;\n  const durationInSeconds = 200;\n\n  for (let i = 0; i \u003c durationInSeconds; i++) {\n    const requests = Array.from({ length: requestsPerSecond }, () =\u003e\n      sendRequest(apertureClient),\n    );\n    // sending requests in parallel to simulate concurrency\n    await Promise.all(requests);\n\n    // Wait 1 second before sending the next batch of requests\n    await new Promise((resolve) =\u003e setTimeout(resolve, 1000));\n  }\n}",
    "handleConcurrencyScheduler": "// Define user tiers and associated priorities\nconst userTiers = {\n  platinum: 8,\n  gold: 4,\n  silver: 2,\n  free: 1,\n};\n\nasync function sendRequestForTier(\n  apertureClient: ApertureClient,\n  tier: string,\n  priority: number,\n) {\n  console.log(`[${tier} Tier] Sending request with priority ${priority}...`);\n  const flow = await apertureClient.startFlow(\n    \"concurrency-scheduling-feature\",\n    {\n      labels: {\n        user_id: \"some_user_id\",\n        priority: priority.toString(),\n        tier: tier,\n      },\n      grpcCallOptions: {\n        deadline: Date.now() + 120000, // ms\n      },\n    },\n  );\n\n  if (flow.shouldRun()) {\n    console.log(`[${tier} Tier] Request accepted with priority ${priority}.`);\n    // sleep for 5 seconds to simulate a long-running request\n    await new Promise((resolve) =\u003e setTimeout(resolve, 5000));\n  } else {\n    console.log(`[${tier} Tier] Request rejected. Priority was ${priority}.`);\n  }\n\n  await flow.end();\n}\n\n// Launch each batch in parallel\nasync function handleConcurrencyScheduler(apertureClient: ApertureClient) {\n  const requestsPerBatch = 10;\n  const batchInterval = 1000; // ms\n\n  while (true) {\n    console.log(\"Sending new batch of requests...\");\n    // Send requests for each tier\n    const promises = Object.entries(userTiers).flatMap(([tier, priority]) =\u003e {\n      return Array(requestsPerBatch)\n        .fill(null)\n        .map(() =\u003e sendRequestForTier(apertureClient, tier, priority));\n    });\n\n    await Promise.all(promises);\n    await new Promise((resolve) =\u003e setTimeout(resolve, batchInterval));\n  }\n}",
    "handleRequestRateLimit": "async function handleRequestRateLimit(req: Request, res: Response) {\n  const flow = await apertureClient.startFlow(\"awesomeFeature\", {\n    labels: {\n      user_id: \"some_user_id\",\n    },\n    grpcCallOptions: {\n      deadline: Date.now() + 300, // ms\n    },\n  });\n\n  if (flow.shouldRun()) {\n    // Add business logic to process incoming request\n    console.log(\"Request accepted. Processing...\");\n    const resString = \"foo\";\n    res.send({ message: resString });\n\n  } else {\n    console.log(\"Request rate-limited. Try again later.\");\n    // Handle flow rejection\n    flow.setStatus(FlowStatus.Error);\n    res.status(429).send({ message: \"Too many requests\" });\n  }\n\n  flow.end();\n}",
    "handleRequestWithCache": "import { FlowStatus, LookupStatus } from \"@fluxninja/aperture-js\";\nimport { Request, Response } from \"express\";\n\nasync function handleRequest(req: Request, res: Response) {\n  const flow = await apertureClient.startFlow(\"archimedes-service\", {\n    labels: {\n      user: \"user1\",\n      tier: \"premium\",\n    },\n    grpcCallOptions: {\n      deadline: Date.now() + 300, // 300ms deadline\n    },\n    resultCacheKey: \"cache\", // optional, in case caching is needed\n  });\n\n  if (flow.shouldRun()) {\n    // Check if the response is cached in Aperture from a previous request\n    if (flow.resultCache().getLookupStatus() === LookupStatus.Hit) {\n      res.send({ message: flow.resultCache().getValue()?.toString() });\n    } else {\n      // Do Actual Work\n      // After completing the work, you can store the response in the cache and return it, for example\n      const resString = \"foo\";\n\n      // create a new buffer\n      const buffer = Buffer.from(resString);\n\n      // set cache value\n      const setResp = await flow.setResultCache({\n        value: buffer,\n        ttl: {\n          seconds: 30,\n          nanos: 0,\n        },\n      });\n      if (setResp.getError()) {\n        console.log(`Error setting cache value: ${setResp.getError()}`);\n      }\n\n\n      res.send({ message: resString });\n    }\n  } else {\n    // Aperture has rejected the request due to a rate limiting policy\n    res.status(429).send({ message: \"Too many requests\" });\n    // Handle flow rejection\n    flow.setStatus(FlowStatus.Error);\n  }\n\n  flow.end();\n}",
    "setResultCache": "// set cache value\n      const setResp = await flow.setResultCache({\n        value: buffer,\n        ttl: {\n          seconds: 30,\n          nanos: 0,\n        },\n      });\n      if (setResp.getError()) {\n        console.log(`Error setting cache value: ${setResp.getError()}`);\n      }"
  }
}
