{
  "go": {
    "clientConstructor": "opts := aperture.Options{\n\t\tAddress:     apertureAgentAddr,\n\t\tDialOptions: grpcOptions(apertureAgentInsecureBool, apertureAgentSkipVerifyBool),\n\t\tAPIKey:      getEnvOrDefault(\"APERTURE_API_KEY\", \"\"),\n\t}\n\n\t// initialize Aperture Client with the provided options.\n\tapertureClient, err := aperture.NewClient(ctx, opts)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to create client: %v\", err)\n\t}"
  },
  "ts": {
    "clientConstructor": "import { ApertureClient } from \"@fluxninja/aperture-js\";\n\n// Create aperture client\nexport const apertureClient = new ApertureClient({\n  address: \"ORGANIZATION.app.fluxninja.com:443\",\n  agentAPIKey: \"API_KEY\",\n});",
    "handleRequest": "import { FlowStatusEnum, LookupStatus } from \"@fluxninja/aperture-js\";\nimport { Request, Response } from \"express\";\n\nasync function handleRequest(req: Request, res: Response) {\n  const flow = await apertureClient.StartFlow(\"archimedes-service\", {\n    labels: {\n      api_key: \"some_api_key\",\n    },\n    grpcCallOptions: {\n      deadline: Date.now() + 300, // ms\n    },\n    cacheKey: \"cache\", // optional, in case caching is needed\n  });\n\n  if (flow.ShouldRun()) {\n    // Check if the response is cached in Aperture from a previous request\n    if (flow.CachedValue().GetLookupStatus() === LookupStatus.Hit) {\n      res.send({ message: flow.CachedValue().GetValue()?.toString() });\n    } else {\n      // Do Actual Work\n      // After completing the work, you can return store the response in cache and return it, for example:\n      const resString = \"foo\";\n\n      // create a new buffer\n      const buffer = Buffer.from(resString);\n\n      // set cache value\n      const setResult = await flow.SetCachedValue(buffer, {\n        seconds: 30,\n        nanos: 0,\n      });\n      if (setResult?.error) {\n        console.log(`Error setting cache value: ${setResult.error}`);\n      }\n\n\n      res.send({ message: resString });\n    }\n  } else {\n    // Aperture has rejected the request due to a rate limiting policy\n    res.status(429).send({ message: \"Too many requests\" });\n    // Handle flow rejection\n    flow.SetStatus(FlowStatusEnum.Error);\n  }\n\n  flow.End();\n}",
    "setCache": "// set cache value\n      const setResult = await flow.SetCachedValue(buffer, {\n        seconds: 30,\n        nanos: 0,\n      });\n      if (setResult?.error) {\n        console.log(`Error setting cache value: ${setResult.error}`);\n      }"
  }
}
