consumes:
- application/json
produces:
- application/json
swagger: "2.0"
info:
  description: Policy
  title: Policy
basePath: /aperture-controller
paths:
  /:
    post:
      tags:
      - policy-configuration
      operationId: Policy
      parameters:
      - name: body
        in: body
        required: true
        schema:
          $ref: '#/definitions/Policy'
      responses:
        "200":
          description: A successful response.
definitions:
  AIMDConcurrencyController:
    description: High level concurrency control component. Baselines a signal via
      exponential moving average and applies concurrency limits based on deviation
      of signal from the baseline. Internally implemented as a nested circuit.
    type: object
    properties:
      alerter_parameters:
        description: Configuration for embedded alerter.
        x-order: 0
        $ref: '#/definitions/AlerterParameters'
      default_config:
        description: Default configuration.
        x-order: 1
        $ref: '#/definitions/LoadActuatorDynamicConfig'
      dynamic_config_key:
        description: Configuration key for load actuation.
        type: string
        x-order: 2
      flow_selector:
        description: |+
          Flow Selector decides the service and flows at which the concurrency limiter is applied.

        x-go-tag-validate: required
        x-order: 3
        $ref: '#/definitions/FlowSelector'
      gradient_parameters:
        description: Gradient parameters for the controller.
        x-order: 4
        $ref: '#/definitions/GradientControllerParameters'
      in_ports:
        description: Input ports for the AIMDConcurrencyController component.
        x-order: 5
        $ref: '#/definitions/AIMDConcurrencyControllerIns'
      load_multiplier_linear_increment:
        description: |+
          Linear increment to load multiplier in each execution tick when the system is not in overloaded state.

        type: number
        format: double
        default: 0.0025
        x-go-tag-default: "0.0025"
        x-order: 6
      max_load_multiplier:
        description: |+
          Current accepted concurrency is multiplied with this number to dynamically calculate the upper concurrency limit of a Service during normal (non-overload) state. This protects the Service from sudden spikes.

        type: number
        format: double
        default: 2
        x-go-tag-default: "2.0"
        x-order: 7
      out_ports:
        description: Output ports for the AIMDConcurrencyController component.
        x-order: 8
        $ref: '#/definitions/AIMDConcurrencyControllerOuts'
      scheduler_parameters:
        description: |+
          Scheduler parameters.

        x-go-tag-validate: required
        x-order: 9
        $ref: '#/definitions/SchedulerParameters'
  AIMDConcurrencyControllerIns:
    description: Inputs for the AIMDConcurrencyController component.
    type: object
    properties:
      setpoint:
        description: The setpoint to the controller.
        x-order: 0
        $ref: '#/definitions/InPort'
      signal:
        description: The signal to the controller.
        x-order: 1
        $ref: '#/definitions/InPort'
  AIMDConcurrencyControllerOuts:
    description: Outputs for the AIMDConcurrencyController component.
    type: object
    properties:
      accepted_concurrency:
        description: Accepted concurrency is the number of concurrent requests that
          are accepted by the service.
        x-order: 0
        $ref: '#/definitions/OutPort'
      desired_load_multiplier:
        description: Desired Load multiplier is the ratio of desired concurrency to
          the incoming concurrency.
        x-order: 1
        $ref: '#/definitions/OutPort'
      incoming_concurrency:
        description: IncomingConcurrency is the number of concurrent requests that
          are received by the service.
        x-order: 2
        $ref: '#/definitions/OutPort'
      is_overload:
        description: Is overload is a boolean signal that indicates whether the service
          is overloaded based on the deviation of the signal from the setpoint taking
          into account some tolerance.
        x-order: 3
        $ref: '#/definitions/OutPort'
      observed_load_multiplier:
        description: Observed Load multiplier is the ratio of accepted concurrency
          to the incoming concurrency.
        x-order: 4
        $ref: '#/definitions/OutPort'
  AddressExtractor:
    description: |-
      IP addresses in attribute context are defined as objects with separate ip and port fields.
      This is a helper to display an address as a single string.

      Note: Use with care, as it might accidentally introduce a high-cardinality flow label values.

      [ext-authz-address]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address

      Example:
      ```yaml
      from: "source.address # or destination.address"
      ```
    type: object
    title: Display an [Address][ext-authz-address] as a single string, eg. `<ip>:<port>`
    required:
    - from
    properties:
      from:
        description: |+
          Attribute path pointing to some string - eg. "source.address".

        type: string
        x-go-tag-validate: required
        x-order: 0
  Alerter:
    description: Alerter reacts to a signal and generates alert to send to alert manager.
    type: object
    properties:
      in_ports:
        description: Input ports for the Alerter component.
        x-order: 0
        $ref: '#/definitions/AlerterIns'
      parameters:
        title: Alerter configuration
        x-go-tag-validate: required
        x-order: 1
        $ref: '#/definitions/AlerterParameters'
  AlerterIns:
    description: Inputs for the Alerter component.
    type: object
    properties:
      signal:
        description: Signal which Alerter is monitoring. If the signal greater than
          0, Alerter generates an alert.
        x-order: 0
        $ref: '#/definitions/InPort'
  AlerterParameters:
    description: Alerter Parameters is a common config for separate alerter components
      and alerters embedded in other components.
    type: object
    required:
    - alert_name
    properties:
      alert_channels:
        description: A list of alert channel strings.
        type: array
        items:
          type: string
        x-order: 0
      alert_name:
        description: |+
          Name of the alert.

        type: string
        x-go-tag-validate: required
        x-order: 1
      labels:
        description: Additional labels to add to alert.
        type: object
        additionalProperties:
          type: string
        x-order: 2
      resolve_timeout:
        description: |+
          Duration of alert resolver.

        type: string
        default: 5s
        x-go-tag-default: 5s
        x-order: 3
      severity:
        description: |+
          Severity of the alert, one of 'info', 'warn' or 'crit'.

        type: string
        default: info
        enum:
        - info
        - warn
        - crit
        x-go-tag-default: info
        x-go-tag-validate: oneof=info warn crit
        x-oneof: info | warn | crit
        x-order: 4
  And:
    description: |-
      Logical AND.

      Signals are mapped to boolean values as follows:
      * Zero is treated as false.
      * Any non-zero is treated as true.
      * Invalid inputs are considered unknown.

        :::note

        Treating invalid inputs as "unknowns" has a consequence that the result
        might end up being valid even when some inputs are invalid. Eg. `unknown && false == false`,
        because the result would end up false no matter if
        first signal was true or false. On the other hand, `unknown && true == unknown`.

        :::
    type: object
    properties:
      in_ports:
        description: Input ports for the And component.
        x-order: 0
        $ref: '#/definitions/AndIns'
      out_ports:
        description: Output ports for the And component.
        x-order: 1
        $ref: '#/definitions/AndOuts'
  AndIns:
    description: Inputs for the And component.
    type: object
    properties:
      inputs:
        description: |+
          Array of input signals.

        type: array
        items:
          $ref: '#/definitions/InPort'
        x-go-tag-validate: dive
        x-order: 0
  AndOuts:
    description: Output ports for the And component.
    type: object
    properties:
      output:
        description: |-
          Result of logical AND of all the input signals.

          Will always be 0 (false), 1 (true) or invalid (unknown).
        x-order: 0
        $ref: '#/definitions/OutPort'
  ArithmeticCombinator:
    type: object
    title: Type of combinator that computes the arithmetic operation on the operand
      signals
    properties:
      in_ports:
        description: Input ports for the Arithmetic Combinator component.
        x-order: 0
        $ref: '#/definitions/ArithmeticCombinatorIns'
      operator:
        description: |+
          Operator of the arithmetic operation.

          The arithmetic operation can be addition, subtraction, multiplication, division, XOR, right bit shift or left bit shift.
          In case of XOR and bitshifts, value of signals is cast to integers before performing the operation.

        type: string
        enum:
        - add
        - sub
        - mul
        - div
        - xor
        - lshift
        - rshift
        x-go-tag-validate: oneof=add sub mul div xor lshift rshift
        x-oneof: add | sub | mul | div | xor | lshift | rshift
        x-order: 1
      out_ports:
        description: Output ports for the Arithmetic Combinator component.
        x-order: 2
        $ref: '#/definitions/ArithmeticCombinatorOuts'
  ArithmeticCombinatorIns:
    description: Inputs for the Arithmetic Combinator component.
    type: object
    properties:
      lhs:
        description: Left hand side of the arithmetic operation.
        x-order: 0
        $ref: '#/definitions/InPort'
      rhs:
        description: Right hand side of the arithmetic operation.
        x-order: 1
        $ref: '#/definitions/InPort'
  ArithmeticCombinatorOuts:
    description: Outputs for the Arithmetic Combinator component.
    type: object
    properties:
      output:
        description: Result of arithmetic operation.
        x-order: 0
        $ref: '#/definitions/OutPort'
  AutoScale:
    description: AutoScale components are used to scale a service.
    type: object
    properties:
      autoscaler:
        description: AutoScaler provides auto scaling functionality for any resource.
        x-order: 0
        $ref: '#/definitions/AutoScaler'
      pod_scaler:
        description: PodScaler provides pod horizontal scaling functionality for scalable
          Kubernetes resources.
        x-order: 1
        $ref: '#/definitions/PodScaler'
  AutoScaler:
    type: object
    title: AutoScaler
    properties:
      cooldown_override_percentage:
        description: |+
          Cooldown override percentage defines a threshold change in scale out beyond which previous cooldown is overridden.
          For example, if the cooldown is 5 minutes and the cooldown override percentage is 10%, then if the
          scale increases by 10% or more, the previous cooldown is cancelled. Defaults to 50%.

        type: number
        format: double
        default: 50
        x-go-tag-default: "50"
        x-order: 0
      max_scale:
        description: |+
          The maximum scale to which the autoscaler can scale out. E.g. in case of KubernetesReplicas Scaler, this is the maximum number of replicas.

        type: string
        format: uint64
        default: "4294967295"
        x-go-tag-default: "4294967295"
        x-order: 1
      max_scale_in_percentage:
        description: |+
          The maximum decrease of scale (e.g. pods) at one time. Defined as percentage of current scale value. Can never go below one even if percentage computation is less than one. Defaults to 1% of current scale value.

        type: number
        format: double
        default: 1
        x-go-tag-default: "1"
        x-order: 2
      max_scale_out_percentage:
        description: |+
          The maximum increase of scale (e.g. pods) at one time. Defined as percentage of current scale value. Can never go below one even if percentage computation is less than one. Defaults to 10% of current scale value.

        type: number
        format: double
        default: 10
        x-go-tag-default: "10"
        x-order: 3
      min_scale:
        description: |+
          The minimum scale to which the autoscaler can scale in. E.g. in case of KubernetesReplicas Scaler, this is the minimum number of replicas.

        type: string
        format: uint64
        default: "0"
        x-go-tag-default: "0"
        x-order: 4
      out_ports:
        description: Output ports for the AutoScaler.
        x-order: 5
        $ref: '#/definitions/AutoScalerOuts'
      scale_in_alerter_parameters:
        description: Configuration for scale in alerter.
        x-order: 6
        $ref: '#/definitions/AlerterParameters'
      scale_in_controllers:
        description: List of Controllers for scaling in.
        type: array
        items:
          $ref: '#/definitions/AutoScalerScaleInController'
        x-order: 7
      scale_in_cooldown:
        description: |+
          The amount of time to wait after a scale in operation for another scale in operation.

        type: string
        default: 120s
        x-go-tag-default: 120s
        x-order: 8
      scale_out_alerter_parameters:
        description: Configuration for scale out alerter.
        x-order: 9
        $ref: '#/definitions/AlerterParameters'
      scale_out_controllers:
        description: List of Controllers for scaling out.
        type: array
        items:
          $ref: '#/definitions/AutoScalerScaleOutController'
        x-order: 10
      scale_out_cooldown:
        description: |+
          The amount of time to wait after a scale out operation for another scale out or scale in operation.

        type: string
        default: 30s
        x-go-tag-default: 30s
        x-order: 11
      scaler:
        x-go-tag-validate: required
        x-order: 12
        $ref: '#/definitions/AutoScalerScaler'
  AutoScalerDecreasingGradient:
    description: Decreasing Gradient defines a controller for scaling in based on
      Gradient Controller.
    type: object
    properties:
      in_ports:
        description: Input ports for the Gradient.
        x-order: 0
        $ref: '#/definitions/AutoScalerDecreasingGradientIns'
      parameters:
        title: |-
          Gradient parameters for the controller. Defaults and constraints:
          * slope = 1
          * min_gradient = -Inf (must be less than 1)
          * max_gradient = 1 (cannot be changed)
        x-order: 1
        $ref: '#/definitions/AutoScalerDecreasingGradientParameters'
  AutoScalerDecreasingGradientIns:
    description: Inputs for Gradient.
    type: object
    properties:
      setpoint:
        description: The setpoint to use for scale in.
        x-order: 0
        $ref: '#/definitions/InPort'
      signal:
        description: The signal to use for scale in.
        x-order: 1
        $ref: '#/definitions/InPort'
  AutoScalerDecreasingGradientParameters:
    description: This allows subset of parameters with constrained values compared
      to a regular gradient controller. For full documentation of these parameters,
      refer to the [GradientControllerParameters](#gradient-controller-parameters).
    type: object
    properties:
      min_gradient:
        type: number
        format: double
        default: -1.7976931348623157e+308
        x-go-tag-default: "-1.79769313486231570814527423731704356798070e+308"
        x-go-tag-validate: lte=1.0
        x-order: 0
      slope:
        type: number
        format: double
        default: 1
        x-go-tag-default: "1.0"
        x-order: 1
  AutoScalerIncreasingGradient:
    description: Increasing Gradient defines a controller for scaling out based on
      Gradient Controller.
    type: object
    properties:
      in_ports:
        description: Input ports for the Gradient.
        x-order: 0
        $ref: '#/definitions/AutoScalerIncreasingGradientIns'
      parameters:
        title: |-
          Gradient parameters for the controller. Defaults and constraints:
          * slope = 1
          * min_gradient = 1 (cannot be changed)
          * max_gradient = +Inf (must be greater than 1)
        x-order: 1
        $ref: '#/definitions/AutoScalerIncreasingGradientParameters'
  AutoScalerIncreasingGradientIns:
    description: Inputs for Gradient.
    type: object
    properties:
      setpoint:
        description: The setpoint to use for scale out.
        x-order: 0
        $ref: '#/definitions/InPort'
      signal:
        description: The signal to use for scale out.
        x-order: 1
        $ref: '#/definitions/InPort'
  AutoScalerIncreasingGradientParameters:
    description: This allows subset of parameters with constrained values compared
      to a regular gradient controller. For full documentation of these parameters,
      refer to the [GradientControllerParameters](#gradient-controller-parameters).
    type: object
    properties:
      max_gradient:
        type: number
        format: double
        default: 1.7976931348623157e+308
        x-go-tag-default: "1.79769313486231570814527423731704356798070e+308"
        x-go-tag-validate: gte=1.0
        x-order: 0
      slope:
        type: number
        format: double
        default: 1
        x-go-tag-default: "1.0"
        x-order: 1
  AutoScalerKubernetesReplicas:
    description: KubernetesReplicas defines a horizontal pod scaler for Kubernetes.
    type: object
    properties:
      default_config:
        description: Default configuration.
        x-order: 0
        $ref: '#/definitions/PodScalerScaleActuatorDynamicConfig'
      dynamic_config_key:
        type: string
        title: Configuration key for DynamicConfig
        x-order: 1
      kubernetes_object_selector:
        description: |+
          The Kubernetes object on which horizontal scaling is applied.

        x-go-tag-validate: required
        x-order: 2
        $ref: '#/definitions/KubernetesObjectSelector'
  AutoScalerOuts:
    description: Outputs for AutoScaler.
    type: object
    properties:
      actual_scale:
        x-order: 0
        $ref: '#/definitions/OutPort'
      configured_scale:
        x-order: 1
        $ref: '#/definitions/OutPort'
      desired_scale:
        x-order: 2
        $ref: '#/definitions/OutPort'
  AutoScalerScaleInController:
    type: object
    properties:
      alerter_parameters:
        description: Configuration for embedded alerter.
        x-order: 0
        $ref: '#/definitions/AlerterParameters'
      controller:
        title: Controller
        x-order: 1
        $ref: '#/definitions/AutoScalerScaleInControllerController'
  AutoScalerScaleInControllerController:
    type: object
    properties:
      gradient:
        x-order: 0
        $ref: '#/definitions/AutoScalerDecreasingGradient'
  AutoScalerScaleOutController:
    type: object
    properties:
      alerter_parameters:
        description: Configuration for embedded alerter.
        x-order: 0
        $ref: '#/definitions/AlerterParameters'
      controller:
        title: Controller
        x-go-tag-validate: required
        x-order: 1
        $ref: '#/definitions/AutoScalerScaleOutControllerController'
  AutoScalerScaleOutControllerController:
    type: object
    properties:
      gradient:
        x-order: 0
        $ref: '#/definitions/AutoScalerIncreasingGradient'
  AutoScalerScaler:
    type: object
    properties:
      kubernetes_replicas:
        x-order: 0
        $ref: '#/definitions/AutoScalerKubernetesReplicas'
  Circuit:
    description: |-
      :::info

      See also [Circuit overview](/concepts/policy/circuit.md).

      :::

      Signals flow between components via ports.
      As signals traverse the circuit, they get processed, stored within components or get acted upon (e.g. load-shed, rate-limit, auto-scale etc.).
      Circuit is evaluated periodically in order to respond to changes in signal readings.

      :::info

      **Signal**

      Signals are floating-point values.

      A signal can also have a special **Invalid** value. It's usually used to
      communicate that signal doesn't have a meaningful value at the moment, eg.
      [PromQL](#prom-q-l) emits such a value if it cannot execute a query.
      Components know when their input signals are invalid and can act
      accordingly. They can either propagate the invalidness, by making their
      output itself invalid (like eg.
      [ArithmeticCombinator](#arithmetic-combinator)) or use some different
      logic, like eg. [Extrapolator](#extrapolator). Refer to a component's
      docs on how exactly it handles invalid inputs.

      :::
    type: object
    title: Circuit is defined as a dataflow graph of inter-connected components
    properties:
      components:
        description: |+
          Defines a signal processing graph as a list of components.

        type: array
        items:
          $ref: '#/definitions/Component'
        x-go-tag-validate: dive
        x-order: 0
      evaluation_interval:
        description: |+
          Evaluation interval (tick) is the time period between consecutive runs of the policy circuit.
          This interval is typically aligned with how often the corrective action (actuation) needs to be taken.

        type: string
        default: 0.5s
        x-go-tag-default: 0.5s
        x-order: 1
  Classifier:
    description: |-
      :::info

      See also [Classifier overview](/concepts/integrations/flow-control/resources/classifier.md).

      :::
      Example
      ```yaml
      flow_selector:
        service_selector:
           agent_group: demoapp
           service: service1-demo-app.demoapp.svc.cluster.local
        flow_matcher:
           control_point: ingress
           label_matcher:
              match_labels:
                user_tier: gold
              match_expressions:
                - key: user_type
                  operator: In
      rules:
        user:
         extractor:
           from: request.http.headers.user-agent
        telemetry: false
      ```
    type: object
    title: Set of classification rules sharing a common selector
    required:
    - rules
    properties:
      flow_selector:
        description: |+
          Defines where to apply the flow classification rule.

        x-go-tag-validate: required
        x-order: 0
        $ref: '#/definitions/FlowSelector'
      rules:
        description: |+
          A map of {key, value} pairs mapping from
          [flow label](/concepts/integrations/flow-control/flow-label.md) keys to rules that define
          how to extract and propagate flow labels with that key.

        type: object
        minProperties: 1
        additionalProperties:
          $ref: '#/definitions/Rule'
        x-go-tag-validate: required,gt=0,dive,keys,required,endkeys,required
        x-order: 1
  Component:
    description: |-
      :::info

      See also [Components overview](/concepts/policy/circuit.md#components).

      :::

      Signals flow into the components via input ports and results are emitted on output ports.
      Components are wired to each other based on signal names forming an execution graph of the circuit.

      :::note

      Loops are broken by the runtime at the earliest component index that is part of the loop.
      The looped signals are saved in the tick they are generated and served in the subsequent tick.

      :::

      There are three categories of components:
      * "source" components – they take some sort of input from "the real world" and output
        a signal based on this input. Example: [PromQL](#prom-q-l). In the UI
        they're represented by green color.
      * signal processor components – "pure" components that don't interact with the "real world".
        Examples: [GradientController](#gradient-controller), [Max](#max).

        :::note

        Signal processor components's output can depend on their internal state, in addition to the inputs.
        Eg. see the [Exponential Moving Average filter](#e-m-a).

        :::

      * "sink" components – they affect the real world.
        [ConcurrencyLimiter.LoadActuator](#concurrency-limiter) and [RateLimiter](#rate-limiter).
        In the UI, represented by orange color.  Sink components usually come in pairs with a
        "sources" component which emits a feedback signal, like
        `accepted_concurrency` emitted by ConcurrencyLimiter.Scheduler.

      :::tip

      Sometimes you may want to use a constant value as one of component's inputs.
      You can create an input port containing the constant value instead of being connected to a signal.
      To do so, use the [InPort](#in_port)'s .withConstantSignal(constant_signal) method.
      You can also use it to provide special math values such as NaN and +- Inf.
      If You need to provide the same constant signal to multiple components,
      You can use the [Variable](#variable) component.

      :::

      See also [Policy](#policy) for a higher-level explanation of circuits.
    type: object
    title: Computational block that form the circuit
    properties:
      alerter:
        description: Alerter reacts to a signal and generates alert to send to alert
          manager.
        x-order: 0
        $ref: '#/definitions/Alerter'
      and:
        description: Logical AND.
        x-order: 1
        $ref: '#/definitions/And'
      arithmetic_combinator:
        description: Applies the given operator on input operands (signals) and emits
          the result.
        x-order: 2
        $ref: '#/definitions/ArithmeticCombinator'
      auto_scale:
        description: AutoScale components are used to scale the service.
        x-order: 3
        $ref: '#/definitions/AutoScale'
      decider:
        description: Decider emits the binary result of comparison operator on two
          operands.
        x-order: 4
        $ref: '#/definitions/Decider'
      differentiator:
        description: Differentiator calculates rate of change per tick.
        x-order: 5
        $ref: '#/definitions/Differentiator'
      ema:
        description: Exponential Moving Average filter.
        x-order: 6
        $ref: '#/definitions/EMA'
      extrapolator:
        description: Takes an input signal and emits the extrapolated value; either
          mirroring the input value or repeating the last known value up to the maximum
          extrapolation interval.
        x-order: 7
        $ref: '#/definitions/Extrapolator'
      first_valid:
        description: Picks the first valid input signal and emits it.
        x-order: 8
        $ref: '#/definitions/FirstValid'
      flow_control:
        description: FlowControl components are used to regulate requests flow.
        x-order: 9
        $ref: '#/definitions/FlowControl'
      gradient_controller:
        description: |-
          Gradient controller basically calculates the ratio between the signal and the setpoint to determine the magnitude of the correction that need to be applied.
          This controller can be used to build AIMD (Additive Increase, Multiplicative Decrease) or MIMD style response.
        x-order: 10
        $ref: '#/definitions/GradientController'
      holder:
        description: Holds the last valid signal value for the specified duration
          then waits for next valid value to hold.
        x-order: 11
        $ref: '#/definitions/Holder'
      integrator:
        description: Accumulates sum of signal every tick.
        x-order: 12
        $ref: '#/definitions/Integrator'
      inverter:
        description: Logical NOT.
        x-order: 13
        $ref: '#/definitions/Inverter'
      max:
        description: Emits the maximum of the input signals.
        x-order: 14
        $ref: '#/definitions/Max'
      min:
        description: Emits the minimum of the input signals.
        x-order: 15
        $ref: '#/definitions/Min'
      nested_circuit:
        description: Nested circuit defines a sub-circuit as a high-level component.
          It consists of a list of components and a map of input and output ports.
        x-order: 16
        $ref: '#/definitions/NestedCircuit'
      nested_signal_egress:
        description: Nested signal egress is a special type of component that allows
          to extract a signal from a nested circuit.
        x-order: 17
        $ref: '#/definitions/NestedSignalEgress'
      nested_signal_ingress:
        description: Nested signal ingress is a special type of component that allows
          to inject a signal into a nested circuit.
        x-order: 18
        $ref: '#/definitions/NestedSignalIngress'
      or:
        description: Logical OR.
        x-order: 19
        $ref: '#/definitions/Or'
      pulse_generator:
        description: Generates 0 and 1 in turns.
        x-order: 20
        $ref: '#/definitions/PulseGenerator'
      query:
        description: Query components that are query databases such as Prometheus.
        x-order: 21
        $ref: '#/definitions/Query'
      switcher:
        description: Switcher acts as a switch that emits one of the two signals based
          on third signal.
        x-order: 22
        $ref: '#/definitions/Switcher'
      unary_operator:
        description: Takes an input signal and emits the square root of the input
          signal.
        x-order: 23
        $ref: '#/definitions/UnaryOperator'
      variable:
        description: Emits a variable signal which can be set to invalid.
        x-order: 24
        $ref: '#/definitions/Variable'
  ConcurrencyLimiter:
    description: |-
      :::info

      See also [Concurrency Limiter overview](/concepts/integrations/flow-control/components/concurrency-limiter.md).

      :::

      It is based on the actuation strategy (e.g. load actuator) and workload scheduling which is based on Weighted Fair Queuing principles.
      Concurrency is calculated in terms of total tokens which translate to (avg. latency \* in-flight requests), i.e. Little's Law.

      ConcurrencyLimiter configuration is split into two parts: An actuation
      strategy and a scheduler. Right now, only `load_actuator` strategy is available.
    type: object
    title: Concurrency Limiter is an actuator component that regulates flows in order
      to provide active service protection
    properties:
      flow_selector:
        description: |+
          Flow Selector decides the service and flows at which the concurrency limiter is applied.

        x-go-tag-validate: required
        x-order: 0
        $ref: '#/definitions/FlowSelector'
      load_actuator:
        description: |-
          Actuator based on limiting the accepted concurrency under incoming concurrency * load multiplier.

          Actuation strategy defines the input signal that will drive the scheduler.
        x-order: 1
        $ref: '#/definitions/LoadActuator'
      scheduler:
        description: |+
          Configuration of Weighted Fair Queuing-based workload scheduler.

          Contains configuration of per-agent scheduler, and also defines some
          output signals.

        x-go-tag-validate: required
        x-order: 2
        $ref: '#/definitions/Scheduler'
  ConstantSignal:
    description: Special constant input for ports and Variable component. Can provide
      either a constant value or special Nan/+-Inf value.
    type: object
    properties:
      special_value:
        description: |+
          A special value such as NaN, +Inf, -Inf.

        type: string
        enum:
        - NaN
        - +Inf
        - -Inf
        x-go-tag-validate: oneof=NaN +Inf -Inf
        x-oneof: NaN | +Inf | -Inf
        x-order: 0
      value:
        description: A constant value.
        type: number
        format: double
        x-order: 1
  Decider:
    description: |-
      The comparison operator can be greater-than, less-than, greater-than-or-equal, less-than-or-equal, equal, or not-equal.

      This component also supports time-based response, i.e. the output
      transitions between 1.0 or 0.0 signal if the decider condition is
      true or false for at least "true_for" or "false_for" duration. If
      `true_for` and `false_for` durations are zero then the transitions are
      instantaneous.
    type: object
    title: Type of combinator that computes the comparison operation on lhs and rhs
      signals
    properties:
      false_for:
        description: |+
          Duration of time to wait before a transition to false state.
          If the duration is zero, the transition will happen instantaneously.

        type: string
        default: 0s
        x-go-tag-default: 0s
        x-order: 0
      in_ports:
        description: Input ports for the Decider component.
        x-order: 1
        $ref: '#/definitions/DeciderIns'
      operator:
        description: |+
          Comparison operator that computes operation on lhs and rhs input signals.

        type: string
        enum:
        - gt
        - lt
        - gte
        - lte
        - eq
        - neq
        x-go-tag-validate: oneof=gt lt gte lte eq neq
        x-oneof: gt | lt | gte | lte | eq | neq
        x-order: 2
      out_ports:
        description: Output ports for the Decider component.
        x-order: 3
        $ref: '#/definitions/DeciderOuts'
      true_for:
        description: |+
          Duration of time to wait before a transition to true state.
          If the duration is zero, the transition will happen instantaneously.

        type: string
        default: 0s
        x-go-tag-default: 0s
        x-order: 4
  DeciderIns:
    description: Inputs for the Decider component.
    type: object
    properties:
      lhs:
        description: Left hand side input signal for the comparison operation.
        x-order: 0
        $ref: '#/definitions/InPort'
      rhs:
        description: Right hand side input signal for the comparison operation.
        x-order: 1
        $ref: '#/definitions/InPort'
  DeciderOuts:
    description: Outputs for the Decider component.
    type: object
    properties:
      output:
        description: Selected signal (1.0 or 0.0).
        x-order: 0
        $ref: '#/definitions/OutPort'
  Differentiator:
    description: Differentiator calculates rate of change per tick.
    type: object
    properties:
      in_ports:
        description: Input ports for the Differentiator component.
        x-order: 0
        $ref: '#/definitions/DifferentiatorIns'
      out_ports:
        description: Output ports for the Differentiator component.
        x-order: 1
        $ref: '#/definitions/DifferentiatorOuts'
      window:
        description: |+
          The window of time over which differentiator operates.

        type: string
        default: 5s
        x-go-tag-default: 5s
        x-order: 2
  DifferentiatorIns:
    description: Inputs for the Differentiator component.
    type: object
    properties:
      input:
        x-order: 0
        $ref: '#/definitions/InPort'
  DifferentiatorOuts:
    description: Outputs for the Differentiator component.
    type: object
    properties:
      output:
        x-order: 0
        $ref: '#/definitions/OutPort'
  EMA:
    description: |-
      At any time EMA component operates in one of the following states:
      1. Warm up state: The first warmup_window samples are used to compute the initial EMA.
         If an invalid reading is received during the warmup_window, the last good average is emitted and the state gets reset back to beginning of warm up state.
      2. Normal state: The EMA is computed using following formula.

      The EMA for a series $Y$ is calculated recursively as:

      $$
      \text{EMA} _t =
      \begin{cases}
        Y_0, &\text{for } t = 0 \\
        \alpha Y_t + (1 - \alpha) \text{EMA} _{t-1}, &\text{for }t > 0
      \end{cases}
      $$

      The coefficient $\alpha$ represents the degree of weighting decrease, a constant smoothing factor between 0 and 1.
      A higher $\alpha$ discounts older observations faster.
      The $\alpha$ is computed using ema\_window:

      $$
      \alpha = \frac{2}{N + 1} \quad\text{where } N = \frac{\text{ema\_window}}{\text{evaluation\_period}}
      $$
    type: object
    title: Exponential Moving Average (EMA) is a type of moving average that applies
      exponentially more weight to recent signal readings
    properties:
      in_ports:
        description: Input ports for the EMA component.
        x-order: 0
        $ref: '#/definitions/EMAIns'
      out_ports:
        description: Output ports for the EMA component.
        x-order: 1
        $ref: '#/definitions/EMAOuts'
      parameters:
        description: |+
          Parameters for the EMA component.

        x-go-tag-validate: required
        x-order: 2
        $ref: '#/definitions/EMAParameters'
  EMAIns:
    description: Inputs for the EMA component.
    type: object
    properties:
      input:
        description: Input signal to be used for the EMA computation.
        x-order: 0
        $ref: '#/definitions/InPort'
      max_envelope:
        description: |-
          Upper bound of the moving average.

          When the signal exceeds `max_envelope` it's multiplied by
          `correction_factor_on_max_envelope_violation` **once per tick**.

          :::note

          If the signal deviates from `max_envelope` faster than the correction
          faster, it might end up exceeding the envelope.

          :::
        x-order: 1
        $ref: '#/definitions/InPort'
      min_envelope:
        description: |-
          Lower bound of the moving average.

          Behavior is similar to `max_envelope`.
        x-order: 2
        $ref: '#/definitions/InPort'
  EMAOuts:
    description: Outputs for the EMA component.
    type: object
    properties:
      output:
        description: Exponential moving average of the series of reading as an output
          signal.
        x-order: 0
        $ref: '#/definitions/OutPort'
  EMAParameters:
    description: Parameters for the EMA component.
    type: object
    required:
    - ema_window
    - warmup_window
    properties:
      correction_factor_on_max_envelope_violation:
        description: |+
          Correction factor to apply on the output value if its in violation of the max envelope.

        type: number
        format: double
        default: 1
        minimum: 0
        x-go-tag-default: "1.0"
        x-go-tag-validate: gte=0,lte=1.0
        x-order: 0
      correction_factor_on_min_envelope_violation:
        description: |+
          Correction factor to apply on the output value if its in violation of the min envelope.

        type: number
        format: double
        default: 1
        x-go-tag-default: "1.0"
        x-go-tag-validate: gte=1.0
        x-order: 1
      ema_window:
        description: |+
          Duration of EMA sampling window.

        type: string
        x-go-tag-validate: required
        x-order: 2
      valid_during_warmup:
        description: |+
          Whether the output is valid during the warm up stage.

        type: boolean
        default: false
        x-go-tag-default: "false"
        x-order: 3
      warmup_window:
        description: |+
          Duration of EMA warming up window.

          The initial value of the EMA is the average of signal readings received during the warm up window.

        type: string
        x-go-tag-validate: required
        x-order: 4
  EqualsMatchExpression:
    description: Label selector expression of the equal form "label == value".
    type: object
    required:
    - label
    properties:
      label:
        description: |+
          Name of the label to equal match the value.

        type: string
        x-go-tag-validate: required
        x-order: 0
      value:
        description: Exact value that the label should be equal to.
        type: string
        x-order: 1
  Extractor:
    description: There are multiple variants of extractor, specify exactly one.
    type: object
    title: Defines a high-level way to specify how to extract a flow label value given
      http request metadata, without a need to write rego code
    properties:
      address:
        description: Display an address as a single string - `<ip>:<port>`.
        x-order: 0
        $ref: '#/definitions/AddressExtractor'
      from:
        description: |-
          Attribute path is a dot-separated path to attribute.

          Should be either:
          * one of the fields of [Attribute Context][attribute-context], or
          * a special "request.http.bearer" pseudo-attribute.
          Eg. "request.http.method" or "request.http.header.user-agent"

          Note: The same attribute path syntax is shared by other extractor variants,
          wherever attribute path is needed in their "from" syntax.

          Example:
          ```yaml
          from: request.http.headers.user-agent
          ```
          [attribute-context]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/attribute_context.proto
        type: string
        title: Use an attribute with no conversion
        x-order: 1
      json:
        description: Deserialize a json, and extract one of the fields.
        x-order: 2
        $ref: '#/definitions/JSONExtractor'
      jwt:
        description: Parse the attribute as JWT and read the payload.
        x-order: 3
        $ref: '#/definitions/JWTExtractor'
      path_templates:
        description: Match HTTP Path to given path templates.
        x-order: 4
        $ref: '#/definitions/PathTemplateMatcher'
  Extrapolator:
    description: It does so until `maximum_extrapolation_interval` is reached, beyond
      which it emits invalid signal unless input signal becomes valid again.
    type: object
    title: Extrapolates the input signal by repeating the last valid value during
      the period in which it is invalid
    properties:
      in_ports:
        description: Input ports for the Extrapolator component.
        x-order: 0
        $ref: '#/definitions/ExtrapolatorIns'
      out_ports:
        description: Output ports for the Extrapolator component.
        x-order: 1
        $ref: '#/definitions/ExtrapolatorOuts'
      parameters:
        description: |+
          Parameters for the Extrapolator component.

        x-go-tag-validate: required
        x-order: 2
        $ref: '#/definitions/ExtrapolatorParameters'
  ExtrapolatorIns:
    description: Inputs for the Extrapolator component.
    type: object
    properties:
      input:
        description: Input signal for the Extrapolator component.
        x-order: 0
        $ref: '#/definitions/InPort'
  ExtrapolatorOuts:
    description: Outputs for the Extrapolator component.
    type: object
    properties:
      output:
        description: Extrapolated signal.
        x-order: 0
        $ref: '#/definitions/OutPort'
  ExtrapolatorParameters:
    description: Parameters for the Extrapolator component.
    type: object
    required:
    - max_extrapolation_interval
    properties:
      max_extrapolation_interval:
        description: |+
          Maximum time interval to repeat the last valid value of input signal.

        type: string
        x-go-tag-validate: required
        x-order: 0
  FirstValid:
    type: object
    title: Picks the first valid input signal from the array of input signals and
      emits it as an output signal
    properties:
      in_ports:
        description: Input ports for the FirstValid component.
        x-order: 0
        $ref: '#/definitions/FirstValidIns'
      out_ports:
        description: Output ports for the FirstValid component.
        x-order: 1
        $ref: '#/definitions/FirstValidOuts'
  FirstValidIns:
    description: Inputs for the FirstValid component.
    type: object
    properties:
      inputs:
        description: |+
          Array of input signals.

        type: array
        items:
          $ref: '#/definitions/InPort'
        x-go-tag-validate: dive
        x-order: 0
  FirstValidOuts:
    description: Outputs for the FirstValid component.
    type: object
    properties:
      output:
        description: First valid input signal as an output signal.
        x-order: 0
        $ref: '#/definitions/OutPort'
  FlowControl:
    description: FlowControl components are used to regulate requests flow.
    type: object
    properties:
      aimd_concurrency_controller:
        description: AIMD Concurrency control component is based on Additive Increase
          and Multiplicative Decrease of Concurrency. It takes a signal and setpoint
          as inputs and reduces concurrency limits proportionally (or any arbitrary
          power) based on deviation of the signal from setpoint. Internally implemented
          as a nested circuit.
        x-order: 0
        $ref: '#/definitions/AIMDConcurrencyController'
      concurrency_limiter:
        description: Concurrency Limiter provides service protection by applying prioritized
          load shedding of flows using a network scheduler (e.g. Weighted Fair Queuing).
        x-order: 1
        $ref: '#/definitions/ConcurrencyLimiter'
      rate_limiter:
        description: Rate Limiter provides service protection by applying rate limiter.
        x-order: 2
        $ref: '#/definitions/RateLimiter'
  FlowMatcher:
    description: |-
      :::info

      See also [FlowSelector overview](/concepts/integrations/flow-control/flow-selector.md).

      :::
      Example:
      ```yaml
      control_point: ingress
      label_matcher:
        match_labels:
          user_tier: gold
        match_expressions:
          - key: query
            operator: In
            values:
              - insert
              - delete
        expression:
          label_matches:
              - label: user_agent
                regex: ^(?!.*Chrome).*Safari
      ```
    type: object
    title: |-
      Describes which flows a [flow control
      component](/concepts/integrations/flow-control/flow-control.md#components) should apply
      to
    required:
    - control_point
    properties:
      control_point:
        description: |+
          [Control Point](/concepts/integrations/flow-control/flow-selector.md#control-point)
          identifies the location of a Flow within a Service. For an SDK based insertion, a Control Point can represent a particular feature or execution
          block within a Service. In case of Service Mesh or Middleware insertion, a Control Point can identify ingress vs egress calls or distinct listeners
          or filter chains.

        type: string
        x-go-tag-validate: required
        x-order: 0
      label_matcher:
        description: |-
          :::info

          See also [Label Matcher overview](/concepts/integrations/flow-control/flow-selector.md#label-matcher).

          :::

          :::note

          [Classifiers](#classifier) _can_ use flow labels created by some other
          classifier, but only if they were created at some previous control point
          (and propagated in baggage).

          This limitation doesn't apply to selectors of other entities, like
          Flux Meters or Actuators. It's valid to create a flow label on a control
          point using classifier, and immediately use it for matching on the same
          control point.

          :::
        title: |-
          Label matcher allows to add _additional_ condition on
          [flow labels](/concepts/integrations/flow-control/flow-label.md)
          must also be satisfied (in addition to service+control point matching)
        x-order: 1
        $ref: '#/definitions/LabelMatcher'
  FlowSelector:
    description: |-
      :::info

      See also [FlowSelector overview](/concepts/integrations/flow-control/flow-selector.md).

      :::
    type: object
    title: |-
      Describes which flow in which service a [flow control
      component](/concepts/integrations/flow-control/flow-control.md#components) should apply
      to
    properties:
      flow_matcher:
        title: Match control points and labels
        x-go-tag-validate: required
        x-order: 0
        $ref: '#/definitions/FlowMatcher'
      service_selector:
        title: Match agent group and service
        x-go-tag-validate: required
        x-order: 1
        $ref: '#/definitions/ServiceSelector'
  FluxMeter:
    description: |-
      Flux Meter gathers metrics for the traffic that matches its selector.
      The histogram created by Flux Meter measures the workload latency by default.

      :::info

      See also [Flux Meter overview](/concepts/integrations/flow-control/resources/flux-meter.md).

      :::
      Example:
      ```yaml
      static_buckets:
         buckets: [5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]
      flow_selector:
        service_selector:
           agent_group: demoapp
           service: service1-demo-app.demoapp.svc.cluster.local
        flow_matcher:
           control_point: ingress
      attribute_key: response_duration_ms
      ```
    type: object
    properties:
      attribute_key:
        description: |+
          Key of the attribute in access log or span from which the metric for this flux meter is read.

          :::info

          For list of available attributes in Envoy access logs, refer
          [Envoy Filter](/get-started/integrations/flow-control/envoy/istio.md#envoy-filter)

          :::

        type: string
        default: workload_duration_ms
        x-go-tag-default: workload_duration_ms
        x-order: 0
      exponential_buckets:
        x-order: 1
        $ref: '#/definitions/FluxMeterExponentialBuckets'
      exponential_buckets_range:
        x-order: 2
        $ref: '#/definitions/FluxMeterExponentialBucketsRange'
      flow_selector:
        description: The selection criteria for the traffic that will be measured.
        x-order: 3
        $ref: '#/definitions/FlowSelector'
      linear_buckets:
        x-order: 4
        $ref: '#/definitions/FluxMeterLinearBuckets'
      static_buckets:
        x-order: 5
        $ref: '#/definitions/FluxMeterStaticBuckets'
  FluxMeterExponentialBuckets:
    description: |-
      ExponentialBuckets creates `count` number of buckets where the lowest bucket has an upper bound of `start`
      and each following bucket's upper bound is `factor` times the previous bucket's upper bound. The final +inf
      bucket is not counted.
    type: object
    properties:
      count:
        description: |+
          Number of buckets.

        type: integer
        format: int32
        minimum: 0
        exclusiveMinimum: true
        x-go-tag-validate: gt=0
        x-order: 0
      factor:
        description: |+
          Factor to be multiplied to the previous bucket's upper bound to calculate the following bucket's upper bound.

        type: number
        format: double
        x-go-tag-validate: gt=1.0
        x-order: 1
      start:
        description: |+
          Upper bound of the lowest bucket.

        type: number
        format: double
        x-go-tag-validate: gt=0.0
        x-order: 2
  FluxMeterExponentialBucketsRange:
    description: |-
      ExponentialBucketsRange creates `count` number of buckets where the lowest bucket is `min` and the highest
      bucket is `max`. The final +inf bucket is not counted.
    type: object
    properties:
      count:
        description: |+
          Number of buckets.

        type: integer
        format: int32
        minimum: 0
        exclusiveMinimum: true
        x-go-tag-validate: gt=0
        x-order: 0
      max:
        description: Highest bucket.
        type: number
        format: double
        x-order: 1
      min:
        description: |+
          Lowest bucket.

        type: number
        format: double
        x-go-tag-validate: gt=0.0
        x-order: 2
  FluxMeterLinearBuckets:
    description: |-
      LinearBuckets creates `count` number of buckets, each `width` wide, where the lowest bucket has an
      upper bound of `start`. The final +inf bucket is not counted.
    type: object
    properties:
      count:
        description: |+
          Number of buckets.

        type: integer
        format: int32
        minimum: 0
        exclusiveMinimum: true
        x-go-tag-validate: gt=0
        x-order: 0
      start:
        description: Upper bound of the lowest bucket.
        type: number
        format: double
        x-order: 1
      width:
        description: Width of each bucket.
        type: number
        format: double
        x-order: 2
  FluxMeterStaticBuckets:
    description: StaticBuckets holds the static value of the buckets where latency
      histogram will be stored.
    type: object
    properties:
      buckets:
        description: |+
          The buckets in which latency histogram will be stored.

        type: array
        default:
        - 5
        - 10
        - 25
        - 50
        - 100
        - 250
        - 500
        - 1000
        - 2500
        - 5000
        - 10000
        items:
          type: number
          format: double
        x-go-tag-default: '[5.0,10.0,25.0,50.0,100.0,250.0,500.0,1000.0,2500.0,5000.0,10000.0]'
        x-order: 0
  GradientController:
    description: |-
      The `gradient` describes a corrective factor that should be applied to the
      control variable to get the signal closer to the setpoint. It is computed as follows:

      $$
      \text{gradient} = \left(\frac{\text{signal}}{\text{setpoint}}\right)^{\text{slope}}
      $$

      `gradient` is then clamped to [min_gradient, max_gradient] range.

      The output of gradient controller is computed as follows:
      $$
      \text{output} = \text{gradient}_{\text{clamped}} \cdot \text{control\_variable} + \text{optimize}.
      $$

      Note the additional `optimize` signal, that can be used to "nudge" the
      controller into desired idle state.

      The output can be _optionally_ clamped to desired range using `max` and
      `min` input.
    type: object
    title: |-
      Gradient controller is a type of controller which tries to adjust the
      control variable proportionally to the relative difference between setpoint
      and actual value of the signal
    properties:
      default_config:
        description: Default configuration.
        x-order: 0
        $ref: '#/definitions/GradientControllerDynamicConfig'
      dynamic_config_key:
        type: string
        title: Configuration key for DynamicConfig
        x-order: 1
      in_ports:
        description: Input ports of the Gradient Controller.
        x-order: 2
        $ref: '#/definitions/GradientControllerIns'
      out_ports:
        description: Output ports of the Gradient Controller.
        x-order: 3
        $ref: '#/definitions/GradientControllerOuts'
      parameters:
        description: |+
          Gradient Parameters.

        x-go-tag-validate: required
        x-order: 4
        $ref: '#/definitions/GradientControllerParameters'
  GradientControllerDynamicConfig:
    type: object
    title: Dynamic Configuration for a Controller
    properties:
      manual_mode:
        description: |+
          Decides whether the controller runs in "manual_mode".
          In manual mode, the controller does not adjust the control variable I.E. emits the same output as the control variable input.

        type: boolean
        default: false
        x-go-tag-default: "false"
        x-order: 0
  GradientControllerIns:
    description: Inputs for the Gradient Controller component.
    type: object
    properties:
      control_variable:
        description: |-
          Actual current value of the control variable.

          This signal is multiplied by the gradient to produce the output.
        x-order: 0
        $ref: '#/definitions/InPort'
      max:
        description: Maximum value to limit the output signal.
        x-order: 1
        $ref: '#/definitions/InPort'
      min:
        description: Minimum value to limit the output signal.
        x-order: 2
        $ref: '#/definitions/InPort'
      optimize:
        description: Optimize signal is added to the output of the gradient calculation.
        x-order: 3
        $ref: '#/definitions/InPort'
      setpoint:
        description: Setpoint to be used for the gradient computation.
        x-order: 4
        $ref: '#/definitions/InPort'
      signal:
        description: Signal to be used for the gradient computation.
        x-order: 5
        $ref: '#/definitions/InPort'
  GradientControllerOuts:
    description: Outputs for the Gradient Controller component.
    type: object
    properties:
      output:
        description: Computed desired value of the control variable.
        x-order: 0
        $ref: '#/definitions/OutPort'
  GradientControllerParameters:
    description: Gradient Parameters.
    type: object
    required:
    - slope
    properties:
      max_gradient:
        description: |+
          Maximum gradient which clamps the computed gradient value to the range, [min_gradient, max_gradient].

        type: number
        format: double
        default: 1.7976931348623157e+308
        x-go-tag-default: "1.79769313486231570814527423731704356798070e+308"
        x-order: 0
      min_gradient:
        description: |+
          Minimum gradient which clamps the computed gradient value to the range, [min_gradient, max_gradient].

        type: number
        format: double
        default: -1.7976931348623157e+308
        x-go-tag-default: "-1.79769313486231570814527423731704356798070e+308"
        x-order: 1
      slope:
        description: |+
          Slope controls the aggressiveness and direction of the Gradient Controller.

          Slope is used as exponent on the signal to setpoint ratio in computation
          of the gradient (see the [main description](#gradient-controller) for
          exact equation). Good intuition for this parameter is "What should the
          Gradient Controller do to the control variable when signal is too high",
          eg.:
          * $\text{slope} = 1$: when signal is too high, increase control variable,
          * $\text{slope} = -1$: when signal is too high, decrease control variable,
          * $\text{slope} = -0.5$: when signal is too high, decrease control variable slowly.

          The sign of slope depends on correlation between the signal and control variable:
          * Use $\text{slope} < 0$ if signal and control variable are _positively_
          correlated (eg. Per-pod CPU usage and total concurrency).
          * Use $\text{slope} > 0$ if signal and control variable are _negatively_
          correlated (eg. Per-pod CPU usage and number of pods).

          :::note

          You need to set _negative_ slope for a _positive_ correlation, as you're
          describing the _action_ which controller should make when the signal
          increases.

          :::

          The magnitude of slope describes how aggressively should the controller
          react to a deviation of signal.
          With $|\text{slope}| = 1$, the controller will aim to bring the signal to
          the setpoint in one tick (assuming linear correlation with signal and setpoint).
          Smaller magnitudes of slope will make the controller adjust the control
          variable more slowly.

          We recommend setting $|\text{slope}| < 1$ (eg. $\pm0.8$).
          If you experience overshooting, consider lowering the magnitude even more.
          Values of $|\text{slope}| > 1$ are not recommended.

          :::note

          Remember that the gradient and output signal can be (optionally) clamped,
          so the _slope_ might not fully describe aggressiveness of the controller.

          :::

        type: number
        format: double
        x-go-tag-validate: required
        x-order: 2
  Holder:
    description: |-
      Holds the last valid signal value for the specified duration then waits for next valid value to hold.
      If it's holding a value that means it ignores both valid and invalid new signals until the hold_for duration is finished.
    type: object
    properties:
      hold_for:
        description: |+
          Holding the last valid signal value for the hold_for duration.

        type: string
        default: 5s
        x-go-tag-default: 5s
        x-order: 0
      in_ports:
        description: Input ports for the Holder component.
        x-order: 1
        $ref: '#/definitions/HolderIns'
      out_ports:
        description: Output ports for the Holder component.
        x-order: 2
        $ref: '#/definitions/HolderOuts'
  HolderIns:
    description: Inputs for the Holder component.
    type: object
    properties:
      input:
        description: The input signal.
        x-order: 0
        $ref: '#/definitions/InPort'
      reset:
        description: Resets the holder output to the current input signal when reset
          signal is valid and non-zero.
        x-order: 1
        $ref: '#/definitions/InPort'
  HolderOuts:
    description: Outputs for the Holder component.
    type: object
    properties:
      output:
        description: The output signal.
        x-order: 0
        $ref: '#/definitions/OutPort'
  InPort:
    type: object
    title: Components receive input from other components via InPorts
    properties:
      constant_signal:
        description: Constant value to be used for this InPort instead of a signal.
        x-order: 0
        $ref: '#/definitions/ConstantSignal'
      signal_name:
        description: Name of the incoming Signal on the InPort.
        type: string
        x-order: 1
  Integrator:
    description: Accumulates sum of signal every tick.
    type: object
    properties:
      in_ports:
        description: Input ports for the Integrator component.
        x-order: 0
        $ref: '#/definitions/IntegratorIns'
      out_ports:
        description: Output ports for the Integrator component.
        x-order: 1
        $ref: '#/definitions/IntegratorOuts'
  IntegratorIns:
    description: Inputs for the Integrator component.
    type: object
    properties:
      input:
        description: The input signal.
        x-order: 0
        $ref: '#/definitions/InPort'
      max:
        description: The maximum output.
        x-order: 1
        $ref: '#/definitions/InPort'
      min:
        description: The minimum output.
        x-order: 2
        $ref: '#/definitions/InPort'
      reset:
        description: Resets the integrator output to zero when reset signal is valid
          and non-zero. Reset also resets the max and min constraints.
        x-order: 3
        $ref: '#/definitions/InPort'
  IntegratorOuts:
    description: Outputs for the Integrator component.
    type: object
    properties:
      output:
        x-order: 0
        $ref: '#/definitions/OutPort'
  Inverter:
    description: |-
      Logical NOT.

      See [And component](#and) on how signals are mapped onto boolean values.
    type: object
    properties:
      in_ports:
        description: Input ports for the Inverter component.
        x-order: 0
        $ref: '#/definitions/InverterIns'
      out_ports:
        description: Output ports for the Inverter component.
        x-order: 1
        $ref: '#/definitions/InverterOuts'
  InverterIns:
    description: Inputs for the Inverter component.
    type: object
    properties:
      input:
        description: |+
          Signal to be negated.

        x-go-tag-validate: dive
        x-order: 0
        $ref: '#/definitions/InPort'
  InverterOuts:
    description: Output ports for the Inverter component.
    type: object
    properties:
      output:
        description: |-
          Logical negation of the input signal.

          Will always be 0 (false), 1 (true) or invalid (unknown).
        x-order: 0
        $ref: '#/definitions/OutPort'
  JSONExtractor:
    description: |-
      Example:
      ```yaml
      from: request.http.body
      pointer: /user/name
      ```
    type: object
    title: Deserialize a json, and extract one of the fields
    required:
    - from
    properties:
      from:
        description: |+
          Attribute path pointing to some strings - eg. "request.http.body".

        type: string
        x-go-tag-validate: required
        x-order: 0
      pointer:
        description: |-
          Json pointer represents a parsed json pointer which allows to select a specified field from the json payload.

          Note: Uses [json pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,
          eg. `/foo/bar`. If the pointer points into an object, it'd be stringified.
        type: string
        x-order: 1
  JWTExtractor:
    description: |-
      Specify a field to be extracted from payload using "json_pointer".

      Note: The signature is not verified against the secret (we're assuming there's some
      other parts of the system that handles such verification).

      Example:
      ```yaml
      from: request.http.bearer
      json_pointer: /user/email
      ```
    type: object
    title: Parse the attribute as JWT and read the payload
    required:
    - from
    properties:
      from:
        description: |+
          Jwt token can be pulled from any input attribute, but most likely you'd want to use "request.http.bearer".

        type: string
        x-go-tag-validate: required
        x-order: 0
      json_pointer:
        description: |-
          Json pointer allowing to select a specified field from the json payload.

          Note: Uses [json pointer](https://datatracker.ietf.org/doc/html/rfc6901) syntax,
          eg. `/foo/bar`. If the pointer points into an object, it'd be stringified.
        type: string
        x-order: 1
  K8sLabelMatcherRequirement:
    description: Label selector requirement which is a selector that contains values,
      a key, and an operator that relates the key and values.
    type: object
    required:
    - key
    properties:
      key:
        description: |+
          Label key that the selector applies to.

        type: string
        x-go-tag-validate: required
        x-order: 0
      operator:
        description: |+
          Logical operator which represents a key's relationship to a set of values.
          Valid operators are In, NotIn, Exists and DoesNotExist.

        type: string
        enum:
        - In
        - NotIn
        - Exists
        - DoesNotExists
        x-go-tag-validate: oneof=In NotIn Exists DoesNotExists
        x-oneof: In | NotIn | Exists | DoesNotExists
        x-order: 1
      values:
        description: |-
          An array of string values that relates to the key by an operator.
          If the operator is In or NotIn, the values array must be non-empty.
          If the operator is Exists or DoesNotExist, the values array must be empty.
        type: array
        items:
          type: string
        x-order: 2
  KubernetesObjectSelector:
    description: |-
      Describes which pods a control or observability
      component should apply to.
    type: object
    required:
    - api_version
    - kind
    - name
    - namespace
    properties:
      agent_group:
        description: |+
          Which [agent-group](/concepts/integrations/flow-control/flow-selector.md#agent-group) this
          selector applies to.

        type: string
        default: default
        x-go-tag-default: default
        x-order: 0
      api_version:
        type: string
        title: API version of Kubernetes resource
        x-go-tag-validate: required
        x-order: 1
      kind:
        description: |+
          Kubernetes resource type.

        type: string
        x-go-tag-validate: required
        x-order: 2
      name:
        description: |+
          Kubernetes resource name.

        type: string
        x-go-tag-validate: required
        x-order: 3
      namespace:
        description: |+
          Kubernetes namespace that the resource belongs to.

        type: string
        x-go-tag-validate: required
        x-order: 4
  LabelMatcher:
    description: |-
      It provides three ways to define requirements:
      - matchLabels
      - matchExpressions
      - arbitrary expression

      If multiple requirements are set, they are all ANDed.
      An empty label matcher always matches.
    type: object
    title: |-
      Allows to define rules whether a map of
      [labels](/concepts/integrations/flow-control/flow-label.md)
      should be considered a match or not
    properties:
      expression:
        description: An arbitrary expression to be evaluated on the labels.
        x-order: 0
        $ref: '#/definitions/MatchExpression'
      match_expressions:
        description: |-
          List of k8s-style label matcher requirements.

          Note: The requirements are ANDed.
        type: array
        items:
          $ref: '#/definitions/K8sLabelMatcherRequirement'
        x-order: 1
      match_labels:
        description: |-
          A map of {key,value} pairs representing labels to be matched.
          A single {key,value} in the matchLabels requires that the label "key" is present and equal to "value".

          Note: The requirements are ANDed.
        type: object
        additionalProperties:
          type: string
        x-order: 2
  LoadActuator:
    type: object
    title: Takes the load multiplier input signal and publishes it to the schedulers
      in the data-plane
    properties:
      default_config:
        description: Default configuration.
        x-order: 0
        $ref: '#/definitions/LoadActuatorDynamicConfig'
      dynamic_config_key:
        description: Configuration key for DynamicConfig.
        type: string
        x-order: 1
      in_ports:
        description: Input ports for the Load Actuator component.
        x-order: 2
        $ref: '#/definitions/LoadActuatorIns'
  LoadActuatorDynamicConfig:
    type: object
    title: Dynamic Configuration for LoadActuator
    properties:
      dry_run:
        description: |-
          Decides whether to run the load actuator in dry-run mode. Dry run mode ensures that no traffic gets dropped by this load actuator.
          Useful for observing the behavior of Load Actuator without disrupting any real traffic.
        type: boolean
        x-order: 0
  LoadActuatorIns:
    description: Input for the Load Actuator component.
    type: object
    properties:
      load_multiplier:
        description: |-
          Load multiplier is ratio of [incoming
          concurrency](#scheduler-outs) that needs to be accepted.
        x-order: 0
        $ref: '#/definitions/InPort'
  MatchExpression:
    description: |-
      MatchExpression has multiple variants, exactly one should be set.

      Example:
      ```yaml
      all:
        of:
          - label_exists: foo
          - label_equals: { label = app, value = frobnicator }
      ```
    type: object
    title: Defines a [map<string, string> → bool] expression to be evaluated on labels
    required:
    - label_exists
    properties:
      all:
        description: The expression is true when all subexpressions are true.
        x-order: 0
        $ref: '#/definitions/MatchExpressionList'
      any:
        description: The expression is true when any subexpression is true.
        x-order: 1
        $ref: '#/definitions/MatchExpressionList'
      label_equals:
        description: The expression is true when label value equals given value.
        x-order: 2
        $ref: '#/definitions/EqualsMatchExpression'
      label_exists:
        description: |+
          The expression is true when label with given name exists.

        type: string
        x-go-tag-validate: required
        x-order: 3
      label_matches:
        description: The expression is true when label matches given regex.
        x-order: 4
        $ref: '#/definitions/MatchesMatchExpression'
      not:
        description: The expression negates the result of subexpression.
        x-order: 5
        $ref: '#/definitions/MatchExpression'
  MatchExpressionList:
    description: 'eg. {any: {of: [expr1, expr2]}}.'
    type: object
    title: List of MatchExpressions that is used for all/any matching
    properties:
      of:
        description: List of subexpressions of the match expression.
        type: array
        items:
          $ref: '#/definitions/MatchExpression'
        x-order: 0
  MatchesMatchExpression:
    description: Label selector expression of the matches form "label matches regex".
    type: object
    required:
    - label
    - regex
    properties:
      label:
        description: |+
          Name of the label to match the regular expression.

        type: string
        x-go-tag-validate: required
        x-order: 0
      regex:
        description: |+
          Regular expression that should match the label value.
          It uses [golang's regular expression syntax](https://github.com/google/re2/wiki/Syntax).

        type: string
        x-go-tag-validate: required
        x-order: 1
  Max:
    description: 'Max: output = max([]inputs).'
    type: object
    title: Takes a list of input signals and emits the signal with the maximum value
    properties:
      in_ports:
        description: Input ports for the Max component.
        x-order: 0
        $ref: '#/definitions/MaxIns'
      out_ports:
        description: Output ports for the Max component.
        x-order: 1
        $ref: '#/definitions/MaxOuts'
  MaxIns:
    description: Inputs for the Max component.
    type: object
    properties:
      inputs:
        description: |+
          Array of input signals.

        type: array
        items:
          $ref: '#/definitions/InPort'
        x-go-tag-validate: dive
        x-order: 0
  MaxOuts:
    description: Output for the Max component.
    type: object
    properties:
      output:
        description: Signal with maximum value as an output signal.
        x-order: 0
        $ref: '#/definitions/OutPort'
  Min:
    description: |-
      Takes an array of input signals and emits the signal with the minimum value
      Min: output = min([]inputs).
    type: object
    properties:
      in_ports:
        description: Input ports for the Min component.
        x-order: 0
        $ref: '#/definitions/MinIns'
      out_ports:
        description: Output ports for the Min component.
        x-order: 1
        $ref: '#/definitions/MinOuts'
  MinIns:
    description: Inputs for the Min component.
    type: object
    properties:
      inputs:
        description: |+
          Array of input signals.

        type: array
        items:
          $ref: '#/definitions/InPort'
        x-go-tag-validate: dive
        x-order: 0
  MinOuts:
    description: Output ports for the Min component.
    type: object
    properties:
      output:
        description: Signal with minimum value as an output signal.
        x-order: 0
        $ref: '#/definitions/OutPort'
  NestedCircuit:
    description: Nested circuit defines a sub-circuit as a high-level component. It
      consists of a list of components and a map of input and output ports.
    type: object
    properties:
      components:
        description: |+
          List of components in the nested circuit.

        type: array
        items:
          $ref: '#/definitions/Component'
        x-go-tag-validate: dive
        x-order: 0
      in_ports_map:
        description: Maps input port names to input ports.
        type: object
        additionalProperties:
          $ref: '#/definitions/InPort'
        x-order: 1
      name:
        description: Name of the nested circuit component. This name is displayed
          by graph visualization tools.
        type: string
        x-order: 2
      out_ports_map:
        description: Maps output port names to output ports.
        type: object
        additionalProperties:
          $ref: '#/definitions/OutPort'
        x-order: 3
      short_description:
        description: Short description of the nested circuit component. This description
          is displayed by graph visualization tools.
        type: string
        x-order: 4
  NestedSignalEgress:
    description: Nested signal egress is a special type of component that allows to
      extract a signal from a nested circuit.
    type: object
    properties:
      in_ports:
        description: Input ports for the NestedSignalEgress component.
        x-order: 0
        $ref: '#/definitions/NestedSignalEgressIns'
      port_name:
        description: Name of the port.
        type: string
        x-order: 1
  NestedSignalEgressIns:
    description: Inputs for the NestedSignalEgress component.
    type: object
    properties:
      signal:
        description: The signal to be egressed.
        x-order: 0
        $ref: '#/definitions/InPort'
  NestedSignalIngress:
    description: Nested signal ingress is a special type of component that allows
      to inject a signal into a nested circuit.
    type: object
    properties:
      out_ports:
        description: Output ports for the NestedSignalIngress component.
        x-order: 0
        $ref: '#/definitions/NestedSignalIngressOuts'
      port_name:
        description: Name of the port.
        type: string
        x-order: 1
  NestedSignalIngressOuts:
    description: Outputs for the NestedSignalIngress component.
    type: object
    properties:
      signal:
        description: The signal to be ingressed.
        x-order: 0
        $ref: '#/definitions/OutPort'
  Or:
    description: |-
      Logical OR.

      See [And component](#and) on how signals are mapped onto boolean values.
    type: object
    properties:
      in_ports:
        description: Input ports for the Or component.
        x-order: 0
        $ref: '#/definitions/OrIns'
      out_ports:
        description: Output ports for the Or component.
        x-order: 1
        $ref: '#/definitions/OrOuts'
  OrIns:
    description: Inputs for the Or component.
    type: object
    properties:
      inputs:
        description: |+
          Array of input signals.

        type: array
        items:
          $ref: '#/definitions/InPort'
        x-go-tag-validate: dive
        x-order: 0
  OrOuts:
    description: Output ports for the Or component.
    type: object
    properties:
      output:
        description: |-
          Result of logical OR of all the input signals.

          Will always be 0 (false), 1 (true) or invalid (unknown).
        x-order: 0
        $ref: '#/definitions/OutPort'
  OutPort:
    type: object
    title: Components produce output for other components via OutPorts
    properties:
      signal_name:
        description: Name of the outgoing Signal on the OutPort.
        type: string
        x-order: 0
  PathTemplateMatcher:
    description: |-
      HTTP path will be matched against given path templates.
      If a match occurs, the value associated with the path template will be treated as a result.
      In case of multiple path templates matching, the most specific one will be chosen.
    type: object
    title: Matches HTTP Path to given path templates
    properties:
      template_values:
        description: |+
          Template value keys are OpenAPI-inspired path templates.

          * Static path segment `/foo` matches a path segment exactly
          * `/{param}` matches arbitrary path segment.
            (The param name is ignored and can be omitted (`{}`))
          * The parameter must cover whole segment.
          * Additionally, path template can end with `/*` wildcard to match
            arbitrary number of trailing segments (0 or more).
          * Multiple consecutive `/` are ignored, as well as trailing `/`.
          * Parametrized path segments must come after static segments.
          * `*`, if present, must come last.
          * Most specific template "wins" (`/foo` over `/{}` and `/{}` over `/*`).

          See also <https://swagger.io/specification/#path-templating-matching>

          Example:
          ```yaml
          /register: register
          "/user/{userId}": user
          /static/*: other
          ```

        type: object
        minProperties: 1
        additionalProperties:
          type: string
        x-go-tag-validate: gt=0,dive,keys,required,endkeys,required
        x-order: 0
  PodScaler:
    description: Component for scaling pods based on a signal.
    type: object
    properties:
      kubernetes_object_selector:
        description: |+
          The Kubernetes object on which horizontal scaling is applied.

        x-go-tag-validate: required
        x-order: 0
        $ref: '#/definitions/KubernetesObjectSelector'
      scale_actuator:
        description: Actuates scaling of pods based on a signal.
        x-order: 1
        $ref: '#/definitions/PodScalerScaleActuator'
      scale_reporter:
        description: Reports actual and configured number of replicas.
        x-order: 2
        $ref: '#/definitions/PodScalerScaleReporter'
  PodScalerScaleActuator:
    description: Actuates scaling of pods based on a signal.
    type: object
    properties:
      default_config:
        description: Default configuration.
        x-order: 0
        $ref: '#/definitions/PodScalerScaleActuatorDynamicConfig'
      dynamic_config_key:
        type: string
        title: Configuration key for DynamicConfig
        x-order: 1
      in_ports:
        description: Input ports for the PodScaler component.
        x-order: 2
        $ref: '#/definitions/PodScalerScaleActuatorIns'
  PodScalerScaleActuatorDynamicConfig:
    type: object
    title: Dynamic Configuration for ScaleActuator
    properties:
      dry_run:
        description: |+
          Decides whether to run the pod scaler in dry-run mode. Dry run mode ensures that no scaling is invoked by this pod scaler.
          Useful for observing the behavior of Scaler without disrupting any real traffic.

        type: boolean
        default: false
        x-go-tag-default: "false"
        x-order: 0
  PodScalerScaleActuatorIns:
    description: Inputs for the PodScaler component.
    type: object
    properties:
      desired_replicas:
        x-order: 0
        $ref: '#/definitions/InPort'
  PodScalerScaleReporter:
    description: Reports actual and configured number of replicas.
    type: object
    properties:
      out_ports:
        description: Output ports for the PodScaler component.
        x-order: 0
        $ref: '#/definitions/PodScalerScaleReporterOuts'
  PodScalerScaleReporterOuts:
    description: Outputs for the PodScaler component.
    type: object
    properties:
      actual_replicas:
        description: The number of replicas that are currently running.
        x-order: 0
        $ref: '#/definitions/OutPort'
      configured_replicas:
        description: The number of replicas that are desired.
        x-order: 1
        $ref: '#/definitions/OutPort'
  Policy:
    description: |-
      :::info

      See also [Policy overview](/concepts/policy/policy.md).

      :::

      Policy specification contains a circuit that defines the controller logic and resources that need to be setup.
    type: object
    title: Policy expresses reliability automation workflow that automatically protects
      services
    properties:
      circuit:
        description: Defines the control-loop logic of the policy.
        x-order: 0
        $ref: '#/definitions/Circuit'
      resources:
        description: Resources (Flux Meters, Classifiers etc.) to setup.
        x-order: 1
        $ref: '#/definitions/Resources'
  PromQL:
    type: object
    title: Component that runs a Prometheus query periodically and returns the result
      as an output signal
    properties:
      evaluation_interval:
        description: |+
          Describes the interval between successive evaluations of the Prometheus query.

        type: string
        default: 10s
        x-go-tag-default: 10s
        x-order: 0
      out_ports:
        description: Output ports for the PromQL component.
        x-order: 1
        $ref: '#/definitions/PromQLOuts'
      query_string:
        description: |-
          Describes the Prometheus query to be run.

          :::caution

          TODO we should describe how to construct the query, eg. how to employ the
          fluxmeters here or link to appropriate place in docs.

          :::
        type: string
        x-order: 2
  PromQLOuts:
    description: Output for the PromQL component.
    type: object
    properties:
      output:
        description: The result of the Prometheus query as an output signal.
        x-order: 0
        $ref: '#/definitions/OutPort'
  PulseGenerator:
    description: Generates 0 and 1 in turns.
    type: object
    properties:
      false_for:
        description: |+
          Emitting 0 for the false_for duration.

        type: string
        default: 5s
        x-go-tag-default: 5s
        x-order: 0
      out_ports:
        description: Output ports for the PulseGenerator component.
        x-order: 1
        $ref: '#/definitions/PulseGeneratorOuts'
      true_for:
        description: |+
          Emitting 1 for the true_for duration.

        type: string
        default: 5s
        x-go-tag-default: 5s
        x-order: 2
  PulseGeneratorOuts:
    description: Outputs for the PulseGenerator component.
    type: object
    properties:
      output:
        x-order: 0
        $ref: '#/definitions/OutPort'
  Query:
    description: Query components that are query databases such as Prometheus.
    type: object
    properties:
      promql:
        description: Periodically runs a Prometheus query in the background and emits
          the result.
        x-order: 0
        $ref: '#/definitions/PromQL'
  RateLimiter:
    description: |-
      :::info

      See also [Rate Limiter overview](/concepts/integrations/flow-control/components/rate-limiter.md).

      :::

      Ratelimiting is done separately on per-label-value basis. Use _label\_key_
      to select which label should be used as key.
    type: object
    title: Limits the traffic on a control point to specified rate
    properties:
      default_config:
        title: Default configuration
        x-order: 0
        $ref: '#/definitions/RateLimiterDynamicConfig'
      dynamic_config_key:
        type: string
        title: Configuration key for DynamicConfig
        x-order: 1
      flow_selector:
        description: |+
          Which control point to apply this ratelimiter to.

        x-go-tag-validate: required
        x-order: 2
        $ref: '#/definitions/FlowSelector'
      in_ports:
        title: Input ports for the RateLimiter component
        x-go-tag-validate: required
        x-order: 3
        $ref: '#/definitions/RateLimiterIns'
      parameters:
        title: Parameters for the RateLimiter component
        x-go-tag-validate: required
        x-order: 4
        $ref: '#/definitions/RateLimiterParameters'
  RateLimiterDynamicConfig:
    type: object
    title: Dynamic Configuration for the rate limiter
    properties:
      overrides:
        description: |+
          Allows to specify different limits for particular label values.

        type: array
        items:
          $ref: '#/definitions/RateLimiterOverride'
        x-go-tag-validate: dive
        x-order: 0
  RateLimiterIns:
    type: object
    title: Inputs for the RateLimiter component
    properties:
      limit:
        description: |+
          Number of flows allowed per _limit\_reset\_interval_ per each label.
          Negative values disable the ratelimiter.

          :::tip

          Negative limit can be useful to _conditionally_ enable the ratelimiter
          under certain circumstances. [Decider](#decider) might be helpful.

          :::

        x-go-tag-validate: required
        x-order: 0
        $ref: '#/definitions/InPort'
  RateLimiterOverride:
    type: object
    required:
    - label_value
    properties:
      label_value:
        description: |+
          Value of the label for which the override should be applied.

        type: string
        x-go-tag-validate: required
        x-order: 0
      limit_scale_factor:
        description: |+
          Amount by which the _in\_ports.limit_ should be multiplied for this label value.

        type: number
        format: double
        default: 1
        x-go-tag-default: "1.0"
        x-order: 1
  RateLimiterParameters:
    type: object
    required:
    - label_key
    properties:
      label_key:
        description: |+
          Specifies which label the ratelimiter should be keyed by.

          Rate limiting is done independently for each value of the
          [label](/concepts/integrations/flow-control/flow-label.md) with given key.
          Eg., to give each user a separate limit, assuming you have a _user_ flow
          label set up, set `label_key: "user"`.

        type: string
        x-go-tag-validate: required
        x-order: 0
      lazy_sync:
        title: Configuration of lazy-syncing behaviour of ratelimiter
        x-order: 1
        $ref: '#/definitions/RateLimiterParametersLazySync'
      limit_reset_interval:
        description: |+
          Time after which the limit for a given label value will be reset.

        type: string
        default: 60s
        x-go-tag-default: 60s
        x-order: 2
  RateLimiterParametersLazySync:
    type: object
    properties:
      enabled:
        type: boolean
        title: Enables lazy sync
        default: false
        x-go-tag-default: "false"
        x-order: 0
      num_sync:
        description: |+
          Number of times to lazy sync within the _limit\_reset\_interval_.

        type: integer
        format: int64
        default: 5
        minimum: 0
        exclusiveMinimum: true
        x-go-tag-default: "5"
        x-go-tag-validate: gt=0
        x-order: 1
  Resources:
    description: |-
      :::info

      See also [Resources overview](/concepts/policy/resources.md).

      :::

      Resources are typically Flux Meters, Classifiers, etc. that can be used to create on-demand metrics or label the flows.
    type: object
    title: Resources that need to be setup for the policy to function
    properties:
      classifiers:
        description: |+
          Classifiers are installed in the data-plane and are used to label the requests based on payload content.

          The flow labels created by Classifiers can be matched by Flux Meters to create metrics for control purposes.

        type: array
        items:
          $ref: '#/definitions/Classifier'
        x-go-tag-validate: dive
        x-order: 0
      flux_meters:
        description: |+
          Flux Meters are installed in the data-plane and form the observability leg of the feedback loop.

          Flux Meter created metrics can be consumed as input to the circuit via the PromQL component.

        type: object
        additionalProperties:
          $ref: '#/definitions/FluxMeter'
        x-go-tag-validate: dive
        x-order: 1
  Rule:
    description: |-
      Classification rule extracts a value from request metadata.
      More specifically, from `input`, which has the same spec as [Envoy's External Authorization Attribute Context][attribute-context].
      See https://play.openpolicyagent.org/p/gU7vcLkc70 for an example input.
      There are two ways to define a flow classification rule:
      * Using a declarative extractor – suitable from simple cases, such as directly reading a value from header or a field from json body.
      * Rego expression.

      Performance note: It's recommended to use declarative extractors where possible, as they may be slightly performant than Rego expressions.

      Example of Declarative JSON extractor:
      ```yaml
      extractor:
        json:
          from: request.http.body
          pointer: /user/name
      ```

      Example of Rego module which also disables telemetry visibility of label:
      ```yaml
      rego:
        query: data.user_from_cookie.user
        source: |
          package user_from_cookie
          cookies := split(input.attributes.request.http.headers.cookie, "; ")
          user := user {
              cookie := cookies[_]
              startswith(cookie, "session=")
              session := substring(cookie, count("session="), -1)
              parts := split(session, ".")
              object := json.unmarshal(base64url.decode(parts[0]))
              user := object.user
          }
      telemetry: false
      ```
      [attribute-context]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/attribute_context.proto
    type: object
    title: Rule describes a single classification Rule
    properties:
      extractor:
        description: High-level declarative extractor.
        x-order: 0
        $ref: '#/definitions/Extractor'
      rego:
        description: Rego module to extract a value from.
        x-order: 1
        $ref: '#/definitions/RuleRego'
      telemetry:
        description: |+
          :::note

          The flow label is always accessible in Aperture Policies regardless of this setting.

          :::

          :::caution

          When using [FluxNinja ARC plugin](arc/plugin.md), telemetry enabled
          labels are sent to FluxNinja ARC for observability. Telemetry should be disabled for
          sensitive labels.

          :::

        type: boolean
        title: |-
          Decides if the created flow label should be available as an attribute in OLAP telemetry and
          propagated in [baggage](/concepts/integrations/flow-control/flow-label.md#baggage)
        default: true
        x-go-tag-default: "true"
        x-order: 2
  RuleRego:
    description: High-level extractor-based rules are compiled into a single rego
      query.
    type: object
    title: Raw rego rules are compiled 1:1 to rego queries
    required:
    - query
    - source
    properties:
      query:
        description: |+
          Query string to extract a value (eg. `data.<mymodulename>.<variablename>`).

          Note: The module name must match the package name from the "source".

        type: string
        x-go-tag-validate: required
        x-order: 0
      source:
        description: |+
          Source code of the rego module.

          Note: Must include a "package" declaration.

        type: string
        x-go-tag-validate: required
        x-order: 1
  Scheduler:
    description: |-
      :::note

      Each Agent instantiates an independent copy of the scheduler, but output
      signals for accepted and incoming concurrency are aggregated across all agents.

      :::

      See [ConcurrencyLimiter](#concurrency-limiter) for more context.
    type: object
    title: Weighted Fair Queuing-based workload scheduler
    properties:
      out_ports:
        description: Output ports for the Scheduler component.
        x-order: 0
        $ref: '#/definitions/SchedulerOuts'
      parameters:
        description: |+
          Scheduler parameters.

        x-go-tag-validate: required
        x-order: 1
        $ref: '#/definitions/SchedulerParameters'
  SchedulerOuts:
    description: Output for the Scheduler component.
    type: object
    properties:
      accepted_concurrency:
        description: |-
          Accepted concurrency is actual concurrency on a control point that this
          scheduler is applied on.

          :::info

          Concurrency is a unitless number describing mean number of
          [flows](/concepts/integrations/flow-control/flow-control.md#flow) being
          concurrently processed by the system (system = control point).
          Concurrency is calculated as _work_ done per unit of time (so
          work-seconds per world-seconds). Work-seconds are computed based on
          token-weights of of flows (which are either estimated via `auto_tokens`
          or specified by `Workload.tokens`).

          :::

          Value of this signal is aggregated from all the relevant schedulers.
        x-order: 0
        $ref: '#/definitions/OutPort'
      incoming_concurrency:
        description: |-
          Incoming concurrency is concurrency that'd be needed to accept all the
          flows entering the scheduler.

          This is computed in the same way as `accepted_concurrency`, but summing
          up work-seconds from all the flows entering scheduler, including
          rejected ones.
        x-order: 1
        $ref: '#/definitions/OutPort'
  SchedulerParameters:
    type: object
    title: Scheduler parameters
    properties:
      auto_tokens:
        description: |+
          Automatically estimate the size of a request in each workload, based on
          historical latency. Each workload's `tokens` will be set to average
          latency of flows in that workload during last few seconds (exact duration
          of this average can change).

        type: boolean
        default: true
        x-go-tag-default: "true"
        x-order: 0
      default_workload_parameters:
        description: Parameters to be used if none of workloads specified in `workloads`
          match.
        x-order: 1
        $ref: '#/definitions/SchedulerWorkloadParameters'
      max_timeout:
        description: |+
          :::caution

          This timeout needs to be strictly less than the timeout set on the
          client for the whole GRPC call:
          * in case of envoy, timeout set on `grpc_service` used in `ext_authz` filter,
          * in case of libraries, timeout configured... TODO.

          We're using fail-open logic in integrations, so if the GRPC timeout
          fires first, the flow will end up being unconditionally allowed while
          it're still waiting on the scheduler.

          To avoid such cases, the end-to-end GRPC timeout should also contain
          some headroom for constant overhead like serialization, etc. Default
          value for GRPC timeouts is 500ms, giving 50ms of headeroom, so when
          tweaking this timeout, make sure to adjust the GRPC timeout accordingly.

          :::

        type: string
        title: Max Timeout is the value with which the flow timeout calculated by
          `timeout_factor` is capped
        default: 0.49s
        x-go-tag-default: 0.49s
        x-order: 2
      timeout_factor:
        description: |+
          If a flow is not able to get tokens within `timeout_factor * tokens` of duration,
          it will be rejected.

          This value impacts the prioritization and fairness because the larger the timeout the higher the chance a request has to get scheduled.

        type: number
        format: double
        title: Timeout as a factor of tokens for a flow in a workload
        default: 0.5
        x-go-tag-default: "0.5"
        x-go-tag-validate: gte=0.0
        x-order: 3
      workloads:
        description: |+
          List of workloads to be used in scheduler.

          Categorizing [flows](/concepts/integrations/flow-control/flow-control.md#flow) into workloads
          allows for load-shedding to be "smarter" than just "randomly deny 50% of
          requests". There are two aspects of this "smartness":
          * Scheduler can more precisely calculate concurrency if it understands
            that flows belonging to different classes have different weights (eg.
            inserts vs lookups).
          * Setting different priorities to different workloads lets the scheduler
            avoid dropping important traffic during overload.

          Each workload in this list specifies also a matcher that's used to
          determine which flow will be categorized into which workload.
          In case of multiple matching workloads, the first matching one will be used.
          If none of workloads match, `default_workload` will be used.

          :::info

          See also [workload definition in the concepts
          section](/concepts/integrations/flow-control/components/concurrency-limiter.md#workload).

          :::

        type: array
        items:
          $ref: '#/definitions/SchedulerWorkload'
        x-go-tag-validate: dive
        x-order: 4
  SchedulerWorkload:
    description: Workload defines a class of requests that preferably have similar
      properties such as response latency or desired priority.
    type: object
    properties:
      label_matcher:
        description: |+
          Label Matcher to select a Workload based on
          [flow labels](/concepts/integrations/flow-control/flow-label.md).

        x-go-tag-validate: required
        x-order: 0
        $ref: '#/definitions/LabelMatcher'
      parameters:
        description: |+
          Parameters associated with flows matching the label matcher.

        x-go-tag-validate: required
        x-order: 1
        $ref: '#/definitions/SchedulerWorkloadParameters'
  SchedulerWorkloadParameters:
    description: Parameters defines parameters such as priority, tokens and fairness
      key that are applicable to flows within a workload.
    type: object
    properties:
      fairness_key:
        description: |-
          Fairness key is a label key that can be used to provide fairness within a workload.
          Any [flow label](/concepts/integrations/flow-control/flow-label.md) can be used here. Eg. if
          you have a classifier that sets `user` flow label, you might want to set
          `fairness_key = "user"`.
        type: string
        x-order: 0
      priority:
        description: |+
          $$
          \text{virtual\_finish\_time} = \text{virtual\_time} + \left(\text{tokens} \cdot \left(\text{256} - \text{priority}\right)\right)
          $$

        type: integer
        format: int64
        title: |-
          Describes priority level of the requests within the workload.
          Priority level ranges from 0 to 255.
          Higher numbers means higher priority level.
          Priority levels have non-linear effect on the workload scheduling. The following formula is used to determine the position of a request in the queue based on virtual finish time:
        default: 0
        maximum: 255
        minimum: 0
        x-go-tag-default: "0"
        x-go-tag-validate: gte=0,lte=255
        x-order: 1
      tokens:
        description: |+
          Tokens determines the cost of admitting a single request the workload, which is typically defined as milliseconds of response latency.
          This override is applicable only if `auto_tokens` is set to false.

        type: string
        format: uint64
        default: "1"
        x-go-tag-default: "1"
        x-order: 2
  ServiceSelector:
    description: |-
      :::info

      See also [FlowSelector overview](/concepts/integrations/flow-control/flow-selector.md).

      :::
    type: object
    title: |-
      Describes which service a [flow control or observability
      component](/concepts/integrations/flow-control/flow-control.md#components) should apply
      to
    required:
    - service
    properties:
      agent_group:
        description: |+
          Which [agent-group](/concepts/integrations/flow-control/flow-selector.md#agent-group) this
          selector applies to.

          :::info

          Agent Groups are used to scope policies to a subset of agents connected to the same controller. This is especially useful in the Kubernetes sidecar installation because service discovery is switched off in that mode. The agents within an agent group form a peer to peer cluster and constantly share state.

          :::

        type: string
        default: default
        x-go-tag-default: default
        x-order: 0
      service:
        description: |+
          The Fully Qualified Domain Name of the
          [service](/concepts/integrations/flow-control/flow-selector.md) to select.

          In Kubernetes, this is the FQDN of the Service object.

          "all" means all services within an agent group (catch-all).

          :::info

          In the Kubernetes sidecar installation mode, service discovery is switched off by default. In order to scope policies to services, the `service` should be set to `all` and instead, `agent_group` name should be used.

          :::

          :::info

          An entity (e.g. Kubernetes pod) may belong to multiple services.

          :::

        type: string
        x-go-tag-validate: required
        x-order: 1
  Switcher:
    description: |-
      `on_signal` will be returned if switch input is valid and not equal to 0.0 ,
       otherwise `off_signal` will be returned.
    type: object
    title: Type of combinator that switches between `on_signal` and `off_signal` signals
      based on switch input
    properties:
      in_ports:
        description: Input ports for the Switcher component.
        x-order: 0
        $ref: '#/definitions/SwitcherIns'
      out_ports:
        description: Output ports for the Switcher component.
        x-order: 1
        $ref: '#/definitions/SwitcherOuts'
  SwitcherIns:
    description: Inputs for the Switcher component.
    type: object
    properties:
      off_signal:
        description: Output signal when switch is invalid or 0.0.
        x-order: 0
        $ref: '#/definitions/InPort'
      on_signal:
        description: Output signal when switch is valid and not 0.0.
        x-order: 1
        $ref: '#/definitions/InPort'
      switch:
        description: Decides whether to return `on_signal` or `off_signal`.
        x-order: 2
        $ref: '#/definitions/InPort'
  SwitcherOuts:
    description: Outputs for the Switcher component.
    type: object
    properties:
      output:
        description: Selected signal (`on_signal` or `off_signal`).
        x-order: 0
        $ref: '#/definitions/OutPort'
  UnaryOperator:
    description: |-
      $$
      \text{output} = \unary_operator{\text{input}}
      $$
    type: object
    title: Takes an input signal and emits the output after applying the specified
      unary operator
    properties:
      in_ports:
        description: Input ports for the UnaryOperator component.
        x-order: 0
        $ref: '#/definitions/UnaryOperatorIns'
      operator:
        description: |+
          Unary Operator to apply.

          The unary operator can be one of the following:
          * abs: Absolute value with the sign removed.
          * acos: arccosine, in radians.
          * acosh: Inverse hyperbolic cosine.
          * asin: arcsine, in radians.
          * asinh: Inverse hyperbolic sine.
          * atan: arctangent, in radians.
          * atanh: Inverse hyperbolic tangent.
          * cbrt: Cube root.
          * ceil: Least integer value greater than or equal to input signal.
          * cos: cosine, in radians.
          * cosh: Hyperbolic cosine.
          * erf: Error function.
          * erfc: Complementary error function.
          * erfcinv: Inverse complementary error function.
          * erfinv: Inverse error function.
          * exp: The base-e exponential of input signal.
          * exp2: The base-2 exponential of input signal.
          * expm1: The base-e exponential of input signal minus 1.
          * floor: Greatest integer value less than or equal to input signal.
          * gamma: Gamma function.
          * j0: Bessel function of the first kind of order 0.
          * j1: Bessel function of the first kind of order 1.
          * lgamma: Natural logarithm of the absolute value of the gamma function.
          * log: Natural logarithm of input signal.
          * log10: Base-10 logarithm of input signal.
          * log1p: Natural logarithm of input signal plus 1.
          * log2: Base-2 logarithm of input signal.
          * round: Round to nearest integer.
          * roundtoeven: Round to nearest integer, with ties going to the nearest even integer.
          * sin: sine, in radians.
          * sinh: Hyperbolic sine.
          * sqrt: Square root.
          * tan: tangent, in radians.
          * tanh: Hyperbolic tangent.
          * trunc: Truncate to integer.
          * y0: Bessel function of the second kind of order 0.
          * y1: Bessel function of the second kind of order 1.

        type: string
        enum:
        - abs
        - acos
        - acosh
        - asin
        - asinh
        - atan
        - atanh
        - cbrt
        - ceil
        - cos
        - cosh
        - erf
        - erfc
        - erfcinv
        - erfinv
        - exp
        - exp2
        - expm1
        - floor
        - gamma
        - j0
        - j1
        - lgamma
        - log
        - log10
        - log1p
        - log2
        - round
        - roundtoeven
        - sin
        - sinh
        - sqrt
        - tan
        - tanh
        - trunc
        - y0
        - y1
        x-go-tag-validate: oneof=abs acos acosh asin asinh atan atanh cbrt ceil cos
          cosh erf erfc erfcinv erfinv exp exp2 expm1 floor gamma j0 j1 lgamma log
          log10 log1p log2 round roundtoeven sin sinh sqrt tan tanh trunc y0 y1
        x-oneof: abs | acos | acosh | asin | asinh | atan | atanh | cbrt | ceil |
          cos | cosh | erf | erfc | erfcinv | erfinv | exp | exp2 | expm1 | floor
          | gamma | j0 | j1 | lgamma | log | log10 | log1p | log2 | round | roundtoeven
          | sin | sinh | sqrt | tan | tanh | trunc | y0 | y1
        x-order: 1
      out_ports:
        description: Output ports for the UnaryOperator component.
        x-order: 2
        $ref: '#/definitions/UnaryOperatorOuts'
  UnaryOperatorIns:
    description: Inputs for the UnaryOperator component.
    type: object
    properties:
      input:
        description: Input signal.
        x-order: 0
        $ref: '#/definitions/InPort'
  UnaryOperatorOuts:
    description: Outputs for the UnaryOperator component.
    type: object
    properties:
      output:
        description: Output signal.
        x-order: 0
        $ref: '#/definitions/OutPort'
  Variable:
    description: Component that emits a variable value as an output signal, can be
      defined in dynamic configuration.
    type: object
    properties:
      default_config:
        description: Default configuration.
        x-order: 0
        $ref: '#/definitions/VariableDynamicConfig'
      dynamic_config_key:
        description: Configuration key for DynamicConfig.
        type: string
        x-order: 1
      out_ports:
        description: Output ports for the Variable component.
        x-order: 2
        $ref: '#/definitions/VariableOuts'
  VariableDynamicConfig:
    type: object
    properties:
      constant_signal:
        x-order: 0
        $ref: '#/definitions/ConstantSignal'
  VariableOuts:
    description: Outputs for the Variable component.
    type: object
    properties:
      output:
        description: The value is emitted to the output port.
        x-order: 0
        $ref: '#/definitions/OutPort'
