version: 2.1

orbs:
  docker: circleci/docker@2.1.1
  gcp-gcr: circleci/gcp-gcr@0.13.0
  slack: circleci/slack@4.4.4
  rust: circleci/rust@1.5.0
  codecov: codecov/codecov@3.2.2

executors:
  base-cimg-executor:
    docker:
      - image: cimg/base:2022.07
  go-cimg-executor:
    docker:
      - image: cimg/go:1.20.3
        user: root
  python-cimg-executor:
    docker:
      - image: cimg/python:3.11
  base-machine-executor:
    machine:
      image: ubuntu-2204:2022.10.2
      docker_layer_caching: true
  ubuntu-18-executor:
    docker:
      - image: cimg/base:2022.12-18.04

parameters:
  updated-aperture:
    type: boolean
    default: false
  updated-aperture-agent-packaging:
    type: boolean
    default: false
  updated-aperturectl-packaging:
    type: boolean
    default: false
  updated-aperture-operator:
    type: boolean
    default: false
  updated-aperture-docs:
    type: boolean
    default: false
  updated-circleci-config:
    type: boolean
    default: false
  updated-aperture-charts:
    type: boolean
    default: false
  updated-demo-app:
    type: boolean
    default: false
  updated-aperture-go:
    type: boolean
    default: false
  updated-aperture-js:
    type: boolean
    default: false
  updated-aperture-java:
    type: boolean
    default: false
  updated-aperture-py:
    type: boolean
    default: false
  updated-sdk-validator:
    type: boolean
    default: false
  updated-blueprints:
    type: boolean
    default: false

jobs:
  build-push-add-tag:
    parameters:
      attach-workspace:
        type: boolean
        description:
          Boolean for whether or not to attach to an existing workspace
        default: false
      docker-context:
        type: string
        description:
          Path to the directory containing your build context, defaults to .
        default: .
      dockerfile:
        type: string
        description: Name of dockerfile to use, defaults to Dockerfile
        default: Dockerfile
      executor:
        type: executor
        description: executor to use for this job
        default: base-cimg-executor
      extra_build_args:
        type: string
        description: Extra flags to pass to docker build
        default: ""
      docker_ssh:
        type: string
        description: SSH socket to forward to the docker build process
        default: ""
      dockerhub-image:
        type: string
        description: A name for your Docker image
      gcr-registry:
        type: string
        description: Google Container Registry to push images to
      gcr-image:
        type: string
        description: A name for the image pushed to GCR
      path:
        type: string
        description:
          Path to the directory containing your Dockerfile, defaults to .
        default: .
      remote-docker-version:
        type: string
        description: Specify the remote docker version
        default: 20.10.18
      setup-remote-docker:
        type: boolean
        description: Setup and use CircleCI's remote Docker environment
        default: true
      registry:
        type: string
        default: docker.io
        description: Name of registry to use, defaults to docker.io
      tag:
        type: string
        description: A Docker image tag
        default: ${CIRCLE_SHA1:0:8}
      target-tag:
        type: string
        description: Additional image tag applied when job runs on main branch
        default: latest
      use-docker-layer-caching:
        type: boolean
        description: Setup docker layer caching for optimized build
        default: false
      workspace-root:
        type: string
        description: >
          Workspace root path that is either an absolute path or a path relative
          to the working directory. Defaults to '.' (the working directory)
        default: .
      push-to-dockerhub:
        type: boolean
        description: Boolean for whether or not to push images to DockerHub
        default: true
      no_output_timeout:
        type: string
        default: 20m
        description: |
          Pass through a default timeout if your Docker build does not output anything for more than 10 minutes.
    executor: <<parameters.executor>>
    resource_class: small
    environment:
      DOCKER_BUILDKIT: 1
      GOMAXPROCS: 1
    steps:
      - checkout
      - when:
          condition: <<parameters.setup-remote-docker>>
          steps:
            - setup_remote_docker:
                docker_layer_caching: <<parameters.use-docker-layer-caching>>
                version: <<parameters.remote-docker-version>>
      - when:
          condition: <<parameters.attach-workspace>>
          steps:
            - attach_workspace:
                at: <<parameters.workspace-root>>
      - aperture_docker_build:
          docker-context: <<parameters.docker-context>>
          dockerfile: <<parameters.dockerfile>>
          extra_build_args: <<parameters.extra_build_args>>
          registry: <<parameters.registry>>``
          image: <<parameters.dockerhub-image>>
          path: <<parameters.path>>
          tag: <<parameters.tag>>
          ssh: <<parameters.docker_ssh>>
          no_output_timeout: <<parameters.no_output_timeout>>
          use-buildkit: true
      - aperture_docker_tag:
          source-registry: <<parameters.registry>>
          source-image: <<parameters.dockerhub-image>>
          source-tag: <<parameters.tag>>
          dest-registry: <<parameters.gcr-registry>>
          dest-image: <<parameters.gcr-image>>
          dest-tag: <<parameters.tag>>
      - gcp-gcr/gcr-auth
      - gcp-gcr/push-image:
          image: <<parameters.gcr-image>>
          tag: <<parameters.tag>>
      - when:
          condition:
            equal: [main, << pipeline.git.branch >>]
          steps:
            - gcp-gcr/tag-image:
                image: <<parameters.gcr-image>>
                source-tag: <<parameters.tag>>
                target-tag: <<parameters.target-tag>>
            - when:
                condition: <<parameters.push-to-dockerhub>>
                steps:
                  - run:
                      name: Push images to DockerHub
                      command: |
                        docker tag <<parameters.dockerhub-image>>:<<parameters.tag>> <<parameters.dockerhub-image>>:<<parameters.target-tag>>
                        docker login -u "$DOCKERHUB_USERNAME" --password "$DOCKERHUB_TOKEN"
                        docker push <<parameters.dockerhub-image>>:<<parameters.target-tag>>

  go-test-coverage:
    parameters:
      work_dir:
        type: string
        description: working directory
    executor: go-cimg-executor
    resource_class: xlarge
    environment:
      GOMAXPROCS: 4
    steps:
      - checkout
      - run:
          name: download etcd
          command: |
            ETCD_VER=v3.5.3
            DOWNLOAD_URL=https://storage.googleapis.com/etcd
            rm -f /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz
            rm -rf /tmp/etcd-download-test && mkdir -p /tmp/etcd-download-test
            curl -L ${DOWNLOAD_URL}/${ETCD_VER}/etcd-${ETCD_VER}-linux-amd64.tar.gz -o /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz
            tar xzvf /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz -C /tmp/etcd-download-test --strip-components=1 --no-same-owner
            rm -f /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz
            /tmp/etcd-download-test/etcd --version
            mv /tmp/etcd-download-test/etcd /home/circleci/bin/etcd
      - run:
          name: download prometheus
          command: |
            PROMETHEUS_VER=2.36.1
            DOWNLOAD_URL=https://github.com/prometheus/prometheus/releases/download
            rm -f /tmp/prometheus-${PROMETHEUS_VER}.linux-amd64.tar.gz
            rm -rf /tmp/prometheus-download-test && mkdir -p /tmp/prometheus-download-test
            curl -L ${DOWNLOAD_URL}/v${PROMETHEUS_VER}/prometheus-${PROMETHEUS_VER}.linux-amd64.tar.gz -o /tmp/prometheus-${PROMETHEUS_VER}.linux-amd64.tar.gz
            tar xvf /tmp/prometheus-${PROMETHEUS_VER}.linux-amd64.tar.gz -C /tmp/prometheus-download-test --strip-components=1 --no-same-owner
            rm -f /tmp/prometheus-${PROMETHEUS_VER}.linux-amd64.tar.gz
            /tmp/prometheus-download-test/prometheus --version
            mv /tmp/prometheus-download-test/prometheus /home/circleci/bin/prometheus
      - run:
          name: Run tests and coverage
          working_directory: << parameters.work_dir >>
          command: |
            go install sigs.k8s.io/controller-runtime/tools/setup-envtest@latest
            envtest_path=$(make operator-setup_envtest -s)
            export KUBEBUILDER_ASSETS="${envtest_path}"
            PKGS=$(go list ./... | grep -v gen | grep -v operator/api) && \
              gotestsum \
                --format=testname \
                --junitfile=unit-tests.xml \
                --rerun-fails=2 \
                --packages="$PKGS" \
                -- \
                  -race \
                  -coverprofile=coverage.out \
                  -coverpkg=./... \
                  -ldflags='-extldflags "-Wl,--allow-multiple-definition"' \
              $PKGS
            mkdir -p /tmp/test-results
            mv unit-tests.xml /tmp/test-results
      - codecov/upload
      - store_test_results:
          path: /tmp/test-results
      - run:
          name: Show peak memory usage in bytes
          command: cat /sys/fs/cgroup/memory/memory.max_usage_in_bytes
          when: always

  pre-commit:
    executor: python-cimg-executor
    resource_class: xlarge
    environment:
      GOMAXPROCS: 8
    steps:
      - add_ssh_keys:
          fingerprints:
            - "10:d1:92:4e:2a:55:81:c9:82:c2:74:ce:6d:0e:e8:a8" # fluxninja/cloud R/O
      - checkout
      - asdf_install:
          cache_name: pre-commit
          tools: |-
            bats
            buf
            circleci
            golang
            golangci-lint
            helm
            java
            jb
            jsonnet
            kustomize
            mockery
            nodejs
            pre-commit
            shellcheck
            tanka
            yq
      - run:
          name: Install additional system dependencies for pre-commit
          command: |
            sudo apt-get update
            sudo apt-get install \
              libgtk-3-0 \
              libgbm1 \
              libasound2
      - run: &install_opsninja
          name: Install opsninja and its dependencies
          command: |
            # We need R/O access to cloud repository to be able to fetch opsninja library
            # FIXME: make "releases" of opsninja library somehow, even as a separate repository
            # to limit exposure.
            export CLOUD_RO_KEY_FINGERPRINT="10:d1:92:4e:2a:55:81:c9:82:c2:74:ce:6d:0e:e8:a8"
            export GIT_SSH_COMMAND="ssh -i ~/.ssh/id_rsa_$(echo "${CLOUD_RO_KEY_FINGERPRINT}" | tr -d ':')"
            export SSH_AUTH_SOCK=""
            pip3 install 'git+ssh://git@github.com/fluxninja/cloud@main#egg=opsninja&subdirectory=ops/apps/opsninja/'
      - restore_cache:
          name: Restore go cache
          keys:
            - aperture-v4-go-cache-{{ checksum "~/day" }}
      - run:
          name: Cache golangci-lint run
          command: |
            golangci-lint run || true
      - run:
          name: Generate pre-commit cache key file
          command: |
            cp .pre-commit-config.yaml /tmp/pre-commit-cache-key.txt
            python --version --version >> /tmp/pre-commit-cache-key.txt
            pre-commit --version >> /tmp/pre-commit-cache-key.txt
      - restore_cache:
          name: Restore pre-commit cache
          keys:
            - aperture-v1-pc-cache-{{ checksum "/tmp/pre-commit-cache-key.txt"
              }}
            - aperture-v1-pc-cache-
      - run:
          name: Install pre-commit hooks
          command: |
            pre-commit install-hooks
      - run:
          name: Run pre-commit
          # It'd be faster to run it only on files changed between current branch and target PR branch
          # This can be done with: pre-commit run --from-ref <TARGET_BRANCH> --to-ref HEAD
          # Unfortunately, CircleCI doesn't expose target branch
          # Possible option is to use narrativescience/ghpr orb with get-pr-info, but this step can't be disabled
          # So then we'd only be able to run this job on PRs, and would require separate job for running on main
          # We use alternative approach, in which:
          # 1) If current branch is main - pre-commit checks all files
          # 2) Otherwise - we find common ancestor between current commit and main and run pre-commit with a base (from-ref) set to that ancestor
          command: |
            set -euo pipefail
            set -x
            export LOGURU_LEVEL=TRACE
            export GIT_SSH_COMMAND="fn circleci ssh -o IdentitiesOnly=yes -o IdentityAgent=none"
            if [ "$CIRCLE_BRANCH" = "main" ]; then
              pre-commit run --all-files
            else
              base_ref="$(git merge-base main $CIRCLE_SHA1)"
              pre-commit run --from-ref "${base_ref}" --to-ref "$CIRCLE_SHA1"
            fi
      - save_cache:
          name: Save go cache
          key: aperture-v4-go-cache-{{ checksum "~/day" }}
          paths:
            - ../.cache/golangci-lint
            - ../.cache/go-build
            - ../.cache/buf
            - ~/.aperturectl
            - ./blueprints/vendor
          when: on_success
      - save_cache:
          name: Save pre-commit cache
          key:
            aperture-v1-pc-cache-{{ checksum "/tmp/pre-commit-cache-key.txt" }}
          paths:
            - ~/.cache/pre-commit
      - asdf_save_cache:
          cache_name: pre-commit
      - run:
          name:
            Show diff and assert pre-commit didn't create any non-ignored files
          command: |
            git status
            git add .
            git diff --cached --exit-code
          when: always

  validate-publish-java-sdk:
    executor: base-machine-executor
    environment:
      DOCKER_BUILDKIT: 1
    parameters:
      docker-context:
        type: string
        description:
          Path to the directory containing your build context, defaults to "".
        default: .
      path:
        type: string
        description:
          Path to the directory containing your Dockerfile, defaults to "".
        default: .
      tag:
        type: string
        description: Docker image tag.
        default: ${CIRCLE_SHA1:0:8}
      registry:
        type: string
        default: docker.io
        description: Name of registry to use, defaults to docker.io.
      remote-repo:
        type: string
        default: ""
        description: Remote repository to mirror the SDK to.
      remote-repo-fingerprint:
        type: string
        default: ""
        description: Fingerprint of remote repository to mirror the SDK to.
      port:
        type: string
        default: "8089"
        description: Port to start sdk-validator's grpc server on.
      requests:
        type: integer
        default: 10
        description: Number of requests to make to SDK example server.
      rejects:
        type: integer
        default: 5
        description: Number of requests (out of 'requests') to reject.
      sdk-port:
        type: string
        default: "8080"
        description: Port to expose on SDK's example container.
    steps:
      - checkout
      - add_ssh_keys:
          fingerprints:
            - "10:d1:92:4e:2a:55:81:c9:82:c2:74:ce:6d:0e:e8:a8" # fluxninja/cloud R/O
            - << parameters.remote-repo-fingerprint >> # fluxninja/<sdk> R/W
      - run: *install_opsninja
      - run:
          name: Workaround for old expired Heroku apt key
          command: |
            sudo rm -rf /etc/apt/sources.list.d/heroku.list
      - aperture_docker_build:
          step-name: Build base image with all aperture java SDK jars
          docker-context: <<parameters.docker-context>>
          dockerfile: dockerfiles/aperture-java-all/Dockerfile
          image: aperture-java-all
          path: <<parameters.path>>
          tag: <<parameters.tag>>
          registry: <<parameters.registry>>
          use-buildkit: true
      - run:
          name: print images
          command: |
            docker image ls
      - aperture_docker_build:
          step-name: Build feature flow example image
          docker-context: <<parameters.docker-context>>
          dockerfile: dockerfiles/featureflow/Dockerfile
          image: aperture-java-feature-flow
          path: <<parameters.path>>
          tag: <<parameters.tag>>
          registry: <<parameters.registry>>
          use-buildkit: true
          extra_build_args: --build-arg=IMAGE_TAG=<<parameters.tag>>
      - aperture_docker_build:
          step-name: Build armeria example image
          docker-context: <<parameters.docker-context>>
          dockerfile: dockerfiles/middlewares/armeria/Dockerfile
          image: aperture-java-armeria
          path: <<parameters.path>>
          tag: <<parameters.tag>>
          registry: <<parameters.registry>>
          use-buildkit: true
          extra_build_args: --build-arg=IMAGE_TAG=<<parameters.tag>>
      - aperture_docker_build:
          step-name: Build netty example image
          docker-context: <<parameters.docker-context>>
          dockerfile: dockerfiles/middlewares/netty/Dockerfile
          image: aperture-java-netty
          path: <<parameters.path>>
          tag: <<parameters.tag>>
          registry: <<parameters.registry>>
          use-buildkit: true
          extra_build_args: --build-arg=IMAGE_TAG=<<parameters.tag>>
      - aperture_docker_build:
          step-name: Build spring boot example image
          docker-context: <<parameters.docker-context>>
          dockerfile: dockerfiles/middlewares/spring/Dockerfile
          image: aperture-java-spring
          path: <<parameters.path>>
          tag: <<parameters.tag>>
          registry: <<parameters.registry>>
          use-buildkit: true
          extra_build_args: --build-arg=IMAGE_TAG=<<parameters.tag>>
      - aperture_docker_build:
          step-name: Build javaagent armeria example image
          docker-context: <<parameters.docker-context>>
          dockerfile: dockerfiles/javaagent/armeria/Dockerfile
          image: aperture-javaagent-armeria
          path: <<parameters.path>>
          tag: <<parameters.tag>>
          registry: <<parameters.registry>>
          use-buildkit: true
          extra_build_args: --build-arg=IMAGE_TAG=<<parameters.tag>>
      - aperture_docker_build:
          step-name: Build javaagent netty example image
          docker-context: <<parameters.docker-context>>
          dockerfile: dockerfiles/javaagent/netty/Dockerfile
          image: aperture-javaagent-netty
          path: <<parameters.path>>
          tag: <<parameters.tag>>
          registry: <<parameters.registry>>
          use-buildkit: true
          extra_build_args: --build-arg=IMAGE_TAG=<<parameters.tag>>
      - aperture_docker_build:
          step-name: Build java sdk example image
          docker-context: <<parameters.docker-context>>
          dockerfile: dockerfiles/example/Dockerfile
          image: aperture-java-example
          path: <<parameters.path>>
          tag: <<parameters.tag>>
          registry: <<parameters.registry>>
          use-buildkit: true
          extra_build_args: --build-arg=IMAGE_TAG=<<parameters.tag>>
      - asdf_install:
          cache_name: validate-sdk
          tools: |-
            golang
      - run:
          name: Run SDK Validator against feature flow example
          command: >
            go run cmd/sdk-validator/main.go
            -sdk-docker-image=<<parameters.registry>>/aperture-java-feature-flow:<<parameters.tag>>
            -port=<<parameters.port>> -requests=<<parameters.requests>>
            -rejects=<<parameters.rejects>> -sdk-port=<<parameters.sdk-port>>
      - run:
          name: Run SDK Validator against armeria example
          command: >
            go run cmd/sdk-validator/main.go
            -sdk-docker-image=<<parameters.registry>>/aperture-java-armeria:<<parameters.tag>>
            -port=<<parameters.port>> -requests=<<parameters.requests>>
            -rejects=<<parameters.rejects>> -sdk-port=<<parameters.sdk-port>>
      - run:
          name: Run SDK Validator against netty example
          command: >
            go run cmd/sdk-validator/main.go
            -sdk-docker-image=<<parameters.registry>>/aperture-java-netty:<<parameters.tag>>
            -port=<<parameters.port>> -requests=<<parameters.requests>>
            -rejects=<<parameters.rejects>> -sdk-port=<<parameters.sdk-port>>
      - run:
          name: Run SDK Validator against spring boot example
          command: >
            go run cmd/sdk-validator/main.go
            -sdk-docker-image=<<parameters.registry>>/aperture-java-spring:<<parameters.tag>>
            -port=<<parameters.port>> -requests=<<parameters.requests>>
            -rejects=<<parameters.rejects>> -sdk-port=<<parameters.sdk-port>>
      - run:
          name: Run SDK Validator against javaagent armeria example
          command: >
            go run cmd/sdk-validator/main.go
            -sdk-docker-image=<<parameters.registry>>/aperture-javaagent-armeria:<<parameters.tag>>
            -port=<<parameters.port>> -requests=<<parameters.requests>>
            -rejects=<<parameters.rejects>> -sdk-port=<<parameters.sdk-port>>
      - run:
          name: Run SDK Validator against javaagent netty example
          command: >
            go run cmd/sdk-validator/main.go
            -sdk-docker-image=<<parameters.registry>>/aperture-javaagent-netty:<<parameters.tag>>
            -port=<<parameters.port>> -requests=<<parameters.requests>>
            -rejects=<<parameters.rejects>> -sdk-port=<<parameters.sdk-port>>
      - when:
          condition:
            equal: [main, << pipeline.git.branch >>]
          steps:
            - run:
                name: Publish SDK to <<parameters.remote-repo>>
                command: |
                  export LOGURU_LEVEL=TRACE
                  export GIT_SSH_COMMAND="fn circleci ssh -o IdentitiesOnly=yes -o IdentityAgent=none"
                  args=(
                    --remote-repo=<<parameters.remote-repo>>
                    --source-repo-sdk-path=<<parameters.path>>
                  )
                  fn release publish-sdk "${args[@]}"

  validate-publish-sdk:
    executor: base-machine-executor
    environment:
      DOCKER_BUILDKIT: 1
    parameters:
      docker-context:
        type: string
        description:
          Path to the directory containing your build context, defaults to "".
        default: .
      dockerfile:
        type: string
        description: Name of docker file to use, defaults to Dockerfile.
        default: Dockerfile
      docker-image:
        type: string
        description: Name for Docker image
      path:
        type: string
        description:
          Path to the directory containing your Dockerfile, defaults to "".
        default: .
      tag:
        type: string
        description: Docker image tag.
        default: ${CIRCLE_SHA1:0:8}
      registry:
        type: string
        default: docker.io
        description: Name of registry to use, defaults to docker.io.
      remote-repo:
        type: string
        default: ""
        description: Remote repository to mirror the SDK to.
      remote-repo-fingerprint:
        type: string
        default: ""
        description: Fingerprint of remote repository to mirror the SDK to.
      port:
        type: string
        default: "8089"
        description: Port to start sdk-validator's grpc server on.
      requests:
        type: integer
        default: 10
        description: Number of requests to make to SDK example server.
      rejects:
        type: integer
        default: 5
        description: Number of requests (out of 'requests') to reject.
      sdk-port:
        type: string
        default: "8080"
        description: Port to expose on SDK's example container.
    steps:
      - checkout
      - add_ssh_keys:
          fingerprints:
            - "10:d1:92:4e:2a:55:81:c9:82:c2:74:ce:6d:0e:e8:a8" # fluxninja/cloud R/O
            - << parameters.remote-repo-fingerprint >> # fluxninja/<sdk> R/W
      - run: *install_opsninja
      - run:
          name: Workaround for old expired Heroku apt key
          command: |
            sudo rm -rf /etc/apt/sources.list.d/heroku.list
      - aperture_docker_build:
          docker-context: <<parameters.docker-context>>
          dockerfile: <<parameters.dockerfile>>
          image: <<parameters.docker-image>>
          path: <<parameters.path>>
          tag: <<parameters.tag>>
          registry: <<parameters.registry>>
          use-buildkit: true
      - asdf_install:
          cache_name: validate-sdk
          tools: |-
            golang
      - run:
          name: Run SDK Validator
          command: |
            go run cmd/sdk-validator/main.go \
              -sdk-docker-image=<<parameters.registry>>/<<parameters.docker-image>>:<<parameters.tag>> \
              -port=<<parameters.port>> \
              -requests=<<parameters.requests>> \
              -rejects=<<parameters.rejects>> \
              -sdk-port=<<parameters.sdk-port>>
      - when:
          condition:
            equal: [main, << pipeline.git.branch >>]
          steps:
            - run:
                name: Publish SDK to <<parameters.remote-repo>>
                command: |
                  export LOGURU_LEVEL=TRACE
                  export GIT_SSH_COMMAND="fn circleci ssh -o IdentitiesOnly=yes -o IdentityAgent=none"
                  args=(
                    --remote-repo=<<parameters.remote-repo>>
                    --source-repo-sdk-path=<<parameters.path>>
                  )
                  fn release publish-sdk "${args[@]}"

  publish-aperture-docs:
    executor: python-cimg-executor
    parameters:
      release-ref:
        type: string
        default: main
        description: What release tag or branch to copy documentation from
      dry-run:
        type: boolean
        default: false
        description: Whether to push changes to the deployment repository
      task-name:
        type: string
        default: Publish documentation updates
        description: The name of the actual task
    steps:
      - checkout
      - add_ssh_keys:
          fingerprints:
            - "10:d1:92:4e:2a:55:81:c9:82:c2:74:ce:6d:0e:e8:a8" # fluxninja/cloud R/O
            - "2e:ea:3a:1e:2c:59:2d:40:aa:6a:a8:f5:1d:e2:91:f0" # fluxninja/aperture-tech-docs R/W
      - run: *install_opsninja
      - asdf_install:
          cache_name: publish-docs
          tools: |-
            nodejs
      - run:
          name: Install yarn
          command: npm install --global yarn
      - run:
          name: << parameters.task-name >>
          command: |
            export LOGURU_LEVEL=TRACE
            export GIT_SSH_COMMAND="fn circleci ssh -o IdentitiesOnly=yes"
             args=(
               --release=<< parameters.release-ref >>
               --source-repo-path=/home/circleci/project/
               --docs-root-dir=docs/
             )
             if [[ "<< parameters.dry-run >>" == "true" ]]; then
               args+=( --dry-run )
             fi
            fn release update-aperture-docs "${args[@]}"
      - asdf_save_cache:
          cache_name: publish-docs

  publish-deployment-code:
    parameters:
      task-name:
        type: string
        description: How to name the step that executes invoke task
      dry-run:
        type: boolean
        default: false
        description: Whether to push changes to the deployment repository
      deployment-repo:
        type: string
        default: git@github.com:fluxninja/deployment.git
        description: Deployment repository to push deployment changes to
    executor: python-cimg-executor
    steps:
      - add_ssh_keys:
          fingerprints:
            - "10:d1:92:4e:2a:55:81:c9:82:c2:74:ce:6d:0e:e8:a8" # fluxninja/cloud R/O
            - "2a:af:6f:d5:b9:d4:dd:95:df:18:47:e9:0b:4a:c7:82" # fluxninja/deployment R/W
      - checkout
      - run: *install_opsninja
      - run:
          name: Checkout git submodules
          command: git submodule update --init --recursive
      - run:
          name: << parameters.task-name >>
          command: |
            echo "parameters.dry-run: '<< parameters.dry-run >>'"
            args=(
              --color=always
              --dest-repo-url "<< parameters.deployment-repo >>"
              --target-branch "main"
              --ssh-identity "~/.ssh/id_rsa_$(echo "2a:af:6f:d5:b9:d4:dd:95:df:18:47:e9:0b:4a:c7:82" | tr -d ':')"
            )
            if [[ "<< parameters.dry-run >>" == "true" ]]; then
              args+=( --dry-run )
            fi
            fn release sync-deployment-repo "${args[@]}"

  build-aperture-java:
    parameters:
      docker-image:
        type: string
        description: Docker image to be used to run gradle.
        default: cimg/openjdk:18.0
      path:
        type: string
        description: Path to aperture-java
        default: sdks/aperture-java
      omit-examples:
        type: boolean
        description: Whether examples should be omitted.
        default: false
    docker:
      - image: <<parameters.docker-image>>
    environment:
      JVM_OPTS: -Xmx3200m
      TERM: dumb
    steps:
      - checkout
      - restore_cache:
          keys:
            - gradle-v1-{{ checksum "<<parameters.path>>/build.gradle.kts" }}
            - gradle-v1-
      - when:
          condition: <<parameters.omit-examples>>
          steps:
            - run:
                name: Dependencies (no examples)
                command: |
                  cd <<parameters.path>>
                  gradle --configure-on-demand :lib:dependencies
                  gradle --configure-on-demand :javaagent:dependencies
            - save_cache:
                paths:
                  - ~/.gradle
                key:
                  gradle-v1-{{ checksum "<<parameters.path>>/build.gradle.kts"
                  }}
            - run:
                name: Build
                command: |
                  cd <<parameters.path>>
                  gradle --configure-on-demand :lib:build --no-daemon
                  gradle --configure-on-demand :javaagent:build --no-daemon
            # run tests if any are added
      - when:
          condition:
            not: <<parameters.omit-examples>>
          steps:
            - run:
                name: Dependencies
                command: |
                  cd <<parameters.path>>
                  gradle dependencies
            - save_cache:
                paths:
                  - ~/.gradle
                key:
                  gradle-v1-{{ checksum "<<parameters.path>>/build.gradle.kts"
                  }}
            - run:
                name: Build
                command: |
                  cd <<parameters.path>>
                  gradle build --no-daemon
            # run tests!
            - run:
                name: Test
                command: |
                  cd <<parameters.path>>
                  gradle test

  update-environment:
    parameters:
      job-root:
        type: string
        default: "/home/circleci"
        description:
          The root folder of the job where all repositories will be cloned to
      manifests-repo:
        type: string
        default: git@github.com:fluxninja/argo-manifests.git
        description: ArgoCD manifests repository to update
      manifests-branch:
        type: string
        default: tests
        description: Branch to use when pushing deployment changes
      environment-path:
        type: string
        description: Path to the environment to update
      component:
        type: string
        default: ""
        description:
          Application component to update image and deployment code for
      update:
        type: string
        default: everything
        description:
          Whether to update 'images', 'deployment-code' or 'everything'
    executor: python-cimg-executor
    steps:
      - add_ssh_keys:
          fingerprints:
            - "f9:49:04:10:b1:77:16:b0:0e:c0:ba:21:0e:9d:fd:40" # argo-manifests R/W
            - "2a:af:6f:d5:b9:d4:dd:95:df:18:47:e9:0b:4a:c7:82" # deployment R/W
            - "10:d1:92:4e:2a:55:81:c9:82:c2:74:ce:6d:0e:e8:a8" #cloud keys
      - checkout
      - gcp-gcr/gcr-auth
      - run: *install_opsninja
      - run:
          name: Update application in the deployment
          environment:
            JOB_ROOT: << parameters.job-root >>
            UPDATE: << parameters.update >>
            MANIFESTS_BRANCH: << parameters.manifests-branch >>
            MANIFESTS_REPO: << parameters.manifests-repo >>
            COMPONENT: << parameters.component >>
            ENVIRONMENT_PATH: << parameters.environment-path >>
          command: .circleci/scripts/update_environment.sh

  package-binaries:
    parameters:
      workspace-name:
        type: string
        description:
          the name of the workspace to which built packages should be added
        default: packages
      goarch:
        type: string
        description: the GOARCH to use for the build
        default: amd64
      goos:
        type: string
        description: the GOOS to use for the build
        default: linux
      component:
        type: string
        description: the component to build
      upload-to-gcp:
        type: boolean
        default: false
        description: Whether to push artifacts to GCP
    executor: ubuntu-18-executor
    environment:
      PACKAGES_DIR: "/tmp/packages"
      GOARCH: <<parameters.goarch>>
      GOOS: <<parameters.goos>>
      COMPONENT: <<parameters.component>>
    steps:
      - checkout
      - asdf_install: # We need to install python before gcloud
          cache_name: aperture-{{ .Environment.COMPONENT }}-packages
          tools: |-
            python
            gcloud
            golang
      - run:
          name: "Set version"
          command: |
            component=aperture-agent
            tag_matcher="releases/${component}/*"
            current_branch="$(git branch --show-current)"
            tags="$(git tag -l --sort="-version:refname" "${tag_matcher}")"
            tag="$(head -n1 \<<<"${tags}")"
            commits="$(git rev-list "${tag}"..HEAD --count)"
            APERTURECTL_BUILD_VERSION="${tag##*/}-b.${commits}"

            export APERTURECTL_BUILD_VERSION
            declare -p APERTURECTL_BUILD_VERSION >> "${BASH_ENV}"
      - restore_cache:
          name: Restore go cache
          keys:
            - aperture-{{ .Environment.COMPONENT }}-packages-go-cache
      - run:
          name: "Compile binaries"
          command: ./.circleci/scripts/compile.sh "${COMPONENT}"
      - run:
          name: Install nFPM
          command: ./.circleci/scripts/install_nfpm.sh
      - run:
          name: Package
          command: ./.circleci/scripts/nfpm_package.sh
      - when:
          condition:
            equal: [cli, << parameters.component >>]
          steps:
            - run:
                name: Create tarball file for Given OS
                command: ./.circleci/scripts/create_tarball_file.sh
            - run:
                name: Create binaries for different OS
                command: |
                  mv "$HOME"/project/dist/aperturectl "$HOME"/project/dist/aperturectl-"${APERTURECTL_BUILD_VERSION#v}"-"${GOOS}"-"${GOARCH}"
                  cp -rf "$HOME"/project/dist/aperturectl-"${APERTURECTL_BUILD_VERSION#v}"-"${GOOS}"-"${GOARCH}" "$HOME"/project/dist/packages/
                  ls -al "$HOME"/project/dist/packages/

      - when:
          condition: <<parameters.upload-to-gcp>>
          steps:
            - run:
                name: GCloud SOPS Auth
                command: .circleci/scripts/setup_gcloud.sh
            - run:
                name: Upload package to GCP
                command: |
                  if [ "${GOOS}" != "darwin" ]
                  then
                    gcloud config set artifacts/location us-central1
                    for package in "deb" "rpm"
                    do
                      gcloud config set artifacts/repository aperture-${package}-packages
                      case "${package}" in
                        deb) gcloud artifacts apt upload aperture-${package}-packages --source="$(ls dist/packages/*.${package})" --project=${GOOGLE_PROJECT_ID};;
                        rpm) gcloud artifacts yum upload aperture-${package}-packages --source="$(ls dist/packages/*.${package})" --project=${GOOGLE_PROJECT_ID};;
                      esac
                    done
                  fi
      - save_cache:
          name: Save go cache
          key: aperture-{{ .Environment.COMPONENT }}-packages-go-cache
          paths:
            - ../.cache/go-build
          when: on_success
      - asdf_save_cache:
          cache_name: aperture-{{ .Environment.COMPONENT }}-packages

workflows:
  version: 2

  build-aperture-agent-bare-metal-package:
    when:
      and:
        - not:
            equal: [main, << pipeline.git.branch >>]
        - or:
            - << pipeline.parameters.updated-aperture-agent-packaging >>
            - << pipeline.parameters.updated-aperture >>
    jobs:
      - package-binaries:
          name: build-aperture-agent-bare-metal-package
          component: agent
          matrix:
            parameters:
              goos: ["linux"]
              goarch: ["amd64"]

  publish-aperture-agent-bare-metal-package:
    when:
      and:
        - equal: [main, << pipeline.git.branch >>]
        - or:
            - << pipeline.parameters.updated-aperture-agent-packaging >>
            - << pipeline.parameters.updated-aperture >>
    jobs:
      - package-binaries:
          name: publish-aperture-agent-bare-metal-package
          component: agent
          upload-to-gcp: true
          matrix:
            parameters:
              goos: ["linux"]
              goarch: ["amd64"]

  build-aperturectl-packages:
    when:
      and:
        - not:
            equal: [main, << pipeline.git.branch >>]
        - or:
            - << pipeline.parameters.updated-aperturectl-packaging >>
            - << pipeline.parameters.updated-aperture >>
    jobs:
      - package-binaries:
          name: build-aperturectl-packages
          component: cli
          matrix:
            parameters:
              goos: ["linux","darwin"]
              goarch: ["amd64","arm64"]


  publish-aperturectl-packages:
    when:
      and:
        - equal: [main, << pipeline.git.branch >>]
        - or:
            - << pipeline.parameters.updated-aperturectl-packaging >>
            - << pipeline.parameters.updated-aperture >>
    jobs:
      - package-binaries:
          name: publish-aperturectl-packages
          component: cli
          upload-to-gcp: true
          matrix:
            parameters:
              goos: ["linux","darwin"]
              goarch: ["amd64","arm64"]

  aperture:
    when:
      or:
        - << pipeline.parameters.updated-aperture >>
    jobs:
      - build-push-add-tag:
          name: image-build-aperture-agent
          dockerhub-image: fluxninja/aperture-agent
          gcr-registry: gcr.io/devel-309501
          gcr-image: cf-fn/aperture-agent
          docker-context: .
          dockerfile: cmd/aperture-agent/Dockerfile
          use-docker-layer-caching: true
      - update-environment:
          filters:
            branches:
              only:
                - main
          name: aperture-agent-update-environment
          requires:
            - image-build-aperture-agent
          environment-path: environments/latest/
          component: aperture-agent
          update: images

      - build-push-add-tag:
          name: image-build-aperture-controller
          dockerhub-image: fluxninja/aperture-controller
          gcr-registry: gcr.io/devel-309501
          gcr-image: cf-fn/aperture-controller
          docker-context: .
          dockerfile: cmd/aperture-controller/Dockerfile
          use-docker-layer-caching: true
      - update-environment:
          filters:
            branches:
              only:
                - main
          name: aperture-controller-update-environment
          requires:
            - image-build-aperture-controller
          environment-path: environments/latest/
          component: aperture-controller
          update: images

      - go-test-coverage:
          name: go-test-coverage-aperture
          work_dir: .

  aperture-go:
    when:
      or:
        - << pipeline.parameters.updated-aperture-go >>
        - << pipeline.parameters.updated-sdk-validator >>
    jobs:
      - validate-publish-sdk:
          name: validate-publish-aperture-go
          path: sdks/aperture-go
          docker-context: sdks/aperture-go
          dockerfile: Dockerfile
          docker-image: aperture-go-example
          remote-repo: fluxninja/aperture-go
          remote-repo-fingerprint: "eb:80:c9:44:c7:53:0f:ae:b7:4e:86:0f:62:60:6f:76"

  aperture-js:
    when:
      or:
        - << pipeline.parameters.updated-aperture-js >>
        - << pipeline.parameters.updated-sdk-validator >>
    jobs:
      - validate-publish-sdk:
          name: validate-publish-aperture-js
          path: sdks/aperture-js
          docker-context: sdks/aperture-js
          dockerfile: Dockerfile
          docker-image: aperture-js-example
          remote-repo: fluxninja/aperture-js
          remote-repo-fingerprint: "00:5e:cf:81:48:2d:e9:b8:34:74:8b:46:cc:ad:2f:ce"

  aperture-py:
    when:
      or:
        - << pipeline.parameters.updated-aperture-py >>
        - << pipeline.parameters.updated-sdk-validator >>
    jobs:
      - validate-publish-sdk:
          name: validate-publish-aperture-py
          path: sdks/aperture-py
          docker-context: sdks/aperture-py
          dockerfile: example/Dockerfile
          docker-image: aperture-py-example
          remote-repo: fluxninja/aperture-py
          remote-repo-fingerprint: "0b:a2:a7:de:46:d5:e8:c7:46:1e:49:29:e3:6e:e8:a8"

  # Verify that libs and java agent can be built with Java 8+
  # Verify that lib, java agent and examples can be built with Java 17+
  aperture-java:
    when:
      or:
        - << pipeline.parameters.updated-aperture-java >>
        - << pipeline.parameters.updated-sdk-validator >>
    jobs:
      - build-aperture-java:
          name: Build with OpenJDK 8
          docker-image: cimg/openjdk:8.0
          path: sdks/aperture-java
          omit-examples: true
      - build-aperture-java:
          name: Build with OpenJDK 11
          docker-image: cimg/openjdk:11.0
          path: sdks/aperture-java
      - build-aperture-java:
          name: Build with OpenJDK 13
          docker-image: cimg/openjdk:13.0
          path: sdks/aperture-java
      - build-aperture-java:
          name: Build with OpenJDK 15
          docker-image: cimg/openjdk:15.0
          path: sdks/aperture-java
      - build-aperture-java:
          name: Build with OpenJDK 17
          docker-image: cimg/openjdk:17.0
          path: sdks/aperture-java
      - build-aperture-java:
          name: Build with OpenJDK 18
          docker-image: cimg/openjdk:18.0
          path: sdks/aperture-java
      - validate-publish-java-sdk:
          name: Validate and publish java SDK
          path: sdks/aperture-java
          docker-context: sdks/aperture-java
          remote-repo: fluxninja/aperture-java
          remote-repo-fingerprint: "79:0e:fb:cd:d3:3e:14:dd:52:de:b7:1c:ac:1e:ea:84"

  aperture-operator:
    when: << pipeline.parameters.updated-aperture-operator >>
    jobs:
      - build-push-add-tag:
          name: image-build-aperture-operator
          dockerhub-image: fluxninja/aperture-operator
          gcr-registry: gcr.io/devel-309501
          gcr-image: cf-fn/aperture-operator
          docker-context: .
          dockerfile: ./operator/Dockerfile
          no_output_timeout: 15m
          use-docker-layer-caching: true
      - update-environment:
          filters:
            branches:
              only:
                - main
          name: aperture-operator-update-environment
          requires:
            - image-build-aperture-operator
          environment-path: environments/latest/
          component: aperture-operator
          update: images

  demo-app:
    when: << pipeline.parameters.updated-demo-app >>
    jobs:
      - build-push-add-tag:
          name: image-demo-app
          dockerhub-image: fluxninja/demo-app
          gcr-registry: gcr.io/devel-309501
          gcr-image: cf-fn/demo-app
          docker-context: ./playground/demo_app
          dockerfile: ./playground/demo_app/Dockerfile
          use-docker-layer-caching: true
          push-to-dockerhub: false
      - update-environment:
          filters:
            branches:
              only:
                - main
          name: demo-app-update-environment
          requires:
            - image-demo-app
          environment-path: environments/latest/
          component: demo-app
          update: images
  pre-commit:
    jobs:
      - pre-commit

  publish-aperture-docs:
    when:
      and:
        - equal: [main, << pipeline.git.branch >>]
        - << pipeline.parameters.updated-aperture-docs >>
    jobs:
      - publish-aperture-docs

  build-aperture-docs:
    when:
      and:
        - not:
            equal: [main, << pipeline.git.branch >>]
        - << pipeline.parameters.updated-aperture-docs >>
    jobs:
      - publish-aperture-docs:
          name: build-aperture-docs
          task-name: Build aperture documentation and verify changes
          dry-run: true

  push-blueprints-changes:
    when:
      and:
        - equal: [main, << pipeline.git.branch >>]
        - << pipeline.parameters.updated-blueprints >>
    jobs:
      - update-environment:
          filters:
            branches:
              only:
                - main
          name: push-blueprints-changes-update-environment
          update: blueprints
          environment-path: environments/latest/

  push-deployment-changes:
    when:
      and:
        - or: &updated_deployment_code
            - << pipeline.parameters.updated-aperture-charts >>
        - or: &main_or_stable_branch
            - equal: [main, << pipeline.git.branch >>]
            - matches:
                { pattern: "^stable/.+", value: << pipeline.git.branch>> }
    jobs:
      - publish-deployment-code: &push_deployment_code_job
          name: push-deployment-changes
          task-name: Push deployment code changes to fluxninja/deployment.git
      - update-environment:
          filters:
            branches:
              only:
                - main
          name: push-deployment-changes-update-environment
          requires:
            - push-deployment-changes
          update: deployment-code
          environment-path: environments/latest/

  preview-deployment-changes:
    when:
      and:
        - not:
            or: *main_or_stable_branch
        - or: *updated_deployment_code
    jobs:
      - publish-deployment-code:
          <<: *push_deployment_code_job
          name: preview-deployment-changes
          dry-run: true
          task-name:
            "Preview changes between aperture.git and deployment repository"

commands:
  asdf_install:
    description: "Install tools using ASDF"
    parameters:
      tools:
        type: string
        description:
          "Newline separated list of tools to install. If empty, will install
          everything."
        default: ""
      cache_name:
        type: string
        description: "Name of asdf cache"
        default: "default"
    steps:
      - run:
          name: Install ASDF
          command: |
            git clone https://github.com/asdf-vm/asdf.git ~/.asdf --branch v0.10.2
            printf '\nsource "${HOME}/.asdf/asdf.sh"\n' >> "${BASH_ENV}"
            date +%m > ~/month
            date +%d > ~/day
      # We need to restore ASDF cache after installing, otherwise we will try to clone it to non-empty dir
      - restore_cache:
          name: Restore ASDF cache
          keys:
            - aperture-asdf-cache-v6-{{ checksum "~/month" }}-<<
              parameters.cache_name >>-{{ checksum ".tool-versions" }}-{{
              checksum "tools/go/go.mod" }}
            - aperture-asdf-cache-v6-{{ checksum "~/month" }}-<<
              parameters.cache_name >>-
      - run:
          name: Install ASDF tools
          environment:
            TOOLS: << parameters.tools >>
          command: .circleci/scripts/asdf_install.sh

  asdf_save_cache:
    parameters:
      cache_name:
        type: string
        description: "Name of asdf cache"
        default: "default"
    steps:
      - save_cache:
          name: Save ASDF cache
          key:
            aperture-asdf-cache-v6-{{ checksum "~/month" }}-<<
            parameters.cache_name >>-{{ checksum ".tool-versions" }}-{{ checksum
            "tools/go/go.mod" }}
          paths:
            - ~/.asdf

  aperture_docker_build:
    description: |
      Build and tag a Docker image (forked from circleci/docker with SSH support)
    parameters:
      attach-at:
        default: ""
        description: |
          Provide a path if you wish to attach a workspace. Use `./` for the working directory. `attach_workspace` attached location - where to mount folder/files that were `persist_to_workspace` in a previous step. https://circleci.com/docs/2.0/configuration-reference/#attach_workspace
        type: string
      cache_from:
        default: ""
        description: |
          Comma-separated list of images, images will first be pulled, then passed as the --cache-from build argument https://docs.docker.com/engine/reference/commandline/build/
        type: string
      debug:
        default: false
        description: |
          Extra output for orb developers
        type: boolean
      docker-context:
        default: .
        description: |
          Path to the directory containing your build context, defaults to . (working directory)
        type: string
      dockerfile:
        default: Dockerfile
        description: Name of dockerfile to use, defaults to Dockerfile
        type: string
      extra_build_args:
        default: ""
        description: |
          Extra flags to pass to docker build. For examples, see https://docs.docker.com/engine/reference/commandline/build
        type: string
      image:
        description: Name of image to build
        type: string
      lint-dockerfile:
        default: false
        description: |
          Lint Dockerfile before building?
        type: boolean
      no_output_timeout:
        default: 10m
        description: |
          Pass through a default timeout if your Docker build does not output anything for more than 10 minutes.
        type: string
      path:
        default: .
        description: |
          Path to the directory containing your Dockerfile, defaults to . (working directory)
        type: string
      registry:
        default: docker.io
        description: |
          Name of registry to use, defaults to docker.io
        type: string
      step-name:
        default: Docker build
        description: Specify a custom step name for this command, if desired
        type: string
      tag:
        default: $CIRCLE_SHA1
        description: Image tag, defaults to the value of $CIRCLE_SHA1
        type: string
      treat-warnings-as-errors:
        default: false
        description: |
          If linting Dockerfile, treat linting warnings as errors? (would trigger an exit code and fail the CircleCI job)
        type: boolean
      use-buildkit:
        default: false
        description: |
          Use buildkit to build the image. Available on Docker >= 18.09.0 https://docs.docker.com/develop/develop-images/build_enhancements/
        type: boolean
      ssh:
        default: ""
        description: |
          Which ssh socket to forward to the docker build process
        type: string
      git-branch:
        type: string
        description:
          Use the name of the current branch been used for Image build
        default: ${CIRCLE_BRANCH}
      git-commit-hash:
        type: string
        description: Use the hash of the current commit.
        default: ${CIRCLE_SHA1}
    steps:
      - when:
          condition: <<parameters.lint-dockerfile>>
          steps:
            - docker/dockerlint:
                debug: <<parameters.debug>>
                dockerfile: <<parameters.path>>/<<parameters.dockerfile>>
                treat-warnings-as-errors: <<parameters.treat-warnings-as-errors>>
      - when:
          condition: <<parameters.use-buildkit>>
          steps:
            - run: echo 'export DOCKER_BUILDKIT=1' >> $BASH_ENV
      - when:
          condition: <<parameters.attach-at>>
          steps:
            - attach_workspace:
                at: <<parameters.attach-at>>
      - run:
          command: .circleci/scripts/docker_build.sh
          environment:
            PARAM_CACHE_FROM: <<parameters.cache_from>>
            PARAM_DOCKER_CONTEXT: <<parameters.docker-context>>
            PARAM_DOCKERFILE_NAME: <<parameters.dockerfile>>
            PARAM_DOCKERFILE_PATH: <<parameters.path>>
            PARAM_EXTRA_BUILD_ARGS: <<parameters.extra_build_args>>
            PARAM_IMAGE: <<parameters.image>>
            PARAM_REGISTRY: <<parameters.registry>>
            PARAM_TAG: <<parameters.tag>>
            PARAM_USE_BUILDKIT: <<parameters.use-buildkit>>
            PARAM_SSH_FORWARD: <<parameters.ssh>>
            PARAM_GIT_BRANCH: <<parameters.git-branch>>
            PARAM_GIT_COMMIT_HASH: <<parameters.git-commit-hash>>
          name: <<parameters.step-name>>
          no_output_timeout: << parameters.no_output_timeout >>

  aperture_docker_tag:
    description: |
      Tag source image with destination registry, image and tag
    parameters:
      source-registry:
        type: string
        description: Source registry of the image to tag
      source-image:
        type: string
        description: Source image name to tag
      source-tag:
        type: string
        description: Source tag to use for the source image
      dest-registry:
        type: string
        description: Destination registry to use for the image
      dest-image:
        type: string
        description: Destination image name to be used
      dest-tag:
        type: string
        description: Destination tag to be used for the image
      step-name:
        type: string
        description: Custom step name, if desired
        default: Tag docker image
    steps:
      - run:
          command: .circleci/scripts/docker_tag.sh
          environment:
            PARAM_SOURCE_REGISTRY: <<parameters.source-registry>>
            PARAM_SOURCE_IMAGE: <<parameters.source-image>>
            PARAM_SOURCE_TAG: <<parameters.source-tag>>
            PARAM_DEST_REGISTRY: <<parameters.dest-registry>>
            PARAM_DEST_IMAGE: <<parameters.dest-image>>
            PARAM_DEST_TAG: <<parameters.dest-tag>>
          name: <<parameters.step-name>>
